[
  {
    "label": "Status",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Status"
  },
  {
    "label": "LevenbergMarquardt",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LevenbergMarquardt"
  },
  {
    "label": "Parameters",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Parameters"
  },
  {
    "label": "sqrt_epsilon()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_LEVENBERGMARQUARDT__H # define EIGEN_LEVENBERGMARQUARDT__H namespace Eigen { namespace LevenbergMarquardtSpace { enum Status { NotStarted = - 2,Running = - 1,ImproperInputParameters = 0,RelativeReductionTooSmall = 1,RelativeErrorTooSmall = 2,RelativeErrorAndReductionTooSmall = 3,CosinusTooSmall = 4,TooManyFunctionEvaluation = 5,FtolTooSmall = 6,XtolTooSmall = 7,GtolTooSmall = 8,UserAsked = 9 } ; } template<FunctorType,Scalar = double> class LevenbergMarquardt { Scalar)",
    "insertText": "sqrt_epsilon()"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (using std::sqrt ; return)",
    "insertText": "sqrt(NumTraits<Scalar>::epsilon())"
  },
  {
    "label": "LevenbergMarquardt()",
    "kind": "Method",
    "detail": "Function (} public :)",
    "insertText": "LevenbergMarquardt(FunctorType &_functor) : functor(_functor)"
  },
  {
    "label": "Parameters()",
    "kind": "Method",
    "detail": "Function (nfev = njev = iter = 0 ; fnorm = gnorm = 0 . ; useExternalScaling = false ; } typedef DenseIndex Index ; struct Parameters {)",
    "insertText": "Parameters() : factor(Scalar(100.)) , maxfev(400) , ftol(sqrt_epsilon()) , xtol(sqrt_epsilon()) , gtol(Scalar(0.)) , epsfcn(Scalar(0.))"
  },
  {
    "label": "lmder1()",
    "kind": "Method",
    "detail": "Function (} Scalar factor ; Index maxfev ; Scalar ftol ; Scalar xtol ; Scalar gtol ; Scalar epsfcn ; } ; typedef Matrix<Scalar,Dynamic,1> FVectorType ; typedef Matrix<Scalar,Dynamic,Dynamic> JacobianType ; LevenbergMarquardtSpace::Status)",
    "insertText": "lmder1(FVectorType &x, const Scalar tol = sqrt_epsilon())"
  },
  {
    "label": "minimize()",
    "kind": "Method",
    "detail": "Function (LevenbergMarquardtSpace::Status)",
    "insertText": "minimize(FVectorType &x)"
  },
  {
    "label": "minimizeInit()",
    "kind": "Method",
    "detail": "Function (LevenbergMarquardtSpace::Status)",
    "insertText": "minimizeInit(FVectorType &x)"
  },
  {
    "label": "minimizeOneStep()",
    "kind": "Method",
    "detail": "Function (LevenbergMarquardtSpace::Status)",
    "insertText": "minimizeOneStep(FVectorType &x)"
  },
  {
    "label": "lmdif1()",
    "kind": "Method",
    "detail": "Function (LevenbergMarquardtSpace::Status)",
    "insertText": "lmdif1(FunctorType &functor, FVectorType &x, Index *nfev, const Scalar tol = sqrt_epsilon())"
  },
  {
    "label": "lmstr1()",
    "kind": "Method",
    "detail": "Function (LevenbergMarquardtSpace::Status)",
    "insertText": "lmstr1(FVectorType &x, const Scalar tol = sqrt_epsilon())"
  },
  {
    "label": "minimizeOptimumStorage()",
    "kind": "Method",
    "detail": "Function (LevenbergMarquardtSpace::Status)",
    "insertText": "minimizeOptimumStorage(FVectorType &x)"
  },
  {
    "label": "minimizeOptimumStorageInit()",
    "kind": "Method",
    "detail": "Function (LevenbergMarquardtSpace::Status)",
    "insertText": "minimizeOptimumStorageInit(FVectorType &x)"
  },
  {
    "label": "minimizeOptimumStorageOneStep()",
    "kind": "Method",
    "detail": "Function (LevenbergMarquardtSpace::Status)",
    "insertText": "minimizeOptimumStorageOneStep(FVectorType &x)"
  },
  {
    "label": "resetParameters()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resetParameters(void)"
  },
  {
    "label": "Parameters()",
    "kind": "Method",
    "detail": "Function (parameters =)",
    "insertText": "Parameters()"
  },
  {
    "label": "lm_param()",
    "kind": "Method",
    "detail": "Function (} Parameters parameters ; FVectorType fvec,qtf,diag ; JacobianType fjac ; PermutationMatrix<Dynamic,Dynamic> permutation ; Index nfev ; Index njev ; Index iter ; Scalar fnorm,gnorm ; bool useExternalScaling ; Scalar)",
    "insertText": "lm_param(void)"
  },
  {
    "label": "lmder1()",
    "kind": "Method",
    "detail": "Function (} ; template<FunctorType,Scalar> LevenbergMarquardtSpace::Status LevenbergMarquardt<FunctorType,Scalar)",
    "insertText": "lmder1(FVectorType &x, const Scalar tol)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (n = x .)",
    "insertText": "size()"
  },
  {
    "label": "values()",
    "kind": "Method",
    "detail": "Function (m = functor .)",
    "insertText": "values()"
  },
  {
    "label": "resetParameters()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resetParameters()"
  },
  {
    "label": "maxfev()",
    "kind": "Method",
    "detail": "Function (parameters . ftol = tol ; parameters . xtol = tol ; parameters .)",
    "insertText": "maxfev(n+1)"
  },
  {
    "label": "minimizeInit()",
    "kind": "Method",
    "detail": "Function (LevenbergMarquardtSpace::Status status =)",
    "insertText": "minimizeInit(x)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(status==LevenbergMarquardtSpace::Running)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (wa1 .)",
    "insertText": "resize(n)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (wa4 .)",
    "insertText": "resize(m)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (fjac .)",
    "insertText": "resize(m, n)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert((!useExternalScaling || diag.size()==n) && \"When useExternalScaling is set, the caller must provide a valid 'diag'\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (nfev = 0 ; njev = 0 ;)",
    "insertText": "if(n <= 0 || m < n || parameters.ftol < 0. || parameters.xtol < 0. || parameters.gtol < 0. || parameters.maxfev <= 0 || parameters.factor <= 0.)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (nfev = 1 ;)",
    "insertText": "if(functor(x, fvec) < 0)"
  },
  {
    "label": "stableNorm()",
    "kind": "Method",
    "detail": "Function (fnorm = fvec .)",
    "insertText": "stableNorm()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (using std::abs ; using std::sqrt ;)",
    "insertText": "eigen_assert(x.size()==n)"
  },
  {
    "label": "df()",
    "kind": "Method",
    "detail": "Function (Index df_ret = functor .)",
    "insertText": "df(x, fjac)"
  },
  {
    "label": "qrfac()",
    "kind": "Method",
    "detail": "Function (ColPivHouseholderQR<JacobianType>)",
    "insertText": "qrfac(fjac)"
  },
  {
    "label": "matrixQR()",
    "kind": "Method",
    "detail": "Function (fjac = qrfac .)",
    "insertText": "matrixQR()"
  },
  {
    "label": "colsPermutation()",
    "kind": "Method",
    "detail": "Function (permutation = qrfac .)",
    "insertText": "colsPermutation()"
  },
  {
    "label": "cwiseProduct()",
    "kind": "Method",
    "detail": "Function (xnorm = diag .)",
    "insertText": "cwiseProduct(x).stableNorm()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (delta = parameters . factor* xnorm ;)",
    "insertText": "if(delta == 0.)"
  },
  {
    "label": "applyOnTheLeft()",
    "kind": "Method",
    "detail": "Function (} wa4 = fvec ; wa4 .)",
    "insertText": "applyOnTheLeft(qrfac.householderQ().adjoint())"
  },
  {
    "label": "head()",
    "kind": "Method",
    "detail": "Function (qtf = wa4 .)",
    "insertText": "head(n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (gnorm = 0 . ;)",
    "insertText": "if(fnorm != 0.) for (Index j = 0; j < n; ++j) if (wa2[permutation.indices()[j]] != 0.) gnorm = (std::max)(gnorm, abs( fjac.col(j).head(j+1).dot(qtf.head(j+1)/fnorm) / wa2[permutation.indices()[j]]))"
  },
  {
    "label": "cwiseProduct()",
    "kind": "Method",
    "detail": "Function (wa1 = - wa1 ; wa2 = x + wa1 ; pnorm = diag .)",
    "insertText": "cwiseProduct(wa1).stableNorm()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (actred = - 1 . ;)",
    "insertText": "if(Scalar(.1) * fnorm1 < fnorm) actred = 1. - numext::abs2(fnorm1 / fnorm)"
  },
  {
    "label": "Upper()",
    "kind": "Method",
    "detail": "Function (wa3 = fjac . template triangularView<)",
    "insertText": "Upper() * (qrfac.colsPermutation().inverse() *wa1)"
  },
  {
    "label": "abs2()",
    "kind": "Method",
    "detail": "Function (temp1 =)",
    "insertText": "abs2(wa3.stableNorm() / fnorm)"
  },
  {
    "label": "abs2()",
    "kind": "Method",
    "detail": "Function (temp2 =)",
    "insertText": "abs2(sqrt(par) * pnorm / fnorm)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (prered = temp1 + temp2 /)",
    "insertText": "Scalar(.5)"
  },
  {
    "label": "dirder()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dirder(temp1 + temp2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ratio = 0 . ;)",
    "insertText": "if(prered != 0.)"
  },
  {
    "label": "temp()",
    "kind": "Method",
    "detail": "Function (delta =)",
    "insertText": "temp(std::min)(delta, pnorm / Scalar(.1))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (par / = temp ; } else)",
    "insertText": "if(!(par != 0. && ratio < Scalar(.75)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ratio >= Scalar(1e-4))"
  },
  {
    "label": "cwiseProduct()",
    "kind": "Method",
    "detail": "Function (x = wa2 ; wa2 = diag .)",
    "insertText": "cwiseProduct(x)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (fnorm = fnorm1 ; + + iter ; })",
    "insertText": "if(abs(actred) <= parameters.ftol && prered <= parameters.ftol && Scalar(.5) * ratio <= 1. && delta <= parameters.xtol * xnorm)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(ratio < Scalar(1e-4))"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (fjac .)",
    "insertText": "resize(n, n)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (Index i,j ; bool sing ; qtf .)",
    "insertText": "fill(0.)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index rownb = 2 ;)",
    "insertText": "for(i = 0; i < m; ++i)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (internal::rwupdt<)",
    "insertText": "Scalar(fjac, wa3, qtf, fvec[i])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (+ + rownb ; } + + njev ; sing = false ;)",
    "insertText": "for(j = 0; j < n; ++j)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (wa2 [ j ] = fjac .)",
    "insertText": "col(j).head(j).stableNorm()"
  },
  {
    "label": "setIdentity()",
    "kind": "Method",
    "detail": "Function (} permutation .)",
    "insertText": "setIdentity(n)"
  },
  {
    "label": "colwise()",
    "kind": "Method",
    "detail": "Function (wa2 = fjac .)",
    "insertText": "colwise().blueNorm()"
  },
  {
    "label": "diagonal()",
    "kind": "Method",
    "detail": "Function (wa1 = fjac .)",
    "insertText": "diagonal()"
  },
  {
    "label": "diagonal()",
    "kind": "Method",
    "detail": "Function (fjac .)",
    "insertText": "diagonal() = qrfac.hCoeffs()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (sum = 0 . ;)",
    "insertText": "for(i = j; i < n; ++i) sum += fjac(i,j)"
  },
  {
    "label": "fjac()",
    "kind": "Method",
    "detail": "Function (temp = - sum /)",
    "insertText": "fjac(j,j)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(iter == 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} gnorm = 0 . ;)",
    "insertText": "if(fnorm != 0.) for (j = 0; j < n; ++j) if (wa2[permutation.indices()[j]] != 0.) gnorm = (std::max)(gnorm, abs( fjac.col(j).head(j+1).dot(qtf.head(j+1)/fnorm) / wa2[permutation.indices()[j]]))"
  },
  {
    "label": "topLeftCorner()",
    "kind": "Method",
    "detail": "Function (wa3 = fjac .)",
    "insertText": "topLeftCorner(n,n).template triangularView<Upper>() * (permutation.inverse() * wa1)"
  },
  {
    "label": "minimizeOptimumStorageInit()",
    "kind": "Method",
    "detail": "Function (LevenbergMarquardtSpace::Status status =)",
    "insertText": "minimizeOptimumStorageInit(x)"
  },
  {
    "label": "numDiff()",
    "kind": "Method",
    "detail": "Function (NumericalDiff<FunctorType>)",
    "insertText": "numDiff(functor)"
  },
  {
    "label": "lm()",
    "kind": "Method",
    "detail": "Function (LevenbergMarquardt<NumericalDiff<FunctorType>,Scalar>)",
    "insertText": "lm(numDiff)"
  },
  {
    "label": "Status()",
    "kind": "Method",
    "detail": "Function (LevenbergMarquardtSpace::Status info =)",
    "insertText": "Status(lm.minimize(x))"
  }
]