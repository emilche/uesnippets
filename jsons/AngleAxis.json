[
  {
    "label": "traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "traits"
  },
  {
    "label": "AngleAxis",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AngleAxis"
  },
  {
    "label": "QuatDerived",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "QuatDerived"
  },
  {
    "label": "AngleAxis()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_ANGLEAXIS_H # define EIGEN_ANGLEAXIS_H namespace Eigen { namespace internal { template<_Scalar> struct traits<AngleAxis<_Scalar>> { typedef _Scalar Scalar ; } ; } template<_Scalar> class AngleAxis : public RotationBase<AngleAxis<_Scalar>,3> { typedef RotationBase<AngleAxis<_Scalar>,3> Base ; public : using Base::operator* ; enum { Dim = 3 } ; typedef _Scalar Scalar ; typedef Matrix<Scalar,3,3> Matrix3 ; typedef Matrix<Scalar,3,1> Vector3 ; typedef Quaternion<Scalar> QuaternionType ; protected : Vector3 m_axis ; Scalar m_angle ; public : EIGEN_DEVICE_FUNC)",
    "insertText": "AngleAxis()"
  },
  {
    "label": "AngleAxis()",
    "kind": "Method",
    "detail": "Function (} template<Derived> EIGEN_DEVICE_FUNC)",
    "insertText": "AngleAxis(const Scalar& angle, const MatrixBase<Derived>& axis) : m_axis(axis), m_angle(angle)"
  },
  {
    "label": "AngleAxis()",
    "kind": "Method",
    "detail": "Function (} template<QuatDerived> EIGEN_DEVICE_FUNC)",
    "insertText": "AngleAxis(const QuaternionBase<QuatDerived>& q)"
  },
  {
    "label": "AngleAxis()",
    "kind": "Method",
    "detail": "Function (* this = q ; } template<Derived> EIGEN_DEVICE_FUNC)",
    "insertText": "AngleAxis(const MatrixBase<Derived>& m)"
  },
  {
    "label": "angle()",
    "kind": "Method",
    "detail": "Function (* this = m ; } EIGEN_DEVICE_FUNC Scalar)",
    "insertText": "angle()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC QuaternionType)",
    "insertText": "operator(const QuaternionType& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC QuaternionType)",
    "insertText": "operator(const QuaternionType& a, const AngleAxis& b)"
  },
  {
    "label": "inverse()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC AngleAxis)",
    "insertText": "inverse()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class QuatDerived> EIGEN_DEVICE_FUNC AngleAxis&)",
    "insertText": "operator(const QuaternionBase<QuatDerived>& q)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<Derived> EIGEN_DEVICE_FUNC AngleAxis&)",
    "insertText": "operator(const MatrixBase<Derived>& m)"
  },
  {
    "label": "fromRotationMatrix()",
    "kind": "Method",
    "detail": "Function (template<Derived> EIGEN_DEVICE_FUNC AngleAxis&)",
    "insertText": "fromRotationMatrix(const MatrixBase<Derived>& m)"
  },
  {
    "label": "toRotationMatrix()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC Matrix3)",
    "insertText": "toRotationMatrix(void)"
  },
  {
    "label": "cast()",
    "kind": "Method",
    "detail": "Function (template<NewScalarType> EIGEN_DEVICE_FUNC internal::cast_return_type<AngleAxis,AngleAxis<NewScalarType>>::type)",
    "insertText": "cast()"
  },
  {
    "label": "AngleAxis()",
    "kind": "Method",
    "detail": "Function (} template<OtherScalarType> EIGEN_DEVICE_FUNC)",
    "insertText": "AngleAxis(const AngleAxis<OtherScalarType>& other)"
  },
  {
    "label": "axis()",
    "kind": "Method",
    "detail": "Function (m_axis = other .)",
    "insertText": "axis().template cast<Scalar>()"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (m_angle =)",
    "insertText": "Scalar(other.angle())"
  },
  {
    "label": "Identity()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC const AngleAxis)",
    "insertText": "Identity()"
  },
  {
    "label": "isApprox()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC bool)",
    "insertText": "isApprox(const AngleAxis& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision())"
  },
  {
    "label": "EIGEN_USING_STD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_USING_STD(atan2) EIGEN_USING_STD(abs) Scalar n = q.vec().norm()"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (m_angle =)",
    "insertText": "Scalar(2)*atan2(n, abs(q.w()))"
  },
  {
    "label": "vec()",
    "kind": "Method",
    "detail": "Function (m_axis = q .)",
    "insertText": "vec()"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (} else { m_angle =)",
    "insertText": "Scalar(0)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (m_axis<<)",
    "insertText": "Scalar(1), Scalar(0), Scalar(0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return* this ; } template<Scalar> template<Derived> EIGEN_DEVICE_FUNC AngleAxis<Scalar>& AngleAxis<Scalar)",
    "insertText": "operator(const MatrixBase<Derived>& mat)"
  },
  {
    "label": "fromRotationMatrix()",
    "kind": "Method",
    "detail": "Function (} template<Scalar> template<Derived> EIGEN_DEVICE_FUNC AngleAxis<Scalar>& AngleAxis<Scalar)",
    "insertText": "fromRotationMatrix(const MatrixBase<Derived>& mat)"
  },
  {
    "label": "EIGEN_USING_STD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_USING_STD(sin) EIGEN_USING_STD(cos)"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (Vector3 sin_axis =)",
    "insertText": "sin(m_angle)"
  },
  {
    "label": "cos()",
    "kind": "Method",
    "detail": "Function (Scalar c =)",
    "insertText": "cos(m_angle)"
  },
  {
    "label": "cos1_axis()",
    "kind": "Method",
    "detail": "Function (Vector3)",
    "insertText": "cos1_axis(Scalar(1)-c)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (Scalar tmp ; tmp = cos1_axis .)",
    "insertText": "x() * m_axis.y()"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (res .)",
    "insertText": "coeffRef(0,1) = tmp - sin_axis.z()"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (res .)",
    "insertText": "coeffRef(1,0) = tmp + sin_axis.z()"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (tmp = cos1_axis .)",
    "insertText": "x() * m_axis.z()"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (res .)",
    "insertText": "coeffRef(0,2) = tmp + sin_axis.y()"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (res .)",
    "insertText": "coeffRef(2,0) = tmp - sin_axis.y()"
  },
  {
    "label": "y()",
    "kind": "Method",
    "detail": "Function (tmp = cos1_axis .)",
    "insertText": "y() * m_axis.z()"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (res .)",
    "insertText": "coeffRef(1,2) = tmp - sin_axis.x()"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (res .)",
    "insertText": "coeffRef(2,1) = tmp + sin_axis.x()"
  },
  {
    "label": "diagonal()",
    "kind": "Method",
    "detail": "Function (res .)",
    "insertText": "diagonal() = (cos1_axis.cwiseProduct(m_axis)).array()"
  }
]