[
  {
    "label": "Time",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Time"
  },
  {
    "label": "TimeTicks",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TimeTicks"
  },
  {
    "label": "ThreadTicks",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ThreadTicks"
  },
  {
    "label": "TraceEventMemoryOverhead",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TraceEventMemoryOverhead"
  },
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "InnerType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "InnerType"
  },
  {
    "label": "Helper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Helper"
  },
  {
    "label": "HasHelperSupport",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HasHelperSupport"
  },
  {
    "label": "TypeFor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TypeFor"
  },
  {
    "label": "TypeCheck",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TypeCheck"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TraceValue",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TraceValue"
  },
  {
    "label": "TraceStringWithCopy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TraceStringWithCopy"
  },
  {
    "label": "TraceArguments",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TraceArguments"
  },
  {
    "label": "Data",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Data"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_TRACE_EVENT_TRACE_ARGUMENTS_H_ # define BASE_TRACE_EVENT_TRACE_ARGUMENTS_H_ # include<stdlib . h> # include<string . h> # include<algorithm> # include<memory> # include<string> # include<utility> # include \" base / base_export . h \" # include \" base / trace_event / common / trace_event_common . h \" # include \" base / tracing_buildflags . h \" # include \" third_party / perfetto / include / perfetto / protozero / scattered_heap_buffer . h \" # include \" third_party / perfetto / include / perfetto / tracing / traced_value . h \" # include \" third_party / perfetto / protos / perfetto / trace / track_event / debug_annotation . pbzero . h \" namespace base { class Time ; class TimeTicks ; class ThreadTicks ; namespace trace_event { class TraceEventMemoryOverhead ; class BASE_EXPORT ConvertableToTraceFormat # if)",
    "insertText": "BUILDFLAG(USE_PERFETTO_CLIENT_LIBRARY)"
  },
  {
    "label": "ConvertableToTraceFormat()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "ConvertableToTraceFormat()"
  },
  {
    "label": "ConvertableToTraceFormat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConvertableToTraceFormat(const ConvertableToTraceFormat&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ConvertableToTraceFormat&)",
    "insertText": "operator(const ConvertableToTraceFormat&)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(USE_PERFETTO_CLIENT_LIBRARY) ~ConvertableToTraceFormat()"
  },
  {
    "label": "AppendAsTraceFormat()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "AppendAsTraceFormat(std::string* out)"
  },
  {
    "label": "ProtoAppender()",
    "kind": "Method",
    "detail": "Function (class BASE_EXPORT ProtoAppender { public : ~)",
    "insertText": "ProtoAppender()"
  },
  {
    "label": "AddBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddBuffer(uint8_t* begin, uint8_t* end)"
  },
  {
    "label": "Finalize()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "Finalize(uint32_t field_id)"
  },
  {
    "label": "AppendToProto()",
    "kind": "Method",
    "detail": "Function (} ; bool)",
    "insertText": "AppendToProto(ProtoAppender* appender)"
  },
  {
    "label": "EstimateTraceMemoryOverhead()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EstimateTraceMemoryOverhead(TraceEventMemoryOverhead* overhead)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(USE_PERFETTO_CLIENT_LIBRARY) void Add(perfetto::protos::pbzero::DebugAnnotation*)"
  },
  {
    "label": "Make()",
    "kind": "Method",
    "detail": "Function (# endif } ; const int kTraceMaxNumArgs = 2 ; union BASE_EXPORT TraceValue { bool as_bool ; unsigned long long as_uint ; long long as_int ; double as_double ; const void* as_pointer ; const char* as_string ; ConvertableToTraceFormat* as_convertable ; protozero::HeapBuffered<perfetto::protos::pbzero::DebugAnnotation>* as_proto ; template<T> TraceValue)",
    "insertText": "Make(T&& value)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (TraceValue ret ; ret .)",
    "insertText": "Init(std::forward<T>(value))"
  },
  {
    "label": "AppendAsString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendAsString(unsigned char type, std::string* out)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "Append(unsigned char type, bool as_json, std::string* out)"
  },
  {
    "label": "check_support()",
    "kind": "Method",
    "detail": "Function (template<T> struct InnerType { using type = std::decay_t<T> ; } ; public : template<T,class = void> struct Helper { } ; template<T> struct HasHelperSupport { private : using Yes = char [ 1 ] ; using No = char [ 2 ] ; template<V> Yes&)",
    "insertText": "check_support(decltype(TraceValue::Helper<typename InnerType<V>::type>::kType, int()))"
  },
  {
    "label": "check_support()",
    "kind": "Method",
    "detail": "Function (template<V> No&)",
    "insertText": "check_support(...)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (public : bool value =)",
    "insertText": "sizeof(Yes) == sizeof(check_support<T>(0))"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} ; template<T,class = void> struct TypeFor ; template<T> struct TypeFor<T,std::enable_if<HasHelperSupport<InnerType<T>::type>::value>::type> { using ValueType = InnerType<T>::type ; const unsigned char value = Helper<ValueType>::kType ; } ; template<T> struct TypeFor<T,std::enable_if<! HasHelperSupport<InnerType<T>::type>::value&& perfetto::internal::has_traced_value_support<InnerType<T>::type>::value>::type> { const unsigned char value = TRACE_VALUE_TYPE_PROTO ; } ; template<T,class = std::enable_if_t<HasHelperSupport<InnerType<T>::type>::value | | perfetto::internal::has_traced_value_support<InnerType<T>::type>::value>> struct TypeCheck { const bool value = true ; } ; template<class T> std::enable_if<HasHelperSupport<InnerType<T>::type>::value>::type)",
    "insertText": "Init(T&& value)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (using ValueType = InnerType<T>::type ; Helper<ValueType)",
    "insertText": "SetValue(this, std::forward<T>(value))"
  },
  {
    "label": "DebugAnnotation()",
    "kind": "Method",
    "detail": "Function (as_proto = new protozero::HeapBuffered<perfetto::protos::)",
    "insertText": "DebugAnnotation()"
  },
  {
    "label": "WriteIntoTracedValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteIntoTracedValue(perfetto::internal::CreateTracedValueFromProto(as_proto->get()), std::forward<T>(value))"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> struct TraceValue::Helper<T,std::enable_if<std::is_integral<T>::value | | std::is_enum<T>::value>::type> { unsigned char kType = std::is_signed<T>::value ? TRACE_VALUE_TYPE_INT : TRACE_VALUE_TYPE_UINT ; void)",
    "insertText": "SetValue(TraceValue* v, T value)"
  },
  {
    "label": "long()",
    "kind": "Method",
    "detail": "Function (v -> as_uint = static_cast<unsigned long)",
    "insertText": "long(value)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (v -> as_double = value ; } } ; template<> struct TraceValue::Helper<bool> { unsigned char kType = TRACE_VALUE_TYPE_BOOL ; void)",
    "insertText": "SetValue(TraceValue* v, bool value)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (v -> as_bool = value ; } } ; template<> struct TraceValue::Helper<const void*> { unsigned char kType = TRACE_VALUE_TYPE_POINTER ; void)",
    "insertText": "SetValue(TraceValue* v, const void* value)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (v -> as_pointer = value ; } } ; template<> struct TraceValue::Helper<void*> { unsigned char kType = TRACE_VALUE_TYPE_POINTER ; void)",
    "insertText": "SetValue(TraceValue* v, void* value)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (v -> as_pointer = value ; } } ; template<> struct TraceValue::Helper<const char*> { unsigned char kType = TRACE_VALUE_TYPE_STRING ; void)",
    "insertText": "SetValue(TraceValue* v, const char* value)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (v -> as_string = value ; } } ; template<> struct TraceValue::Helper<std::string> { unsigned char kType = TRACE_VALUE_TYPE_COPY_STRING ; void)",
    "insertText": "SetValue(TraceValue* v, const std::string& value)"
  },
  {
    "label": "c_str()",
    "kind": "Method",
    "detail": "Function (v -> as_string = value .)",
    "insertText": "c_str()"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (} } ; template<CONVERTABLE_TYPE> struct TraceValue::Helper<std::unique_ptr<CONVERTABLE_TYPE>,std::enable_if<std::is_convertible<CONVERTABLE_TYPE*,ConvertableToTraceFormat*>::value>::type> { unsigned char kType = TRACE_VALUE_TYPE_CONVERTABLE ; void)",
    "insertText": "SetValue(TraceValue* v, std::unique_ptr<CONVERTABLE_TYPE> value)"
  },
  {
    "label": "release()",
    "kind": "Method",
    "detail": "Function (v -> as_convertable = value .)",
    "insertText": "release()"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> struct TraceValue::Helper<T,std::enable_if<std::is_same<T,base::Time>::value | | std::is_same<T,base::TimeTicks>::value | | std::is_same<T,base::ThreadTicks>::value>::type> { unsigned char kType = TRACE_VALUE_TYPE_INT ; void)",
    "insertText": "SetValue(TraceValue* v, const T& value)"
  },
  {
    "label": "ToInternalValue()",
    "kind": "Method",
    "detail": "Function (v -> as_int = value .)",
    "insertText": "ToInternalValue()"
  },
  {
    "label": "TraceStringWithCopy()",
    "kind": "Method",
    "detail": "Function (} } ; class TraceStringWithCopy { public :)",
    "insertText": "TraceStringWithCopy(const char* str) : str_(str)"
  },
  {
    "label": "str()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "str()"
  },
  {
    "label": "StringStorage()",
    "kind": "Method",
    "detail": "Function (} } ; class TraceArguments ; class BASE_EXPORT StringStorage { public :)",
    "insertText": "StringStorage()"
  },
  {
    "label": "StringStorage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StringStorage(size_t alloc_size)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset(alloc_size)"
  },
  {
    "label": "StringStorage()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "StringStorage(StringStorage&& other) noexcept : data_(other.data_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (other . data_ = nullptr ; } StringStorage&)",
    "insertText": "operator(StringStorage&& other)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (data_ = other . data_ ; other . data_ = nullptr ; } return* this ; } void)",
    "insertText": "Reset(size_t alloc_size = 0)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "size()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "end()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} char*)",
    "insertText": "begin()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Contains(const void* ptr)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (const char* char_ptr = static_cast<const)",
    "insertText": "char(ptr)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Contains(const TraceArguments& args)"
  },
  {
    "label": "EstimateTraceMemoryOverhead()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "EstimateTraceMemoryOverhead()"
  },
  {
    "label": "TraceArguments()",
    "kind": "Method",
    "detail": "Function (} private : struct Data { size_t size = 0 ; char chars [ 1 ] ; } ; Data* data_ = nullptr ; } ; class BASE_EXPORT TraceArguments { public : size_t kMaxSize = 2 ;)",
    "insertText": "TraceArguments() : size_(0)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<T,class =)",
    "insertText": "decltype(TraceValue::TypeCheck<T>::value)> TraceArguments(const char* arg1_name, T&& arg1_value) : size_(1)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (types_ [ 0 ] = TraceValue::TypeFor<T>::value ; names_ [ 0 ] = arg1_name ; values_ [ 0 ] .)",
    "insertText": "Init(std::forward<T>(arg1_value))"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<T1,T2,class =)",
    "insertText": "decltype(TraceValue::TypeCheck<T1>::value && TraceValue::TypeCheck<T2>::value)> TraceArguments(const char* arg1_name, T1&& arg1_value, const char* arg2_name, T2&& arg2_value) : size_(2)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (types_ [ 0 ] = TraceValue::TypeFor<T1>::value ; types_ [ 1 ] = TraceValue::TypeFor<T2>::value ; names_ [ 0 ] = arg1_name ; names_ [ 1 ] = arg2_name ; values_ [ 0 ] .)",
    "insertText": "Init(std::forward<T1>(arg1_value))"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (values_ [ 1 ] .)",
    "insertText": "Init(std::forward<T2>(arg2_value))"
  },
  {
    "label": "TraceArguments()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TraceArguments(int num_args, const char* const* arg_names, const unsigned char* arg_types, const unsigned long long* arg_values)"
  },
  {
    "label": "TraceArguments()",
    "kind": "Method",
    "detail": "Function (template<CONVERTABLE_TYPE>)",
    "insertText": "TraceArguments(int num_args, const char* const* arg_names, const unsigned char* arg_types, const unsigned long long* arg_values, CONVERTABLE_TYPE* arg_convertables)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (int max_args = static_cast<)",
    "insertText": "int(kMaxSize)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (size_ = static_cast<unsigned)",
    "insertText": "char(num_args)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (types_ [ n ] = arg_types [ n ] ; names_ [ n ] = arg_names [ n ] ;)",
    "insertText": "if(arg_types[n] == TRACE_VALUE_TYPE_CONVERTABLE)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (values_ [ n ] .)",
    "insertText": "Init(std::forward<CONVERTABLE_TYPE>(std::move(arg_convertables[n])))"
  },
  {
    "label": "TraceArguments()",
    "kind": "Method",
    "detail": "Function (} else { values_ [ n ] . as_uint = arg_values [ n ] ; } } } ~)",
    "insertText": "TraceArguments()"
  },
  {
    "label": "TraceArguments()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "TraceArguments(const TraceArguments&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TraceArguments&)",
    "insertText": "operator(const TraceArguments&)"
  },
  {
    "label": "TraceArguments()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TraceArguments(TraceArguments&& other)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(this, &other, sizeof(*this))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (other . size_ = 0 ; } TraceArguments&)",
    "insertText": "operator(TraceArguments&&)"
  },
  {
    "label": "CopyStringsTo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyStringsTo(StringStorage* storage, bool copy_all_strings, const char** extra_string1, const char** extra_string2)"
  },
  {
    "label": "AppendDebugString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendDebugString(std::string* out)"
  }
]