[
  {
    "label": "IMovieScenePlayer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IMovieScenePlayer"
  },
  {
    "label": "IMovieScenePlaybackClient",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IMovieScenePlaybackClient"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FPlaybackCapabilityPtr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPlaybackCapabilityPtr"
  },
  {
    "label": "TPlaybackCapabilityInterfaceCast",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TPlaybackCapabilityInterfaceCast"
  },
  {
    "label": "TPlaybackCapabilityDestructor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TPlaybackCapabilityDestructor"
  },
  {
    "label": "FPlaybackCapabilityHelpers",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPlaybackCapabilityHelpers"
  },
  {
    "label": "TPlaybackCapabilityHelpers",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TPlaybackCapabilityHelpers"
  },
  {
    "label": "TPlaybackCapabilityStorageTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TPlaybackCapabilityStorageTraits"
  },
  {
    "label": "FPlaybackCapabilityHeader",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPlaybackCapabilityHeader"
  },
  {
    "label": "FPlaybackCapabilitiesImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPlaybackCapabilitiesImpl"
  },
  {
    "label": "FPlaybackCapabilities",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPlaybackCapabilities"
  },
  {
    "label": "ResolveOptional()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Evaluation / IMovieScenePlaybackCapability . h \" # include \" EntitySystem / RelativePtr . h \" # include \" Templates / AlignmentTemplates . h \" # include \" Templates / PointerIsConvertibleFromTo . h \" class IMovieScenePlayer ; class IMovieScenePlaybackClient ; namespace UE::MovieScene { enum class EPlaybackCapabilityStorageMode : uint8 { = 0,RawPointer,SharedPointer } ; struct FPlaybackCapabilityPtr { void* Ptr = 0 ; EPlaybackCapabilityStorageMode StorageMode ; template<T> T*)",
    "insertText": "ResolveOptional()"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (default :)",
    "insertText": "checkf(false, TEXT(\"Unexpected playback capability storage mode\"))"
  },
  {
    "label": "IPlaybackCapability()",
    "kind": "Method",
    "detail": "Function (} } } ; using FPlaybackCapabilityInterfaceCastHelper =)",
    "insertText": "IPlaybackCapability(*)(void* Ptr)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (using FPlaybackCapabilityDestructionHelper =)",
    "insertText": "void(*)(void* Ptr)"
  },
  {
    "label": "InterfaceCast()",
    "kind": "Method",
    "detail": "Function (template<StorageType> struct TPlaybackCapabilityInterfaceCast { IPlaybackCapability*)",
    "insertText": "InterfaceCast(void* Ptr)"
  },
  {
    "label": "TypedPtr()",
    "kind": "Method",
    "detail": "Function (PointedType*)",
    "insertText": "TypedPtr(PointedType**)"
  },
  {
    "label": "TypedPtr()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<PointedType>&)",
    "insertText": "TypedPtr(TSharedPtr<PointedType>*)"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (} else { return nullptr ; } } ; } ; template<StorageType> struct TPlaybackCapabilityDestructor { void)",
    "insertText": "Destroy(void* Ptr)"
  },
  {
    "label": "StoragePtr()",
    "kind": "Method",
    "detail": "Function (StorageType*)",
    "insertText": "StoragePtr(StorageType*)"
  },
  {
    "label": "StorageType()",
    "kind": "Method",
    "detail": "Function (StoragePtr -> ~)",
    "insertText": "StorageType()"
  },
  {
    "label": "GetHelpers()",
    "kind": "Method",
    "detail": "Function (} } ; struct FPlaybackCapabilityHelpers { FPlaybackCapabilityInterfaceCastHelper InterfaceCast = nullptr ; FPlaybackCapabilityDestructionHelper Destructor = nullptr ; } ; template<StorageType> struct TPlaybackCapabilityHelpers { FPlaybackCapabilityHelpers)",
    "insertText": "GetHelpers()"
  },
  {
    "label": "GetStorageMode()",
    "kind": "Method",
    "detail": "Function (FPlaybackCapabilityHelpers Helpers ; Helpers . InterfaceCast =& TPlaybackCapabilityInterfaceCast<StorageType>::InterfaceCast ; Helpers . Destructor =& TPlaybackCapabilityDestructor<StorageType>::Destroy ; return Helpers ; } } ; template<StorageType,CapabilityType,= void> struct TPlaybackCapabilityStorageTraits ; template<StorageType,CapabilityType> struct TPlaybackCapabilityStorageTraits<StorageType,CapabilityType,TEnableIf<TPointerIsConvertibleFromTo<StorageType,CapabilityType>::Value>::Type> { EPlaybackCapabilityStorageMode)",
    "insertText": "GetStorageMode()"
  },
  {
    "label": "uint64()",
    "kind": "Method",
    "detail": "Function (const uint64 PointerOffset = reinterpret_cast<)",
    "insertText": "uint64(static_cast<CapabilityType*>(StoragePtr)) - reinterpret_cast<uint64>(StoragePtr)"
  },
  {
    "label": "Resolve()",
    "kind": "Method",
    "detail": "Function (void* DerivedPointer = Capability .)",
    "insertText": "Resolve(InMemory)"
  },
  {
    "label": "FPlaybackCapabilitiesImpl()",
    "kind": "Method",
    "detail": "Function (} } ; struct FPlaybackCapabilitiesImpl { protected :)",
    "insertText": "FPlaybackCapabilitiesImpl()"
  },
  {
    "label": "FPlaybackCapabilitiesImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPlaybackCapabilitiesImpl(const FPlaybackCapabilitiesImpl&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FPlaybackCapabilitiesImpl&)",
    "insertText": "operator(const FPlaybackCapabilitiesImpl&)"
  },
  {
    "label": "FPlaybackCapabilitiesImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPlaybackCapabilitiesImpl(FPlaybackCapabilitiesImpl&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FPlaybackCapabilitiesImpl&)",
    "insertText": "operator(FPlaybackCapabilitiesImpl&&)"
  },
  {
    "label": "HasCapability()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasCapability(uint32 CapabilityBit)"
  },
  {
    "label": "FindCapability()",
    "kind": "Method",
    "detail": "Function (} FPlaybackCapabilityPtr)",
    "insertText": "FindCapability(uint32 CapabilityBit)"
  },
  {
    "label": "GetCapabilityIndex()",
    "kind": "Method",
    "detail": "Function (const int32 Index =)",
    "insertText": "GetCapabilityIndex(CapabilityBit)"
  },
  {
    "label": "FPlaybackCapabilityPtr()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "FPlaybackCapabilityPtr()"
  },
  {
    "label": "GetCapabilityChecked()",
    "kind": "Method",
    "detail": "Function (} FPlaybackCapabilityPtr)",
    "insertText": "GetCapabilityChecked(uint32 CapabilityBit)"
  },
  {
    "label": "AddCapability()",
    "kind": "Method",
    "detail": "Function (} template<StorageType,CapabilityType,. . . ArgTypes> FPlaybackCapabilityPtr)",
    "insertText": "AddCapability(uint32 CapabilityBit, ArgTypes&&... InArgs)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (AllCapabilities | = CapabilityBit ; const int32 NewCapabilityIndex = static_cast<)",
    "insertText": "int32(FMath::CountBits(AllCapabilities & (CapabilityBit-1u)))"
  },
  {
    "label": "FPlaybackCapabilityHeader()",
    "kind": "Method",
    "detail": "Function (const FPlaybackCapabilityHeader* ExistingHeaders = reinterpret_cast<const)",
    "insertText": "FPlaybackCapabilityHeader(Memory)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (uint64 RequiredAlignment =)",
    "insertText": "Max(alignof(StorageType), alignof(FPlaybackCapabilityHeader))"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (const int32 ExistingNum = static_cast<)",
    "insertText": "int32(Num)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function ({)",
    "insertText": "for(int32 Index = 0; Index < ExistingNum; ++Index)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (RequiredAlignment =)",
    "insertText": "Max(RequiredAlignment, (uint64)ExistingHeaders[Index].Alignment)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (} } TArray<uint16,TInlineAllocator<1 6>> NewCapabilityOffsets ; NewCapabilityOffsets .)",
    "insertText": "SetNum(ExistingNum + 1)"
  },
  {
    "label": "RequiredSizeof()",
    "kind": "Method",
    "detail": "Function (uint64 RequiredSizeof = 0 u ; {)",
    "insertText": "RequiredSizeof(ExistingNum + 1) * sizeof(FPlaybackCapabilityHeader)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 Index = 0 ;)",
    "insertText": "for(; Index < NewCapabilityIndex; ++Index)"
  },
  {
    "label": "Align()",
    "kind": "Method",
    "detail": "Function (RequiredSizeof =)",
    "insertText": "Align(RequiredSizeof, (uint64)ExistingHeaders[Index].Alignment)"
  },
  {
    "label": "uint16()",
    "kind": "Method",
    "detail": "Function (NewCapabilityOffsets [ Index ] = static_cast<)",
    "insertText": "uint16(RequiredSizeof)"
  },
  {
    "label": "Align()",
    "kind": "Method",
    "detail": "Function (RequiredSizeof + = ExistingHeaders [ Index ] . Sizeof ; } RequiredSizeof =)",
    "insertText": "Align(RequiredSizeof, alignof(StorageType))"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (RequiredSizeof + =)",
    "insertText": "sizeof(StorageType)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (+ + Index ;)",
    "insertText": "for(; Index < ExistingNum+1; ++Index)"
  },
  {
    "label": "Align()",
    "kind": "Method",
    "detail": "Function (RequiredSizeof =)",
    "insertText": "Align(RequiredSizeof, (uint64)ExistingHeaders[Index-1].Alignment)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (RequiredSizeof + = ExistingHeaders [ Index - 1 ] . Sizeof ; } })",
    "insertText": "check(RequiredAlignment <= 0XFF)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uint8* OldMemory = Memory ; const bool bNeedsReallocation = RequiredAlignment> Alignment | | RequiredSizeof> Capacity ;)",
    "insertText": "if(bNeedsReallocation)"
  },
  {
    "label": "uint16()",
    "kind": "Method",
    "detail": "Function (Capacity = static_cast<)",
    "insertText": "uint16(FMath::Max(RequiredSizeof, uint64(Capacity)*2))"
  },
  {
    "label": "uint8()",
    "kind": "Method",
    "detail": "Function (Memory = reinterpret_cast<)",
    "insertText": "uint8(FMemory::Malloc(Capacity, RequiredAlignment))"
  },
  {
    "label": "NewCapabilityOffsets()",
    "kind": "Method",
    "detail": "Function (} + + Num ; const FPlaybackCapabilityHeader* OldHeaders = ExistingHeaders ; auto RelocateCapability = [ this,OldMemory,OldHeaders,&)",
    "insertText": "NewCapabilityOffsets(int32 OldIndex, int32 NewIndex)"
  },
  {
    "label": "Resolve()",
    "kind": "Method",
    "detail": "Function (void* NewCapabilityPtr = this -> Memory + NewCapabilityOffsets [ NewIndex ] ; void* OldCapabilityPtr = OldHeaders [ OldIndex ] . Capability .)",
    "insertText": "Resolve(OldMemory)"
  },
  {
    "label": "Memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memmove(NewCapabilityPtr, OldCapabilityPtr, OldHeaders[OldIndex].Sizeof)"
  },
  {
    "label": "RelocateCapability()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RelocateCapability(Index - 1, Index)"
  },
  {
    "label": "StorageType()",
    "kind": "Method",
    "detail": "Function (} { void* NewCapabilityPtr = this -> Memory + NewCapabilityOffsets [ Index ] ; StorageType* NewCapabilityTypedPtr = reinterpret_cast<)",
    "insertText": "StorageType(NewCapabilityPtr)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(NewCapabilityTypedPtr) StorageType (Forward<ArgTypes>(InArgs)...)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} - - Index ;)",
    "insertText": "for(; Index >= 0; --Index)"
  },
  {
    "label": "RelocateCapability()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RelocateCapability(Index, Index)"
  },
  {
    "label": "OldHeader()",
    "kind": "Method",
    "detail": "Function (const FPlaybackCapabilityHeader&)",
    "insertText": "OldHeader(OldHeaders[OldIndex])"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (FPlaybackCapabilityHeader* NewHeaderPtr =& NewHeaders [ NewIndex ] ;)",
    "insertText": "new(NewHeaderPtr) FPlaybackCapabilityHeader(OldHeader)"
  },
  {
    "label": "uint16()",
    "kind": "Method",
    "detail": "Function (void* NewCapabilityPtr = this -> Memory + NewCapabilityOffsets [ NewIndex ] ; NewHeaderPtr -> Capability = TRelativePtr<void,)",
    "insertText": "uint16(this->Memory, NewCapabilityPtr)"
  },
  {
    "label": "RelocateHeader()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RelocateHeader(Index - 1, Index)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} FPlaybackCapabilityHeader* NewHeaderPtr =& NewHeaders [ Index ] ; { using FStorageTraits = TPlaybackCapabilityStorageTraits<StorageType,CapabilityType> ;)",
    "insertText": "static_assert(alignof(StorageType) < 0x7F, \"Required alignment of capability must fit in 7 bytes\")"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(NewHeaderPtr) FPlaybackCapabilityHeader()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (NewHeaderPtr -> Capability .)",
    "insertText": "Reset(Memory, NewCapabilityPtr)"
  },
  {
    "label": "alignof()",
    "kind": "Method",
    "detail": "Function (NewHeaderPtr -> Alignment =)",
    "insertText": "alignof(StorageType)"
  },
  {
    "label": "ComputePointerOffset()",
    "kind": "Method",
    "detail": "Function (NewHeaderPtr -> PointerOffset =)",
    "insertText": "ComputePointerOffset(NewCapabilityTypedPtr)"
  },
  {
    "label": "RelocateHeader()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RelocateHeader(Index, Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bNeedsReallocation && OldMemory)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(OldMemory)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (} Helpers .)",
    "insertText": "Insert(TPlaybackCapabilityHelpers<StorageType>::GetHelpers(), NewCapabilityIndex)"
  },
  {
    "label": "OverwriteCapability()",
    "kind": "Method",
    "detail": "Function (} template<StorageType,CapabilityType,. . . ArgTypes> bool)",
    "insertText": "OverwriteCapability(uint32 CapabilityBit, ArgTypes&&... InArgs)"
  },
  {
    "label": "GetHeader()",
    "kind": "Method",
    "detail": "Function (const FPlaybackCapabilityHeader& Header =)",
    "insertText": "GetHeader(static_cast<uint8>(Index))"
  },
  {
    "label": "Destructor()",
    "kind": "Method",
    "detail": "Function (Helpers [ Index ] .)",
    "insertText": "Destructor(CapabilityPtr)"
  },
  {
    "label": "StorageType()",
    "kind": "Method",
    "detail": "Function (StorageType* TypedCapabilityPtr = reinterpret_cast<)",
    "insertText": "StorageType(CapabilityPtr)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(TypedCapabilityPtr) StorageType(Forward<ArgTypes>(InArgs)...)"
  },
  {
    "label": "GetHeaders()",
    "kind": "Method",
    "detail": "Function (} TArrayView<const FPlaybackCapabilityHeader>)",
    "insertText": "GetHeaders()"
  },
  {
    "label": "GetCapabilityIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetCapabilityIndex(uint32 CapabilityBit)"
  },
  {
    "label": "FPlaybackCapabilities()",
    "kind": "Method",
    "detail": "Function (} uint8* Memory = nullptr ; uint16 Alignment = 0 u ; uint16 Capacity = 0 u ; uint8 Num = 0 u ; uint32 AllCapabilities = 0 u ; TArray<FPlaybackCapabilityHelpers> Helpers ; } ; struct FPlaybackCapabilities : FPlaybackCapabilitiesImpl {)",
    "insertText": "FPlaybackCapabilities()"
  },
  {
    "label": "FPlaybackCapabilities()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPlaybackCapabilities(const FPlaybackCapabilities&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FPlaybackCapabilities&)",
    "insertText": "operator(const FPlaybackCapabilities&)"
  },
  {
    "label": "FPlaybackCapabilities()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPlaybackCapabilities(FPlaybackCapabilities&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FPlaybackCapabilities&)",
    "insertText": "operator(FPlaybackCapabilities&&)"
  },
  {
    "label": "HasCapability()",
    "kind": "Method",
    "detail": "Function (template<T> bool)",
    "insertText": "HasCapability()"
  },
  {
    "label": "HasCapability()",
    "kind": "Method",
    "detail": "Function (uint32 CapabilityBit = 1<<T::ID . Index ; return)",
    "insertText": "HasCapability(CapabilityBit)"
  },
  {
    "label": "FindCapability()",
    "kind": "Method",
    "detail": "Function (} template<T> T*)",
    "insertText": "FindCapability()"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (using CapabilityIDType =)",
    "insertText": "decltype(T::ID)"
  },
  {
    "label": "CapabilityID()",
    "kind": "Method",
    "detail": "Function (const TPlaybackCapabilityID<T>)",
    "insertText": "CapabilityID(T::ID)"
  },
  {
    "label": "FindCapability()",
    "kind": "Method",
    "detail": "Function (uint32 CapabilityBit = 1<<CapabilityID . Index ; FPlaybackCapabilityPtr Ptr =)",
    "insertText": "FindCapability(CapabilityBit)"
  },
  {
    "label": "GetCapabilityChecked()",
    "kind": "Method",
    "detail": "Function (} template<T> T&)",
    "insertText": "GetCapabilityChecked()"
  },
  {
    "label": "GetCapabilityChecked()",
    "kind": "Method",
    "detail": "Function (uint32 CapabilityBit = 1<<CapabilityID . Index ; FPlaybackCapabilityPtr Ptr =)",
    "insertText": "GetCapabilityChecked(CapabilityBit)"
  },
  {
    "label": "AddCapability()",
    "kind": "Method",
    "detail": "Function (} template<T,. . . ArgTypes> T&)",
    "insertText": "AddCapability(ArgTypes&&... InArgs)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (using CapabilityType = CapabilityIDType::CapabilityType ; CapabilityType& NewCapability = DoAddCapability<)",
    "insertText": "T(T::ID, Forward<ArgTypes>(InArgs)...)"
  },
  {
    "label": "AddCapabilityRaw()",
    "kind": "Method",
    "detail": "Function (} template<T> T&)",
    "insertText": "AddCapabilityRaw(T* InPointer)"
  },
  {
    "label": "CapabilityType()",
    "kind": "Method",
    "detail": "Function (using CapabilityType = CapabilityIDType::CapabilityType ; CapabilityType& NewCapability = DoAddCapability<)",
    "insertText": "CapabilityType(T::ID, static_cast<CapabilityType*>(InPointer))"
  },
  {
    "label": "AddCapabilityShared()",
    "kind": "Method",
    "detail": "Function (} template<T> T&)",
    "insertText": "AddCapabilityShared(TSharedRef<T> InSharedRef)"
  },
  {
    "label": "CapabilityType()",
    "kind": "Method",
    "detail": "Function (using CapabilityType = CapabilityIDType::CapabilityType ; CapabilityType& NewCapability = DoAddCapability<TSharedPtr<)",
    "insertText": "CapabilityType(T::ID, StaticCastSharedRef<CapabilityType>(InSharedRef))"
  },
  {
    "label": "OverwriteCapability()",
    "kind": "Method",
    "detail": "Function (} template<T,. . . ArgTypes> T&)",
    "insertText": "OverwriteCapability(ArgTypes&&... InArgs)"
  },
  {
    "label": "OverwriteCapabilityRaw()",
    "kind": "Method",
    "detail": "Function (} template<T> T&)",
    "insertText": "OverwriteCapabilityRaw(T* InPointer)"
  },
  {
    "label": "OverwriteCapabilityShared()",
    "kind": "Method",
    "detail": "Function (} template<T> T&)",
    "insertText": "OverwriteCapabilityShared(TSharedRef<T> InSharedRef)"
  },
  {
    "label": "OnSubInstanceCreated()",
    "kind": "Method",
    "detail": "Function (} public : void)",
    "insertText": "OnSubInstanceCreated(TSharedRef<const FSharedPlaybackState> Owner, const FInstanceHandle InstanceHandle)"
  },
  {
    "label": "InvalidateCachedData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InvalidateCachedData(UMovieSceneEntitySystemLinker* Linker)"
  },
  {
    "label": "ForEachCapabilityInterface()",
    "kind": "Method",
    "detail": "Function (private : template<Callback,. . . ArgTypes> void)",
    "insertText": "ForEachCapabilityInterface(Callback&& InCallback, ArgTypes&&... InArgs)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (const FPlaybackCapabilityHeader& Header = Headers [ Index ] ; const FPlaybackCapabilityHelpers& ThisHelpers = Helpers [ Index ] ;)",
    "insertText": "check(ThisHelpers.InterfaceCast != nullptr)"
  },
  {
    "label": "Resolve()",
    "kind": "Method",
    "detail": "Function ({ void* Ptr = Header . Capability .)",
    "insertText": "Resolve(Memory)"
  },
  {
    "label": "InCallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InCallback(*Interface, Forward<ArgTypes>(InArgs)...)"
  },
  {
    "label": "DoAddCapability()",
    "kind": "Method",
    "detail": "Function (} } } } template<Impl,T,. . . ArgTypes> T&)",
    "insertText": "DoAddCapability(TPlaybackCapabilityID<T> CapabilityID, ArgTypes&&... InArgs)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (uint32 CapabilityBit = 1<<CapabilityID . Index ; FPlaybackCapabilityPtr Ptr = FPlaybackCapabilitiesImpl::AddCapability<Impl,)",
    "insertText": "T(CapabilityBit, Forward<ArgTypes>(InArgs)...)"
  },
  {
    "label": "DoOverwriteCapability()",
    "kind": "Method",
    "detail": "Function (} template<Impl,T,. . . ArgTypes> T&)",
    "insertText": "DoOverwriteCapability(TPlaybackCapabilityID<T> CapabilityID, ArgTypes&&... InArgs)"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Destroy()"
  }
]