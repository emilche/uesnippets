[
  {
    "label": "_Int",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Int"
  },
  {
    "label": "__get_wider_signed",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__get_wider_signed"
  },
  {
    "label": "_Start",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Start"
  },
  {
    "label": "_Iter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Iter"
  },
  {
    "label": "__iota_iterator_category",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__iota_iterator_category"
  },
  {
    "label": "iota_view",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "iota_view"
  },
  {
    "label": "__iterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__iterator"
  },
  {
    "label": "__sentinel",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__sentinel"
  },
  {
    "label": "_BoundSentinel",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_BoundSentinel"
  },
  {
    "label": "__fn",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__fn"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___RANGES_IOTA_VIEW_H # define _LIBCPP___RANGES_IOTA_VIEW_H # include<__assert> # include<__compare / three_way_comparable . h> # include<__concepts / arithmetic . h> # include<__concepts / constructible . h> # include<__concepts / convertible_to . h> # include<__concepts / copyable . h> # include<__concepts / equality_comparable . h> # include<__concepts / invocable . h> # include<__concepts / same_as . h> # include<__concepts / semiregular . h> # include<__concepts / totally_ordered . h> # include<__config> # include<__functional / ranges_operations . h> # include<__iterator / concepts . h> # include<__iterator / incrementable_traits . h> # include<__iterator / iterator_traits . h> # include<__iterator / unreachable_sentinel . h> # include<__ranges / copyable_box . h> # include<__ranges / enable_borrowed_range . h> # include<__ranges / view_interface . h> # include<__utility / forward . h> # include<__utility / move . h> # include<type_traits> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER) # pragma GCC system_header #endif _LIBCPP_BEGIN_NAMESPACE_STD #if _LIBCPP_STD_VER > 17 && !defined(_LIBCPP_HAS_NO_INCOMPLETE_RANGES)"
  },
  {
    "label": "__call()",
    "kind": "Method",
    "detail": "Function (template<class _Int> struct __get_wider_signed { auto)",
    "insertText": "__call()"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} ; else if)",
    "insertText": "constexpr(sizeof(_Int) < sizeof(int))"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} ; else if)",
    "insertText": "constexpr(sizeof(_Int) < sizeof(long))"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} ; else return type_identity<long long> { } ;)",
    "insertText": "static_assert(sizeof(_Int) <= sizeof(long long), \"Found integer-like type that is bigger than largest integer like type.\")"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} using type =)",
    "insertText": "decltype(__call())"
  },
  {
    "label": "_If()",
    "kind": "Method",
    "detail": "Function (} ; template<class _Start> using _IotaDiffT =)",
    "insertText": "_If(!integral<_Start> || sizeof(iter_difference_t<_Start>) > sizeof(_Start))"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (template<class _Iter> concept __decrementable = incrementable<_Iter>&&)",
    "insertText": "requires(_Iter __i)"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function ({ - - __i } -> same_as<_Iter&> ; { __i - - } -> same_as<_Iter> ; } ; template<class _Iter> concept __advanceable = __decrementable<_Iter>&& totally_ordered<_Iter>&&)",
    "insertText": "requires(_Iter __i, const _Iter __j, const _IotaDiffT<_Iter> __n)"
  },
  {
    "label": "_Iter()",
    "kind": "Method",
    "detail": "Function ({ __i + = __n } -> same_as<_Iter&> ; { __i - = __n } -> same_as<_Iter&> ;)",
    "insertText": "_Iter(__j + __n)"
  },
  {
    "label": "_Iter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_Iter(__n + __j)"
  },
  {
    "label": "_Iter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_Iter(__j - __n)"
  },
  {
    "label": "_Start()",
    "kind": "Method",
    "detail": "Function ({ __j - __j } -> convertible_to<_IotaDiffT<_Iter>> ; } ; template<class> struct __iota_iterator_category { } ; template<incrementable _Tp> struct __iota_iterator_category<_Tp> { using iterator_category = input_iterator_tag ; } ; template<weakly_incrementable _Start,semiregular _BoundSentinel = unreachable_sentinel_t> requires __weakly_equality_comparable_with<_Start,_BoundSentinel>&& copyable<_Start> class iota_view : public view_interface<iota_view<_Start,_BoundSentinel>> { struct __iterator : public __iota_iterator_category<_Start> { class iota_view ; using iterator_concept = _If<__advanceable<_Start>,random_access_iterator_tag,_If<__decrementable<_Start>,bidirectional_iterator_tag,_If<incrementable<_Start>,forward_iterator_tag,input_iterator_tag>>> ; using value_type = _Start ; using difference_type = _IotaDiffT<_Start> ; _Start __value_ =)",
    "insertText": "_Start()"
  },
  {
    "label": "__iterator()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__iterator()"
  },
  {
    "label": "__iterator()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__iterator(_Start __value) : __value_(std::move(__value))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI _Start)",
    "insertText": "operator() const noexcept(is_nothrow_copy_constructible_v<_Start>)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (+ + __value_ ; return* this ; } _LIBCPP_HIDE_FROM_ABI void)",
    "insertText": "operator(int)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (auto __tmp =* this ; + +* this ; return __tmp ; } _LIBCPP_HIDE_FROM_ABI __iterator&)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (auto __tmp =* this ; - -* this ; return __tmp ; } _LIBCPP_HIDE_FROM_ABI __iterator&)",
    "insertText": "operator(difference_type __n)"
  },
  {
    "label": "_Start()",
    "kind": "Method",
    "detail": "Function (__value_ + = static_cast<)",
    "insertText": "_Start(__n)"
  },
  {
    "label": "_Start()",
    "kind": "Method",
    "detail": "Function (} else { __value_ - = static_cast<)",
    "insertText": "_Start(-__n)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "operator(const __iterator& __x, const __iterator& __y)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (__i + = __n ; return __i ; } _LIBCPP_HIDE_FROM_ABI __iterator)",
    "insertText": "operator(difference_type __n, __iterator __i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(__y.__value_ > __x.__value_)"
  },
  {
    "label": "difference_type()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "difference_type(__x.__value_ - __y.__value_)"
  },
  {
    "label": "_BoundSentinel()",
    "kind": "Method",
    "detail": "Function (} return __x . __value_ - __y . __value_ ; } } ; struct __sentinel { class iota_view ; private : _BoundSentinel __bound_sentinel_ =)",
    "insertText": "_BoundSentinel()"
  },
  {
    "label": "__sentinel()",
    "kind": "Method",
    "detail": "Function (public : _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__sentinel()"
  },
  {
    "label": "__sentinel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__sentinel(_BoundSentinel __bound_sentinel) : __bound_sentinel_(std::move(__bound_sentinel))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "operator(const __iterator& __x, const __sentinel& __y)"
  },
  {
    "label": "iota_view()",
    "kind": "Method",
    "detail": "Function (public : _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "iota_view()"
  },
  {
    "label": "iota_view()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI)",
    "insertText": "iota_view(_Start __value) : __value_(std::move(__value))"
  },
  {
    "label": "iota_view()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "iota_view(type_identity_t<_Start> __value, type_identity_t<_BoundSentinel> __bound_sentinel) : __value_(std::move(__value)), __bound_sentinel_(std::move(__bound_sentinel))"
  },
  {
    "label": "_LIBCPP_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_LIBCPP_ASSERT(ranges::less_equal()(__value_, __bound_sentinel_), \"Precondition violated: value is greater than bound.\")"
  },
  {
    "label": "iota_view()",
    "kind": "Method",
    "detail": "Function (} } _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "iota_view(__iterator __first, __iterator __last) requires same_as<_Start, _BoundSentinel> : iota_view(std::move(__first.__value_), std::move(__last.__value_))"
  },
  {
    "label": "iota_view()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "iota_view(__iterator __first, _BoundSentinel __last) requires same_as<_BoundSentinel, unreachable_sentinel_t> : iota_view(std::move(__first.__value_), std::move(__last))"
  },
  {
    "label": "iota_view()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "iota_view(__iterator __first, __sentinel __last) requires(!same_as<_Start, _BoundSentinel> && !same_as<_Start, unreachable_sentinel_t>) : iota_view(std::move(__first.__value_), std::move(__last.__bound_sentinel_))"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI __iterator)",
    "insertText": "begin()"
  },
  {
    "label": "__to_unsigned_like()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "__to_unsigned_like(__bound_sentinel_) + std::__to_unsigned_like(-__value_)"
  },
  {
    "label": "__to_unsigned_like()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "__to_unsigned_like(__bound_sentinel_) - std::__to_unsigned_like(__value_)"
  },
  {
    "label": "__to_unsigned_like()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "__to_unsigned_like(__bound_sentinel_ - __value_)"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (iota_view<_Start, _BoundSentinel>)",
    "insertText": "requires(!__integer_like<_Start> || !__integer_like<_BoundSentinel> || (__signed_integer_like<_Start> == __signed_integer_like<_BoundSentinel>)) iota_view(_Start, _BoundSentinel)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class _Start,class _BoundSentinel> bool enable_borrowed_range<iota_view<_Start,_BoundSentinel>> = true ; namespace views { namespace __iota { struct __fn { template<class _Start> _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Start&& __start) const noexcept(noexcept(ranges::iota_view(std::forward<_Start>(__start)))) -> decltype( ranges::iota_view(std::forward<_Start>(__start)))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _Start,class _BoundSentinel> _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Start&& __start, _BoundSentinel&& __bound_sentinel) const noexcept(noexcept(ranges::iota_view(std::forward<_Start>(__start), std::forward<_BoundSentinel>(__bound_sentinel)))) -> decltype( ranges::iota_view(std::forward<_Start>(__start), std::forward<_BoundSentinel>(__bound_sentinel)))"
  }
]