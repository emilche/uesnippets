[
  {
    "label": "MakePointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MakePointer"
  },
  {
    "label": "StorageMemory",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StorageMemory"
  },
  {
    "label": "Pointer_type_promotion",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Pointer_type_promotion"
  },
  {
    "label": "TypeConversion",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TypeConversion"
  },
  {
    "label": "MakePointer_",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MakePointer_"
  },
  {
    "label": "TensorMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorMap"
  },
  {
    "label": "Tensor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Tensor"
  },
  {
    "label": "TensorFixedSize",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorFixedSize"
  },
  {
    "label": "TensorRef",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorRef"
  },
  {
    "label": "TensorBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorBase"
  },
  {
    "label": "TensorCwiseNullaryOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorCwiseNullaryOp"
  },
  {
    "label": "TensorCwiseUnaryOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorCwiseUnaryOp"
  },
  {
    "label": "TensorCwiseBinaryOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorCwiseBinaryOp"
  },
  {
    "label": "TensorCwiseTernaryOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorCwiseTernaryOp"
  },
  {
    "label": "TensorSelectOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorSelectOp"
  },
  {
    "label": "TensorReductionOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorReductionOp"
  },
  {
    "label": "TensorIndexTupleOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorIndexTupleOp"
  },
  {
    "label": "TensorTupleReducerOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorTupleReducerOp"
  },
  {
    "label": "TensorConcatenationOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorConcatenationOp"
  },
  {
    "label": "TensorContractionOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorContractionOp"
  },
  {
    "label": "TensorConversionOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorConversionOp"
  },
  {
    "label": "TensorConvolutionOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorConvolutionOp"
  },
  {
    "label": "TensorFFTOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorFFTOp"
  },
  {
    "label": "TensorPatchOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorPatchOp"
  },
  {
    "label": "TensorImagePatchOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorImagePatchOp"
  },
  {
    "label": "TensorVolumePatchOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorVolumePatchOp"
  },
  {
    "label": "TensorBroadcastingOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorBroadcastingOp"
  },
  {
    "label": "TensorChippingOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorChippingOp"
  },
  {
    "label": "TensorReshapingOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorReshapingOp"
  },
  {
    "label": "TensorLayoutSwapOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorLayoutSwapOp"
  },
  {
    "label": "TensorSlicingOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorSlicingOp"
  },
  {
    "label": "TensorReverseOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorReverseOp"
  },
  {
    "label": "TensorPaddingOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorPaddingOp"
  },
  {
    "label": "TensorShufflingOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorShufflingOp"
  },
  {
    "label": "TensorStridingOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorStridingOp"
  },
  {
    "label": "TensorStridingSlicingOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorStridingSlicingOp"
  },
  {
    "label": "TensorInflationOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorInflationOp"
  },
  {
    "label": "TensorGeneratorOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorGeneratorOp"
  },
  {
    "label": "TensorAssignOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorAssignOp"
  },
  {
    "label": "TensorScanOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorScanOp"
  },
  {
    "label": "TensorTraceOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorTraceOp"
  },
  {
    "label": "TensorCustomUnaryOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorCustomUnaryOp"
  },
  {
    "label": "TensorCustomBinaryOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorCustomBinaryOp"
  },
  {
    "label": "TensorEvalToOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorEvalToOp"
  },
  {
    "label": "TensorForcedEvalOp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorForcedEvalOp"
  },
  {
    "label": "TensorDevice",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorDevice"
  },
  {
    "label": "TensorAsyncDevice",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorAsyncDevice"
  },
  {
    "label": "TensorEvaluator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TensorEvaluator"
  },
  {
    "label": "NoOpOutputKernel",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NoOpOutputKernel"
  },
  {
    "label": "DefaultDevice",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DefaultDevice"
  },
  {
    "label": "ThreadPoolDevice",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ThreadPoolDevice"
  },
  {
    "label": "GpuDevice",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GpuDevice"
  },
  {
    "label": "SyclDevice",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SyclDevice"
  },
  {
    "label": "MakeSYCLPointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MakeSYCLPointer"
  },
  {
    "label": "GenericNondeterministicReducer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GenericNondeterministicReducer"
  },
  {
    "label": "FFTResultType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "FFTResultType"
  },
  {
    "label": "FFTDirection",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "FFTDirection"
  },
  {
    "label": "IsVectorizable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsVectorizable"
  },
  {
    "label": "TiledEvaluation",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "TiledEvaluation"
  },
  {
    "label": "IsTileable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsTileable"
  },
  {
    "label": "TensorExecutor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorExecutor"
  },
  {
    "label": "TensorAsyncExecutor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorAsyncExecutor"
  },
  {
    "label": "constCast()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_CXX11_TENSOR_TENSOR_FORWARD_DECLARATIONS_H # define EIGEN_CXX11_TENSOR_TENSOR_FORWARD_DECLARATIONS_H namespace Eigen { template<T> struct MakePointer { typedef T* Type ; typedef const T* ConstType ; } ; template<T> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T*)",
    "insertText": "constCast(const T* data)"
  },
  {
    "label": "constCast()",
    "kind": "Method",
    "detail": "Function (} template<T,device> struct StorageMemory : MakePointer<T> { } ; namespace internal { template<A,B> struct Pointer_type_promotion { const bool val = false ; } ; template<A> struct Pointer_type_promotion<A,A> { const bool val = true ; } ; template<A,B> struct TypeConversion { typedef A* type ; } ; } template<PlainObjectType,int Options_ = Unaligned,template<class> class MakePointer_ = MakePointer> class TensorMap ; template<Scalar_,int NumIndices_,int Options_ = 0,IndexType = DenseIndex> class Tensor ; template<Scalar_,Dimensions,int Options_ = 0,IndexType = DenseIndex> class TensorFixedSize ; template<PlainObjectType> class TensorRef ; template<Derived,int AccessLevel> class TensorBase ; template<NullaryOp,PlainObjectType> class TensorCwiseNullaryOp ; template<UnaryOp,XprType> class TensorCwiseUnaryOp ; template<BinaryOp,LeftXprType,RightXprType> class TensorCwiseBinaryOp ; template<TernaryOp,Arg1XprType,Arg2XprType,Arg3XprType> class TensorCwiseTernaryOp ; template<IfXprType,ThenXprType,ElseXprType> class TensorSelectOp ; template<Op,Dims,XprType,template<class> class MakePointer_ = MakePointer> class TensorReductionOp ; template<XprType> class TensorIndexTupleOp ; template<ReduceOp,Dims,XprType> class TensorTupleReducerOp ; template<Axis,LeftXprType,RightXprType> class TensorConcatenationOp ; template<Dimensions,LeftXprType,RightXprType,OutputKernelType> class TensorContractionOp ; template<TargetType,XprType> class TensorConversionOp ; template<Dimensions,InputXprType,KernelXprType> class TensorConvolutionOp ; template<FFT,XprType,int FFTDataType,int FFTDirection> class TensorFFTOp ; template<PatchDim,XprType> class TensorPatchOp ; template<DenseIndex Rows,DenseIndex Cols,XprType> class TensorImagePatchOp ; template<DenseIndex Planes,DenseIndex Rows,DenseIndex Cols,XprType> class TensorVolumePatchOp ; template<Broadcast,XprType> class TensorBroadcastingOp ; template<DenseIndex DimId,XprType> class TensorChippingOp ; template<NewDimensions,XprType> class TensorReshapingOp ; template<XprType> class TensorLayoutSwapOp ; template<StartIndices,Sizes,XprType> class TensorSlicingOp ; template<ReverseDimensions,XprType> class TensorReverseOp ; template<PaddingDimensions,XprType> class TensorPaddingOp ; template<Shuffle,XprType> class TensorShufflingOp ; template<Strides,XprType> class TensorStridingOp ; template<StartIndices,StopIndices,Strides,XprType> class TensorStridingSlicingOp ; template<Strides,XprType> class TensorInflationOp ; template<Generator,XprType> class TensorGeneratorOp ; template<LeftXprType,RightXprType> class TensorAssignOp ; template<Op,XprType> class TensorScanOp ; template<Dims,XprType> class TensorTraceOp ; template<CustomUnaryFunc,XprType> class TensorCustomUnaryOp ; template<CustomBinaryFunc,LhsXprType,RhsXprType> class TensorCustomBinaryOp ; template<XprType,template<class> class MakePointer_ = MakePointer> class TensorEvalToOp ; template<XprType> class TensorForcedEvalOp ; template<ExpressionType,DeviceType> class TensorDevice ; template<ExpressionType,DeviceType,DoneCallback> class TensorAsyncDevice ; template<Derived,Device> struct TensorEvaluator ; struct NoOpOutputKernel ; struct DefaultDevice ; struct ThreadPoolDevice ; struct GpuDevice ; struct SyclDevice ; # ifdef EIGEN_USE_SYCL template<T> struct MakeSYCLPointer { typedef Eigen::TensorSycl::internal::RangeAccess<cl::sycl::access::mode::read_write,T> Type ; } ; template<T> EIGEN_STRONG_INLINE const Eigen::TensorSycl::internal::RangeAccess<cl::sycl::access::mode::read_write,T>&)",
    "insertText": "constCast(const Eigen::TensorSycl::internal::RangeAccess<cl::sycl::access::mode::read_write, T>& data)"
  }
]