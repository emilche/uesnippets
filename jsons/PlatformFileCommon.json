[
  {
    "label": "FRegisteredFileHandle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRegisteredFileHandle"
  },
  {
    "label": "FFileHandleRegistry",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FFileHandleRegistry"
  },
  {
    "label": "FFileHandleRegistryReadTracker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FFileHandleRegistryReadTracker"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "MANAGE_FILE_HANDLES()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" HAL / ThreadSafeCounter . h \" # include \" Misc / ScopeLock . h \" # include \" HAL / DiskUtilizationTracker . h \" # include \" HAL / ThreadSafeCounter . h \" # include \" Misc / ScopeLock . h \" # include \" GenericPlatform / GenericPlatformFile . h \" # include \" HAL / PlatformProcess . h \" # define)",
    "insertText": "MANAGE_FILE_HANDLES(#)"
  },
  {
    "label": "FFileHandleRegistry()",
    "kind": "Method",
    "detail": "Function (private : class FFileHandleRegistry ; FRegisteredFileHandle* NextLink = nullptr ; FRegisteredFileHandle* PreviousLink = nullptr ; uint32 ReadRequestCount = 0 ; bool bIsOpenAndAvailableForClosing = false ; } ; class FFileHandleRegistry { public :)",
    "insertText": "FFileHandleRegistry(int32 InMaxOpenHandles) : MaxOpenHandles(InMaxOpenHandles)"
  },
  {
    "label": "FFileHandleRegistry()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FFileHandleRegistry()"
  },
  {
    "label": "InitialOpenFile()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FRegisteredFileHandle*)",
    "insertText": "InitialOpenFile(const TCHAR* Filename)"
  },
  {
    "label": "FreeHandles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeHandles()"
  },
  {
    "label": "PlatformInitialOpenFile()",
    "kind": "Method",
    "detail": "Function (} FRegisteredFileHandle* Handle =)",
    "insertText": "PlatformInitialOpenFile(Filename)"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (FScopeLock)",
    "insertText": "Lock(&LockSection)"
  },
  {
    "label": "LinkToTail()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LinkToTail(Handle)"
  },
  {
    "label": "Decrement()",
    "kind": "Method",
    "detail": "Function (} else { HandlesCurrentlyInUse .)",
    "insertText": "Decrement()"
  },
  {
    "label": "UnTrackAndCloseFile()",
    "kind": "Method",
    "detail": "Function (} return Handle ; } void)",
    "insertText": "UnTrackAndCloseFile(FRegisteredFileHandle* Handle)"
  },
  {
    "label": "UnLink()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnLink(Handle)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bWasOpen = true ; } })",
    "insertText": "if(bWasOpen)"
  },
  {
    "label": "PlatformCloseFile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PlatformCloseFile(Handle)"
  },
  {
    "label": "TrackStartRead()",
    "kind": "Method",
    "detail": "Function (} } [ [ nodiscard ] ] bool)",
    "insertText": "TrackStartRead(FRegisteredFileHandle* Handle)"
  },
  {
    "label": "PlatformReopenFile()",
    "kind": "Method",
    "detail": "Function (} bool bSuccess =)",
    "insertText": "PlatformReopenFile(Handle)"
  },
  {
    "label": "TrackEndRead()",
    "kind": "Method",
    "detail": "Function (- - Handle -> ReadRequestCount ; } return bSuccess ; } void)",
    "insertText": "TrackEndRead(FRegisteredFileHandle* Handle)"
  },
  {
    "label": "PlatformInitialOpenFile()",
    "kind": "Method",
    "detail": "Function (} } protected : FRegisteredFileHandle*)",
    "insertText": "PlatformInitialOpenFile(const TCHAR* Filename)"
  },
  {
    "label": "PlatformReopenFile()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "PlatformReopenFile(FRegisteredFileHandle*)"
  },
  {
    "label": "PlatformCloseFile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PlatformCloseFile(FRegisteredFileHandle*)"
  },
  {
    "label": "PopFromHead()",
    "kind": "Method",
    "detail": "Function (ToBeClosed =)",
    "insertText": "PopFromHead()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ToBeClosed)"
  },
  {
    "label": "PlatformCloseFile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PlatformCloseFile(ToBeClosed)"
  },
  {
    "label": "LowLevelOutputDebugString()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "LowLevelOutputDebugString(TEXT(\"FFileHandleRegistry: Spinning because we are actively reading from more file handles than we have possible handles.\\r\\n\"))"
  },
  {
    "label": "SleepNoStats()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SleepNoStats(.1f)"
  },
  {
    "label": "LinkToTail()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "LinkToTail(FRegisteredFileHandle* Handle)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Handle -> bIsOpenAndAvailableForClosing = true ;)",
    "insertText": "if(OpenAndAvailableForClosingTail)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (Handle -> PreviousLink = OpenAndAvailableForClosingTail ;)",
    "insertText": "check(!OpenAndAvailableForClosingTail->NextLink)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (OpenAndAvailableForClosingTail -> NextLink = Handle ; } else {)",
    "insertText": "check(!OpenAndAvailableForClosingHead)"
  },
  {
    "label": "UnLink()",
    "kind": "Method",
    "detail": "Function (OpenAndAvailableForClosingHead = Handle ; } OpenAndAvailableForClosingTail = Handle ; } void)",
    "insertText": "UnLink(FRegisteredFileHandle* Handle)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Handle -> bIsOpenAndAvailableForClosing = false ;)",
    "insertText": "if(OpenAndAvailableForClosingTail == Handle)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (OpenAndAvailableForClosingTail = Handle -> PreviousLink ; OpenAndAvailableForClosingTail -> NextLink = nullptr ; Handle -> NextLink = nullptr ; Handle -> PreviousLink = nullptr ; return ; })",
    "insertText": "check(Handle->NextLink && Handle->PreviousLink)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FRegisteredFileHandle* Result = OpenAndAvailableForClosingHead ;)",
    "insertText": "if(Result)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Result -> bIsOpenAndAvailableForClosing = false ; OpenAndAvailableForClosingHead = Result -> NextLink ;)",
    "insertText": "if(!OpenAndAvailableForClosingHead)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (OpenAndAvailableForClosingTail = nullptr ; } else {)",
    "insertText": "check(OpenAndAvailableForClosingHead->PreviousLink == Result)"
  },
  {
    "label": "FFileHandleRegistryReadTracker()",
    "kind": "Method",
    "detail": "Function (OpenAndAvailableForClosingHead -> PreviousLink = nullptr ; } Result -> NextLink = nullptr ; Result -> PreviousLink = nullptr ; } return Result ; } FCriticalSection LockSection ; int32 MaxOpenHandles = 0 ; FRegisteredFileHandle* OpenAndAvailableForClosingHead = nullptr ; FRegisteredFileHandle* OpenAndAvailableForClosingTail = nullptr ; FThreadSafeCounter HandlesCurrentlyInUse ; } ; class FFileHandleRegistryReadTracker { public :)",
    "insertText": "FFileHandleRegistryReadTracker(FFileHandleRegistry& InFileRegistry, FRegisteredFileHandle& InHandle, bool bTrackRead = true) : FileRegistry(InFileRegistry) , Handle(InHandle)"
  },
  {
    "label": "TrackStartRead()",
    "kind": "Method",
    "detail": "Function (State = FileRegistry .)",
    "insertText": "TrackStartRead(&Handle)"
  },
  {
    "label": "FFileHandleRegistryReadTracker()",
    "kind": "Method",
    "detail": "Function (} else { State = ETrackingState::Skip ; } } ~)",
    "insertText": "FFileHandleRegistryReadTracker()"
  },
  {
    "label": "TrackEndRead()",
    "kind": "Method",
    "detail": "Function (FileRegistry .)",
    "insertText": "TrackEndRead(&Handle)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "IsValid()"
  }
]