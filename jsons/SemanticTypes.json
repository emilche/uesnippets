[
  {
    "label": "SQualifier",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SQualifier"
  },
  {
    "label": "CSymbol",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CSymbol"
  },
  {
    "label": "CClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CClass"
  },
  {
    "label": "CInterface",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CInterface"
  },
  {
    "label": "CDefinition",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CDefinition"
  },
  {
    "label": "CFunctionType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CFunctionType"
  },
  {
    "label": "CAstPackage",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CAstPackage"
  },
  {
    "label": "CExpressionBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CExpressionBase"
  },
  {
    "label": "CFlowType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CFlowType"
  },
  {
    "label": "CFunction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CFunction"
  },
  {
    "label": "CNamedType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CNamedType"
  },
  {
    "label": "CNormalType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CNormalType"
  },
  {
    "label": "CNominalType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CNominalType"
  },
  {
    "label": "CSemanticProgram",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CSemanticProgram"
  },
  {
    "label": "CTypeVariable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CTypeVariable"
  },
  {
    "label": "CTupleType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CTupleType"
  },
  {
    "label": "CUnknownType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CUnknownType"
  },
  {
    "label": "CAliasType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CAliasType"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "VERSECOMPILER_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VERSECOMPILER_API"
  },
  {
    "label": "CGlobalType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CGlobalType"
  },
  {
    "label": "Key",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Key"
  },
  {
    "label": "SKey",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SKey"
  },
  {
    "label": "Constraint",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Constraint"
  },
  {
    "label": "VERSE_ENUM_SEMANTIC_TYPE_KINDS()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" uLang / Common / Algo / Cases . h \" # include \" uLang / Common / Containers / Array . h \" # include \" uLang / Common / Containers / Function . h \" # include \" uLang / Common / Containers / RangeView . h \" # include \" uLang / Common / Containers / Set . h \" # include \" uLang / Common / Containers / UniquePointerArray . h \" # include \" uLang / Common / Text / Named . h \" # include \" uLang / Common / Text / UTF8StringBuilder . h \" # include \" uLang / Semantics / Effects . h \" # include \" uLang / Semantics / MemberOrigin . h \" # include \" uLang / Semantics / Revision . h \" # include \" uLang / Semantics / SmallDefinitionArray . h \" # include \" uLang / Semantics / VisitStamp . h \" # include<cmath> namespace uLang { struct SQualifier ; class CSymbol ; class CClass ; class CInterface ; class CDefinition ; class CFunctionType ; class CAstPackage ; class CExpressionBase ; class CFlowType ; class CFunction ; class CNamedType ; class CNormalType ; class CNominalType ; class CSemanticProgram ; class CTypeVariable ; class CTupleType ; class CUnknownType ; class CAliasType ; # define)",
    "insertText": "VERSE_ENUM_SEMANTIC_TYPE_KINDS(v) \\ v(Unknown, CUnknownType)\\ v(False, CFalseType) \\ v(True, CTrueType) \\ v(Void, CVoidType) \\ v(Any, CAnyType) \\ v(Comparable, CComparableType) \\ v(Logic, CLogicType) \\ v(Int, CIntType) \\ v(Rational, CRationalType) \\ v(Float, CFloatType) \\ v(Char8, CChar8Type) \\ v(Char32, CChar32Type) \\ v(Path, CPathType) \\ v(Range, CRangeType) \\ v(Type, CTypeType) \\ v(Class, CClass) \\ v(Module, CModule) \\ v(Enumeration, CEnumeration) \\ v(Array, CArrayType) \\ v(Generator, CGeneratorType) \\ v(Map, CMapType) \\ v(Pointer, CPointerType) \\ v(Reference, CReferenceType) \\ v(Option, COptionType) \\ v(Interface, CInterface) \\ v(Tuple, CTupleType) \\ v(Function, CFunctionType) \\ v(Variable, CTypeVariable) \\ v(Named, CNamedType) \\ v(Persistable, CPersistableType)"
  },
  {
    "label": "VISIT_KIND()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "VISIT_KIND(Name, CppType) Name, VERSE_ENUM_SEMANTIC_TYPE_KINDS(VISIT_KIND)"
  },
  {
    "label": "TypeKindAsCString()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "TypeKindAsCString(ETypeKind Type)"
  },
  {
    "label": "CTypeBase()",
    "kind": "Method",
    "detail": "Function (enum class ETypeSyntaxPrecedence : uint8_t { Min = 0,List = 0,Definition = 1,Comparison = 2,To = 3,Call = 4,} ; enum class EComparability : uint8_t { Incomparable,Comparable,ComparableAndHashable } ; class CTypeBase { public :)",
    "insertText": "CTypeBase(CSemanticProgram& Program): _Program(Program)"
  },
  {
    "label": "CTypeBase()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "CTypeBase()"
  },
  {
    "label": "GetProgram()",
    "kind": "Method",
    "detail": "Function (} CSemanticProgram&)",
    "insertText": "GetProgram()"
  },
  {
    "label": "AsNamedType()",
    "kind": "Method",
    "detail": "Function (CNamedType*)",
    "insertText": "AsNamedType()"
  },
  {
    "label": "AsCode()",
    "kind": "Method",
    "detail": "Function (CUTF8String)",
    "insertText": "AsCode(ETypeSyntaxPrecedence OuterPrecedence = ETypeSyntaxPrecedence::Min)"
  },
  {
    "label": "AsCodeRecursive()",
    "kind": "Method",
    "detail": "Function (TArray<const CFlowType*> VisitedFlowTypes ; return)",
    "insertText": "AsCodeRecursive(OuterPrecedence, VisitedFlowTypes, false)"
  },
  {
    "label": "AsCodeRecursive()",
    "kind": "Method",
    "detail": "Function (} CUTF8String)",
    "insertText": "AsCodeRecursive(ETypeSyntaxPrecedence OuterPrecedence, TArray<const CFlowType*>& VisitedFlowTypes, bool bLinkable)"
  },
  {
    "label": "AsParamsCode()",
    "kind": "Method",
    "detail": "Function (CUTF8String)",
    "insertText": "AsParamsCode(ETypeSyntaxPrecedence OuterPrecedence = ETypeSyntaxPrecedence::Min)"
  },
  {
    "label": "AsParamsCode()",
    "kind": "Method",
    "detail": "Function (TArray<const CFlowType*> VisitedFlowTypes ; return)",
    "insertText": "AsParamsCode(OuterPrecedence, VisitedFlowTypes, true)"
  },
  {
    "label": "AsParamsCode()",
    "kind": "Method",
    "detail": "Function (} CUTF8String)",
    "insertText": "AsParamsCode(ETypeSyntaxPrecedence OuterPrecedence, TArray<const CFlowType*>& VisitedFlowTypes, bool WithColon)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CUTF8StringBuilder DestCode ;)",
    "insertText": "if(WithColon)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (DestCode .)",
    "insertText": "Append(\":\")"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (} DestCode .)",
    "insertText": "Append(AsCodeRecursive(OuterPrecedence, VisitedFlowTypes, false))"
  },
  {
    "label": "AsLinkableCode()",
    "kind": "Method",
    "detail": "Function (} CUTF8String)",
    "insertText": "AsLinkableCode()"
  },
  {
    "label": "AsCodeRecursive()",
    "kind": "Method",
    "detail": "Function (TArray<const CFlowType*> VisitedFlowTypes ; return)",
    "insertText": "AsCodeRecursive(ETypeSyntaxPrecedence::Min, VisitedFlowTypes, true)"
  },
  {
    "label": "CNormalType()",
    "kind": "Method",
    "detail": "Function (} private : class CSemanticProgram ; CSemanticProgram& _Program ; TURefArray<CTupleType> _TupleTypesStartingWithThisType ; TURefArray<CFunctionType> _FunctionTypesWithThisParameterType ; } ; class CNormalType : public CTypeBase { public :)",
    "insertText": "CNormalType(ETypeKind Kind, CSemanticProgram& Program): CTypeBase(Program), _Kind(Kind)"
  },
  {
    "label": "GetKind()",
    "kind": "Method",
    "detail": "Function (} ETypeKind)",
    "insertText": "GetKind()"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(IsA<TType>(), \"Failed to cast Type.\")"
  },
  {
    "label": "AsChecked()",
    "kind": "Method",
    "detail": "Function (} template<TType> TType const&)",
    "insertText": "AsChecked()"
  },
  {
    "label": "IsA()",
    "kind": "Method",
    "detail": "Function (} template<TType> bool)",
    "insertText": "IsA()"
  },
  {
    "label": "AsNullable()",
    "kind": "Method",
    "detail": "Function (} template<TType> TType const*)",
    "insertText": "AsNullable()"
  },
  {
    "label": "GetReferenceValueType()",
    "kind": "Method",
    "detail": "Function (} const CTypeBase*)",
    "insertText": "GetReferenceValueType()"
  },
  {
    "label": "FindInstanceMember()",
    "kind": "Method",
    "detail": "Function (SmallDefinitionArray)",
    "insertText": "FindInstanceMember(const CSymbol& MemberName, EMemberOrigin Origin, const SQualifier& Qualifier, const CAstPackage* ContextPackage, VisitStampType VisitStamp)"
  },
  {
    "label": "FindTypeMember()",
    "kind": "Method",
    "detail": "Function (SmallDefinitionArray)",
    "insertText": "FindTypeMember(const CSymbol& MemberName, EMemberOrigin Origin, const SQualifier& Qualifier, VisitStampType VisitStamp)"
  },
  {
    "label": "GetComparability()",
    "kind": "Method",
    "detail": "Function (} } EComparability)",
    "insertText": "GetComparability()"
  },
  {
    "label": "CTypeType()",
    "kind": "Method",
    "detail": "Function (} class CSemanticProgram ; } ; using CFalseType = CGlobalType<ETypeKind::False> ; using CTrueType = CGlobalType<ETypeKind::True> ; using CVoidType = CGlobalType<ETypeKind::Void> ; using CAnyType = CGlobalType<ETypeKind::Any> ; using CComparableType = CGlobalType<ETypeKind::Comparable> ; using CLogicType = CGlobalType<ETypeKind::Logic> ; using CRationalType = CGlobalType<ETypeKind::Rational> ; using CChar8Type = CGlobalType<ETypeKind::Char8> ; using CChar32Type = CGlobalType<ETypeKind::Char32> ; using CPathType = CGlobalType<ETypeKind::Path> ; using CRangeType = CGlobalType<ETypeKind::Range> ; using CPersistableType = CGlobalType<ETypeKind::Persistable> ; class CTypeType : public CNormalType { public : const ETypeKind StaticTypeKind = ETypeKind::Type ;)",
    "insertText": "CTypeType(CSemanticProgram& Program, const CTypeBase* NegativeType, const CTypeBase* PositiveType) : CNormalType(StaticTypeKind, Program) , _NegativeType(NegativeType) , _PositiveType(PositiveType)"
  },
  {
    "label": "NegativeType()",
    "kind": "Method",
    "detail": "Function (} const CTypeBase*)",
    "insertText": "NegativeType()"
  },
  {
    "label": "Definition()",
    "kind": "Method",
    "detail": "Function (} const CDefinition*)",
    "insertText": "Definition()"
  },
  {
    "label": "AsNominalType()",
    "kind": "Method",
    "detail": "Function (const CNominalType*)",
    "insertText": "AsNominalType()"
  },
  {
    "label": "NegativeValueType()",
    "kind": "Method",
    "detail": "Function (} const CTypeBase*)",
    "insertText": "NegativeValueType()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} struct Key { const CTypeBase* NegativeValueType ; const CTypeBase* PositiveValueType ; bool)",
    "insertText": "operator(const Key& Left, const Key& Right)"
  },
  {
    "label": "CanBeCustomAccessorDataType()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "CanBeCustomAccessorDataType()"
  },
  {
    "label": "GetInnerType()",
    "kind": "Method",
    "detail": "Function (} const CTypeBase*)",
    "insertText": "GetInnerType()"
  },
  {
    "label": "const()",
    "kind": "Method",
    "detail": "Function (} operator CTypeBase)",
    "insertText": "const()"
  },
  {
    "label": "GetValueType()",
    "kind": "Method",
    "detail": "Function (const CTypeBase*)",
    "insertText": "GetValueType()"
  },
  {
    "label": "IsPersistable()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsPersistable()"
  },
  {
    "label": "CArrayType()",
    "kind": "Method",
    "detail": "Function (} } ; class CArrayType : public CValueType { public : const ETypeKind StaticTypeKind = ETypeKind::Array ;)",
    "insertText": "CArrayType(CSemanticProgram& Program, const CTypeBase* ElementType) : CValueType(ETypeKind::Array, Program, ElementType)"
  },
  {
    "label": "GetElementType()",
    "kind": "Method",
    "detail": "Function (} const CTypeBase*)",
    "insertText": "GetElementType()"
  },
  {
    "label": "CGeneratorType()",
    "kind": "Method",
    "detail": "Function (} } ; class CGeneratorType : public CValueType { public : const ETypeKind StaticTypeKind = ETypeKind::Generator ;)",
    "insertText": "CGeneratorType(CSemanticProgram& Program, const CTypeBase* ElementType) : CValueType(ETypeKind::Generator, Program, ElementType)"
  },
  {
    "label": "GetKeyType()",
    "kind": "Method",
    "detail": "Function (} const CTypeBase*)",
    "insertText": "GetKeyType()"
  },
  {
    "label": "CUTF8String()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "CUTF8String(\"[%s]%s\", GetKeyType()->AsCodeRecursive(ETypeSyntaxPrecedence::Min, VisitedFlowTypes, bLinkable).AsCString(), GetValueType()->AsCodeRecursive(ETypeSyntaxPrecedence::Call, VisitedFlowTypes, bLinkable).AsCString())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const SKey& Left, const SKey& Right)"
  },
  {
    "label": "TryMarkVisited()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE bool)",
    "insertText": "TryMarkVisited(VisitStampType VisitStamp)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const CTypeBase*)",
    "insertText": "operator(int32_t Index)"
  },
  {
    "label": "FindNamedType()",
    "kind": "Method",
    "detail": "Function (const CNamedType*)",
    "insertText": "FindNamedType(CSymbol Name)"
  },
  {
    "label": "GetFirstNamedIndex()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "GetFirstNamedIndex()"
  },
  {
    "label": "AsParamsCode()",
    "kind": "Method",
    "detail": "Function (CUTF8String)",
    "insertText": "AsParamsCode(ETypeSyntaxPrecedence OuterPrecedence, TArray<const CFlowType*>& VisitedFlowTypes, bool WithColon, bool bLinkable)"
  },
  {
    "label": "CFunctionType()",
    "kind": "Method",
    "detail": "Function (private : ElementArray _Elements ; int32_t _FirstNamedIndex ; VisitStampType _LastVisitStamp ; } ; class CFunctionType : public CNormalType { public : const ETypeKind StaticTypeKind = ETypeKind::Function ; using ParamTypes = TRangeView<CTypeBase const* const*,CTypeBase const* const*> ;)",
    "insertText": "CFunctionType(CSemanticProgram& Program, const CTypeBase& ParamsType, const CTypeBase& ReturnType, const SEffectSet Effects, TArray<const CTypeVariable*>&& TypeVariables = {}, bool ImplicitlySpecialized = false) : CNormalType(ETypeKind::Function, Program) , _ParamsType(&ParamsType) , _ReturnType(ReturnType) , _Effects(Effects) , _TypeVariables(Move(TypeVariables)) , _bImplicitlySpecialized(ImplicitlySpecialized)"
  },
  {
    "label": "GetParamsType()",
    "kind": "Method",
    "detail": "Function (} const CTypeBase&)",
    "insertText": "GetParamsType()"
  },
  {
    "label": "GetOrCreateParamType()",
    "kind": "Method",
    "detail": "Function (const CTypeBase*)",
    "insertText": "GetOrCreateParamType(CSemanticProgram&, CTupleType::ElementArray&& ParamTypes, int32_t FirstNamedIndex)"
  },
  {
    "label": "AsParamTypes()",
    "kind": "Method",
    "detail": "Function (ParamTypes)",
    "insertText": "AsParamTypes(CTypeBase const* const& Type)"
  },
  {
    "label": "SingletonRangeView()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "SingletonRangeView(Type)"
  },
  {
    "label": "GetParamTypes()",
    "kind": "Method",
    "detail": "Function (} ParamTypes)",
    "insertText": "GetParamTypes()"
  },
  {
    "label": "BuildTypeVariableCode()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "BuildTypeVariableCode(CUTF8StringBuilder& Builder, TArray<const CFlowType*>& VisitedFlowTypes, bool bLinkable)"
  },
  {
    "label": "BuildTypeVariableCode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BuildTypeVariableCode(CUTF8StringBuilder& Builder)"
  },
  {
    "label": "BuildTypeVariableCode()",
    "kind": "Method",
    "detail": "Function (TArray<const CFlowType*> VisitedFlowTypes ;)",
    "insertText": "BuildTypeVariableCode(Builder, VisitedFlowTypes, false)"
  },
  {
    "label": "BuildEffectAttributeCode()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "BuildEffectAttributeCode(CUTF8StringBuilder& Builder)"
  },
  {
    "label": "BuildParameterBlockCode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BuildParameterBlockCode(CUTF8StringBuilder& Builder, TArray<const CFlowType*>& VisitedFlowTypes, bool bLinkable)"
  },
  {
    "label": "CFlowType()",
    "kind": "Method",
    "detail": "Function (} } class CFlowType : public CTypeBase { public :)",
    "insertText": "CFlowType(CSemanticProgram& Program, ETypePolarity Polarity, const CTypeBase* Child) : CTypeBase(Program) , _Polarity(Polarity) , _Child(Child)"
  },
  {
    "label": "Polarity()",
    "kind": "Method",
    "detail": "Function (} ETypePolarity)",
    "insertText": "Polarity()"
  },
  {
    "label": "GetChild()",
    "kind": "Method",
    "detail": "Function (const CTypeBase*)",
    "insertText": "GetChild()"
  },
  {
    "label": "SetChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetChild(const CTypeBase*)"
  },
  {
    "label": "FlowEdges()",
    "kind": "Method",
    "detail": "Function (TSet<const CFlowType*>&)",
    "insertText": "FlowEdges()"
  },
  {
    "label": "EmptyFlowEdges()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EmptyFlowEdges()"
  },
  {
    "label": "GetNormalType()",
    "kind": "Method",
    "detail": "Function (const CNormalType&)",
    "insertText": "GetNormalType()"
  },
  {
    "label": "AsFlowType()",
    "kind": "Method",
    "detail": "Function (CFlowType*)",
    "insertText": "AsFlowType()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const STypeVariableSubstitution& Left, const STypeVariableSubstitution& Right)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const SInstantiatedTypeVariable& Left, const SInstantiatedTypeVariable& Right)"
  },
  {
    "label": "CreateNormalType()",
    "kind": "Method",
    "detail": "Function (_NormalType =&)",
    "insertText": "CreateNormalType()"
  },
  {
    "label": "CInstantiatedType()",
    "kind": "Method",
    "detail": "Function (} protected :)",
    "insertText": "CInstantiatedType(CSemanticProgram& Program, ETypePolarity Polarity, TArray<STypeVariableSubstitution> Arguments) : CTypeBase(Program) , _Polarity(Polarity) , _Substitutions(Move(Arguments))"
  },
  {
    "label": "CInstantiatedType()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "CInstantiatedType()"
  },
  {
    "label": "GetPolarity()",
    "kind": "Method",
    "detail": "Function (ETypePolarity)",
    "insertText": "GetPolarity()"
  },
  {
    "label": "GetName()",
    "kind": "Method",
    "detail": "Function (} CSymbol)",
    "insertText": "GetName()"
  },
  {
    "label": "ToTupleType()",
    "kind": "Method",
    "detail": "Function (const CTupleType&)",
    "insertText": "ToTupleType()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const Constraint& lhs, const Constraint& rhs)"
  },
  {
    "label": "GetMin()",
    "kind": "Method",
    "detail": "Function (} Constraint)",
    "insertText": "GetMin()"
  },
  {
    "label": "AsSingleInterface()",
    "kind": "Method",
    "detail": "Function (const CInterface*)",
    "insertText": "AsSingleInterface(const CNormalType& NegativeType, const CNormalType& PositiveType)"
  },
  {
    "label": "Instantiate()",
    "kind": "Method",
    "detail": "Function (TArray<STypeVariableSubstitution>)",
    "insertText": "Instantiate(const TArray<const CTypeVariable*>& TypeVariables)"
  },
  {
    "label": "Substitute()",
    "kind": "Method",
    "detail": "Function (const CTypeBase*)",
    "insertText": "Substitute(const CTypeBase&, ETypePolarity Polarity, const TArray<STypeVariableSubstitution>& InstTypeVariables)"
  },
  {
    "label": "Instantiate()",
    "kind": "Method",
    "detail": "Function (const CFunctionType*)",
    "insertText": "Instantiate(const CFunctionType*)"
  },
  {
    "label": "Canonicalize()",
    "kind": "Method",
    "detail": "Function (const CTypeBase&)",
    "insertText": "Canonicalize(const CTypeBase&)"
  },
  {
    "label": "Canonicalize()",
    "kind": "Method",
    "detail": "Function (const CFunctionType&)",
    "insertText": "Canonicalize(const CFunctionType&)"
  },
  {
    "label": "Canonicalize()",
    "kind": "Method",
    "detail": "Function (const CTupleType&)",
    "insertText": "Canonicalize(const CTupleType&)"
  },
  {
    "label": "AsPolarity()",
    "kind": "Method",
    "detail": "Function (const CTypeBase&)",
    "insertText": "AsPolarity(const CTypeBase&, const TArray<SInstantiatedTypeVariable>&, ETypePolarity)"
  },
  {
    "label": "AsPositive()",
    "kind": "Method",
    "detail": "Function (const CTypeBase&)",
    "insertText": "AsPositive(const CTypeBase&, const TArray<SInstantiatedTypeVariable>&)"
  },
  {
    "label": "AsNegative()",
    "kind": "Method",
    "detail": "Function (const CTypeBase&)",
    "insertText": "AsNegative(const CTypeBase&, const TArray<SInstantiatedTypeVariable>&)"
  },
  {
    "label": "Constrain()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Constrain(const CTypeBase* PositiveType1, const CTypeBase* NegativeType2)"
  },
  {
    "label": "IsSubtype()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSubtype(const CTypeBase* PositiveType1, const CTypeBase* PositiveType2)"
  },
  {
    "label": "IsEquivalent()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsEquivalent(const CTypeBase* PositiveType1, const CTypeBase* PositiveType2)"
  },
  {
    "label": "Matches()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Matches(const CTypeBase* PositiveType1, const CTypeBase* NegativeType2)"
  },
  {
    "label": "SkipIdentityFlowType()",
    "kind": "Method",
    "detail": "Function (const CTypeBase&)",
    "insertText": "SkipIdentityFlowType(const CFlowType&, ETypePolarity)"
  },
  {
    "label": "SkipIdentityFlowType()",
    "kind": "Method",
    "detail": "Function (const CTypeBase&)",
    "insertText": "SkipIdentityFlowType(const CTypeBase&, ETypePolarity)"
  },
  {
    "label": "SkipEmptyFlowType()",
    "kind": "Method",
    "detail": "Function (const CTypeBase&)",
    "insertText": "SkipEmptyFlowType(const CTypeBase&)"
  },
  {
    "label": "Join()",
    "kind": "Method",
    "detail": "Function (const CTypeBase*)",
    "insertText": "Join(const CTypeBase* Type1, const CTypeBase* Type2)"
  },
  {
    "label": "Meet()",
    "kind": "Method",
    "detail": "Function (const CTypeBase*)",
    "insertText": "Meet(const CTypeBase* Type1, const CTypeBase* Type2)"
  },
  {
    "label": "AreDomainsDistinct()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AreDomainsDistinct(const CTypeBase* DomainType1, const CTypeBase* DomainType2)"
  },
  {
    "label": "IsUnknownType()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsUnknownType(const CTypeBase* Type)"
  },
  {
    "label": "IsAttributeType()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsAttributeType(const CTypeBase* Type)"
  },
  {
    "label": "VisitAllDefinitions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VisitAllDefinitions(const CTypeBase* Type, const TFunction<void(const CDefinition&,const CSymbol&)>& Functor)"
  },
  {
    "label": "ForEachDataType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ForEachDataType(const CTypeBase*, const TFunction<void(const CTypeBase*)>&)"
  },
  {
    "label": "ForEachDataTypeRecursive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ForEachDataTypeRecursive(const CTypeBase*, const TFunction<void(const CTypeBase*)>&)"
  },
  {
    "label": "IsStringType()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsStringType(const CNormalType& NormalType)"
  },
  {
    "label": "IsEditableToCMessage()",
    "kind": "Method",
    "detail": "Function (} enum class EIsEditable { Yes,NotEditableType,MissingConcreteOrEditable,MissingConcrete } ; const char*)",
    "insertText": "IsEditableToCMessage(EIsEditable IsEditable)"
  },
  {
    "label": "IsEditableType()",
    "kind": "Method",
    "detail": "Function (EIsEditable)",
    "insertText": "IsEditableType(const uLang::CTypeBase* Type, bool bAllowNonConcreteClasses)"
  }
]