[
  {
    "label": "uint32_test_case",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "uint32_test_case"
  },
  {
    "label": "uint64_test_case",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "uint64_test_case"
  },
  {
    "label": "Itoa()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_STRINGS_INTERNAL_NUMBERS_TEST_COMMON_H_ # define ABSL_STRINGS_INTERNAL_NUMBERS_TEST_COMMON_H_ # include<array> # include<cstdint> # include<limits> # include<string> # include \" absl / base / config . h \" namespace absl { ABSL_NAMESPACE_BEGIN namespace strings_internal { template<IntType> bool)",
    "insertText": "Itoa(IntType value, int base, std::string* destination)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (destination ->)",
    "insertText": "clear()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (destination ->)",
    "insertText": "push_back('0')"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (const IntType next_value = value / base ; int remainder = static_cast<)",
    "insertText": "int(value > next_value * base ? value - next_value * base : next_value * base - value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (char c = remainder<1 0 ? ' 0 ' + remainder : ' A ' + remainder - 1 0 ; destination ->)",
    "insertText": "insert(0, 1, c)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (value = next_value ; })",
    "insertText": "if(negative)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (destination ->)",
    "insertText": "insert(0, 1, '-')"
  },
  {
    "label": "strtouint32_test_cases()",
    "kind": "Method",
    "detail": "Function (} return true ; } struct uint32_test_case { const char* str ; bool expect_ok ; int base ; uint32_t expected ; } ; const std::array<uint32_test_case,2 7>&)",
    "insertText": "strtouint32_test_cases()"
  },
  {
    "label": "true()",
    "kind": "Method",
    "detail": "Function (const std::array<uint32_test_case,2 7> test_cases { { { \" 0 xffffffff \",)",
    "insertText": "true(std::numeric_limits<uint32_t>::max)()"
  },
  {
    "label": "false()",
    "kind": "Method",
    "detail": "Function (\" 3 4 2 3 4 3 2 4 \\ n \\ t \",true,1 0,3 4 2 3 4 3 2 4 },{ \" 0 \",true,3,0 },{ \" 2 \",true,3,2 },{ \" 1 1 \",true,3,4 },{ \" \",false,0,0 },{ \" \",false,0,0 },{ \" abc \",false,0,0 },{ \" 3 4 2 3 4 3 2 4 a \",false,0,3 4 2 3 4 3 2 4 },{ \" 3 4 2 3 4 . 3 \",false,0,3 4 2 3 4 },{ \" - 1 \",false,0,0 },{ \" - 1 2 3 \",false,0,0 },{ \" \\ t \\ n - 1 2 3 \",false,0,0 },{ \" 4 2 9 4 9 6 7 2 9 6 \",)",
    "insertText": "false(std::numeric_limits<uint32_t>::max)()"
  },
  {
    "label": "strtouint64_test_cases()",
    "kind": "Method",
    "detail": "Function (nullptr,false,0,0 },} } ; return test_cases ; } struct uint64_test_case { const char* str ; bool expect_ok ; int base ; uint64_t expected ; } ; const std::array<uint64_test_case,3 4>&)",
    "insertText": "strtouint64_test_cases()"
  },
  {
    "label": "true()",
    "kind": "Method",
    "detail": "Function (const std::array<uint64_test_case,3 4> test_cases { { { \" 0 x3423432448783446 \",true,1 6,int64_t { 0 x3423432448783446 } },{ \" 3 4 2 3 4 3 2 4 4 8 7 8 3 4 4 6 \",true,1 6,int64_t { 0 x3423432448783446 } },{ \" 0 \",true,1 6,0 },{ \" 0 0 0 \",true,0,0 },{ \" 0 \",true,0,0 },{ \" \\ t \\ n 0 xffffffffffffffff \",)",
    "insertText": "true(std::numeric_limits<uint64_t>::max)()"
  },
  {
    "label": "false()",
    "kind": "Method",
    "detail": "Function (\" 3 4 2 3 4 3 2 4 4 8 7 8 3 4 4 6 6 \\ n \\ t \",true,0,int64_t { 3 4 2 3 4 3 2 4 4 8 7 8 3 4 4 6 6 } },{ \" \\ f \\ v 4 6 \",true,1 0,4 6 },{ \" 0 \",true,3,0 },{ \" 2 \",true,3,2 },{ \" 1 1 \",true,3,4 },{ \" 0 \",true,0,0 },{ \" \",false,0,0 },{ \" \",false,0,0 },{ \" abc \",false,0,0 },{ \" 3 4 2 3 4 3 2 4 4 8 7 8 3 4 4 6 6 a \",false,0,0 },{ \" 3 4 2 3 4 4 8 7 8 3 4 4 6 6 . 3 \",false,0,0 },{ \" - 1 \",false,0,0 },{ \" - 1 2 3 \",false,0,0 },{ \" \\ t \\ n - 1 2 3 \",false,0,0 },{ \" 1 8 4 4 6 7 4 4 0 7 3 7 0 9 5 5 1 6 1 6 \",false,1 0,0 },{ \" 1 8 4 4 6 7 4 4 0 7 3 7 0 9 5 5 1 6 1 6 \",false,0,0 },{ \" 0 x10000000000000000 \",)",
    "insertText": "false(std::numeric_limits<uint64_t>::max)()"
  }
]