[
  {
    "label": "lgamma_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lgamma_impl"
  },
  {
    "label": "lgamma_retval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lgamma_retval"
  },
  {
    "label": "digamma_retval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "digamma_retval"
  },
  {
    "label": "digamma_impl_maybe_poly",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "digamma_impl_maybe_poly"
  },
  {
    "label": "digamma_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "digamma_impl"
  },
  {
    "label": "erf_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "erf_impl"
  },
  {
    "label": "erf_retval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "erf_retval"
  },
  {
    "label": "erfc_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "erfc_impl"
  },
  {
    "label": "erfc_retval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "erfc_retval"
  },
  {
    "label": "ndtri_retval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ndtri_retval"
  },
  {
    "label": "ndtri_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ndtri_impl"
  },
  {
    "label": "igammac_retval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "igammac_retval"
  },
  {
    "label": "cephes_helper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cephes_helper"
  },
  {
    "label": "IgammaComputationMode",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "IgammaComputationMode"
  },
  {
    "label": "igammac_cf_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "igammac_cf_impl"
  },
  {
    "label": "igamma_series_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "igamma_series_impl"
  },
  {
    "label": "igammac_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "igammac_impl"
  },
  {
    "label": "igamma_generic_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "igamma_generic_impl"
  },
  {
    "label": "igamma_retval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "igamma_retval"
  },
  {
    "label": "igamma_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "igamma_impl"
  },
  {
    "label": "igamma_der_a_retval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "igamma_der_a_retval"
  },
  {
    "label": "igamma_der_a_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "igamma_der_a_impl"
  },
  {
    "label": "gamma_sample_der_alpha_retval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "gamma_sample_der_alpha_retval"
  },
  {
    "label": "gamma_sample_der_alpha_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "gamma_sample_der_alpha_impl"
  },
  {
    "label": "zeta_retval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "zeta_retval"
  },
  {
    "label": "zeta_impl_series",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "zeta_impl_series"
  },
  {
    "label": "zeta_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "zeta_impl"
  },
  {
    "label": "polygamma_retval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "polygamma_retval"
  },
  {
    "label": "polygamma_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "polygamma_impl"
  },
  {
    "label": "betainc_retval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "betainc_retval"
  },
  {
    "label": "betainc_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "betainc_impl"
  },
  {
    "label": "incbeta_cfe",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "incbeta_cfe"
  },
  {
    "label": "betainc_helper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "betainc_helper"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_SPECIAL_FUNCTIONS_H # define EIGEN_SPECIAL_FUNCTIONS_H namespace Eigen { namespace internal { template<Scalar> struct lgamma_impl { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar)",
    "insertText": "run(const Scalar)"
  },
  {
    "label": "EIGEN_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT((internal::is_same<Scalar, Scalar>::value == false), THIS_TYPE_IS_NOT_SUPPORTED)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct lgamma_retval { typedef Scalar type ; } ; # if EIGEN_HAS_C99_MATH # if)",
    "insertText": "defined(__GLIBC__) && ((__GLIBC__>=2 && __GLIBC_MINOR__ >= 19) || __GLIBC__>2) \\ && (defined(_DEFAULT_SOURCE) || defined(_BSD_SOURCE) || defined(_SVID_SOURCE)) #define EIGEN_HAS_LGAMMA_R #endif #if defined(__GLIBC__) && ((__GLIBC__==2 && __GLIBC_MINOR__ < 19) || __GLIBC__<2) \\ && (defined(_BSD_SOURCE) || defined(_SVID_SOURCE))"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float)",
    "insertText": "run(float x)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if !)",
    "insertText": "defined(EIGEN_GPU_COMPILE_PHASE) && defined (EIGEN_HAS_LGAMMA_R) && !defined(__APPLE__)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# elif)",
    "insertText": "defined(SYCL_DEVICE_ONLY) return cl::sycl::lgamma(x)"
  },
  {
    "label": "lgammaf()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "lgammaf(x)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (# endif } } ; template<> struct lgamma_impl<double> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double)",
    "insertText": "run(double x)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if !)",
    "insertText": "defined(EIGEN_GPU_COMPILE_PHASE) && defined(EIGEN_HAS_LGAMMA_R) && !defined(__APPLE__)"
  },
  {
    "label": "lgamma()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "lgamma(x)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct digamma_impl_maybe_poly<float> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float)",
    "insertText": "run(const float s)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const float A [ ] = { - 4 . 1 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 E - 3 f,3 . 9 6 8 2 5 3 9 6 8 2 5 3 9 6 8 2 5 3 9 7 E - 3 f,- 8 . 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 E - 3 f,8 . 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 E - 2 f } ; float z ;)",
    "insertText": "if(s < 1.0e8f)"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (z = 1 . 0)",
    "insertText": "f(s * s)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} else return 0 . 0 f ; } } ; template<> struct digamma_impl_maybe_poly<double> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double)",
    "insertText": "run(const double s)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const double A [ ] = { 8 . 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 E - 2,- 2 . 1 0 9 2 7 9 6 0 9 2 7 9 6 0 9 2 7 9 6 1 E - 2,7 . 5 7 5 7 5 7 5 7 5 7 5 7 5 7 5 7 5 7 5 8 E - 3,- 4 . 1 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 E - 3,3 . 9 6 8 2 5 3 9 6 8 2 5 3 9 6 8 2 5 3 9 7 E - 3,- 8 . 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 E - 3,8 . 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 E - 2 } ; double z ;)",
    "insertText": "if(s < 1.0e17)"
  },
  {
    "label": "z()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "z(s * s)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} else return 0 . 0 ; } } ; template<Scalar> struct digamma_impl { EIGEN_DEVICE_FUNC Scalar)",
    "insertText": "run(Scalar x)"
  },
  {
    "label": "quiet_NaN()",
    "kind": "Method",
    "detail": "Function (Scalar p,q,nz,s,w,y ; bool negative = false ; const Scalar nan = NumTraits<Scalar)",
    "insertText": "quiet_NaN()"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (const Scalar m_pi =)",
    "insertText": "Scalar(EIGEN_PI)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (const Scalar zero =)",
    "insertText": "Scalar(0)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (const Scalar one =)",
    "insertText": "Scalar(1)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (const Scalar half =)",
    "insertText": "Scalar(0.5)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (nz = zero ;)",
    "insertText": "if(x <= zero)"
  },
  {
    "label": "floor()",
    "kind": "Method",
    "detail": "Function (negative = true ; q = x ; p =)",
    "insertText": "floor(q)"
  },
  {
    "label": "tan()",
    "kind": "Method",
    "detail": "Function (p + = one ; nz = q - p ; } nz = m_pi /)",
    "insertText": "tan(m_pi * nz)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} else { nz = zero ; } x = one - x ; } s = x ; w = zero ;)",
    "insertText": "while(s < Scalar(10))"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (w + = one / s ; s + = one ; } y = digamma_impl_maybe_poly<Scalar)",
    "insertText": "run(s)"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (y =)",
    "insertText": "log(s) - (half / s)"
  },
  {
    "label": "generic_fast_erf_float()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T)",
    "insertText": "generic_fast_erf_float(const T& a_x)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T plus_4 = pset1<)",
    "insertText": "T(4.f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T minus_4 = pset1<)",
    "insertText": "T(-4.f)"
  },
  {
    "label": "pmax()",
    "kind": "Method",
    "detail": "Function (const T x =)",
    "insertText": "pmax(pmin(a_x, plus_4), minus_4)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T alpha_1 = pset1<)",
    "insertText": "T(-1.60960333262415e-02f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T alpha_3 = pset1<)",
    "insertText": "T(-2.95459980854025e-03f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T alpha_5 = pset1<)",
    "insertText": "T(-7.34990630326855e-04f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T alpha_7 = pset1<)",
    "insertText": "T(-5.69250639462346e-05f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T alpha_9 = pset1<)",
    "insertText": "T(-2.10102402082508e-06f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T alpha_11 = pset1<)",
    "insertText": "T(2.77068142495902e-08f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T alpha_13 = pset1<)",
    "insertText": "T(-2.72614225801306e-10f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T beta_0 = pset1<)",
    "insertText": "T(-1.42647390514189e-02f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T beta_2 = pset1<)",
    "insertText": "T(-7.37332916720468e-03f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T beta_4 = pset1<)",
    "insertText": "T(-1.68282697438203e-03f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T beta_6 = pset1<)",
    "insertText": "T(-2.13374055278905e-04f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T beta_8 = pset1<)",
    "insertText": "T(-1.45660718464996e-05f)"
  },
  {
    "label": "pmul()",
    "kind": "Method",
    "detail": "Function (const T x2 =)",
    "insertText": "pmul(x, x)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (T p =)",
    "insertText": "pmadd(x2, alpha_13, alpha_11)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (p =)",
    "insertText": "pmadd(x2, p, alpha_9)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (p =)",
    "insertText": "pmadd(x2, p, alpha_7)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (p =)",
    "insertText": "pmadd(x2, p, alpha_5)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (p =)",
    "insertText": "pmadd(x2, p, alpha_3)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (p =)",
    "insertText": "pmadd(x2, p, alpha_1)"
  },
  {
    "label": "pmul()",
    "kind": "Method",
    "detail": "Function (p =)",
    "insertText": "pmul(x, p)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (T q =)",
    "insertText": "pmadd(x2, beta_8, beta_6)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (q =)",
    "insertText": "pmadd(x2, q, beta_4)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (q =)",
    "insertText": "pmadd(x2, q, beta_2)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (q =)",
    "insertText": "pmadd(x2, q, beta_0)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} template<T> struct erf_impl { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T)",
    "insertText": "run(const T& x)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(SYCL_DEVICE_ONLY) return cl::sycl::erf(x)"
  },
  {
    "label": "generic_fast_erf_float()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "generic_fast_erf_float(x)"
  },
  {
    "label": "erf()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "erf(x)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct erfc_retval { typedef Scalar type ; } ; # if EIGEN_HAS_C99_MATH template<> struct erfc_impl<float> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float)",
    "insertText": "run(const float x)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(SYCL_DEVICE_ONLY) return cl::sycl::erfc(x)"
  },
  {
    "label": "erfcf()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "erfcf(x)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (# endif } } ; template<> struct erfc_impl<double> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double)",
    "insertText": "run(const double x)"
  },
  {
    "label": "erfc()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "erfc(x)"
  },
  {
    "label": "flipsign()",
    "kind": "Method",
    "detail": "Function (# endif } } ; # endif template<T> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T)",
    "insertText": "flipsign(const T& should_flipsign, const T& x)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (typedef unpacket_traits<T>::type Scalar ; const T sign_mask = pset1<)",
    "insertText": "T(Scalar(-0.0))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T sign_bit = pand<)",
    "insertText": "T(should_flipsign, sign_mask)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (} template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double flipsign<)",
    "insertText": "double(const double& should_flipsign, const double& x)"
  },
  {
    "label": "ScalarType()",
    "kind": "Method",
    "detail": "Function (const ScalarType p0 [ ] = {)",
    "insertText": "ScalarType(-5.99633501014107895267e1), ScalarType(9.80010754185999661536e1), ScalarType(-5.66762857469070293439e1), ScalarType(1.39312609387279679503e1), ScalarType(-1.23916583867381258016e0)"
  },
  {
    "label": "ScalarType()",
    "kind": "Method",
    "detail": "Function (const ScalarType q0 [ ] = {)",
    "insertText": "ScalarType(1.0), ScalarType(1.95448858338141759834e0), ScalarType(4.67627912898881538453e0), ScalarType(8.63602421390890590575e1), ScalarType(-2.25462687854119370527e2), ScalarType(2.00260212380060660359e2), ScalarType(-8.20372256168333339912e1), ScalarType(1.59056225126211695515e1), ScalarType(-1.18331621121330003142e0)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T sqrt2pi = pset1<)",
    "insertText": "T(ScalarType(2.50662827463100050242e0))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T half = pset1<)",
    "insertText": "T(ScalarType(0.5))"
  },
  {
    "label": "psub()",
    "kind": "Method",
    "detail": "Function (T c,c2,ndtri_gt_exp_neg_two ; c =)",
    "insertText": "psub(b, half)"
  },
  {
    "label": "pmul()",
    "kind": "Method",
    "detail": "Function (c2 =)",
    "insertText": "pmul(c, c)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (ndtri_gt_exp_neg_two =)",
    "insertText": "pmadd(c, pmul( c2, pdiv( internal::ppolevl<T, 4>::run(c2, p0), internal::ppolevl<T, 8>::run(c2, q0))), c)"
  },
  {
    "label": "generic_ndtri_lt_exp_neg_two()",
    "kind": "Method",
    "detail": "Function (} template<T,ScalarType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T)",
    "insertText": "generic_ndtri_lt_exp_neg_two(const T& b, const T& should_flipsign)"
  },
  {
    "label": "ScalarType()",
    "kind": "Method",
    "detail": "Function (const ScalarType p1 [ ] = {)",
    "insertText": "ScalarType(4.05544892305962419923e0), ScalarType(3.15251094599893866154e1), ScalarType(5.71628192246421288162e1), ScalarType(4.40805073893200834700e1), ScalarType(1.46849561928858024014e1), ScalarType(2.18663306850790267539e0), ScalarType(-1.40256079171354495875e-1), ScalarType(-3.50424626827848203418e-2), ScalarType(-8.57456785154685413611e-4)"
  },
  {
    "label": "ScalarType()",
    "kind": "Method",
    "detail": "Function (const ScalarType q1 [ ] = {)",
    "insertText": "ScalarType(1.0), ScalarType(1.57799883256466749731e1), ScalarType(4.53907635128879210584e1), ScalarType(4.13172038254672030440e1), ScalarType(1.50425385692907503408e1), ScalarType(2.50464946208309415979e0), ScalarType(-1.42182922854787788574e-1), ScalarType(-3.80806407691578277194e-2), ScalarType(-9.33259480895457427372e-4)"
  },
  {
    "label": "ScalarType()",
    "kind": "Method",
    "detail": "Function (const ScalarType p2 [ ] = {)",
    "insertText": "ScalarType(3.23774891776946035970e0), ScalarType(6.91522889068984211695e0), ScalarType(3.93881025292474443415e0), ScalarType(1.33303460815807542389e0), ScalarType(2.01485389549179081538e-1), ScalarType(1.23716634817820021358e-2), ScalarType(3.01581553508235416007e-4), ScalarType(2.65806974686737550832e-6), ScalarType(6.23974539184983293730e-9)"
  },
  {
    "label": "ScalarType()",
    "kind": "Method",
    "detail": "Function (const ScalarType q2 [ ] = {)",
    "insertText": "ScalarType(1.0), ScalarType(6.02427039364742014255e0), ScalarType(3.67983563856160859403e0), ScalarType(1.37702099489081330271e0), ScalarType(2.16236993594496635890e-1), ScalarType(1.34204006088543189037e-2), ScalarType(3.28014464682127739104e-4), ScalarType(2.89247864745380683936e-6), ScalarType(6.79019408009981274425e-9)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T eight = pset1<)",
    "insertText": "T(ScalarType(8.0))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T one = pset1<)",
    "insertText": "T(ScalarType(1))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T neg_two = pset1<)",
    "insertText": "T(ScalarType(-2))"
  },
  {
    "label": "psqrt()",
    "kind": "Method",
    "detail": "Function (T x,x0,x1,z ; x =)",
    "insertText": "psqrt(pmul(neg_two, plog(b)))"
  },
  {
    "label": "psub()",
    "kind": "Method",
    "detail": "Function (x0 =)",
    "insertText": "psub(x, pdiv(plog(x), x))"
  },
  {
    "label": "pdiv()",
    "kind": "Method",
    "detail": "Function (z =)",
    "insertText": "pdiv(one, x)"
  },
  {
    "label": "pmul()",
    "kind": "Method",
    "detail": "Function (x1 =)",
    "insertText": "pmul(z, pselect( pcmp_lt(x, eight), pdiv(internal::ppolevl<T, 8>::run(z, p1), internal::ppolevl<T, 8>::run(z, q1)), pdiv(internal::ppolevl<T, 8>::run(z, p2), internal::ppolevl<T, 8>::run(z, q2))))"
  },
  {
    "label": "generic_ndtri()",
    "kind": "Method",
    "detail": "Function (} template<T,ScalarType> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE T)",
    "insertText": "generic_ndtri(const T& a)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T maxnum = pset1<)",
    "insertText": "T(NumTraits<ScalarType>::infinity())"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T neg_maxnum = pset1<)",
    "insertText": "T(-NumTraits<ScalarType>::infinity())"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T zero = pset1<)",
    "insertText": "T(ScalarType(0))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T exp_neg_two = pset1<)",
    "insertText": "T(ScalarType(0.13533528323661269189))"
  },
  {
    "label": "pcmp_le()",
    "kind": "Method",
    "detail": "Function (T b,ndtri,should_flipsign ; should_flipsign =)",
    "insertText": "pcmp_le(a, psub(one, exp_neg_two))"
  },
  {
    "label": "pselect()",
    "kind": "Method",
    "detail": "Function (b =)",
    "insertText": "pselect(should_flipsign, a, psub(one, a))"
  },
  {
    "label": "pselect()",
    "kind": "Method",
    "detail": "Function (ndtri =)",
    "insertText": "pselect(pcmp_lt(exp_neg_two, b), generic_ndtri_gt_exp_neg_two<T, ScalarType>(b), generic_ndtri_lt_exp_neg_two<T, ScalarType>(b, should_flipsign))"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; # else template<Scalar> struct ndtri_impl { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar)",
    "insertText": "run(const Scalar x)"
  },
  {
    "label": "machep()",
    "kind": "Method",
    "detail": "Function (} } ; # endif template<Scalar> struct igammac_retval { typedef Scalar type ; } ; template<Scalar> struct cephes_helper { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar)",
    "insertText": "machep()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(false && \"machep not supported for this type\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(false && \"big not supported for this type\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(false && \"biginv not supported for this type\")"
  },
  {
    "label": "big()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float)",
    "insertText": "big()"
  },
  {
    "label": "biginv()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float)",
    "insertText": "biginv()"
  },
  {
    "label": "main_igamma_term()",
    "kind": "Method",
    "detail": "Function (} } ; enum IgammaComputationMode { VALUE,DERIVATIVE,SAMPLE_DERIVATIVE } ; template<Scalar> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar)",
    "insertText": "main_igamma_term(Scalar a, Scalar x)"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (Scalar logax = a*)",
    "insertText": "log(x) - x - lgamma_impl<Scalar>::run(a)"
  },
  {
    "label": "exp()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "exp(logax)"
  },
  {
    "label": "igamma_num_iterations()",
    "kind": "Method",
    "detail": "Function (} template<Scalar,IgammaComputationMode mode> EIGEN_DEVICE_FUNC int)",
    "insertText": "igamma_num_iterations()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (c + = one ; y + = one ; z + = two ; Scalar yc = y* c ; Scalar pk = pkm1* z - pkm2* yc ; Scalar qk = qkm1* z - qkm2* yc ; Scalar dpk_da = dpkm1_da* z - pkm1 - dpkm2_da* yc + pkm2* c ; Scalar dqk_da = dqkm1_da* z - qkm1 - dqkm2_da* yc + qkm2* c ;)",
    "insertText": "if(qk != zero)"
  },
  {
    "label": "dans_da()",
    "kind": "Method",
    "detail": "Function (Scalar ans_prev = ans ; ans = pk / qk ; Scalar dans_da_prev = dans_da ;)",
    "insertText": "dans_da(dpk_da - ans * dqk_da)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } } else {)",
    "insertText": "if(numext::abs(dans_da - dans_da_prev) <= machep)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } } } pkm2 = pkm1 ; pkm1 = pk ; qkm2 = qkm1 ; qkm1 = qk ; dpkm2_da = dpkm1_da ; dpkm1_da = dpk_da ; dqkm2_da = dqkm1_da ; dqkm1_da = dqk_da ;)",
    "insertText": "if(numext::abs(pk) > big)"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (pkm2* = biginv ; pkm1* = biginv ; qkm2* = biginv ; qkm1* = biginv ; dpkm2_da* = biginv ; dpkm1_da* = biginv ; dqkm2_da* = biginv ; dqkm1_da* = biginv ; } } Scalar dlogax_da =)",
    "insertText": "log(x) - digamma_impl<Scalar>::run(a)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (Scalar dax_da = ax* dlogax_da ;)",
    "insertText": "switch(mode)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } } ; template<Scalar,IgammaComputationMode mode> struct igamma_series_impl { EIGEN_DEVICE_FUNC Scalar)",
    "insertText": "run(Scalar a, Scalar x)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (Scalar ax = main_igamma_term<)",
    "insertText": "Scalar(a, x)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (r + = one ; Scalar term = x / r ; Scalar dterm_da = -)",
    "insertText": "x(r * r)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (dc_da = term* dc_da + dterm_da* c ; dans_da + = dc_da ; c* = term ; ans + = c ;)",
    "insertText": "if(mode == VALUE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } } else {)",
    "insertText": "if(numext::abs(dc_da) <= machep * numext::abs(dans_da))"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (break ; } } } Scalar dlogax_da =)",
    "insertText": "log(x) - digamma_impl<Scalar>::run(a + one)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} return igammac_cf_impl<Scalar,VALUE)",
    "insertText": "run(a, x)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct zeta_impl_series<float> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool)",
    "insertText": "run(float& a, float& b, float& s, const float x, const float machep)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int i = 0 ;)",
    "insertText": "while(i < 9)"
  },
  {
    "label": "pow()",
    "kind": "Method",
    "detail": "Function (i + = 1 ; a + = 1 . 0 f ; b =)",
    "insertText": "pow(a, -x)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (s + = b ;)",
    "insertText": "if(numext::abs(b/s) < machep)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} return false ; } } ; template<> struct zeta_impl_series<double> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool)",
    "insertText": "run(double& a, double& b, double& s, const double x, const double machep)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int i = 0 ;)",
    "insertText": "while((i < 9) || (a <= 9.0))"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} return false ; } } ; template<Scalar> struct zeta_impl { EIGEN_DEVICE_FUNC Scalar)",
    "insertText": "run(Scalar x, Scalar q)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (int i ; Scalar p,r,a,b,k,s,t,w ; const Scalar A [ ] = {)",
    "insertText": "Scalar(12.0), Scalar(-720.0), Scalar(30240.0), Scalar(-1209600.0), Scalar(47900160.0), Scalar(-1.8924375803183791606e9), Scalar(7.47242496e10), Scalar(-2.950130727918164224e12), Scalar(1.1646782814350067249e14), Scalar(-4.5979787224074726105e15), Scalar(1.8152105401943546773e17), Scalar(-7.1661652561756670113e18)"
  },
  {
    "label": "infinity()",
    "kind": "Method",
    "detail": "Function (const Scalar maxnum = NumTraits<Scalar)",
    "insertText": "infinity()"
  },
  {
    "label": "pow()",
    "kind": "Method",
    "detail": "Function (} s =)",
    "insertText": "pow(q, -x)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (a = q ; b = zero ;)",
    "insertText": "if(zeta_impl_series<Scalar>::run(a, b, s, x, machep))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (s - = half* b ; a = one ; k = zero ;)",
    "insertText": "for(i=0; i<12; i++)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (a* = x + k ; b / = w ; t = a* b / A [ i ] ; s = s + t ; t =)",
    "insertText": "abs(t/s)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (break ; } k + = one ; a* = x + k ; b / = w ; k + = one ; } return s ; } } ; template<Scalar> struct polygamma_retval { typedef Scalar type ; } ; # if ! EIGEN_HAS_C99_MATH template<Scalar> struct polygamma_impl { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar)",
    "insertText": "run(Scalar n, Scalar x)"
  },
  {
    "label": "exp()",
    "kind": "Method",
    "detail": "Function (} else { Scalar factorial =)",
    "insertText": "exp(lgamma_impl<Scalar>::run(nplus))"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } } ; # endif template<Scalar> struct betainc_retval { typedef Scalar type ; } ; # if ! EIGEN_HAS_C99_MATH template<Scalar> struct betainc_impl { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar)",
    "insertText": "run(Scalar a, Scalar b, Scalar x)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; # else template<Scalar> struct betainc_impl { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar)",
    "insertText": "run(Scalar, Scalar, Scalar)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct incbeta_cfe { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar)",
    "insertText": "run(Scalar a, Scalar b, Scalar x, bool small_branch)"
  },
  {
    "label": "EIGEN_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT((internal::is_same<Scalar, float>::value || internal::is_same<Scalar, double>::value), THIS_TYPE_IS_NOT_SUPPORTED)"
  },
  {
    "label": "num_iters()",
    "kind": "Method",
    "detail": "Function (const Scalar zero = 0 ; const Scalar one = 1 ; const Scalar two = 2 ; Scalar xk,pk,pkm1,pkm2,qk,qkm1,qkm2 ; Scalar k1,k2,k3,k4,k5,k6,k7,k8,k26update ; Scalar ans ; int n ; const int)",
    "insertText": "num_iters(internal::is_same<Scalar, float>::value)"
  },
  {
    "label": "thresh()",
    "kind": "Method",
    "detail": "Function (const Scalar)",
    "insertText": "thresh(internal::is_same<Scalar, float>::value) ? machep : Scalar(3)"
  },
  {
    "label": "r()",
    "kind": "Method",
    "detail": "Function (Scalar)",
    "insertText": "r(internal::is_same<Scalar, float>::value)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (k1 = a ; k2 = a + b ; k3 = a ; k4 = a + one ; k5 = one ; k6 = b - one ; k7 = k4 ; k8 = a + two ; k26update = one ; } else { k1 = a ; k2 = b - one ; k3 = a ; k4 = a + one ; k5 = one ; k6 = a + b ; k7 = a + one ; k8 = a + two ; k26update = - one ; x =)",
    "insertText": "x(one - x)"
  },
  {
    "label": "xk()",
    "kind": "Method",
    "detail": "Function (} pkm2 = zero ; qkm2 = one ; pkm1 = one ; qkm1 = one ; ans = one ; n = 0 ; do {)",
    "insertText": "xk(x * k1 * k2) / (k3 * k4)"
  },
  {
    "label": "xk()",
    "kind": "Method",
    "detail": "Function (pk = pkm1 + pkm2* xk ; qk = qkm1 + qkm2* xk ; pkm2 = pkm1 ; pkm1 = pk ; qkm2 = qkm1 ; qkm1 = qk ;)",
    "insertText": "xk(x * k5 * k6) / (k7 * k8)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (r = pk / qk ;)",
    "insertText": "if(numext::abs(ans - r) < numext::abs(r) * thresh)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pkm2* = biginv ; pkm1* = biginv ; qkm2* = biginv ; qkm1* = biginv ; })",
    "insertText": "if((numext::abs(qk) < biginv) || (numext::abs(pk) < biginv))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (pkm2* = big ; pkm1* = big ; qkm2* = big ; qkm1* = big ; } })",
    "insertText": "while(++n < num_iters)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (float ans,a,b,t,x,onemx ; bool reversed_a_b = false ; onemx = 1 . 0 f - xx ;)",
    "insertText": "if(xx > (aa / (aa + bb)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (reversed_a_b = true ; a = bb ; b = aa ; t = xx ; x = onemx ; } else { a = aa ; b = bb ; t = onemx ; x = xx ; })",
    "insertText": "if(b > 10.0f)"
  },
  {
    "label": "incbps()",
    "kind": "Method",
    "detail": "Function (t = betainc_helper<float)",
    "insertText": "incbps(a, b, x)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (ans = incbeta_cfe<float)",
    "insertText": "run(a, b, x, true)"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (t = b*)",
    "insertText": "log(t)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} else { ans = incbeta_cfe<float)",
    "insertText": "run(a, b, x, false)"
  },
  {
    "label": "t()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "t(b - 1.0f) * numext::log(t)"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (} t + = a*)",
    "insertText": "log(x) + lgamma_impl<float>::run(a + b) - lgamma_impl<float>::run(a) - lgamma_impl<float>::run(b)"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (t + =)",
    "insertText": "log(ans / a)"
  },
  {
    "label": "exp()",
    "kind": "Method",
    "detail": "Function (t =)",
    "insertText": "exp(t)"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (y = a*)",
    "insertText": "log(x) + (b - 1.0f) * numext::log1p(-x) - numext::log(a)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (y - = lgamma_impl<float)",
    "insertText": "run(a) + lgamma_impl<float>::run(b)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (y + = lgamma_impl<float)",
    "insertText": "run(a + b)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (t =)",
    "insertText": "x(1.0f - x)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (s = 0 . 0 f ; u = 1 . 0 f ; do { b - = 1 . 0 f ;)",
    "insertText": "if(b == 0.0f)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (break ; } a + = 1 . 0 f ; u* = t* b / a ; s + = u ; })",
    "insertText": "while(numext::abs(u) > machep)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct betainc_impl<float> { EIGEN_DEVICE_FUNC float)",
    "insertText": "run(float a, float b, float x)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (float ans,t ;)",
    "insertText": "if(a <= 0.0f)"
  },
  {
    "label": "incbsa()",
    "kind": "Method",
    "detail": "Function (ans = betainc_helper<float)",
    "insertText": "incbsa(a + 1.0f, b, x)"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (t = a*)",
    "insertText": "log(x) + b * numext::log1p(-x) + lgamma_impl<float>::run(a + b) - lgamma_impl<float>::run(a + 1.0f) - lgamma_impl<float>::run(b)"
  },
  {
    "label": "incbsa()",
    "kind": "Method",
    "detail": "Function (} else { return betainc_helper<float)",
    "insertText": "incbsa(a, b, x)"
  },
  {
    "label": "incbps()",
    "kind": "Method",
    "detail": "Function (} } } ; template<> struct betainc_helper<double> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double)",
    "insertText": "incbps(double a, double b, double x)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (v =)",
    "insertText": "u(a + 1.0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (t1 = v ; t = u ; n = 2 . 0 ; s = 0 . 0 ; z = machep* ai ;)",
    "insertText": "while(numext::abs(v) > z)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "u(n - b)"
  },
  {
    "label": "t()",
    "kind": "Method",
    "detail": "Function (t* = u ; v =)",
    "insertText": "t(a + n)"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (s + = v ; n + = 1 . 0 ; } s + = t1 ; s + = ai ; u = a*)",
    "insertText": "log(x)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (t = lgamma_impl<double)",
    "insertText": "run(a + b) - lgamma_impl<double>::run(a) - lgamma_impl<double>::run(b) + u + numext::log(s)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct betainc_impl<double> { EIGEN_DEVICE_FUNC double)",
    "insertText": "run(double aa, double bb, double xx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (reversed_a_b = true ; a = bb ; b = aa ; xc = xx ; x = w ; } else { a = aa ; b = bb ; xc = w ; x = xx ; })",
    "insertText": "if(reversed_a_b && (b * x) <= 1.0 && x <= 0.95)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (t = 1 . 0 - machep ; } else { t = 1 . 0 - t ; } return t ; } y =)",
    "insertText": "x(a + b - 2.0) - (a - 1.0)"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (t = b*)",
    "insertText": "log(xc)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (y + = t + lgamma_impl<double)",
    "insertText": "run(a + b) - lgamma_impl<double>::run(a) - lgamma_impl<double>::run(b)"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (y + =)",
    "insertText": "log(w / a)"
  },
  {
    "label": "exp()",
    "kind": "Method",
    "detail": "Function (t =)",
    "insertText": "exp(y)"
  },
  {
    "label": "EIGEN_MATHFUNC_RETVAL()",
    "kind": "Method",
    "detail": "Function (t = 1 . 0 - machep ; } else { t = 1 . 0 - t ; } } return t ; } } ; # endif } namespace numext { template<Scalar> EIGEN_DEVICE_FUNC)",
    "insertText": "EIGEN_MATHFUNC_RETVAL(lgamma, Scalar) lgamma(const Scalar& x)"
  },
  {
    "label": "EIGEN_MATHFUNC_RETVAL()",
    "kind": "Method",
    "detail": "Function (} template<Scalar> EIGEN_DEVICE_FUNC)",
    "insertText": "EIGEN_MATHFUNC_RETVAL(digamma, Scalar) digamma(const Scalar& x)"
  },
  {
    "label": "EIGEN_MATHFUNC_RETVAL()",
    "kind": "Method",
    "detail": "Function (} template<Scalar> EIGEN_DEVICE_FUNC)",
    "insertText": "EIGEN_MATHFUNC_RETVAL(zeta, Scalar) zeta(const Scalar& x, const Scalar& q)"
  },
  {
    "label": "EIGEN_MATHFUNC_RETVAL()",
    "kind": "Method",
    "detail": "Function (} template<Scalar> EIGEN_DEVICE_FUNC)",
    "insertText": "EIGEN_MATHFUNC_RETVAL(polygamma, Scalar) polygamma(const Scalar& n, const Scalar& x)"
  },
  {
    "label": "EIGEN_MATHFUNC_RETVAL()",
    "kind": "Method",
    "detail": "Function (} template<Scalar> EIGEN_DEVICE_FUNC)",
    "insertText": "EIGEN_MATHFUNC_RETVAL(erf, Scalar) erf(const Scalar& x)"
  },
  {
    "label": "EIGEN_MATHFUNC_RETVAL()",
    "kind": "Method",
    "detail": "Function (} template<Scalar> EIGEN_DEVICE_FUNC)",
    "insertText": "EIGEN_MATHFUNC_RETVAL(erfc, Scalar) erfc(const Scalar& x)"
  },
  {
    "label": "EIGEN_MATHFUNC_RETVAL()",
    "kind": "Method",
    "detail": "Function (} template<Scalar> EIGEN_DEVICE_FUNC)",
    "insertText": "EIGEN_MATHFUNC_RETVAL(ndtri, Scalar) ndtri(const Scalar& x)"
  },
  {
    "label": "EIGEN_MATHFUNC_RETVAL()",
    "kind": "Method",
    "detail": "Function (} template<Scalar> EIGEN_DEVICE_FUNC)",
    "insertText": "EIGEN_MATHFUNC_RETVAL(igamma, Scalar) igamma(const Scalar& a, const Scalar& x)"
  },
  {
    "label": "EIGEN_MATHFUNC_RETVAL()",
    "kind": "Method",
    "detail": "Function (} template<Scalar> EIGEN_DEVICE_FUNC)",
    "insertText": "EIGEN_MATHFUNC_RETVAL(igamma_der_a, Scalar) igamma_der_a(const Scalar& a, const Scalar& x)"
  },
  {
    "label": "EIGEN_MATHFUNC_RETVAL()",
    "kind": "Method",
    "detail": "Function (} template<Scalar> EIGEN_DEVICE_FUNC)",
    "insertText": "EIGEN_MATHFUNC_RETVAL(gamma_sample_der_alpha, Scalar) gamma_sample_der_alpha(const Scalar& a, const Scalar& x)"
  },
  {
    "label": "EIGEN_MATHFUNC_RETVAL()",
    "kind": "Method",
    "detail": "Function (} template<Scalar> EIGEN_DEVICE_FUNC)",
    "insertText": "EIGEN_MATHFUNC_RETVAL(igammac, Scalar) igammac(const Scalar& a, const Scalar& x)"
  },
  {
    "label": "EIGEN_MATHFUNC_RETVAL()",
    "kind": "Method",
    "detail": "Function (} template<Scalar> EIGEN_DEVICE_FUNC)",
    "insertText": "EIGEN_MATHFUNC_RETVAL(betainc, Scalar) betainc(const Scalar& a, const Scalar& b, const Scalar& x)"
  }
]