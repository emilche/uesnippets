[
  {
    "label": "FNativeString",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FNativeString"
  },
  {
    "label": "TIsZeroConstructType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsZeroConstructType"
  },
  {
    "label": "TIsContiguousContainer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsContiguousContainer"
  },
  {
    "label": "FNativeString()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Utf8String . h \" namespace Verse { class FNativeString ; } template<> struct TIsZeroConstructType<Verse::FNativeString> { bool Value = true ; } ; template<> struct TIsContiguousContainer<Verse::FNativeString> { bool Value = true ; } ; namespace Verse { class FNativeString { public : using ElementType = FUtf8String::ElementType ; private : FUtf8String String ; public :)",
    "insertText": "FNativeString()"
  },
  {
    "label": "FNativeString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FNativeString(FNativeString&&)"
  },
  {
    "label": "FNativeString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FNativeString(const FNativeString&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FNativeString&)",
    "insertText": "operator(FNativeString&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FNativeString&)",
    "insertText": "operator(const FNativeString&)"
  },
  {
    "label": "FNativeString()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FNativeString(FUtf8String&& InString) : String(MoveTemp(InString))"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<CharRangeType,CharRangeElementType = TElementType_T<CharRangeType>)",
    "insertText": "UE_REQUIRES(TIsContiguousContainer<CharRangeType>::Value&& TIsCharType_V<CharRangeElementType>)> FORCEINLINE explicit FNativeString(CharRangeType&& Range) : String(Forward<CharRangeType>(Range))"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<CharRangeType,CharRangeElementType = TElementType_T<CharRangeType>)",
    "insertText": "UE_REQUIRES(TIsContiguousContainer<CharRangeType>::Value&& std::is_same_v<ElementType, CharRangeElementType>)> FORCEINLINE FNativeString& operator=(CharRangeType&& Range)"
  },
  {
    "label": "CharRangeType()",
    "kind": "Method",
    "detail": "Function (String = Forward<)",
    "insertText": "CharRangeType(Range)"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (} const ElementType*)",
    "insertText": "GetData(const FNativeString& InString)"
  },
  {
    "label": "GetNum()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetNum(const FNativeString& InString)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ElementType&)",
    "insertText": "operator(int32 Index)"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] bool)",
    "insertText": "operator(const FNativeString& Lhs, const FNativeString& Rhs)"
  },
  {
    "label": "Equals()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] bool)",
    "insertText": "Equals(const FNativeString& Other)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetTypeHash(const FNativeString& S)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset(int32 NewReservedSize = 0)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (String .)",
    "insertText": "Reset(NewReservedSize)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<CharRangeType,CharRangeElementType = TElementType_T<CharRangeType>)",
    "insertText": "UE_REQUIRES(TIsContiguousContainer<CharRangeType>::Value&& TIsCharType_V<CharRangeElementType>)> FORCEINLINE FNativeString& operator+=(CharRangeType&& Str)"
  },
  {
    "label": "CharRangeType()",
    "kind": "Method",
    "detail": "Function (String + = Forward<)",
    "insertText": "CharRangeType(Str)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (String + = Str ; return* this ; } template<CharRangeType,CharRangeElementType = TElementType_T<CharRangeType>)",
    "insertText": "UE_REQUIRES(TIsContiguousContainer<CharRangeType>::Value&& std::is_same_v<ElementType, CharRangeElementType>)> FORCEINLINE friend FNativeString operator+(FNativeString&& Lhs, CharRangeType&& Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FNativeString)",
    "insertText": "operator(FNativeString&& Lhs, const ANSICHAR* Rhs)"
  },
  {
    "label": "Printf()",
    "kind": "Method",
    "detail": "Function (} template<FmtType,. . . Types> [ [ nodiscard ] ] FNativeString)",
    "insertText": "Printf(const FmtType& Fmt, Types... Args)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FArchive&)",
    "insertText": "operator(FArchive& Ar, FNativeString& S)"
  }
]