[
  {
    "label": "task_handle_task",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "task_handle_task"
  },
  {
    "label": "task_group",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "task_group"
  },
  {
    "label": "structured_task_group",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "structured_task_group"
  },
  {
    "label": "task_handle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "task_handle"
  },
  {
    "label": "internal",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "internal"
  },
  {
    "label": "task_group_status",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "task_group_status"
  },
  {
    "label": "task_group_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "task_group_base"
  },
  {
    "label": "ref_count_guard",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ref_count_guard"
  },
  {
    "label": "F",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "F"
  },
  {
    "label": "mark_scheduled()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_task_group_H # define __TBB_task_group_H # include \" task . h \" # include \" tbb_exception . h \" # include \" internal / _template_helpers . h \" # if __TBB_TASK_GROUP_CONTEXT namespace tbb { namespace internal { template<F> class task_handle_task ; } class task_group ; class structured_task_group ; template<F> class task_handle : internal::no_assign { template<_F> class internal::task_handle_task ; class task_group ; class structured_task_group ; const intptr_t scheduled = 0 x1 ; F my_func ; intptr_t my_state ; void)",
    "insertText": "mark_scheduled()"
  },
  {
    "label": "task_handle()",
    "kind": "Method",
    "detail": "Function (my_state | = scheduled ; } public :)",
    "insertText": "task_handle(const F& f ) : my_func(f), my_state(0)"
  },
  {
    "label": "task_handle()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_CPP11_RVALUE_REF_PRESENT)",
    "insertText": "task_handle(F&& f ) : my_func( std::move(f)), my_state(0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif void)",
    "insertText": "operator() ()"
  },
  {
    "label": "my_func()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "my_func()"
  },
  {
    "label": "execute()",
    "kind": "Method",
    "detail": "Function (} } ; enum task_group_status { not_complete,complete,canceled } ; namespace internal { template<F> class task_handle_task : public task { task_handle<F>& my_handle ; task*)",
    "insertText": "execute()"
  },
  {
    "label": "my_handle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "my_handle()"
  },
  {
    "label": "ref_count_guard()",
    "kind": "Method",
    "detail": "Function (} } ; class task_group_base : internal::no_copy { class ref_count_guard : internal::no_copy { task& my_task ; public :)",
    "insertText": "ref_count_guard(task& t) : my_task(t)"
  },
  {
    "label": "increment_ref_count()",
    "kind": "Method",
    "detail": "Function (my_task .)",
    "insertText": "increment_ref_count()"
  },
  {
    "label": "ref_count_guard()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ref_count_guard()"
  },
  {
    "label": "decrement_ref_count()",
    "kind": "Method",
    "detail": "Function (my_task .)",
    "insertText": "decrement_ref_count()"
  },
  {
    "label": "owner()",
    "kind": "Method",
    "detail": "Function (} } ; protected : empty_task* my_root ; task_group_context my_context ; task&)",
    "insertText": "owner()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (__TBB_TRY {)",
    "insertText": "if(!my_context.is_group_execution_cancelled())"
  },
  {
    "label": "guard()",
    "kind": "Method",
    "detail": "Function (ref_count_guard)",
    "insertText": "guard(*my_root)"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "f()"
  },
  {
    "label": "__TBB_CATCH()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "__TBB_CATCH(...)"
  },
  {
    "label": "register_pending_exception()",
    "kind": "Method",
    "detail": "Function (my_context .)",
    "insertText": "register_pending_exception()"
  },
  {
    "label": "wait()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "wait()"
  },
  {
    "label": "internal_run()",
    "kind": "Method",
    "detail": "Function (} template<Task,F> void)",
    "insertText": "internal_run(__TBB_FORWARDING_REF(F) f)"
  },
  {
    "label": "owner()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "owner().spawn( *new( owner().allocate_additional_child_of(*my_root) ) Task( internal::forward<F>(f) ))"
  },
  {
    "label": "task_group_base()",
    "kind": "Method",
    "detail": "Function (} public :)",
    "insertText": "task_group_base(uintptr_t traits = 0 ) : my_context(task_group_context::bound, task_group_context::default_traits | traits)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (my_root =)",
    "insertText": "new(task::allocate_root(my_context))"
  },
  {
    "label": "set_ref_count()",
    "kind": "Method",
    "detail": "Function (my_root ->)",
    "insertText": "set_ref_count(1)"
  },
  {
    "label": "task_group_base()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "task_group_base() __TBB_NOEXCEPT(false)"
  },
  {
    "label": "uncaught_exceptions()",
    "kind": "Method",
    "detail": "Function (# if __TBB_CPP17_UNCAUGHT_EXCEPTIONS_PRESENT bool stack_unwinding_in_progress =)",
    "insertText": "uncaught_exceptions()"
  },
  {
    "label": "uncaught_exception()",
    "kind": "Method",
    "detail": "Function (# else bool stack_unwinding_in_progress =)",
    "insertText": "uncaught_exception()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(!is_canceling() ) cancel()"
  },
  {
    "label": "wait_for_all()",
    "kind": "Method",
    "detail": "Function (__TBB_TRY { my_root ->)",
    "insertText": "wait_for_all()"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy(*my_root)"
  },
  {
    "label": "__TBB_RETHROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_RETHROW()"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } template<F> void)",
    "insertText": "run(task_handle<F>& h)"
  },
  {
    "label": "F()",
    "kind": "Method",
    "detail": "Function (internal_run<internal::task_handle_task<)",
    "insertText": "F(h)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (my_context .)",
    "insertText": "reset()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(my_context.is_group_execution_cancelled())"
  },
  {
    "label": "cancel()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "cancel()"
  },
  {
    "label": "cancel_group_execution()",
    "kind": "Method",
    "detail": "Function (my_context .)",
    "insertText": "cancel_group_execution()"
  },
  {
    "label": "task_group()",
    "kind": "Method",
    "detail": "Function (} } ; } class task_group : public internal::task_group_base { public :)",
    "insertText": "task_group() : task_group_base( task_group_context::concurrent_wait)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} # else using task_group_base::run ; # endif # if __TBB_CPP11_RVALUE_REF_PRESENT template<F> void)",
    "insertText": "run(F&& f)"
  },
  {
    "label": "type()",
    "kind": "Method",
    "detail": "Function (internal_run<internal::function_task<internal::strip<F)",
    "insertText": "type(std::forward< F >(f))"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} # else template<F> void)",
    "insertText": "run(const F& f)"
  },
  {
    "label": "F()",
    "kind": "Method",
    "detail": "Function (internal_run<internal::function_task<)",
    "insertText": "F(f)"
  },
  {
    "label": "run_and_wait()",
    "kind": "Method",
    "detail": "Function (} # endif template<F> task_group_status)",
    "insertText": "run_and_wait(const F& f)"
  },
  {
    "label": "run_and_wait()",
    "kind": "Method",
    "detail": "Function (} template<F> task_group_status)",
    "insertText": "run_and_wait(task_handle<F>& h)"
  },
  {
    "label": "make_task()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_CPP11_RVALUE_REF_PRESENT template<class F> task_handle<internal::strip<F>::type>)",
    "insertText": "make_task(F&& f)"
  },
  {
    "label": "make_task()",
    "kind": "Method",
    "detail": "Function (} # else template<class F> task_handle<F>)",
    "insertText": "make_task(const F& f)"
  }
]