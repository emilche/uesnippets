[
  {
    "label": "FSteeringUtility",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSteeringUtility"
  },
  {
    "label": "IntersectTwoCircles()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" VehicleSystemTemplate . h \" # include \" VehicleUtility . h \" # if VEHICLE_DEBUGGING_ENABLED UE_DISABLE_OPTIMIZATION # endif namespace Chaos { struct FSteeringUtility { bool)",
    "insertText": "IntersectTwoCircles(float R1, float R2, float D, FVector2D& OutIntersection)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (OutIntersection .)",
    "insertText": "Set(0, 0)"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (OutIntersection . Y =)",
    "insertText": "Sqrt(4.0f * DSqr * R1Sqr - Sqr(DSqr - R2Sqr + R1Sqr))"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (Input = - Input ; } OutC1 .)",
    "insertText": "Set(0.0f + Input, 0.0f)"
  },
  {
    "label": "RadToDeg()",
    "kind": "Method",
    "detail": "Function (FVector2D C2RelC1 = C2 - OutC1 ; float Angle =)",
    "insertText": "RadToDeg(FMath::Atan2(C2RelC1.Y, C2RelC1.X))"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (float D = C2RelC1 .)",
    "insertText": "Size()"
  },
  {
    "label": "IntersectTwoCircles()",
    "kind": "Method",
    "detail": "Function (FVector2D Intersection ;)",
    "insertText": "IntersectTwoCircles(R1, R2, D, Intersection)"
  },
  {
    "label": "GetRotated()",
    "kind": "Method",
    "detail": "Function (Intersection . Y = - Intersection . Y ; FVector2D Arm = Intersection .)",
    "insertText": "GetRotated(Angle)"
  },
  {
    "label": "RadToDeg()",
    "kind": "Method",
    "detail": "Function (OutPt = OutC1 + Arm ; FVector2D WheelArm = C2 - OutPt ; OutSteerAngle =)",
    "insertText": "RadToDeg(FMath::Atan2(WheelArm.X, WheelArm.Y))"
  },
  {
    "label": "CalculateBetaDegrees()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "CalculateBetaDegrees(float TrackWidth, float WheelBase)"
  },
  {
    "label": "AkermannSetup()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AkermannSetup(float T, float Beta, float R, float& OutH, float& OutS)"
  },
  {
    "label": "Cos()",
    "kind": "Method",
    "detail": "Function (OutH = R*)",
    "insertText": "Cos(DegToRad(Beta))"
  },
  {
    "label": "Sin()",
    "kind": "Method",
    "detail": "Function (OutS = T - 2 . 0 f* R*)",
    "insertText": "Sin(DegToRad(Beta))"
  },
  {
    "label": "CalcJointPositions()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CalcJointPositions(float T, float Beta, float R, FVector2D& C1, float& R1, FVector2D& C2, float& R2)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (C1 .)",
    "insertText": "Set(0.f, 0.f)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (C2 .)",
    "insertText": "Set(T*0.5f, H)"
  }
]