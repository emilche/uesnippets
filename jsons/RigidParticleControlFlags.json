[
  {
    "label": "FString",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FString"
  },
  {
    "label": "FChaosArchive",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FChaosArchive"
  },
  {
    "label": "FRigidParticleControlFlags",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRigidParticleControlFlags"
  },
  {
    "label": "FFlags",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFlags"
  },
  {
    "label": "FRigidParticleTransientFlags",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRigidParticleTransientFlags"
  },
  {
    "label": "FRigidParticleControlFlags()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" class FString ; namespace Chaos { class FChaosArchive ; class FRigidParticleControlFlags { public : using FStorage = uint16 ;)",
    "insertText": "FRigidParticleControlFlags() : Bits(0)"
  },
  {
    "label": "GetFlags()",
    "kind": "Method",
    "detail": "Function (} FStorage)",
    "insertText": "GetFlags()"
  },
  {
    "label": "GetGravityEnabled()",
    "kind": "Method",
    "detail": "Function (Bits = InBits ; } bool)",
    "insertText": "GetGravityEnabled()"
  },
  {
    "label": "GetUpdateKinematicFromSimulation()",
    "kind": "Method",
    "detail": "Function (Flags . bGravityEnabled = bEnabled ; return* this ; } bool)",
    "insertText": "GetUpdateKinematicFromSimulation()"
  },
  {
    "label": "GetGravityGroupIndex()",
    "kind": "Method",
    "detail": "Function (Flags . bUpdateKinematicFromSimulation = bUpdateKinematicFromSimulation ; return* this ; } int32)",
    "insertText": "GetGravityGroupIndex()"
  },
  {
    "label": "FStorage()",
    "kind": "Method",
    "detail": "Function (Flags . GravityGroupIndex = static_cast<)",
    "insertText": "FStorage(GravityGroupIndex)"
  },
  {
    "label": "GetMACDEnabled()",
    "kind": "Method",
    "detail": "Function (Flags . bCCDEnabled = bEnabled ; return* this ; } bool)",
    "insertText": "GetMACDEnabled()"
  },
  {
    "label": "GetOneWayInteractionEnabled()",
    "kind": "Method",
    "detail": "Function (Flags . bMACDEnabled = bEnabled ; return* this ; } bool)",
    "insertText": "GetOneWayInteractionEnabled()"
  },
  {
    "label": "GetInertiaConditioningEnabled()",
    "kind": "Method",
    "detail": "Function (Flags . bOneWayInteractionEnabled = bEnabled ; return* this ; } bool)",
    "insertText": "GetInertiaConditioningEnabled()"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (Flags . bInertiaConditioningEnabled = bEnabled ; return* this ; } FString)",
    "insertText": "ToString()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(const FRigidParticleControlFlags& L, const FRigidParticleControlFlags& R)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar, FRigidParticleControlFlags& Data)"
  },
  {
    "label": "FRigidParticleTransientFlags()",
    "kind": "Method",
    "detail": "Function (class FRigidParticleTransientFlags { public : using FStorage = uint8 ;)",
    "insertText": "FRigidParticleTransientFlags() : Bits(0)"
  },
  {
    "label": "GetInertiaConditioningDirty()",
    "kind": "Method",
    "detail": "Function (Bits = InFlags ; } bool)",
    "insertText": "GetInertiaConditioningDirty()"
  },
  {
    "label": "ClearInertiaConditioningDirty()",
    "kind": "Method",
    "detail": "Function (Flags . bInertiaConditioningDirty = true ; } void)",
    "insertText": "ClearInertiaConditioningDirty()"
  },
  {
    "label": "GetUseIgnoreCollisionManager()",
    "kind": "Method",
    "detail": "Function (Flags . bInertiaConditioningDirty = false ; } bool)",
    "insertText": "GetUseIgnoreCollisionManager()"
  },
  {
    "label": "ClearUseIgnoreCollisionManager()",
    "kind": "Method",
    "detail": "Function (Flags . bUseIgnoreCollisionManager = true ; } void)",
    "insertText": "ClearUseIgnoreCollisionManager()"
  },
  {
    "label": "GetIsMovingKinematic()",
    "kind": "Method",
    "detail": "Function (Flags . bUseIgnoreCollisionManager = false ; } bool)",
    "insertText": "GetIsMovingKinematic()"
  },
  {
    "label": "ClearIsMovingKinematic()",
    "kind": "Method",
    "detail": "Function (Flags . bIsMovingKinematic = true ; } void)",
    "insertText": "ClearIsMovingKinematic()"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (Flags . bIsMovingKinematic = false ; } private : struct FFlags { FStorage bInertiaConditioningDirty : 1 ; FStorage bUseIgnoreCollisionManager : 1 ; FStorage bIsMovingKinematic : 1 ; } ; union { FFlags Flags ; FStorage Bits ; } ; } ;)",
    "insertText": "static_assert(sizeof(FRigidParticleTransientFlags) == sizeof(FRigidParticleTransientFlags::FStorage), \"Change FRigidParticleTransientFlags::FStorage to be larger\")"
  }
]