[
  {
    "label": "CordRepBtreeNavigator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CordRepBtreeNavigator"
  },
  {
    "label": "Position",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Position"
  },
  {
    "label": "ReadResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ReadResult"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_STRINGS_INTERNAL_CORD_REP_BTREE_NAVIGATOR_H_ # define ABSL_STRINGS_INTERNAL_CORD_REP_BTREE_NAVIGATOR_H_ # include<cassert> # include<iostream> # include \" absl / strings / internal / cord_internal . h \" # include \" absl / strings / internal / cord_rep_btree . h \" namespace absl { ABSL_NAMESPACE_BEGIN namespace cord_internal { class CordRepBtreeNavigator { public : struct Position { CordRep* edge ; size_t offset ; } ; struct ReadResult { CordRep* tree ; size_t n ; } ; operator)",
    "insertText": "bool()"
  },
  {
    "label": "btree()",
    "kind": "Method",
    "detail": "Function (CordRepBtree*)",
    "insertText": "btree()"
  },
  {
    "label": "Current()",
    "kind": "Method",
    "detail": "Function (CordRep*)",
    "insertText": "Current()"
  },
  {
    "label": "InitFirst()",
    "kind": "Method",
    "detail": "Function (CordRep*)",
    "insertText": "InitFirst(CordRepBtree* tree)"
  },
  {
    "label": "InitLast()",
    "kind": "Method",
    "detail": "Function (CordRep*)",
    "insertText": "InitLast(CordRepBtree* tree)"
  },
  {
    "label": "InitOffset()",
    "kind": "Method",
    "detail": "Function (Position)",
    "insertText": "InitOffset(CordRepBtree* tree, size_t offset)"
  },
  {
    "label": "Next()",
    "kind": "Method",
    "detail": "Function (CordRep*)",
    "insertText": "Next()"
  },
  {
    "label": "Previous()",
    "kind": "Method",
    "detail": "Function (CordRep*)",
    "insertText": "Previous()"
  },
  {
    "label": "Seek()",
    "kind": "Method",
    "detail": "Function (Position)",
    "insertText": "Seek(size_t offset)"
  },
  {
    "label": "Read()",
    "kind": "Method",
    "detail": "Function (ReadResult)",
    "insertText": "Read(size_t edge_offset, size_t n)"
  },
  {
    "label": "Skip()",
    "kind": "Method",
    "detail": "Function (Position)",
    "insertText": "Skip(size_t n)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "NextUp()",
    "kind": "Method",
    "detail": "Function (private : CordRep*)",
    "insertText": "NextUp()"
  },
  {
    "label": "PreviousUp()",
    "kind": "Method",
    "detail": "Function (CordRep*)",
    "insertText": "PreviousUp()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (template<CordRepBtree::EdgeType edge_type> CordRep*)",
    "insertText": "Init(CordRepBtree* tree)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(height_ >= 0)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(tree != nullptr)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(tree->size() > 0)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(tree->height() <= CordRepBtree::kMaxHeight)"
  },
  {
    "label": "height()",
    "kind": "Method",
    "detail": "Function (int height = height_ = tree ->)",
    "insertText": "height()"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (size_t index = tree ->)",
    "insertText": "index(edge_type)"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (node_ [ height ] = tree ; index_ [ height ] = static_cast<)",
    "insertText": "uint8_t(index)"
  },
  {
    "label": "Edge()",
    "kind": "Method",
    "detail": "Function (tree = tree ->)",
    "insertText": "Edge(index)->btree()"
  },
  {
    "label": "Edge()",
    "kind": "Method",
    "detail": "Function (} return node_ [ 0 ] ->)",
    "insertText": "Edge(index)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(btree() != nullptr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int height = height_ ; CordRepBtree* edge = node_ [ height ] ;)",
    "insertText": "if(ABSL_PREDICT_FALSE(offset >= edge->length))"
  },
  {
    "label": "IndexOf()",
    "kind": "Method",
    "detail": "Function (nullptr,0 } ; CordRepBtree::Position index = edge ->)",
    "insertText": "IndexOf(offset)"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (index_ [ height ] = static_cast<)",
    "insertText": "uint8_t(index.index)"
  },
  {
    "label": "Edge()",
    "kind": "Method",
    "detail": "Function (edge = edge ->)",
    "insertText": "Edge(index.index)->btree()"
  },
  {
    "label": "IndexOf()",
    "kind": "Method",
    "detail": "Function (node_ [ height ] = edge ; index = edge ->)",
    "insertText": "IndexOf(index.n)"
  },
  {
    "label": "Edge()",
    "kind": "Method",
    "detail": "Function (} return { edge ->)",
    "insertText": "Edge(index.index)"
  },
  {
    "label": "Seek()",
    "kind": "Method",
    "detail": "Function (node_ [ height_ ] = tree ; return)",
    "insertText": "Seek(offset)"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (CordRepBtree* edge = node_ [ 0 ] ; return index_ [ 0 ] = = edge ->)",
    "insertText": "back() ? NextUp() : edge->Edge(++index_[0])"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (CordRepBtree* edge = node_ [ 0 ] ; return index_ [ 0 ] = = edge ->)",
    "insertText": "begin() ? PreviousUp() : edge->Edge(--index_[0])"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(index_[0] == node_[0]->back())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CordRepBtree* edge ; size_t index ; int height = 0 ; do {)",
    "insertText": "if(++height > height_)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (edge = node_ [ height ] ; index = index_ [ height ] + 1 ; })",
    "insertText": "while(index == edge->end())"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (index_ [ height ] = static_cast<)",
    "insertText": "uint8_t(index = edge->begin())"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(height > 0)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(index_[0] == node_[0]->begin())"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (edge = node_ [ height ] ; index = index_ [ height ] ; })",
    "insertText": "while(index == edge->begin())"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (index_ [ height ] = static_cast<)",
    "insertText": "uint8_t(--index)"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (index_ [ height ] = static_cast<)",
    "insertText": "uint8_t(index = edge->back())"
  }
]