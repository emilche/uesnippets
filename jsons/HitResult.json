[
  {
    "label": "AActor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AActor"
  },
  {
    "label": "UPackageMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UPackageMap"
  },
  {
    "label": "UPhysicalMaterial",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UPhysicalMaterial"
  },
  {
    "label": "UPrimitiveComponent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UPrimitiveComponent"
  },
  {
    "label": "FHitResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FHitResult"
  },
  {
    "label": "TIsPODType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsPODType"
  },
  {
    "label": "TStructOpsTypeTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TStructOpsTypeTraits"
  },
  {
    "label": "USTRUCT()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Chaos / PhysicsObject . h \" # include \" Engine / NetSerialization . h \" # include \" Engine / ActorInstanceHandle . h \" # include \" HitResult . generated . h \" class AActor ; class UPackageMap ; class UPhysicalMaterial ; class UPrimitiveComponent ;)",
    "insertText": "USTRUCT(BlueprintType, meta = (HasNativeBreak = \"/Script/Engine.GameplayStatics.BreakHitResult\", HasNativeMake = \"/Script/Engine.GameplayStatics.MakeHitResult\"))"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() UPROPERTY()"
  },
  {
    "label": "FHitResult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FHitResult()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init()"
  },
  {
    "label": "FHitResult()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FHitResult(float InTime)"
  },
  {
    "label": "FHitResult()",
    "kind": "Method",
    "detail": "Function (Time = InTime ; })",
    "insertText": "FHitResult(EForceInit InInit)"
  },
  {
    "label": "FHitResult()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FHitResult(ENoInit NoInit)"
  },
  {
    "label": "FHitResult()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FHitResult(FVector Start, FVector End)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(Start, End)"
  },
  {
    "label": "Memzero()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memzero(this, sizeof(FHitResult))"
  },
  {
    "label": "FActorInstanceHandle()",
    "kind": "Method",
    "detail": "Function (HitObjectHandle =)",
    "insertText": "FActorInstanceHandle()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (Time = 1 . f ; MyItem = INDEX_NONE ; } void)",
    "insertText": "Init(FVector Start, FVector End)"
  },
  {
    "label": "FHitResult()",
    "kind": "Method",
    "detail": "Function (Time = 1 . f ; TraceStart = Start ; TraceEnd = End ; MyItem = INDEX_NONE ; })",
    "insertText": "FHitResult(AActor* InActor, UPrimitiveComponent* InComponent, FVector const& HitLoc, FVector const& HitNorm)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Time = InTime ;)",
    "insertText": "if(bPreserveTraceData)"
  },
  {
    "label": "GetActor()",
    "kind": "Method",
    "detail": "Function (TraceStart = SavedTraceStart ; TraceEnd = SavedTraceEnd ; } } AActor*)",
    "insertText": "GetActor()"
  },
  {
    "label": "GetHitObjectHandle()",
    "kind": "Method",
    "detail": "Function (} FActorInstanceHandle)",
    "insertText": "GetHitObjectHandle()"
  },
  {
    "label": "GetComponent()",
    "kind": "Method",
    "detail": "Function (} UPrimitiveComponent*)",
    "insertText": "GetComponent()"
  },
  {
    "label": "NetSerialize()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "NetSerialize(FArchive& Ar, UPackageMap* Map, bool& bOutSuccess)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 NumBlocks = 0 ;)",
    "insertText": "for(int32 HitIdx=0; HitIdx<InHits.Num(); HitIdx++)"
  },
  {
    "label": "GetNumOverlapHits()",
    "kind": "Method",
    "detail": "Function (NumBlocks + + ; } } return NumBlocks ; } int32)",
    "insertText": "GetNumOverlapHits(const TArray<FHitResult>& InHits)"
  },
  {
    "label": "GetReversedHit()",
    "kind": "Method",
    "detail": "Function (} FHitResult)",
    "insertText": "GetReversedHit(const FHitResult& Hit)"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (FHitResult)",
    "insertText": "Result(Hit)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (Result . Normal = - Result . Normal ; Result . ImpactNormal = - Result . ImpactNormal ; int32 TempItem = Result . Item ; Result . Item = Result . MyItem ; Result . MyItem = TempItem ; FName TempBoneName = Result . BoneName ; Result . BoneName = Result . MyBoneName ; Result . MyBoneName = TempBoneName ; return Result ; } FString)",
    "insertText": "ToString()"
  }
]