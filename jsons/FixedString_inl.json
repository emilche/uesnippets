[
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if !)",
    "insertText": "defined(__GNUC__) && !defined(__CELLOS_LV2__) && !defined(__APPLE__) && !defined(__SNC__) && !defined(NDEV) && !defined(vsnprintf) #define SpeedTreeVsnPrintF _vsnprintf #else #define SpeedTreeVsnPrintF vsnprintf #endif template <size_t uiDataSize> inline CBasicFixedString<uiDataSize>::CBasicFixedString(void)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(uiDataSize > 0)"
  },
  {
    "label": "CBasicFixedString()",
    "kind": "Method",
    "detail": "Function (* this = \" \" ; } template<size_t uiDataSize> CBasicFixedString<uiDataSize)",
    "insertText": "CBasicFixedString(const CBasicFixedString& cCopy)"
  },
  {
    "label": "CBasicFixedString()",
    "kind": "Method",
    "detail": "Function (* this = cCopy ; } template<size_t uiDataSize> CBasicFixedString<uiDataSize)",
    "insertText": "CBasicFixedString(const char* pchData)"
  },
  {
    "label": "CBasicFixedString()",
    "kind": "Method",
    "detail": "Function (* this = pchData ; } template<size_t uiDataSize> CBasicFixedString<uiDataSize>::~)",
    "insertText": "CBasicFixedString(void)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} template<size_t uiDataSize> void CBasicFixedString<uiDataSize)",
    "insertText": "clear(void)"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (m_uiSize = 0 ; m_aData [ 0 ] = 0 ; } template<size_t uiDataSize> bool CBasicFixedString<uiDataSize)",
    "insertText": "empty(void)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} template<size_t uiDataSize> bool CBasicFixedString<uiDataSize)",
    "insertText": "resize(size_t uiSize)"
  },
  {
    "label": "c_str()",
    "kind": "Method",
    "detail": "Function (m_uiSize = uiSize ; m_aData [ m_uiSize ] = 0 ; return true ; } m_uiSize = uiDataSize - 1 ; m_aData [ m_uiSize ] = 0 ; return false ; } template<size_t uiDataSize> const char* CBasicFixedString<uiDataSize)",
    "insertText": "c_str(void)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CBasicFixedString strReturn ;)",
    "insertText": "if(m_uiSize > 0 && uiStart < m_uiSize)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (strReturn .)",
    "insertText": "resize(uiCount)"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(strReturn.m_aData, m_aData + uiStart, uiCount * sizeof(char))"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (} return strReturn ; } template<size_t uiDataSize> size_t CBasicFixedString<uiDataSize)",
    "insertText": "find(char chFind, size_t uiStart)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (size_t uiReturn =)",
    "insertText": "size_t(npos)"
  },
  {
    "label": "erase_all()",
    "kind": "Method",
    "detail": "Function (uiReturn = i ; break ; } } return uiReturn ; } template<size_t uiDataSize> void CBasicFixedString<uiDataSize)",
    "insertText": "erase_all(const char chErase)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t uiCheck = m_uiSize - i - 1 ;)",
    "insertText": "if(m_aData[uiCheck] == chErase)"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(&(m_aData[uiCheck]), &(m_aData[uiCheck + 1]), (m_uiSize - uiCheck) * sizeof(char))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (- - m_uiSize ; } else + + i ; } } template<size_t uiDataSize> void CBasicFixedString<uiDataSize)",
    "insertText": "operator(const char* pchData)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t uiSize = 0 ;)",
    "insertText": "if(pchData != NULL) uiSize = strlen(pchData)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(m_uiSize + uiSize < uiDataSize - 1)"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(&(m_aData[m_uiSize]), pchData, uiSize * sizeof(char))"
  },
  {
    "label": "strReturn()",
    "kind": "Method",
    "detail": "Function (CBasicFixedString)",
    "insertText": "strReturn(*this)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (strReturn + = pchData ; return strReturn ; } template<size_t uiDataSize> void CBasicFixedString<uiDataSize)",
    "insertText": "operator(const CBasicFixedString& strRight)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(m_uiSize + strRight.m_uiSize < uiDataSize - 1)"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(&(m_aData[m_uiSize]), strRight.m_aData, strRight.m_uiSize * sizeof(char))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (strReturn + = strRight ; return strReturn ; } template<size_t uiDataSize> void CBasicFixedString<uiDataSize)",
    "insertText": "operator(const char& chRight)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(m_uiSize + 1 < uiDataSize - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_uiSize = strRight . m_uiSize ;)",
    "insertText": "if(strRight.m_uiSize > 0) memmove(m_aData, strRight.m_aData, m_uiSize * sizeof(char))"
  },
  {
    "label": "strlen()",
    "kind": "Method",
    "detail": "Function (m_uiSize = 0 ; m_aData [ 0 ] = 0 ; } else { size_t uiSize =)",
    "insertText": "strlen(pchData)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(uiSize < uiDataSize - 1)"
  },
  {
    "label": "pThis()",
    "kind": "Method",
    "detail": "Function (char*)",
    "insertText": "pThis(char*)"
  },
  {
    "label": "pRight()",
    "kind": "Method",
    "detail": "Function (char*)",
    "insertText": "pRight(char*)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (char* pThis = m_aData ; char* pRight = strRight . m_aData ;)",
    "insertText": "for(; *pThis == *pRight; ++pThis, ++pRight) if (*pThis == 0)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(uiIndex < m_uiSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CBasicFixedString strReturn ;)",
    "insertText": "if(pchFormat != NULL)"
  },
  {
    "label": "va_start()",
    "kind": "Method",
    "detail": "Function (va_list vlArgs ;)",
    "insertText": "va_start(vlArgs, pchFormat)"
  },
  {
    "label": "st_vsnprintf()",
    "kind": "Method",
    "detail": "Function (st_int32 nCharsWritten =)",
    "insertText": "st_vsnprintf(strReturn.m_aData, uiDataSize - 1, pchFormat, vlArgs)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(nCharsWritten < st_int32(uiDataSize) - 1)"
  },
  {
    "label": "va_end()",
    "kind": "Method",
    "detail": "Function (strReturn . m_uiSize = nCharsWritten ;)",
    "insertText": "va_end(vlArgs)"
  },
  {
    "label": "Extension()",
    "kind": "Method",
    "detail": "Function (} return strReturn ; } template<size_t uiDataSize> CBasicFixedString<uiDataSize> CBasicFixedString<uiDataSize)",
    "insertText": "Extension(char chExtensionChar)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (CBasicFixedString strReturn ; const char* pCurrent = m_aData + m_uiSize - 1 ;)",
    "insertText": "while(pCurrent >= m_aData)"
  },
  {
    "label": "uiSize()",
    "kind": "Method",
    "detail": "Function (+ + pCurrent ; size_t)",
    "insertText": "uiSize(m_aData + m_uiSize - pCurrent)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (strReturn .)",
    "insertText": "resize(uiSize)"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(strReturn.m_aData, pCurrent, uiSize * sizeof(char))"
  },
  {
    "label": "NoExtension()",
    "kind": "Method",
    "detail": "Function (break ; } - - pCurrent ; } return strReturn ; } template<size_t uiDataSize> CBasicFixedString<uiDataSize> CBasicFixedString<uiDataSize)",
    "insertText": "NoExtension(char chExtensionChar)"
  },
  {
    "label": "uiSize()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "uiSize(pCurrent - m_aData)"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(strReturn.m_aData, m_aData, uiSize * sizeof(char))"
  },
  {
    "label": "Path()",
    "kind": "Method",
    "detail": "Function (break ; } - - pCurrent ; } return strReturn ; } template<size_t uiDataSize> CBasicFixedString<uiDataSize> CBasicFixedString<uiDataSize)",
    "insertText": "Path(CBasicFixedString strDelimiters)"
  },
  {
    "label": "NoPath()",
    "kind": "Method",
    "detail": "Function (pCurrent = m_aData ; break ; } } - - pCurrent ; } return strReturn ; } template<size_t uiDataSize> CBasicFixedString<uiDataSize> CBasicFixedString<uiDataSize)",
    "insertText": "NoPath(CBasicFixedString strDelimiters)"
  },
  {
    "label": "MakePlatformCompliantPath()",
    "kind": "Method",
    "detail": "Function (pCurrent = m_aData ; break ; } } - - pCurrent ; } return strReturn ; } template<size_t uiDataSize> CBasicFixedString<uiDataSize> CBasicFixedString<uiDataSize)",
    "insertText": "MakePlatformCompliantPath(void)"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (CBasicFixedString strCompliantPath =* this ; const size_t c_siLength = strCompliantPath .)",
    "insertText": "length()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# ifdef _XBOX)",
    "insertText": "for(size_t i = 0; i < c_siLength; ++i) if (strCompliantPath[i] == '/')"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "for(size_t i = 0; i < c_siLength; ++i) if (strCompliantPath[i] == '\\\\')"
  }
]