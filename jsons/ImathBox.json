[
  {
    "label": "V",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "V"
  },
  {
    "label": "IMATH_EXPORT_TEMPLATE_TYPE",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IMATH_EXPORT_TEMPLATE_TYPE"
  },
  {
    "label": "Box",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Box"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "Box()",
    "kind": "Method",
    "detail": "Function (# ifndef INCLUDED_IMATHBOX_H # define INCLUDED_IMATHBOX_H # include \" ImathExport . h \" # include \" ImathNamespace . h \" # include \" ImathVec . h \" IMATH_INTERNAL_NAMESPACE_HEADER_ENTER template<class V> class IMATH_EXPORT_TEMPLATE_TYPE Box { public : V min ; V max ; IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Box()"
  },
  {
    "label": "Box()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Box(const V& point)"
  },
  {
    "label": "Box()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Box(const V& minV, const V& maxV)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE bool)",
    "insertText": "operator(const Box<V>& src)"
  },
  {
    "label": "makeEmpty()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "makeEmpty()"
  },
  {
    "label": "extendBy()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "extendBy(const V& point)"
  },
  {
    "label": "extendBy()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "extendBy(const Box<V>& box)"
  },
  {
    "label": "makeInfinite()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "makeInfinite()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 V)",
    "insertText": "size()"
  },
  {
    "label": "center()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE V)",
    "insertText": "center()"
  },
  {
    "label": "intersects()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "intersects(const V& point)"
  },
  {
    "label": "intersects()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "intersects(const Box<V>& box)"
  },
  {
    "label": "majorAxis()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 unsigned int)",
    "insertText": "majorAxis()"
  },
  {
    "label": "isEmpty()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "isEmpty()"
  },
  {
    "label": "hasVolume()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "hasVolume()"
  },
  {
    "label": "isInfinite()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "isInfinite()"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (min =)",
    "insertText": "V(V::baseTypeMax())"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (max =)",
    "insertText": "V(V::baseTypeLowest())"
  },
  {
    "label": "Box()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Box(const Vec2<T>& point)"
  },
  {
    "label": "Box()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Box(const Vec2<T>& minT, const Vec2<T>& maxT)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE bool)",
    "insertText": "operator(const Box<Vec2<T>>& src)"
  },
  {
    "label": "extendBy()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "extendBy(const Vec2<T>& point)"
  },
  {
    "label": "extendBy()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "extendBy(const Box<Vec2<T>>& box)"
  },
  {
    "label": "intersects()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "intersects(const Vec2<T>& point)"
  },
  {
    "label": "intersects()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "intersects(const Box<Vec2<T>>& box)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (min = Vec2<)",
    "insertText": "T(Vec2<T>::baseTypeMax())"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (max = Vec2<)",
    "insertText": "T(Vec2<T>::baseTypeLowest())"
  },
  {
    "label": "Box()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Box(const Vec3<T>& point)"
  },
  {
    "label": "Box()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Box(const Vec3<T>& minT, const Vec3<T>& maxT)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE bool)",
    "insertText": "operator(const Box<Vec3<T>>& src)"
  },
  {
    "label": "extendBy()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "extendBy(const Vec3<T>& point)"
  },
  {
    "label": "extendBy()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "extendBy(const Box<Vec3<T>>& box)"
  },
  {
    "label": "intersects()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "intersects(const Vec3<T>& point)"
  },
  {
    "label": "intersects()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "intersects(const Box<Vec3<T>>& box)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (min = Vec3<)",
    "insertText": "T(Vec3<T>::baseTypeMax())"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (max = Vec3<)",
    "insertText": "T(Vec3<T>::baseTypeLowest())"
  }
]