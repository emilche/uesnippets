[
  {
    "label": "BDCSVD",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BDCSVD"
  },
  {
    "label": "traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "traits"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_BDCSVD_H # define EIGEN_BDCSVD_H # ifdef EIGEN_BDCSVD_SANITY_CHECKS # undef eigen_internal_assert # define)",
    "insertText": "eigen_internal_assert(X) assert(X)"
  },
  {
    "label": "bdcsvdfmt()",
    "kind": "Method",
    "detail": "Function (# endif namespace Eigen { # ifdef EIGEN_BDCSVD_DEBUG_VERBOSE IOFormat)",
    "insertText": "bdcsvdfmt(8, 0, \", \", \"\\n\", \" [\", \"]\")"
  },
  {
    "label": "EIGEN_SIZE_MIN_PREFER_DYNAMIC()",
    "kind": "Method",
    "detail": "Function (# endif template<_MatrixType> class BDCSVD ; namespace internal { template<_MatrixType> struct traits<BDCSVD<_MatrixType>> : traits<_MatrixType> { typedef _MatrixType MatrixType ; } ; } template<_MatrixType> class BDCSVD : public SVDBase<BDCSVD<_MatrixType>> { typedef SVDBase<BDCSVD> Base ; public : using Base::rows ; using Base::cols ; using Base::computeU ; using Base::computeV ; typedef _MatrixType MatrixType ; typedef MatrixType::Scalar Scalar ; typedef NumTraits<MatrixType::Scalar>::Real RealScalar ; typedef NumTraits<RealScalar>::Literal Literal ; enum { RowsAtCompileTime = MatrixType::RowsAtCompileTime,ColsAtCompileTime = MatrixType::ColsAtCompileTime,DiagSizeAtCompileTime =)",
    "insertText": "EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime, ColsAtCompileTime), MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime, MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime, MaxDiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(MaxRowsAtCompileTime, MaxColsAtCompileTime)"
  },
  {
    "label": "BDCSVD()",
    "kind": "Method",
    "detail": "Function (typedef Base::MatrixUType MatrixUType ; typedef Base::MatrixVType MatrixVType ; typedef Base::SingularValuesType SingularValuesType ; typedef Matrix<Scalar,Dynamic,Dynamic,ColMajor> MatrixX ; typedef Matrix<RealScalar,Dynamic,Dynamic,ColMajor> MatrixXr ; typedef Matrix<RealScalar,Dynamic,1> VectorType ; typedef Array<RealScalar,Dynamic,1> ArrayXr ; typedef Array<Index,1,Dynamic> ArrayXi ; typedef Ref<ArrayXr> ArrayRef ; typedef Ref<ArrayXi> IndicesRef ;)",
    "insertText": "BDCSVD() : m_algoswap(16), m_isTranspose(false), m_compU(false), m_compV(false), m_numIters(0)"
  },
  {
    "label": "BDCSVD()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "BDCSVD(Index rows, Index cols, unsigned int computationOptions = 0) : m_algoswap(16), m_numIters(0)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "allocate(rows, cols, computationOptions)"
  },
  {
    "label": "BDCSVD()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "BDCSVD(const MatrixType& matrix, unsigned int computationOptions = 0) : m_algoswap(16), m_numIters(0)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute(matrix, computationOptions)"
  },
  {
    "label": "BDCSVD()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "BDCSVD()"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (} BDCSVD&)",
    "insertText": "compute(const MatrixType& matrix, unsigned int computationOptions)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (BDCSVD&)",
    "insertText": "compute(const MatrixType& matrix)"
  },
  {
    "label": "setSwitchSize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setSwitchSize(int s)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(s>3 && \"BDCSVD the size of the algo switch has to be greater than 3\")"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (m_algoswap = s ; } private : void)",
    "insertText": "allocate(Index rows, Index cols, unsigned int computationOptions)"
  },
  {
    "label": "divide()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "divide(Index firstCol, Index lastCol, Index firstRowW, Index firstColW, Index shift)"
  },
  {
    "label": "computeSVDofM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeSVDofM(Index firstCol, Index n, MatrixXr& U, VectorType& singVals, MatrixXr& V)"
  },
  {
    "label": "computeSingVals()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeSingVals(const ArrayRef& col0, const ArrayRef& diag, const IndicesRef& perm, VectorType& singVals, ArrayRef shifts, ArrayRef mus)"
  },
  {
    "label": "perturbCol0()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "perturbCol0(const ArrayRef& col0, const ArrayRef& diag, const IndicesRef& perm, const VectorType& singVals, const ArrayRef& shifts, const ArrayRef& mus, ArrayRef zhat)"
  },
  {
    "label": "computeSingVecs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeSingVecs(const ArrayRef& zhat, const ArrayRef& diag, const IndicesRef& perm, const VectorType& singVals, const ArrayRef& shifts, const ArrayRef& mus, MatrixXr& U, MatrixXr& V)"
  },
  {
    "label": "deflation43()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deflation43(Index firstCol, Index shift, Index i, Index size)"
  },
  {
    "label": "deflation44()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deflation44(Index firstColu , Index firstColm, Index firstRowW, Index firstColW, Index i, Index j, Index size)"
  },
  {
    "label": "deflation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deflation(Index firstCol, Index lastCol, Index k, Index firstRowW, Index firstColW, Index shift)"
  },
  {
    "label": "copyUV()",
    "kind": "Method",
    "detail": "Function (template<HouseholderU,HouseholderV,NaiveU,NaiveV> void)",
    "insertText": "copyUV(const HouseholderU &householderU, const HouseholderV &householderV, const NaiveU &naiveU, const NaiveV &naivev)"
  },
  {
    "label": "structured_update()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "structured_update(Block<MatrixXr,Dynamic,Dynamic> A, const MatrixXr &B, Index n1)"
  },
  {
    "label": "secularEq()",
    "kind": "Method",
    "detail": "Function (RealScalar)",
    "insertText": "secularEq(RealScalar x, const ArrayRef& col0, const ArrayRef& diag, const IndicesRef &perm, const ArrayRef& diagShifted, RealScalar shift)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (protected : MatrixXr m_naiveU,m_naiveV ; MatrixXr m_computed ; Index m_nRec ; ArrayXr m_workspace ; ArrayXi m_workspaceI ; int m_algoswap ; bool m_isTranspose,m_compU,m_compV ; using Base::m_singularValues ; using Base::m_diagSize ; using Base::m_computeFullU ; using Base::m_computeFullV ; using Base::m_computeThinU ; using Base::m_computeThinV ; using Base::m_matrixU ; using Base::m_matrixV ; using Base::m_info ; using Base::m_isInitialized ; using Base::m_nonzeroSingularValues ; public : int m_numIters ; } ; template<MatrixType> void BDCSVD<MatrixType)",
    "insertText": "allocate(Eigen::Index rows, Eigen::Index cols, unsigned int computationOptions)"
  },
  {
    "label": "m_isTranspose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_isTranspose(cols > rows)"
  },
  {
    "label": "Zero()",
    "kind": "Method",
    "detail": "Function (m_computed =)",
    "insertText": "Zero(m_diagSize + 1, m_diagSize)"
  },
  {
    "label": "computeV()",
    "kind": "Method",
    "detail": "Function (m_compU =)",
    "insertText": "computeV()"
  },
  {
    "label": "computeU()",
    "kind": "Method",
    "detail": "Function (m_compV =)",
    "insertText": "computeU()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_workspace .)",
    "insertText": "resize((m_diagSize+1)*(m_diagSize+1)*3)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_workspaceI .)",
    "insertText": "resize(3*m_diagSize)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_DEBUG_VERBOSE std::cout<<\" \\ n \\ n \\ n = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\ n \\ n \\ n \" ; # endif)",
    "insertText": "allocate(matrix.rows(), matrix.cols(), computationOptions)"
  },
  {
    "label": "considerZero()",
    "kind": "Method",
    "detail": "Function (using std::abs ; const RealScalar)",
    "insertText": "considerZero(std::numeric_limits<RealScalar>::min)()"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (Index n = A .)",
    "insertText": "rows()"
  },
  {
    "label": "A1()",
    "kind": "Method",
    "detail": "Function (Index n2 = n - n1 ; Map<MatrixXr>)",
    "insertText": "A1(m_workspace.data() , n1, n)"
  },
  {
    "label": "A2()",
    "kind": "Method",
    "detail": "Function (Map<MatrixXr>)",
    "insertText": "A2(m_workspace.data()+ n1*n, n2, n)"
  },
  {
    "label": "B1()",
    "kind": "Method",
    "detail": "Function (Map<MatrixXr>)",
    "insertText": "B1(m_workspace.data()+ n*n, n, n)"
  },
  {
    "label": "B2()",
    "kind": "Method",
    "detail": "Function (Map<MatrixXr>)",
    "insertText": "B2(m_workspace.data()+2*n*n, n, n)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index k1 = 0,k2 = 0 ;)",
    "insertText": "for(Index j=0; j<n; ++j)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (A1 .)",
    "insertText": "col(k1) = A.col(j).head(n1)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (B1 .)",
    "insertText": "row(k1) = B.row(j)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + k1 ; })",
    "insertText": "if((A.col(j).tail(n2).array()!=Literal(0)).any())"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (A2 .)",
    "insertText": "col(k2) = A.col(j).tail(n2)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (B2 .)",
    "insertText": "row(k2) = B.row(j)"
  },
  {
    "label": "topRows()",
    "kind": "Method",
    "detail": "Function (+ + k2 ; } } A .)",
    "insertText": "topRows(n1).noalias() = A1.leftCols(k1) * B1.topRows(k1)"
  },
  {
    "label": "bottomRows()",
    "kind": "Method",
    "detail": "Function (A .)",
    "insertText": "bottomRows(n2).noalias() = A2.leftCols(k2) * B2.topRows(k2)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (} else { Map<MatrixXr,Aligned>)",
    "insertText": "tmp(m_workspace.data(),n,n)"
  },
  {
    "label": "noalias()",
    "kind": "Method",
    "detail": "Function (tmp .)",
    "insertText": "noalias()"
  },
  {
    "label": "divide()",
    "kind": "Method",
    "detail": "Function (A = tmp ; } } template<MatrixType> void BDCSVD<MatrixType)",
    "insertText": "divide(Eigen::Index firstCol, Eigen::Index lastCol, Eigen::Index firstRowW, Eigen::Index firstColW, Eigen::Index shift)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (RealScalar alphaK ; RealScalar betaK ; RealScalar r0 ; RealScalar lambda,phi,c0,s0 ; VectorType l,f ;)",
    "insertText": "if(n < m_algoswap)"
  },
  {
    "label": "b()",
    "kind": "Method",
    "detail": "Function (JacobiSVD<MatrixXr>)",
    "insertText": "b(m_computed.block(firstCol, firstCol, n + 1, n), ComputeFullU | (m_compV ? ComputeFullV : 0))"
  },
  {
    "label": "info()",
    "kind": "Method",
    "detail": "Function (m_info = b .)",
    "insertText": "info()"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (m_naiveU .)",
    "insertText": "row(1).segment(firstCol, n + 1).real() = b.matrixU().row(n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(m_compV) m_naiveV.block(firstRowW, firstColW, n, n).real() = b.matrixV()"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (m_computed .)",
    "insertText": "block(firstCol + shift, firstCol + shift, n + 1, n).setZero()"
  },
  {
    "label": "diagonal()",
    "kind": "Method",
    "detail": "Function (m_computed .)",
    "insertText": "diagonal().segment(firstCol + shift, n) = b.singularValues().head(n)"
  },
  {
    "label": "m_computed()",
    "kind": "Method",
    "detail": "Function (betaK =)",
    "insertText": "m_computed(firstCol + k + 1, firstCol + k)"
  },
  {
    "label": "divide()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "divide(k + 1 + firstCol, lastCol, k + 1 + firstRowW, k + 1 + firstColW, shift)"
  },
  {
    "label": "divide()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "divide(firstCol, k - 1 + firstCol, firstRowW, firstColW + 1, shift + 1)"
  },
  {
    "label": "m_naiveU()",
    "kind": "Method",
    "detail": "Function (lambda =)",
    "insertText": "m_naiveU(firstCol + k, firstCol + k)"
  },
  {
    "label": "m_naiveU()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "m_naiveU(firstCol + k + 1, lastCol + 1)"
  },
  {
    "label": "m_naiveU()",
    "kind": "Method",
    "detail": "Function (} else { lambda =)",
    "insertText": "m_naiveU(1, firstCol + k)"
  },
  {
    "label": "m_naiveU()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "m_naiveU(0, lastCol + 1)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (} r0 =)",
    "insertText": "sqrt((abs(alphaK * lambda) * abs(alphaK * lambda)) + abs(betaK * phi) * abs(betaK * phi))"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (l = m_naiveU .)",
    "insertText": "row(firstCol + k).segment(firstCol, k)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (f = m_naiveU .)",
    "insertText": "row(firstCol + k + 1).segment(firstCol + k + 1, n - k - 1)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (} else { l = m_naiveU .)",
    "insertText": "row(1).segment(firstCol, k)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (f = m_naiveU .)",
    "insertText": "row(0).segment(firstCol + k + 1, n - k - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(m_compV) m_naiveV(firstRowW+k, firstColW) = Literal(1)"
  },
  {
    "label": "Literal()",
    "kind": "Method",
    "detail": "Function (c0 =)",
    "insertText": "Literal(1)"
  },
  {
    "label": "Literal()",
    "kind": "Method",
    "detail": "Function (s0 =)",
    "insertText": "Literal(0)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (} else { c0 = alphaK* lambda / r0 ; s0 = betaK* phi / r0 ; } # ifdef EIGEN_BDCSVD_SANITY_CHECKS)",
    "insertText": "assert(m_naiveU.allFinite())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(m_naiveV.allFinite())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(m_computed.allFinite())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(m_compU)"
  },
  {
    "label": "q1()",
    "kind": "Method",
    "detail": "Function (MatrixXr)",
    "insertText": "q1(m_naiveU.col(firstCol + k).segment(firstCol, k + 1))"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (m_naiveU .)",
    "insertText": "col(firstCol).segment( firstCol, k + 1) = (q1 * c0)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (m_naiveU .)",
    "insertText": "col(lastCol + 1).segment(firstCol, k + 1) = (q1 * ( - s0))"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (m_naiveU .)",
    "insertText": "col(firstCol).segment(firstCol + k + 1, n - k) = m_naiveU.col(lastCol + 1).segment(firstCol + k + 1, n - k)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (m_naiveU .)",
    "insertText": "col(lastCol + 1).segment(firstCol + k + 1, n - k)"
  },
  {
    "label": "m_naiveU()",
    "kind": "Method",
    "detail": "Function (} else { RealScalar q1 =)",
    "insertText": "m_naiveU(0, firstCol + k)"
  },
  {
    "label": "m_naiveU()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_naiveU(0, firstCol) = (q1 * c0)"
  },
  {
    "label": "m_naiveU()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_naiveU(0, lastCol + 1) = (q1 * ( - s0))"
  },
  {
    "label": "m_naiveU()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_naiveU(1, firstCol) = m_naiveU(1, lastCol + 1)"
  },
  {
    "label": "m_naiveU()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_naiveU(1, lastCol + 1)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (m_naiveU .)",
    "insertText": "row(1).segment(firstCol + 1, k).setZero()"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (m_naiveU .)",
    "insertText": "row(0).segment(firstCol + k + 1, n - k - 1).setZero()"
  },
  {
    "label": "m_computed()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "m_computed(firstCol + shift, firstCol + shift)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (m_computed .)",
    "insertText": "col(firstCol + shift).segment(firstCol + shift + 1, k) = alphaK * l.transpose().real()"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (m_computed .)",
    "insertText": "col(firstCol + shift).segment(firstCol + shift + k + 1, n - k - 1) = betaK * f.transpose().real()"
  },
  {
    "label": "tmp1()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_DEBUG_VERBOSE ArrayXr)",
    "insertText": "tmp1(m_computed.block(firstCol+shift, firstCol+shift, n, n)).jacobiSvd().singularValues()"
  },
  {
    "label": "deflation()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "deflation(firstCol, lastCol, k, firstRowW, firstColW, shift)"
  },
  {
    "label": "tmp2()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_DEBUG_VERBOSE ArrayXr)",
    "insertText": "tmp2(m_computed.block(firstCol+shift, firstCol+shift, n, n)).jacobiSvd().singularValues()"
  },
  {
    "label": "transpose()",
    "kind": "Method",
    "detail": "Function (std::cout<<\" \\ n \\ nj1 = \"<<tmp1 .)",
    "insertText": "transpose().format(bdcsvdfmt)"
  },
  {
    "label": "err()",
    "kind": "Method",
    "detail": "Function (std::cout<<\")",
    "insertText": "err((tmp1-tmp2).abs()>1e-12*tmp2.abs()).transpose()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (int count = 0 ; std::cout<<\" # \"<<+ + count<<\" \\ n \\ n \" ;)",
    "insertText": "assert((tmp1-tmp2).matrix().norm() < 1e-14*tmp2.matrix().norm())"
  },
  {
    "label": "computeSVDofM()",
    "kind": "Method",
    "detail": "Function (# endif MatrixXr UofSVD,VofSVD ; VectorType singVals ;)",
    "insertText": "computeSVDofM(firstCol + shift, n, UofSVD, singVals, VofSVD)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_SANITY_CHECKS)",
    "insertText": "assert(UofSVD.allFinite())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(VofSVD.allFinite())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(m_compU) structured_update(m_naiveU.block(firstCol, firstCol, n + 1, n + 1), UofSVD, (n+2)/2)"
  },
  {
    "label": "noalias()",
    "kind": "Method",
    "detail": "Function (tmp .)",
    "insertText": "noalias() = m_naiveU.middleCols(firstCol, n+1)"
  },
  {
    "label": "middleCols()",
    "kind": "Method",
    "detail": "Function (m_naiveU .)",
    "insertText": "middleCols(firstCol, n + 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(m_compV) structured_update(m_naiveV.block(firstRowW, firstColW, n, n), VofSVD, (n+1)/2)"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (# endif m_computed .)",
    "insertText": "block(firstCol + shift, firstCol + shift, n, n).setZero()"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (m_computed .)",
    "insertText": "block(firstCol + shift, firstCol + shift, n, n).diagonal()"
  },
  {
    "label": "computeSVDofM()",
    "kind": "Method",
    "detail": "Function (} template<MatrixType> void BDCSVD<MatrixType)",
    "insertText": "computeSVDofM(Eigen::Index firstCol, Eigen::Index n, MatrixXr& U, VectorType& singVals, MatrixXr& V)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (using std::abs ; ArrayRef col0 = m_computed .)",
    "insertText": "col(firstCol).segment(firstCol, n)"
  },
  {
    "label": "head()",
    "kind": "Method",
    "detail": "Function (m_workspace .)",
    "insertText": "head(n) = m_computed.block(firstCol, firstCol, n, n).diagonal()"
  },
  {
    "label": "head()",
    "kind": "Method",
    "detail": "Function (ArrayRef diag = m_workspace .)",
    "insertText": "head(n)"
  },
  {
    "label": "diag()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "diag(0) = Literal(0)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (singVals .)",
    "insertText": "resize(n)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (U .)",
    "insertText": "resize(n+1, n+1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_DEBUG_VERBOSE)",
    "insertText": "if(col0.hasNaN() || diag.hasNaN())"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (# endif Index actual_n = n ;)",
    "insertText": "while(actual_n>1 && diag(actual_n-1)==Literal(0))"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (- - actual_n ;)",
    "insertText": "eigen_internal_assert(col0(actual_n)==Literal(0))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} Index m = 0 ;)",
    "insertText": "for(Index k=0;k<actual_n;++k) if(abs(col0(k))>considerZero) m_workspaceI(m++)"
  },
  {
    "label": "perm()",
    "kind": "Method",
    "detail": "Function (Map<ArrayXi>)",
    "insertText": "perm(m_workspaceI.data(),m)"
  },
  {
    "label": "shifts()",
    "kind": "Method",
    "detail": "Function (Map<ArrayXr>)",
    "insertText": "shifts(m_workspace.data()+1*n, n)"
  },
  {
    "label": "mus()",
    "kind": "Method",
    "detail": "Function (Map<ArrayXr>)",
    "insertText": "mus(m_workspace.data()+2*n, n)"
  },
  {
    "label": "zhat()",
    "kind": "Method",
    "detail": "Function (Map<ArrayXr>)",
    "insertText": "zhat(m_workspace.data()+3*n, n)"
  },
  {
    "label": "transpose()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_DEBUG_VERBOSE std::cout<<\" computeSVDofM using : \\ n \" ; std::cout<<\" z : \"<<col0 .)",
    "insertText": "transpose()"
  },
  {
    "label": "computeSingVals()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "computeSingVals(col0, diag, perm, singVals, shifts, mus)"
  },
  {
    "label": "j()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_DEBUG_VERBOSE std::cout<<\")",
    "insertText": "j(m_computed.block(firstCol, firstCol, n, n)).jacobiSvd().singularValues().transpose().reverse()"
  },
  {
    "label": "head()",
    "kind": "Method",
    "detail": "Function ({ std::cout<<\" \\ n \\ n mus : \"<<mus .)",
    "insertText": "head(actual_n).transpose()"
  },
  {
    "label": "check1()",
    "kind": "Method",
    "detail": "Function (std::cout<<\")",
    "insertText": "check1(expect0) : \" << ((singVals.array()-(shifts+mus)) / singVals.array()).head(actual_n).transpose()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((((singVals.array()-(shifts+mus)) / singVals.array()).head(actual_n) >= 0).all())"
  },
  {
    "label": "check2()",
    "kind": "Method",
    "detail": "Function (std::cout<<\")",
    "insertText": "check2(>0) : \" << ((singVals.array()-diag) / singVals.array()).head(actual_n).transpose()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((((singVals.array()-diag) / singVals.array()).head(actual_n) >= 0).all())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (} # endif # ifdef EIGEN_BDCSVD_SANITY_CHECKS)",
    "insertText": "assert(singVals.allFinite())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(mus.allFinite())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(shifts.allFinite())"
  },
  {
    "label": "perturbCol0()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "perturbCol0(col0, diag, perm, singVals, shifts, mus, zhat)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (# endif # ifdef EIGEN_BDCSVD_SANITY_CHECKS)",
    "insertText": "assert(zhat.allFinite())"
  },
  {
    "label": "computeSingVecs()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "computeSingVecs(zhat, diag, perm, singVals, shifts, mus, U, V)"
  },
  {
    "label": "U()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_DEBUG_VERBOSE std::cout<<\" U ^ T)",
    "insertText": "U(U.transpose() * U - MatrixXr(MatrixXr::Identity(U.cols(),U.cols()))).norm()"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (std::cout<<\" V ^ T)",
    "insertText": "V(V.transpose() * V - MatrixXr(MatrixXr::Identity(V.cols(),V.cols()))).norm()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(U.allFinite())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(V.allFinite())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "for(Index i=0; i<actual_n-1; ++i)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (using std::swap ;)",
    "insertText": "swap(singVals(i),singVals(i+1))"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (U .)",
    "insertText": "col(i).swap(U.col(i+1))"
  },
  {
    "label": "singular_values_sorted()",
    "kind": "Method",
    "detail": "Function (} } # ifdef EIGEN_BDCSVD_SANITY_CHECKS { bool)",
    "insertText": "singular_values_sorted(((singVals.segment(1,actual_n-1)-singVals.head(actual_n-1))).array() >= 0).all()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(singular_values_sorted)"
  },
  {
    "label": "head()",
    "kind": "Method",
    "detail": "Function (} # endif singVals .)",
    "insertText": "head(actual_n).reverseInPlace()"
  },
  {
    "label": "leftCols()",
    "kind": "Method",
    "detail": "Function (U .)",
    "insertText": "leftCols(actual_n).rowwise().reverseInPlace()"
  },
  {
    "label": "jsvd()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_DEBUG_VERBOSE JacobiSVD<MatrixXr>)",
    "insertText": "jsvd(m_computed.block(firstCol, firstCol, n, n))"
  },
  {
    "label": "singularValues()",
    "kind": "Method",
    "detail": "Function (std::cout<<\"* j : \"<<jsvd .)",
    "insertText": "singularValues().transpose()"
  },
  {
    "label": "secularEq()",
    "kind": "Method",
    "detail": "Function (# endif } template<MatrixType> BDCSVD<MatrixType>::RealScalar BDCSVD<MatrixType)",
    "insertText": "secularEq(RealScalar mu, const ArrayRef& col0, const ArrayRef& diag, const IndicesRef &perm, const ArrayRef& diagShifted, RealScalar shift)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (Index m = perm .)",
    "insertText": "size()"
  },
  {
    "label": "perm()",
    "kind": "Method",
    "detail": "Function (Index j =)",
    "insertText": "perm(i)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "res(col0(j) / (diagShifted(j) - mu)) * (col0(j) / (diag(j) + shift + mu))"
  },
  {
    "label": "computeSingVals()",
    "kind": "Method",
    "detail": "Function (} return res ; } template<MatrixType> void BDCSVD<MatrixType)",
    "insertText": "computeSingVals(const ArrayRef& col0, const ArrayRef& diag, const IndicesRef &perm, VectorType& singVals, ArrayRef shifts, ArrayRef mus)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (Index actual_n = n ;)",
    "insertText": "while(actual_n>1 && col0(actual_n-1)==Literal(0))"
  },
  {
    "label": "singVals()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "singVals(k) = k==0 ? col0(0) : diag(k)"
  },
  {
    "label": "mus()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mus(k) = Literal(0)"
  },
  {
    "label": "shifts()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "shifts(k) = k==0 ? col0(0) : diag(k)"
  },
  {
    "label": "diag()",
    "kind": "Method",
    "detail": "Function (continue ; } RealScalar left =)",
    "insertText": "diag(k)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (RealScalar right ;)",
    "insertText": "if(k==actual_n-1) right = (diag(actual_n-1) + col0.matrix().norm())"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (+ + l ;)",
    "insertText": "eigen_internal_assert(l<actual_n)"
  },
  {
    "label": "diag()",
    "kind": "Method",
    "detail": "Function (} right =)",
    "insertText": "diag(l)"
  },
  {
    "label": "left()",
    "kind": "Method",
    "detail": "Function (} RealScalar mid =)",
    "insertText": "left(right-left) / Literal(2)"
  },
  {
    "label": "secularEq()",
    "kind": "Method",
    "detail": "Function (RealScalar fMid =)",
    "insertText": "secularEq(mid, col0, diag, perm, diag, Literal(0))"
  },
  {
    "label": "secularEq()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_DEBUG_VERBOSE std::cout<<\" right - left = \"<<right - left<<\" \\ n \" ; std::cout<<\" = \"<<)",
    "insertText": "secularEq(left+RealScalar(0.000001)*(right-left), col0, diag, perm, diag, 0) << \" \" << secularEq(left+RealScalar(0.1) *(right-left), col0, diag, perm, diag, 0) << \" \" << secularEq(left+RealScalar(0.2) *(right-left), col0, diag, perm, diag, 0) << \" \" << secularEq(left+RealScalar(0.3) *(right-left), col0, diag, perm, diag, 0) << \" \" << secularEq(left+RealScalar(0.4) *(right-left), col0, diag, perm, diag, 0) << \" \" << secularEq(left+RealScalar(0.49) *(right-left), col0, diag, perm, diag, 0) << \" \" << secularEq(left+RealScalar(0.5) *(right-left), col0, diag, perm, diag, 0) << \" \" << secularEq(left+RealScalar(0.51) *(right-left), col0, diag, perm, diag, 0) << \" \" << secularEq(left+RealScalar(0.6) *(right-left), col0, diag, perm, diag, 0) << \" \" << secularEq(left+RealScalar(0.7) *(right-left), col0, diag, perm, diag, 0) << \" \" << secularEq(left+RealScalar(0.8) *(right-left), col0, diag, perm, diag, 0) << \" \" << secularEq(left+RealScalar(0.9) *(right-left), col0, diag, perm, diag, 0) << \" \" << secularEq(left+RealScalar(0.999999)*(right-left), col0, diag, perm, diag, 0)"
  },
  {
    "label": "shift()",
    "kind": "Method",
    "detail": "Function (# endif RealScalar)",
    "insertText": "shift(k == actual_n-1 || fMid > Literal(0))"
  },
  {
    "label": "diagShifted()",
    "kind": "Method",
    "detail": "Function (Map<ArrayXr>)",
    "insertText": "diagShifted(m_workspace.data()+4*n, n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (diagShifted = diag - shift ;)",
    "insertText": "if(k!=actual_n-1)"
  },
  {
    "label": "midShifted()",
    "kind": "Method",
    "detail": "Function (RealScalar)",
    "insertText": "midShifted(right - left) / RealScalar(2)"
  },
  {
    "label": "secularEq()",
    "kind": "Method",
    "detail": "Function (RealScalar fMidShifted =)",
    "insertText": "secularEq(midShifted, col0, diag, perm, diagShifted, shift)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (diagShifted = diag - shift ; } } RealScalar muPrev,muCur ;)",
    "insertText": "if(shift == left)"
  },
  {
    "label": "muPrev()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "muPrev(right - left) * RealScalar(0.1)"
  },
  {
    "label": "muCur()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "muCur(right - left) * RealScalar(0.5)"
  },
  {
    "label": "secularEq()",
    "kind": "Method",
    "detail": "Function (} RealScalar fPrev =)",
    "insertText": "secularEq(muPrev, col0, diag, perm, diagShifted, shift)"
  },
  {
    "label": "secularEq()",
    "kind": "Method",
    "detail": "Function (RealScalar fCur =)",
    "insertText": "secularEq(muCur, col0, diag, perm, diagShifted, shift)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(fPrev, fCur)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(muPrev, muCur)"
  },
  {
    "label": "a()",
    "kind": "Method",
    "detail": "Function (+ + m_numIters ; RealScalar)",
    "insertText": "a(fCur - fPrev) / (Literal(1)/muCur - Literal(1)/muPrev)"
  },
  {
    "label": "secularEq()",
    "kind": "Method",
    "detail": "Function (RealScalar b = fCur - a / muCur ; RealScalar muZero = - a / b ; RealScalar fZero =)",
    "insertText": "secularEq(muZero, col0, diag, perm, diagShifted, shift)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_SANITY_CHECKS)",
    "insertText": "assert((numext::isfinite)(fZero))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif muPrev = muCur ; fPrev = fCur ; muCur = muZero ; fCur = fZero ;)",
    "insertText": "if(shift == left && (muCur < Literal(0) || muCur > right - left))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(useBisection)"
  },
  {
    "label": "RealScalar()",
    "kind": "Method",
    "detail": "Function (leftShifted = numext::maxi<)",
    "insertText": "RealScalar((std::numeric_limits<RealScalar>::min)(), Literal(2) * abs(col0(k)) / sqrt((std::numeric_limits<RealScalar>::max)()))"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert((numext::isfinite)( (col0(k)/leftShifted)*(col0(k)/(diag(k)+shift+leftShifted)) ))"
  },
  {
    "label": "rightShifted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rightShifted(k==actual_n-1) ? right : ((right - left) * RealScalar(0.51))"
  },
  {
    "label": "leftShifted()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "leftShifted(right - left) * RealScalar(0.51)"
  },
  {
    "label": "secularEq()",
    "kind": "Method",
    "detail": "Function (} RealScalar fLeft =)",
    "insertText": "secularEq(leftShifted, col0, diag, perm, diagShifted, shift)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(fLeft<Literal(0))"
  },
  {
    "label": "secularEq()",
    "kind": "Method",
    "detail": "Function (# if defined EIGEN_INTERNAL_DEBUGGING | | defined EIGEN_BDCSVD_SANITY_CHECKS RealScalar fRight =)",
    "insertText": "secularEq(rightShifted, col0, diag, perm, diagShifted, shift)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif # ifdef EIGEN_BDCSVD_SANITY_CHECKS)",
    "insertText": "if(!(numext::isfinite)(fLeft)) std::cout << \"f(\" << leftShifted << \")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (\"<<left<<\" \"<<shift<<\" \"<<right<<\" \\ n \" ;)",
    "insertText": "assert((numext::isfinite)(fLeft))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\"<<left<<\" \"<<shift<<\" \"<<right<<\" \\ n \" ; # endif # ifdef EIGEN_BDCSVD_DEBUG_VERBOSE)",
    "insertText": "if(!(fLeft * fRight<0))"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (std::cout<<\")",
    "insertText": "f(leftShifted)"
  },
  {
    "label": "diagShifted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "diagShifted(1:10):\" << diagShifted.head(10).transpose()"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (\"<<\" left = = shift = \"<<)",
    "insertText": "bool(left==shift)"
  },
  {
    "label": "shift()",
    "kind": "Method",
    "detail": "Function (left -)",
    "insertText": "shift(left-shift)"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (std::cout<<\" k = \"<<k<<\",\"<<fLeft<<\"* \"<<fRight<<\" = = \"<<fLeft* fRight<<\" ; \"<<\" [ \"<<left<<\" . . \"<<right<<\" ] -> [ \"<<leftShifted<<\" \"<<rightShifted<<\" ],shift = \"<<shift<<\",)",
    "insertText": "f(right)=\" << secularEq(0, col0, diag, perm, diagShifted, shift) << \" == \" << secularEq(right, col0, diag, perm, diag, 0)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (} # endif)",
    "insertText": "eigen_internal_assert(fLeft * fRight < Literal(0))"
  },
  {
    "label": "midShifted()",
    "kind": "Method",
    "detail": "Function (RealScalar)",
    "insertText": "midShifted(leftShifted + rightShifted) / Literal(2)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert((numext::isfinite)(fMid))"
  },
  {
    "label": "muCur()",
    "kind": "Method",
    "detail": "Function (rightShifted = midShifted ; } else { leftShifted = midShifted ; fLeft = fMid ; } })",
    "insertText": "muCur(leftShifted + rightShifted) / Literal(2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } singVals [ k ] = shift + muCur ; shifts [ k ] = shift ; mus [ k ] = muCur ; # ifdef EIGEN_BDCSVD_DEBUG_VERBOSE)",
    "insertText": "if(k+1<n) std::cout << \"found \" << singVals[k] << \" == \" << shift << \" + \" << muCur << \" from \" << diag(k) << \" .. \" << diag(k+1)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (# endif # ifdef EIGEN_BDCSVD_SANITY_CHECKS)",
    "insertText": "assert(k==0 || singVals[k]>=singVals[k-1])"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(singVals[k]>=diag(k))"
  },
  {
    "label": "perturbCol0()",
    "kind": "Method",
    "detail": "Function (# endif } } template<MatrixType> void BDCSVD<MatrixType)",
    "insertText": "perturbCol0(const ArrayRef& col0, const ArrayRef& diag, const IndicesRef &perm, const VectorType& singVals, const ArrayRef& shifts, const ArrayRef& mus, ArrayRef zhat)"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (zhat .)",
    "insertText": "setZero()"
  },
  {
    "label": "prod()",
    "kind": "Method",
    "detail": "Function (RealScalar)",
    "insertText": "prod(singVals(lastIdx) + dk) * (mus(lastIdx) + (shifts(lastIdx) - dk))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_SANITY_CHECKS)",
    "insertText": "if(prod<0)"
  },
  {
    "label": "z()",
    "kind": "Method",
    "detail": "Function (std::cout<<\" k = \"<<k<<\" ;)",
    "insertText": "z(k)=\" << col0(k) << \", diag(k)"
  },
  {
    "label": "prod()",
    "kind": "Method",
    "detail": "Function (std::cout<<\")",
    "insertText": "prod(\" << singVals(lastIdx) << \" + \" << dk << \") * (\" << mus(lastIdx) << \" + (\" << shifts(lastIdx) << \" - \" << dk << \"))"
  },
  {
    "label": "singVals()",
    "kind": "Method",
    "detail": "Function (std::cout<<\" = \"<<)",
    "insertText": "singVals(lastIdx) + dk << \" * \" << mus(lastIdx) + (shifts(lastIdx) - dk)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "assert(prod>=0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "for(Index l = 0; l<m; ++l)"
  },
  {
    "label": "perm()",
    "kind": "Method",
    "detail": "Function (Index i =)",
    "insertText": "perm(l)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_SANITY_CHECKS)",
    "insertText": "if(i>=k && (l==0 || l-1>=m))"
  },
  {
    "label": "col0()",
    "kind": "Method",
    "detail": "Function (std::cout<<\" Error in perturbCol0 \\ n \" ; std::cout<<\" \"<<k<<\" / \"<<n<<\" \"<<l<<\" / \"<<m<<\" \"<<i<<\" / \"<<n<<\" ; \"<<)",
    "insertText": "col0(k) << \" \" << diag(k)"
  },
  {
    "label": "diag()",
    "kind": "Method",
    "detail": "Function (std::cout<<\" \"<<)",
    "insertText": "diag(i)"
  },
  {
    "label": "j()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "j(i<k ) ? i : perm(l-1)"
  },
  {
    "label": "perm()",
    "kind": "Method",
    "detail": "Function (std::cout<<\" \"<<\" j = \"<<j<<\" \\ n \" ; } # endif Index j = i<k ? i :)",
    "insertText": "perm(l-1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_SANITY_CHECKS)",
    "insertText": "if(!(dk!=Literal(0) || diag(i)!=Literal(0)))"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (std::cout<<\" k = \"<<k<<\",i = \"<<i<<\",l = \"<<l<<\",perm .)",
    "insertText": "size()=\" << perm.size()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "assert(dk!=Literal(0) || diag(i)!=Literal(0))"
  },
  {
    "label": "prod()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "prod((singVals(j)+dk) / ((diag(i)+dk))) * ((mus(j)+(shifts(j)-dk)) / ((diag(i)-dk)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif # ifdef EIGEN_BDCSVD_DEBUG_VERBOSE)",
    "insertText": "if(i!=k && numext::abs(((singVals(j)+dk)*(mus(j)+(shifts(j)-dk)))/((diag(i)+dk)*(diag(i)-dk)) - 1) > 0.9 ) std::cout << \" \" << ((singVals(j)+dk)*(mus(j)+(shifts(j)-dk)))/((diag(i)+dk)*(diag(i)-dk)) << \" == (\" << (singVals(j)+dk) << \" * \" << (mus(j)+(shifts(j)-dk)) << \") / (\" << (diag(i)+dk) << \" * \" << (diag(i)-dk) << \")"
  },
  {
    "label": "zhat()",
    "kind": "Method",
    "detail": "Function (# endif } } # ifdef EIGEN_BDCSVD_DEBUG_VERBOSE std::cout<<\")",
    "insertText": "zhat(\" << k << \") = sqrt( \" << prod << \")"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (# endif RealScalar tmp =)",
    "insertText": "sqrt(prod)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_SANITY_CHECKS)",
    "insertText": "assert((numext::isfinite)(tmp))"
  },
  {
    "label": "zhat()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "zhat(k) = col0(k) > Literal(0) ? RealScalar(tmp) : RealScalar(-tmp)"
  },
  {
    "label": "computeSingVecs()",
    "kind": "Method",
    "detail": "Function (} } } template<MatrixType> void BDCSVD<MatrixType)",
    "insertText": "computeSingVecs(const ArrayRef& zhat, const ArrayRef& diag, const IndicesRef &perm, const VectorType& singVals, const ArrayRef& shifts, const ArrayRef& mus, MatrixXr& U, MatrixXr& V)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (U .)",
    "insertText": "col(k) = VectorType::Unit(n+1, k)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (} else { U .)",
    "insertText": "col(k).setZero()"
  },
  {
    "label": "U()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "U(i,k) = zhat(i)/(((diag(i) - shifts(k)) - mus(k)) )/( (diag(i) + singVals[k]))"
  },
  {
    "label": "U()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "U(n,k) = Literal(0)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (U .)",
    "insertText": "col(k).normalize()"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "V(i,k) = diag(i) * zhat(i) / (((diag(i) - shifts(k)) - mus(k)) )/( (diag(i) + singVals[k]))"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "V(0,k) = Literal(-1)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (} } } U .)",
    "insertText": "col(n) = VectorType::Unit(n+1, n)"
  },
  {
    "label": "deflation43()",
    "kind": "Method",
    "detail": "Function (} template<MatrixType> void BDCSVD<MatrixType)",
    "insertText": "deflation43(Eigen::Index firstCol, Eigen::Index shift, Eigen::Index i, Eigen::Index size)"
  },
  {
    "label": "m_computed()",
    "kind": "Method",
    "detail": "Function (using std::abs ; using std::sqrt ; using std::pow ; Index start = firstCol + shift ; RealScalar c =)",
    "insertText": "m_computed(start, start)"
  },
  {
    "label": "m_computed()",
    "kind": "Method",
    "detail": "Function (RealScalar s =)",
    "insertText": "m_computed(start+i, start)"
  },
  {
    "label": "hypot()",
    "kind": "Method",
    "detail": "Function (RealScalar r =)",
    "insertText": "hypot(c,s)"
  },
  {
    "label": "m_computed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_computed(start+i, start+i) = Literal(0)"
  },
  {
    "label": "m_computed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_computed(start+i, start) = Literal(0)"
  },
  {
    "label": "J()",
    "kind": "Method",
    "detail": "Function (JacobiRotation<RealScalar>)",
    "insertText": "J(c/r,-s/r)"
  },
  {
    "label": "deflation44()",
    "kind": "Method",
    "detail": "Function (} template<MatrixType> void BDCSVD<MatrixType)",
    "insertText": "deflation44(Eigen::Index firstColu , Eigen::Index firstColm, Eigen::Index firstRowW, Eigen::Index firstColW, Eigen::Index i, Eigen::Index j, Eigen::Index size)"
  },
  {
    "label": "m_computed()",
    "kind": "Method",
    "detail": "Function (using std::abs ; using std::sqrt ; using std::conj ; using std::pow ; RealScalar c =)",
    "insertText": "m_computed(firstColm+i, firstColm)"
  },
  {
    "label": "m_computed()",
    "kind": "Method",
    "detail": "Function (RealScalar s =)",
    "insertText": "m_computed(firstColm+j, firstColm)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (RealScalar r =)",
    "insertText": "sqrt(numext::abs2(c) + numext::abs2(s))"
  },
  {
    "label": "m_computed()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_DEBUG_VERBOSE std::cout<<\" deflation 4 . 4 : \"<<i<<\",\"<<j<<\" -> \"<<c<<\" \"<<s<<\" \"<<r<<\" ; \"<<)",
    "insertText": "m_computed(firstColm + i-1, firstColm) << \" \" << m_computed(firstColm + i, firstColm) << \" \" << m_computed(firstColm + i+1, firstColm) << \" \" << m_computed(firstColm + i+2, firstColm)"
  },
  {
    "label": "m_computed()",
    "kind": "Method",
    "detail": "Function (std::cout<<)",
    "insertText": "m_computed(firstColm + i-1, firstColm + i-1) << \" \" << m_computed(firstColm + i, firstColm+i) << \" \" << m_computed(firstColm + i+1, firstColm+i+1) << \" \" << m_computed(firstColm + i+2, firstColm+i+2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(r==Literal(0))"
  },
  {
    "label": "m_computed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_computed(firstColm + i, firstColm + i) = m_computed(firstColm + j, firstColm + j)"
  },
  {
    "label": "m_computed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_computed(firstColm + j, firstColm + j) = m_computed(firstColm + i, firstColm + i)"
  },
  {
    "label": "m_computed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_computed(firstColm + j, firstColm) = Literal(0)"
  },
  {
    "label": "J()",
    "kind": "Method",
    "detail": "Function (JacobiRotation<RealScalar>)",
    "insertText": "J(c,-s)"
  },
  {
    "label": "deflation()",
    "kind": "Method",
    "detail": "Function (} template<MatrixType> void BDCSVD<MatrixType)",
    "insertText": "deflation(Eigen::Index firstCol, Eigen::Index lastCol, Eigen::Index k, Eigen::Index firstRowW, Eigen::Index firstColW, Eigen::Index shift)"
  },
  {
    "label": "col0()",
    "kind": "Method",
    "detail": "Function (using std::sqrt ; using std::abs ; const Index length = lastCol + 1 - firstCol ; Block<MatrixXr,Dynamic,1>)",
    "insertText": "col0(m_computed, firstCol+shift, firstCol+shift, length, 1)"
  },
  {
    "label": "fulldiag()",
    "kind": "Method",
    "detail": "Function (Diagonal<MatrixXr>)",
    "insertText": "fulldiag(m_computed)"
  },
  {
    "label": "diag()",
    "kind": "Method",
    "detail": "Function (VectorBlock<Diagonal<MatrixXr>,Dynamic>)",
    "insertText": "diag(fulldiag, firstCol+shift, length)"
  },
  {
    "label": "tail()",
    "kind": "Method",
    "detail": "Function (RealScalar maxDiag = diag .)",
    "insertText": "tail((std::max)(Index(1),length-1)).cwiseAbs().maxCoeff()"
  },
  {
    "label": "RealScalar()",
    "kind": "Method",
    "detail": "Function (RealScalar epsilon_strict = numext::maxi<)",
    "insertText": "RealScalar(considerZero,NumTraits<RealScalar>::epsilon() * maxDiag)"
  },
  {
    "label": "Literal()",
    "kind": "Method",
    "detail": "Function (RealScalar epsilon_coarse =)",
    "insertText": "Literal(8) * NumTraits<RealScalar>::epsilon() * numext::maxi<RealScalar>(col0.cwiseAbs().maxCoeff(), maxDiag)"
  },
  {
    "label": "head()",
    "kind": "Method",
    "detail": "Function (# endif # ifdef EIGEN_BDCSVD_DEBUG_VERBOSE std::cout<<\" \\ ndeflate : \"<<diag .)",
    "insertText": "head(k+1).transpose() << \" | \" << diag.segment(k+1,length-k-1).transpose()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(diag(0) < epsilon_coarse)"
  },
  {
    "label": "diag()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_DEBUG_VERBOSE std::cout<<\" deflation 4 . 1,because \"<<)",
    "insertText": "diag(0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(Index i=1;i<length;++i) if (abs(col0(i)) < epsilon_strict)"
  },
  {
    "label": "z()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_DEBUG_VERBOSE std::cout<<\" deflation 4 . 2,set)",
    "insertText": "z(\" << i << \") to zero because \" << abs(col0(i)) << \" < \" << epsilon_strict << \" (diag(\" << i << \")=\" << diag(i) << \")"
  },
  {
    "label": "col0()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "col0(i) = Literal(0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(Index i=1;i<length; i++) if (diag(i) < epsilon_coarse)"
  },
  {
    "label": "z()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_DEBUG_VERBOSE std::cout<<\" deflation 4 . 3,cancel)",
    "insertText": "z(\" << i << \")=\" << col0(i) << \" because diag(\" << i << \")=\" << diag(i)"
  },
  {
    "label": "deflation43()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "deflation43(firstCol, shift, i, length)"
  },
  {
    "label": "total_deflation()",
    "kind": "Method",
    "detail": "Function (# endif { bool)",
    "insertText": "total_deflation(col0.tail(length-1).array()<considerZero).all()"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (Index* permutation = m_workspaceI .)",
    "insertText": "data()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function ({ permutation [ 0 ] = 0 ; Index p = 1 ;)",
    "insertText": "for(Index i=1; i<length; ++i) if(abs(diag(i))<considerZero)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index i = 1,j = k + 1 ;)",
    "insertText": "for(; p < length; ++p)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index pi = permutation [ i ] ;)",
    "insertText": "if(abs(diag(pi))<considerZero || diag(0)<diag(pi))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (realCol [ pos ] = pos ; realInd [ pos ] = pos ; })",
    "insertText": "for(Index i = total_deflation?0:1; i < length; i++)"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (const Index pi = permutation [)",
    "insertText": "length(total_deflation ? i+1 : i)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (const Index J = realCol [ pi ] ; using std::swap ;)",
    "insertText": "swap(diag(i), diag(J))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (# endif { Index i = length - 1 ;)",
    "insertText": "while(i>0 && (abs(diag(i))<considerZero || abs(col0(i))<considerZero))"
  },
  {
    "label": "diag()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_BDCSVD_DEBUG_VERBOSE std::cout<<\" deflation 4 . 4 with i = \"<<i<<\" because \"<<)",
    "insertText": "diag(i) << \" - \" << diag(i-1) << \" == \" << (diag(i) - diag(i-1)) << \" < \" << NumTraits<RealScalar>::epsilon()"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "eigen_internal_assert(abs(diag(i) - diag(i-1))<epsilon_coarse && \" diagonal entries are not properly sorted\")"
  },
  {
    "label": "deflation44()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deflation44(firstCol, firstCol + shift, firstRowW, firstColW, i-1, i, length)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } # ifdef EIGEN_BDCSVD_SANITY_CHECKS)",
    "insertText": "for(Index j=2;j<length;++j) assert(diag(j-1)<=diag(j) || abs(diag(j))<considerZero)"
  },
  {
    "label": "bdcSvd()",
    "kind": "Method",
    "detail": "Function (# endif } template<Derived> BDCSVD<MatrixBase<Derived>::PlainObject> MatrixBase<Derived)",
    "insertText": "bdcSvd(unsigned int computationOptions)"
  }
]