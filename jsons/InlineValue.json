[
  {
    "label": "TInlineValue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TInlineValue"
  },
  {
    "label": "TInlineValue()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Misc / AssertionMacros . h \" # include \" HAL / UnrealMemory . h \" # include \" Templates / MemoryOps . h \" # include \" Templates / PointerIsConvertibleFromTo . h \" # include \" Templates / Decay . h \" # include \" Templates / TypeCompatibleBytes . h \" # include \" Templates / UnrealTemplate . h \" template<BaseType,uint16 DesiredMaxInlineSize = 6 4,uint8 DefaultAlignment = 8> class TInlineValue { public :)",
    "insertText": "TInlineValue() : bIsValid(false), bInline(true)"
  },
  {
    "label": "TInlineValue()",
    "kind": "Method",
    "detail": "Function (} template<T,= TEnableIf<TPointerIsConvertibleFromTo<TDecay<T>::Type,BaseType>::Value>::Type>)",
    "insertText": "TInlineValue(T&& In) : bIsValid(false)"
  },
  {
    "label": "Type()",
    "kind": "Method",
    "detail": "Function (InitializeFrom<TDecay<T)",
    "insertText": "Type(Forward<T>(In))"
  },
  {
    "label": "TInlineValue()",
    "kind": "Method",
    "detail": "Function (} template<. . . ArgTypes>)",
    "insertText": "TInlineValue(EInPlace, ArgTypes&&... Args) : bIsValid(false)"
  },
  {
    "label": "BaseType()",
    "kind": "Method",
    "detail": "Function (InitializeFrom<)",
    "insertText": "BaseType(Forward<ArgTypes>(Args)...)"
  },
  {
    "label": "TInlineValue()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TInlineValue()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "TInlineValue()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TInlineValue(TInlineValue&& In) : bIsValid(false), bInline(true)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "MoveTemp(In)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TInlineValue&)",
    "insertText": "operator(TInlineValue&& In)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset(MoveTemp(In))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TInlineValue&)",
    "insertText": "operator(const TInlineValue& In)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<T> TEnableIf<TPointerIsConvertibleFromTo<TDecay<T>::Type,BaseType>::Value,TInlineValue&>::Type)",
    "insertText": "operator(T&& In)"
  },
  {
    "label": "TInlineValue()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "TInlineValue(Forward<T>(In))"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (BaseType& Value =)",
    "insertText": "GetValue()"
  },
  {
    "label": "BaseType()",
    "kind": "Method",
    "detail": "Function (bIsValid = false ; Value . ~)",
    "insertText": "BaseType()"
  },
  {
    "label": "ConditionallyDestroyAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConditionallyDestroyAllocation()"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (} } template<T,. . . ArgsType> void)",
    "insertText": "Emplace(ArgsType&&... Args)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (InitializeFrom<)",
    "insertText": "T(Forward<ArgsType>(Args)...)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} const BaseType&)",
    "insertText": "Get(const BaseType& Default)"
  },
  {
    "label": "GetPtr()",
    "kind": "Method",
    "detail": "Function (} BaseType*)",
    "insertText": "GetPtr(BaseType* Default = nullptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} BaseType&)",
    "insertText": "operator()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (} void*)",
    "insertText": "Reserve(uint32 InSize, uint32 InAlignment)"
  },
  {
    "label": "ConditionallyAllocateObject()",
    "kind": "Method",
    "detail": "Function (bInline = InSize<= MaxInlineSize&& InAlignment<= DefaultAlignment ;)",
    "insertText": "ConditionallyAllocateObject(InSize, InAlignment)"
  },
  {
    "label": "InitializeFrom()",
    "kind": "Method",
    "detail": "Function (} private : template<T,. . . ArgsType> void)",
    "insertText": "InitializeFrom(ArgsType&&... Args)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (bInline =)",
    "insertText": "sizeof(T) <= MaxInlineSize && alignof(T)"
  },
  {
    "label": "ConditionallyAllocateObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConditionallyAllocateObject(sizeof(T), alignof(T))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (bIsValid = true)",
    "insertText": "new((void*)&GetValue()) T(Forward<ArgsType>(Args)...)"
  },
  {
    "label": "ConditionallyAllocateObject()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ConditionallyAllocateObject(uint32 Size, uint32 Alignment)"
  },
  {
    "label": "Allocation()",
    "kind": "Method",
    "detail": "Function (BaseType*)",
    "insertText": "Allocation(BaseType*)FMemory::Malloc(Size, Alignment)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(*((void**)&Data))"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} } private : enum { MaxInlineSize = DesiredMaxInlineSize<)",
    "insertText": "sizeof(void*) ? sizeof(void*)"
  },
  {
    "label": "MakeInlineValue()",
    "kind": "Method",
    "detail": "Function (TAlignedBytes<MaxInlineSize,DefaultAlignment> Data ; bool bIsValid : 1 ; bool bInline : 1 ; } ; template<BaseType,UserType,uint8 MaxInlineSize = 6 4,uint8 DefaultAlignment = 8,. . . ArgsType> TInlineValue<BaseType,MaxInlineSize,DefaultAlignment>)",
    "insertText": "MakeInlineValue(ArgsType... Args)"
  }
]