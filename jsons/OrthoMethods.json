[
  {
    "label": "cross3_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cross3_impl"
  },
  {
    "label": "unitOrthogonal_selector",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "unitOrthogonal_selector"
  },
  {
    "label": "cross()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_ORTHOMETHODS_H # define EIGEN_ORTHOMETHODS_H namespace Eigen { template<Derived> template<OtherDerived> # ifndef EIGEN_PARSED_BY_DOXYGEN EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE MatrixBase<Derived>::template cross_product_return_type<OtherDerived>::type # else MatrixBase<Derived>::PlainObject # endif MatrixBase<Derived)",
    "insertText": "cross(const MatrixBase<OtherDerived>& other)"
  },
  {
    "label": "EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Derived,3) EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(OtherDerived,3) typename internal::nested_eval<Derived,2>::type lhs(derived())"
  },
  {
    "label": "rhs()",
    "kind": "Method",
    "detail": "Function (internal::nested_eval<OtherDerived,2>::type)",
    "insertText": "rhs(other.derived())"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} namespace internal { template<int Arch,VectorLhs,VectorRhs,Scalar = VectorLhs::Scalar,bool Vectorizable =)",
    "insertText": "bool((VectorLhs::Flags&VectorRhs::Flags)&PacketAccessBit)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC internal::plain_matrix_type<VectorLhs>::type)",
    "insertText": "run(const VectorLhs& lhs, const VectorRhs& rhs)"
  },
  {
    "label": "cross3()",
    "kind": "Method",
    "detail": "Function (} } ; } template<Derived> template<OtherDerived> EIGEN_DEVICE_FUNC MatrixBase<Derived>::PlainObject MatrixBase<Derived)",
    "insertText": "cross3(const MatrixBase<OtherDerived>& other)"
  },
  {
    "label": "EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Derived,4) EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(OtherDerived,4)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (typedef internal::nested_eval<OtherDerived,2>::type OtherDerivedNested ; DerivedNested)",
    "insertText": "lhs(derived())"
  },
  {
    "label": "EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(OtherDerived,3) EIGEN_STATIC_ASSERT((internal::is_same<Scalar, typename OtherDerived::Scalar>::value), YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY) typename internal::nested_eval<ExpressionType,2>::type mat(_expression())"
  },
  {
    "label": "vec()",
    "kind": "Method",
    "detail": "Function (internal::nested_eval<OtherDerived,2>::type)",
    "insertText": "vec(other.derived())"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (CrossReturnType)",
    "insertText": "res(_expression().rows(),_expression().cols())"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(CrossReturnType::RowsAtCompileTime==3 && \"the matrix must have exactly 3 rows\")"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (res .)",
    "insertText": "row(0) = (mat.row(1) * vec.coeff(2) - mat.row(2) * vec.coeff(1)).conjugate()"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (res .)",
    "insertText": "row(1) = (mat.row(2) * vec.coeff(0) - mat.row(0) * vec.coeff(2)).conjugate()"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (res .)",
    "insertText": "row(2) = (mat.row(0) * vec.coeff(1) - mat.row(1) * vec.coeff(0)).conjugate()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "eigen_assert(CrossReturnType::ColsAtCompileTime==3 && \"the matrix must have exactly 3 columns\")"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (res .)",
    "insertText": "col(0) = (mat.col(1) * vec.coeff(2) - mat.col(2) * vec.coeff(1)).conjugate()"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (res .)",
    "insertText": "col(1) = (mat.col(2) * vec.coeff(0) - mat.col(0) * vec.coeff(2)).conjugate()"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (res .)",
    "insertText": "col(2) = (mat.col(0) * vec.coeff(1) - mat.col(1) * vec.coeff(0)).conjugate()"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} return res ; } namespace internal { template<Derived,int Size = Derived::SizeAtCompileTime> struct unitOrthogonal_selector { typedef plain_matrix_type<Derived>::type VectorType ; typedef traits<Derived>::Scalar Scalar ; typedef NumTraits<Scalar>::Real RealScalar ; typedef Matrix<Scalar,2,1> Vector2 ; EIGEN_DEVICE_FUNC VectorType)",
    "insertText": "run(const Derived& src)"
  },
  {
    "label": "Zero()",
    "kind": "Method",
    "detail": "Function (VectorType perp =)",
    "insertText": "Zero(src.size())"
  },
  {
    "label": "cwiseAbs()",
    "kind": "Method",
    "detail": "Function (Index maxi = 0 ; Index sndi = 0 ; src .)",
    "insertText": "cwiseAbs().maxCoeff(&maxi)"
  },
  {
    "label": "RealScalar()",
    "kind": "Method",
    "detail": "Function (RealScalar invnm =)",
    "insertText": "RealScalar(1)/(Vector2() << src.coeff(sndi),src.coeff(maxi)).finished().norm()"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (perp .)",
    "insertText": "coeffRef(maxi) = -numext::conj(src.coeff(sndi))"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (perp .)",
    "insertText": "coeffRef(sndi) = numext::conj(src.coeff(maxi))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VectorType perp ;)",
    "insertText": "if((!isMuchSmallerThan(src.x(), src.z())) || (!isMuchSmallerThan(src.y(), src.z())))"
  },
  {
    "label": "RealScalar()",
    "kind": "Method",
    "detail": "Function (RealScalar invnm =)",
    "insertText": "RealScalar(1)/src.template head<2>().norm()"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (perp .)",
    "insertText": "coeffRef(0) = -numext::conj(src.y())"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (perp .)",
    "insertText": "coeffRef(1) = numext::conj(src.x())"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (perp .)",
    "insertText": "coeffRef(2)"
  },
  {
    "label": "RealScalar()",
    "kind": "Method",
    "detail": "Function (} else { RealScalar invnm =)",
    "insertText": "RealScalar(1)/src.template tail<2>().norm()"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (perp .)",
    "insertText": "coeffRef(0)"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (perp .)",
    "insertText": "coeffRef(1) = -numext::conj(src.z())"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (perp .)",
    "insertText": "coeffRef(2) = numext::conj(src.y())"
  },
  {
    "label": "unitOrthogonal()",
    "kind": "Method",
    "detail": "Function (} } ; } template<Derived> EIGEN_DEVICE_FUNC MatrixBase<Derived>::PlainObject MatrixBase<Derived)",
    "insertText": "unitOrthogonal()"
  },
  {
    "label": "EIGEN_STATIC_ASSERT_VECTOR_ONLY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT_VECTOR_ONLY(Derived) return internal::unitOrthogonal_selector<Derived>::run(derived())"
  }
]