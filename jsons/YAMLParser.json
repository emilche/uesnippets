[
  {
    "label": "MemoryBufferRef",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MemoryBufferRef"
  },
  {
    "label": "SourceMgr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SourceMgr"
  },
  {
    "label": "Twine",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Twine"
  },
  {
    "label": "raw_ostream",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "raw_ostream"
  },
  {
    "label": "document_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "document_iterator"
  },
  {
    "label": "Document",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Document"
  },
  {
    "label": "Node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Node"
  },
  {
    "label": "Scanner",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Scanner"
  },
  {
    "label": "Token",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Token"
  },
  {
    "label": "Stream",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Stream"
  },
  {
    "label": "NodeKind",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "NodeKind"
  },
  {
    "label": "NullNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "NullNode"
  },
  {
    "label": "ScalarNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScalarNode"
  },
  {
    "label": "BlockScalarNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BlockScalarNode"
  },
  {
    "label": "KeyValueNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "KeyValueNode"
  },
  {
    "label": "BaseT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BaseT"
  },
  {
    "label": "ValueT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueT"
  },
  {
    "label": "basic_collection_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "basic_collection_iterator"
  },
  {
    "label": "CollectionType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CollectionType"
  },
  {
    "label": "MappingNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MappingNode"
  },
  {
    "label": "MappingType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "MappingType"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "SequenceNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SequenceNode"
  },
  {
    "label": "SequenceType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "SequenceType"
  },
  {
    "label": "AliasNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AliasNode"
  },
  {
    "label": "dumpTokens()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_SUPPORT_YAMLPARSER_H # define LLVM_SUPPORT_YAMLPARSER_H # include \" llvm / ADT / StringRef . h \" # include \" llvm / Support / Allocator . h \" # include \" llvm / Support / SMLoc . h \" # include<limits> # include<map> # include<utility> namespace llvm { class MemoryBufferRef ; class SourceMgr ; class Twine ; class raw_ostream ; namespace yaml { class document_iterator ; class Document ; class Node ; class Scanner ; struct Token ; bool)",
    "insertText": "dumpTokens(StringRef Input, raw_ostream &)"
  },
  {
    "label": "scanTokens()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "scanTokens(StringRef Input)"
  },
  {
    "label": "escape()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "escape(StringRef Input)"
  },
  {
    "label": "Stream()",
    "kind": "Method",
    "detail": "Function (class Stream { public :)",
    "insertText": "Stream(StringRef Input, SourceMgr &, bool ShowColors = true)"
  },
  {
    "label": "Stream()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Stream(MemoryBufferRef InputBuffer, SourceMgr &, bool ShowColors = true)"
  },
  {
    "label": "Stream()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "Stream()"
  },
  {
    "label": "skip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "skip()"
  },
  {
    "label": "failed()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "failed()"
  },
  {
    "label": "validate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "validate()"
  },
  {
    "label": "printError()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "printError(Node *N, const Twine &Msg)"
  },
  {
    "label": "anchor()",
    "kind": "Method",
    "detail": "Function (private : std::unique_ptr<Scanner> scanner ; std::unique_ptr<Document> CurrentDoc ; class Document ; } ; class Node { void)",
    "insertText": "anchor()"
  },
  {
    "label": "Node()",
    "kind": "Method",
    "detail": "Function (public : enum NodeKind { NK_Null,NK_Scalar,NK_BlockScalar,NK_KeyValue,NK_Mapping,NK_Sequence,NK_Alias } ;)",
    "insertText": "Node(unsigned int Type, std::unique_ptr<Document> &, StringRef Anchor, StringRef Tag)"
  },
  {
    "label": "getAnchor()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "getAnchor()"
  },
  {
    "label": "getSourceRange()",
    "kind": "Method",
    "detail": "Function (SMRange)",
    "insertText": "getSourceRange()"
  },
  {
    "label": "peekNext()",
    "kind": "Method",
    "detail": "Function (SourceRange = SR ; } Token&)",
    "insertText": "peekNext()"
  },
  {
    "label": "getNext()",
    "kind": "Method",
    "detail": "Function (Token)",
    "insertText": "getNext()"
  },
  {
    "label": "parseBlockNode()",
    "kind": "Method",
    "detail": "Function (Node*)",
    "insertText": "parseBlockNode()"
  },
  {
    "label": "getAllocator()",
    "kind": "Method",
    "detail": "Function (BumpPtrAllocator&)",
    "insertText": "getAllocator()"
  },
  {
    "label": "setError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setError(const Twine &Message, Token &Location)"
  },
  {
    "label": "getType()",
    "kind": "Method",
    "detail": "Function (} unsigned int)",
    "insertText": "getType()"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (} void operator)",
    "insertText": "delete(void *Ptr, BumpPtrAllocator &Alloc, size_t Size) throw()"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (Alloc .)",
    "insertText": "Deallocate(Ptr, Size)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (} protected : std::unique_ptr<Document>& Doc ; SMRange SourceRange ; void operator)",
    "insertText": "delete(void *) throw()"
  },
  {
    "label": "Node()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "Node()"
  },
  {
    "label": "NullNode()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "NullNode(std::unique_ptr<Document> &D) : Node(NK_Null, D, StringRef(), StringRef())"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "classof(const Node *N)"
  },
  {
    "label": "ScalarNode()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "ScalarNode(std::unique_ptr<Document> &D, StringRef Anchor, StringRef Tag, StringRef Val) : Node(NK_Scalar, D, Anchor, Tag), Value(Val)"
  },
  {
    "label": "getFromPointer()",
    "kind": "Method",
    "detail": "Function (SMLoc Start =)",
    "insertText": "getFromPointer(Val.begin())"
  },
  {
    "label": "getFromPointer()",
    "kind": "Method",
    "detail": "Function (SMLoc End =)",
    "insertText": "getFromPointer(Val.end())"
  },
  {
    "label": "SMRange()",
    "kind": "Method",
    "detail": "Function (SourceRange =)",
    "insertText": "SMRange(Start, End)"
  },
  {
    "label": "getRawValue()",
    "kind": "Method",
    "detail": "Function (} StringRef)",
    "insertText": "getRawValue()"
  },
  {
    "label": "unescapeDoubleQuoted()",
    "kind": "Method",
    "detail": "Function (} private : StringRef Value ; StringRef)",
    "insertText": "unescapeDoubleQuoted(StringRef UnquotedValue, StringRef::size_type Start, SmallVectorImpl<char> &Storage)"
  },
  {
    "label": "BlockScalarNode()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "BlockScalarNode(std::unique_ptr<Document> &D, StringRef Anchor, StringRef Tag, StringRef Value, StringRef RawVal) : Node(NK_BlockScalar, D, Anchor, Tag), Value(Value)"
  },
  {
    "label": "getFromPointer()",
    "kind": "Method",
    "detail": "Function (SMLoc Start =)",
    "insertText": "getFromPointer(RawVal.begin())"
  },
  {
    "label": "getFromPointer()",
    "kind": "Method",
    "detail": "Function (SMLoc End =)",
    "insertText": "getFromPointer(RawVal.end())"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (} StringRef)",
    "insertText": "getValue()"
  },
  {
    "label": "KeyValueNode()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "KeyValueNode(std::unique_ptr<Document> &D) : Node(NK_KeyValue, D, StringRef(), StringRef()), Key(nullptr), Value(nullptr)"
  },
  {
    "label": "getKey()",
    "kind": "Method",
    "detail": "Function (} Node*)",
    "insertText": "getKey()"
  },
  {
    "label": "getKey()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getKey()->skip()"
  },
  {
    "label": "basic_collection_iterator()",
    "kind": "Method",
    "detail": "Function (} private : Node* Key ; Node* Value ; } ; template<class BaseT,class ValueT> class basic_collection_iterator { public : using iterator_category = std::forward_iterator_tag ; using value_type = ValueT ; using difference_type = std::ptrdiff_t ; using pointer = value_type* ; using reference = value_type& ;)",
    "insertText": "basic_collection_iterator() : Base(nullptr)"
  },
  {
    "label": "basic_collection_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "basic_collection_iterator(BaseT *B) : Base(B)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ValueT*)",
    "insertText": "operator()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Base && Base->CurrentEntry && \"Attempted to access end iterator!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Base && Base->CurrentEntry && \"Attempted to dereference end iterator!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Base && \"Attempted to advance iterator past end!\")"
  },
  {
    "label": "increment()",
    "kind": "Method",
    "detail": "Function (Base ->)",
    "insertText": "increment()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(C.IsAtBeginning && \"You may only iterate over a collection once!\")"
  },
  {
    "label": "ret()",
    "kind": "Method",
    "detail": "Function (C . IsAtBeginning = false ; CollectionType::iterator)",
    "insertText": "ret(&C)"
  },
  {
    "label": "skip()",
    "kind": "Method",
    "detail": "Function (+ + ret ; return ret ; } template<class CollectionType> void)",
    "insertText": "skip(CollectionType &C)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((C.IsAtBeginning || C.IsAtEnd) && \"Cannot skip mid parse!\")"
  },
  {
    "label": "MappingNode()",
    "kind": "Method",
    "detail": "Function (public : enum MappingType { MT_Block,MT_Flow,MT_Inline } ;)",
    "insertText": "MappingNode(std::unique_ptr<Document> &D, StringRef Anchor, StringRef Tag, MappingType MT) : Node(NK_Mapping, D, Anchor, Tag), Type(MT), IsAtBeginning(true), IsAtEnd(false), CurrentEntry(nullptr)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} class basic_collection_iterator<MappingNode,KeyValueNode> ; typedef basic_collection_iterator<MappingNode,KeyValueNode> iterator ; template<class T> T::iterator)",
    "insertText": "begin(T &)"
  },
  {
    "label": "skip()",
    "kind": "Method",
    "detail": "Function (template<class T> void)",
    "insertText": "skip(T &)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "skip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "skip(*this)"
  },
  {
    "label": "SequenceNode()",
    "kind": "Method",
    "detail": "Function (public : enum SequenceType { ST_Block,ST_Flow,ST_Indentless } ;)",
    "insertText": "SequenceNode(std::unique_ptr<Document> &D, StringRef Anchor, StringRef Tag, SequenceType ST) : Node(NK_Sequence, D, Anchor, Tag), SeqType(ST), IsAtBeginning(true), IsAtEnd(false), WasPreviousTokenFlowEntry(true), CurrentEntry(nullptr)"
  },
  {
    "label": "AliasNode()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "AliasNode(std::unique_ptr<Document> &D, StringRef Val) : Node(NK_Alias, D, StringRef(), StringRef()), Name(Val)"
  },
  {
    "label": "getName()",
    "kind": "Method",
    "detail": "Function (} StringRef)",
    "insertText": "getName()"
  },
  {
    "label": "getRoot()",
    "kind": "Method",
    "detail": "Function (Node*)",
    "insertText": "getRoot()"
  },
  {
    "label": "getTagMap()",
    "kind": "Method",
    "detail": "Function (} const std::map<StringRef,StringRef>&)",
    "insertText": "getTagMap()"
  },
  {
    "label": "parseDirectives()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "parseDirectives()"
  },
  {
    "label": "parseYAMLDirective()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parseYAMLDirective()"
  },
  {
    "label": "parseTAGDirective()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parseTAGDirective()"
  },
  {
    "label": "expectToken()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "expectToken(int TK)"
  },
  {
    "label": "document_iterator()",
    "kind": "Method",
    "detail": "Function (} ; class document_iterator { public :)",
    "insertText": "document_iterator() : Doc(nullptr)"
  },
  {
    "label": "document_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "document_iterator(std::unique_ptr<Document> &D) : Doc(&D)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const document_iterator &Other)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Doc && \"incrementing iterator past the end.\")"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (stream)",
    "insertText": "S(*Doc)"
  }
]