[
  {
    "label": "Grid",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Grid"
  },
  {
    "label": "OPENVDB_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OPENVDB_API"
  },
  {
    "label": "ValueConverter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValueConverter"
  },
  {
    "label": "TreeAdapter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TreeAdapter"
  },
  {
    "label": "HasMultiPassIO",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HasMultiPassIO"
  },
  {
    "label": "GridApplyImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GridApplyImpl"
  },
  {
    "label": "createGrid()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_GRID_HAS_BEEN_INCLUDED # define OPENVDB_GRID_HAS_BEEN_INCLUDED # include \" Exceptions . h \" # include \" MetaMap . h \" # include \" Types . h \" # include \" io / io . h \" # include \" math / Transform . h \" # include \" tree / Tree . h \" # include \" util / logging . h \" # include \" util / Name . h \" # include<cassert> # include<iostream> # include<set> # include<type_traits> # include<vector> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { using TreeBase = tree::TreeBase ; template<> class Grid ; template<GridType> GridType::Ptr)",
    "insertText": "createGrid(const typename GridType::ValueType& background)"
  },
  {
    "label": "createGrid()",
    "kind": "Method",
    "detail": "Function (template<GridType> GridType::Ptr)",
    "insertText": "createGrid()"
  },
  {
    "label": "createGrid()",
    "kind": "Method",
    "detail": "Function (template<TreePtrType> Grid<TreePtrType::element_type>::Ptr)",
    "insertText": "createGrid(TreePtrType)"
  },
  {
    "label": "createLevelSet()",
    "kind": "Method",
    "detail": "Function (template<GridType> GridType::Ptr)",
    "insertText": "createLevelSet(Real voxelSize = 1.0, Real halfWidth = LEVEL_SET_HALF_WIDTH)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (class GridBase : public MetaMap { public : using Ptr = SharedPtr<GridBase> ; using ConstPtr = SharedPtr<const GridBase> ; using GridFactory =)",
    "insertText": "Ptr(*)()"
  },
  {
    "label": "GridBase()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "GridBase()"
  },
  {
    "label": "copyGrid()",
    "kind": "Method",
    "detail": "Function (} GridBase::Ptr)",
    "insertText": "copyGrid()"
  },
  {
    "label": "copyGridWithNewTree()",
    "kind": "Method",
    "detail": "Function (GridBase::Ptr)",
    "insertText": "copyGridWithNewTree()"
  },
  {
    "label": "copyGridReplacingMetadata()",
    "kind": "Method",
    "detail": "Function (# if OPENVDB_ABI_VERSION_NUMBER> = 7 GridBase::ConstPtr)",
    "insertText": "copyGridReplacingMetadata(const MetaMap& meta)"
  },
  {
    "label": "copyGridReplacingTransform()",
    "kind": "Method",
    "detail": "Function (GridBase::ConstPtr)",
    "insertText": "copyGridReplacingTransform(math::Transform::Ptr xform)"
  },
  {
    "label": "copyGridReplacingMetadataAndTransform()",
    "kind": "Method",
    "detail": "Function (GridBase::ConstPtr)",
    "insertText": "copyGridReplacingMetadataAndTransform(const MetaMap& meta, math::Transform::Ptr xform)"
  },
  {
    "label": "deepCopyGrid()",
    "kind": "Method",
    "detail": "Function (# endif GridBase::Ptr)",
    "insertText": "deepCopyGrid()"
  },
  {
    "label": "createGrid()",
    "kind": "Method",
    "detail": "Function (Ptr)",
    "insertText": "createGrid(const Name& type)"
  },
  {
    "label": "isRegistered()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isRegistered(const Name &type)"
  },
  {
    "label": "clearRegistry()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clearRegistry()"
  },
  {
    "label": "type()",
    "kind": "Method",
    "detail": "Function (Name)",
    "insertText": "type()"
  },
  {
    "label": "valueType()",
    "kind": "Method",
    "detail": "Function (Name)",
    "insertText": "valueType()"
  },
  {
    "label": "isType()",
    "kind": "Method",
    "detail": "Function (template<GridType> bool)",
    "insertText": "isType()"
  },
  {
    "label": "grid()",
    "kind": "Method",
    "detail": "Function (} template<GridType> GridType::Ptr)",
    "insertText": "grid(const GridBase::Ptr&)"
  },
  {
    "label": "grid()",
    "kind": "Method",
    "detail": "Function (template<GridType> GridType::ConstPtr)",
    "insertText": "grid(const GridBase::ConstPtr&)"
  },
  {
    "label": "constGrid()",
    "kind": "Method",
    "detail": "Function (template<GridType> GridType::ConstPtr)",
    "insertText": "constGrid(const GridBase::Ptr&)"
  },
  {
    "label": "constGrid()",
    "kind": "Method",
    "detail": "Function (template<GridType> GridType::ConstPtr)",
    "insertText": "constGrid(const GridBase::ConstPtr&)"
  },
  {
    "label": "baseTreePtr()",
    "kind": "Method",
    "detail": "Function (TreeBase::Ptr)",
    "insertText": "baseTreePtr()"
  },
  {
    "label": "constBaseTreePtr()",
    "kind": "Method",
    "detail": "Function (} TreeBase::ConstPtr)",
    "insertText": "constBaseTreePtr()"
  },
  {
    "label": "isTreeUnique()",
    "kind": "Method",
    "detail": "Function (# if OPENVDB_ABI_VERSION_NUMBER> = 8 bool)",
    "insertText": "isTreeUnique()"
  },
  {
    "label": "baseTree()",
    "kind": "Method",
    "detail": "Function (# endif TreeBase&)",
    "insertText": "baseTree()"
  },
  {
    "label": "constBaseTree()",
    "kind": "Method",
    "detail": "Function (} const TreeBase&)",
    "insertText": "constBaseTree()"
  },
  {
    "label": "setTree()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setTree(TreeBase::Ptr)"
  },
  {
    "label": "newTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "newTree()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "empty()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "pruneGrid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pruneGrid(float tolerance = 0.0)"
  },
  {
    "label": "clipGrid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clipGrid(const BBoxd&)"
  },
  {
    "label": "clip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clip(const CoordBBox&)"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (template<GridTypeListT,OpT> bool)",
    "insertText": "apply(OpT&)"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (template<GridTypeListT,OpT> bool)",
    "insertText": "apply(const OpT&)"
  },
  {
    "label": "getName()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "getName()"
  },
  {
    "label": "setName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setName(const std::string&)"
  },
  {
    "label": "getCreator()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "getCreator()"
  },
  {
    "label": "setCreator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setCreator(const std::string&)"
  },
  {
    "label": "saveFloatAsHalf()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "saveFloatAsHalf()"
  },
  {
    "label": "setSaveFloatAsHalf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setSaveFloatAsHalf(bool)"
  },
  {
    "label": "getGridClass()",
    "kind": "Method",
    "detail": "Function (GridClass)",
    "insertText": "getGridClass()"
  },
  {
    "label": "setGridClass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setGridClass(GridClass)"
  },
  {
    "label": "clearGridClass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clearGridClass()"
  },
  {
    "label": "gridClassToString()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "gridClassToString(GridClass)"
  },
  {
    "label": "gridClassToMenuName()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "gridClassToMenuName(GridClass)"
  },
  {
    "label": "stringToGridClass()",
    "kind": "Method",
    "detail": "Function (GridClass)",
    "insertText": "stringToGridClass(const std::string&)"
  },
  {
    "label": "getVectorType()",
    "kind": "Method",
    "detail": "Function (VecType)",
    "insertText": "getVectorType()"
  },
  {
    "label": "setVectorType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setVectorType(VecType)"
  },
  {
    "label": "clearVectorType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clearVectorType()"
  },
  {
    "label": "vecTypeToString()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "vecTypeToString(VecType)"
  },
  {
    "label": "vecTypeExamples()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "vecTypeExamples(VecType)"
  },
  {
    "label": "vecTypeDescription()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "vecTypeDescription(VecType)"
  },
  {
    "label": "stringToVecType()",
    "kind": "Method",
    "detail": "Function (VecType)",
    "insertText": "stringToVecType(const std::string&)"
  },
  {
    "label": "isInWorldSpace()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isInWorldSpace()"
  },
  {
    "label": "setIsInWorldSpace()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setIsInWorldSpace(bool)"
  },
  {
    "label": "activeVoxelCount()",
    "kind": "Method",
    "detail": "Function (const char* const META_GRID_CLASS ; const char* const META_GRID_CREATOR ; const char* const META_GRID_NAME ; const char* const META_SAVE_HALF_FLOAT ; const char* const META_IS_LOCAL_SPACE ; const char* const META_VECTOR_TYPE ; const char* const META_FILE_BBOX_MIN ; const char* const META_FILE_BBOX_MAX ; const char* const META_FILE_COMPRESSION ; const char* const META_FILE_MEM_BYTES ; const char* const META_FILE_VOXEL_COUNT ; const char* const META_FILE_DELAYED_LOAD ; Index64)",
    "insertText": "activeVoxelCount()"
  },
  {
    "label": "evalActiveVoxelBoundingBox()",
    "kind": "Method",
    "detail": "Function (CoordBBox)",
    "insertText": "evalActiveVoxelBoundingBox()"
  },
  {
    "label": "evalActiveVoxelDim()",
    "kind": "Method",
    "detail": "Function (Coord)",
    "insertText": "evalActiveVoxelDim()"
  },
  {
    "label": "memUsage()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "memUsage()"
  },
  {
    "label": "addStatsMetadata()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addStatsMetadata()"
  },
  {
    "label": "getStatsMetadata()",
    "kind": "Method",
    "detail": "Function (MetaMap::Ptr)",
    "insertText": "getStatsMetadata()"
  },
  {
    "label": "transformPtr()",
    "kind": "Method",
    "detail": "Function (math::Transform::Ptr)",
    "insertText": "transformPtr()"
  },
  {
    "label": "voxelSize()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "voxelSize()"
  },
  {
    "label": "voxelSize()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "voxelSize(const Vec3d& xyz)"
  },
  {
    "label": "hasUniformVoxels()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasUniformVoxels()"
  },
  {
    "label": "indexToWorld()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "indexToWorld(const Vec3d& xyz)"
  },
  {
    "label": "indexToWorld()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "indexToWorld(const Coord& ijk)"
  },
  {
    "label": "worldToIndex()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "worldToIndex(const Vec3d& xyz)"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "readTopology(std::istream&)"
  },
  {
    "label": "writeTopology()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeTopology(std::ostream&)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(std::istream&)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(std::istream&, const CoordBBox&)"
  },
  {
    "label": "readNonresidentBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readNonresidentBuffers()"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeBuffers(std::ostream&)"
  },
  {
    "label": "readTransform()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readTransform(std::istream& is)"
  },
  {
    "label": "transform()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transform().read(is)"
  },
  {
    "label": "writeTransform()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "writeTransform(std::ostream& os)"
  },
  {
    "label": "transform()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transform().write(os)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "print(std::ostream& = std::cout, int verboseLevel = 1)"
  },
  {
    "label": "GridBase()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "GridBase(): mTransform(math::Transform::createLinearTransform())"
  },
  {
    "label": "GridBase()",
    "kind": "Method",
    "detail": "Function (} # if OPENVDB_ABI_VERSION_NUMBER> = 7)",
    "insertText": "GridBase(const MetaMap& meta, math::Transform::Ptr xform)"
  },
  {
    "label": "GridBase()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "GridBase(const GridBase& other): MetaMap(other), mTransform(other.mTransform->copy())"
  },
  {
    "label": "GridBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "GridBase(GridBase& other, ShallowCopy): MetaMap(other), mTransform(other.mTransform)"
  },
  {
    "label": "registerGrid()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "registerGrid(const Name& type, GridFactory)"
  },
  {
    "label": "unregisterGrid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "unregisterGrid(const Name& type)"
  },
  {
    "label": "GridNamePred()",
    "kind": "Method",
    "detail": "Function (private : math::Transform::Ptr mTransform ; } ; using GridPtrVec = std::vector<GridBase::Ptr> ; using GridPtrVecIter = GridPtrVec::iterator ; using GridPtrVecCIter = GridPtrVec::const_iterator ; using GridPtrVecPtr = SharedPtr<GridPtrVec> ; using GridCPtrVec = std::vector<GridBase::ConstPtr> ; using GridCPtrVecIter = GridCPtrVec::iterator ; using GridCPtrVecCIter = GridCPtrVec::const_iterator ; using GridCPtrVecPtr = SharedPtr<GridCPtrVec> ; using GridPtrSet = std::set<GridBase::Ptr> ; using GridPtrSetIter = GridPtrSet::iterator ; using GridPtrSetCIter = GridPtrSet::const_iterator ; using GridPtrSetPtr = SharedPtr<GridPtrSet> ; using GridCPtrSet = std::set<GridBase::ConstPtr> ; using GridCPtrSetIter = GridCPtrSet::iterator ; using GridCPtrSetCIter = GridCPtrSet::const_iterator ; using GridCPtrSetPtr = SharedPtr<GridCPtrSet> ; struct GridNamePred {)",
    "insertText": "GridNamePred(const Name& _name): name(_name)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator()(const GridBase::ConstPtr& g)"
  },
  {
    "label": "findGridByName()",
    "kind": "Method",
    "detail": "Function (} Name name ; } ; template<GridPtrContainerT> GridPtrContainerT::value_type)",
    "insertText": "findGridByName(const GridPtrContainerT& container, const Name& name)"
  },
  {
    "label": "find_if()",
    "kind": "Method",
    "detail": "Function (using GridPtrT = GridPtrContainerT::value_type ; GridPtrContainerT::const_iterator it =)",
    "insertText": "find_if(container.begin(), container.end(), GridNamePred(name))"
  },
  {
    "label": "findGridByName()",
    "kind": "Method",
    "detail": "Function (} template<KeyT,GridPtrT> GridPtrT)",
    "insertText": "findGridByName(const std::map<KeyT, GridPtrT>& container, const Name& name)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (using GridPtrMapT = std::map<KeyT,GridPtrT> ;)",
    "insertText": "for(typename GridPtrMapT::const_iterator it = container.begin(), end = container.end(); it != end; ++it)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const GridPtrT& grid = it -> second ;)",
    "insertText": "if(grid && grid->getName() == name)"
  },
  {
    "label": "GridPtrT()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "GridPtrT()"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (} template<_TreeType> class Grid : public GridBase { public : using Ptr = SharedPtr<Grid> ; using ConstPtr = SharedPtr<const Grid> ; using TreeType = _TreeType ; using TreePtrType = _TreeType::Ptr ; using ConstTreePtrType = _TreeType::ConstPtr ; using ValueType = _TreeType::ValueType ; using BuildType = _TreeType::BuildType ; using ValueOnIter = _TreeType::ValueOnIter ; using ValueOnCIter = _TreeType::ValueOnCIter ; using ValueOffIter = _TreeType::ValueOffIter ; using ValueOffCIter = _TreeType::ValueOffCIter ; using ValueAllIter = _TreeType::ValueAllIter ; using ValueAllCIter = _TreeType::ValueAllCIter ; using Accessor = tree::ValueAccessor<_TreeType,true> ; using ConstAccessor = tree::ValueAccessor<const _TreeType,true> ; using UnsafeAccessor = tree::ValueAccessor<_TreeType,false> ; using ConstUnsafeAccessor = tree::ValueAccessor<const _TreeType,false> ; template<OtherValueType> struct ValueConverter { using Type = Grid<TreeType::template ValueConverter<OtherValueType>::Type> ; } ; Ptr)",
    "insertText": "create(const ValueType& background)"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (Ptr)",
    "insertText": "create()"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (Ptr)",
    "insertText": "create(TreePtrType)"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (Ptr)",
    "insertText": "create(const GridBase& other)"
  },
  {
    "label": "Grid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Grid()"
  },
  {
    "label": "Grid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Grid(const ValueType& background)"
  },
  {
    "label": "Grid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Grid(TreePtrType)"
  },
  {
    "label": "Grid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Grid(const Grid&)"
  },
  {
    "label": "Grid()",
    "kind": "Method",
    "detail": "Function (template<OtherTreeType>)",
    "insertText": "Grid(const Grid<OtherTreeType>&)"
  },
  {
    "label": "Grid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Grid(Grid&, ShallowCopy)"
  },
  {
    "label": "Grid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Grid(const GridBase&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Grid&)",
    "insertText": "operator(const Grid&)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (Ptr)",
    "insertText": "copy()"
  },
  {
    "label": "copyWithNewTree()",
    "kind": "Method",
    "detail": "Function (Ptr)",
    "insertText": "copyWithNewTree()"
  },
  {
    "label": "copyReplacingMetadata()",
    "kind": "Method",
    "detail": "Function (# if OPENVDB_ABI_VERSION_NUMBER> = 7 ConstPtr)",
    "insertText": "copyReplacingMetadata(const MetaMap& meta)"
  },
  {
    "label": "copyReplacingTransform()",
    "kind": "Method",
    "detail": "Function (ConstPtr)",
    "insertText": "copyReplacingTransform(math::Transform::Ptr xform)"
  },
  {
    "label": "copyReplacingMetadataAndTransform()",
    "kind": "Method",
    "detail": "Function (ConstPtr)",
    "insertText": "copyReplacingMetadataAndTransform(const MetaMap& meta, math::Transform::Ptr xform)"
  },
  {
    "label": "deepCopy()",
    "kind": "Method",
    "detail": "Function (# endif Ptr)",
    "insertText": "deepCopy()"
  },
  {
    "label": "gridType()",
    "kind": "Method",
    "detail": "Function (} Name)",
    "insertText": "gridType()"
  },
  {
    "label": "background()",
    "kind": "Method",
    "detail": "Function (} const ValueType&)",
    "insertText": "background()"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tree().clear()"
  },
  {
    "label": "getAccessor()",
    "kind": "Method",
    "detail": "Function (} Accessor)",
    "insertText": "getAccessor()"
  },
  {
    "label": "getUnsafeAccessor()",
    "kind": "Method",
    "detail": "Function (} UnsafeAccessor)",
    "insertText": "getUnsafeAccessor()"
  },
  {
    "label": "getConstAccessor()",
    "kind": "Method",
    "detail": "Function (} ConstAccessor)",
    "insertText": "getConstAccessor()"
  },
  {
    "label": "getConstUnsafeAccessor()",
    "kind": "Method",
    "detail": "Function (} ConstUnsafeAccessor)",
    "insertText": "getConstUnsafeAccessor()"
  },
  {
    "label": "beginValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnIter)",
    "insertText": "beginValueOn()"
  },
  {
    "label": "cbeginValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnCIter)",
    "insertText": "cbeginValueOn()"
  },
  {
    "label": "beginValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffIter)",
    "insertText": "beginValueOff()"
  },
  {
    "label": "cbeginValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "cbeginValueOff()"
  },
  {
    "label": "beginValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllIter)",
    "insertText": "beginValueAll()"
  },
  {
    "label": "cbeginValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "cbeginValueAll()"
  },
  {
    "label": "sparseFill()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "sparseFill(const CoordBBox& bbox, const ValueType& value, bool active = true)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(const CoordBBox& bbox, const ValueType& value, bool active = true)"
  },
  {
    "label": "denseFill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "denseFill(const CoordBBox& bbox, const ValueType& value, bool active = true)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "merge(Grid& other, MergePolicy policy = MERGE_ACTIVE_STATES)"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (template<OtherTreeType> void)",
    "insertText": "topologyUnion(const Grid<OtherTreeType>& other)"
  },
  {
    "label": "topologyIntersection()",
    "kind": "Method",
    "detail": "Function (template<OtherTreeType> void)",
    "insertText": "topologyIntersection(const Grid<OtherTreeType>& other)"
  },
  {
    "label": "topologyDifference()",
    "kind": "Method",
    "detail": "Function (template<OtherTreeType> void)",
    "insertText": "topologyDifference(const Grid<OtherTreeType>& other)"
  },
  {
    "label": "evalMinMax()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalMinMax(ValueType& minVal, ValueType& maxVal)"
  },
  {
    "label": "treePtr()",
    "kind": "Method",
    "detail": "Function (} TreePtrType)",
    "insertText": "treePtr()"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (# endif TreeType&)",
    "insertText": "tree()"
  },
  {
    "label": "hasMultiPassIO()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasMultiPassIO()"
  },
  {
    "label": "isRegistered()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isRegistered()"
  },
  {
    "label": "registerGrid()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "registerGrid()"
  },
  {
    "label": "registerGrid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "registerGrid(Grid::gridType(), Grid::factory)"
  },
  {
    "label": "unregisterGrid()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "unregisterGrid()"
  },
  {
    "label": "unregisterGrid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "unregisterGrid(Grid::gridType())"
  },
  {
    "label": "Grid()",
    "kind": "Method",
    "detail": "Function (} private : # if OPENVDB_ABI_VERSION_NUMBER> = 7)",
    "insertText": "Grid(TreePtrType tree, const MetaMap& meta, math::Transform::Ptr xform)"
  },
  {
    "label": "factory()",
    "kind": "Method",
    "detail": "Function (# endif GridBase::Ptr)",
    "insertText": "factory()"
  },
  {
    "label": "gridPtrCast()",
    "kind": "Method",
    "detail": "Function (} TreePtrType mTree ; } ; template<GridType> GridType::Ptr)",
    "insertText": "gridPtrCast(const GridBase::Ptr& grid)"
  },
  {
    "label": "gridConstPtrCast()",
    "kind": "Method",
    "detail": "Function (} template<GridType> GridType::ConstPtr)",
    "insertText": "gridConstPtrCast(const GridBase::ConstPtr& grid)"
  },
  {
    "label": "deepCopyTypedGrid()",
    "kind": "Method",
    "detail": "Function (} template<GridType> GridType::Ptr)",
    "insertText": "deepCopyTypedGrid(const GridBase::ConstPtr& grid)"
  },
  {
    "label": "deepCopyTypedGrid()",
    "kind": "Method",
    "detail": "Function (} template<GridType> GridType::Ptr)",
    "insertText": "deepCopyTypedGrid(const GridBase& grid)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (} template<_TreeType> struct TreeAdapter { using TreeType = _TreeType ; using NonConstTreeType = std::remove_const<TreeType>::type ; using TreePtrType = TreeType::Ptr ; using ConstTreePtrType = TreeType::ConstPtr ; using NonConstTreePtrType = NonConstTreeType::Ptr ; using GridType = Grid<TreeType> ; using NonConstGridType = Grid<NonConstTreeType> ; using GridPtrType = GridType::Ptr ; using NonConstGridPtrType = NonConstGridType::Ptr ; using ConstGridPtrType = GridType::ConstPtr ; using ValueType = TreeType::ValueType ; using AccessorType = tree::ValueAccessor<TreeType> ; using ConstAccessorType = tree::ValueAccessor<const TreeType> ; using NonConstAccessorType = tree::ValueAccessor<NonConstTreeType> ; TreeType&)",
    "insertText": "tree(TreeType& t)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (} const TreeType&)",
    "insertText": "tree(const TreeType& t)"
  },
  {
    "label": "constTree()",
    "kind": "Method",
    "detail": "Function (} const TreeType&)",
    "insertText": "constTree(TreeType& t)"
  },
  {
    "label": "constTree()",
    "kind": "Method",
    "detail": "Function (} const TreeType&)",
    "insertText": "constTree(const TreeType& t)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (} TreeType&)",
    "insertText": "tree(AccessorType& a)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (} const TreeType&)",
    "insertText": "tree(const AccessorType& a)"
  },
  {
    "label": "GridBase()",
    "kind": "Method",
    "detail": "Function (} } ; template<LeafNodeType> struct HasMultiPassIO { const bool value = std::is_base_of<io::MultiPass,LeafNodeType>::value ; } ; template<RootNodeType> struct HasMultiPassIO<tree::Tree<RootNodeType>> { const bool value = HasMultiPassIO<RootNodeType::LeafNodeType>::value ; } ; template<TreeType> struct HasMultiPassIO<Grid<TreeType>> { const bool value = HasMultiPassIO<TreeType::LeafNodeType>::value ; } ; # if OPENVDB_ABI_VERSION_NUMBER> = 7)",
    "insertText": "GridBase(const MetaMap& meta, math::Transform::Ptr xform) : MetaMap(meta) , mTransform(xform)"
  },
  {
    "label": "grid()",
    "kind": "Method",
    "detail": "Function (} # endif template<GridType> GridType::Ptr)",
    "insertText": "grid(const GridBase::Ptr& grid)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "Ptr()"
  },
  {
    "label": "grid()",
    "kind": "Method",
    "detail": "Function (} template<GridType> GridType::ConstPtr)",
    "insertText": "grid(const GridBase::ConstPtr& grid)"
  },
  {
    "label": "constGrid()",
    "kind": "Method",
    "detail": "Function (} template<GridType> GridType::ConstPtr)",
    "insertText": "constGrid(const GridBase::Ptr& grid)"
  },
  {
    "label": "constGrid()",
    "kind": "Method",
    "detail": "Function (} template<GridType> GridType::ConstPtr)",
    "insertText": "constGrid(const GridBase::ConstPtr& grid)"
  },
  {
    "label": "setTransform()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setTransform(math::Transform::Ptr xform)"
  },
  {
    "label": "Grid()",
    "kind": "Method",
    "detail": "Function (mTransform = xform ; } template<TreeT> Grid<TreeT)",
    "insertText": "Grid(): mTree(new TreeType)"
  },
  {
    "label": "Grid()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> Grid<TreeT)",
    "insertText": "Grid(const ValueType &background): mTree(new TreeType(background))"
  },
  {
    "label": "Grid()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> Grid<TreeT)",
    "insertText": "Grid(TreePtrType tree): mTree(tree)"
  },
  {
    "label": "Grid()",
    "kind": "Method",
    "detail": "Function (} # if OPENVDB_ABI_VERSION_NUMBER> = 7 template<TreeT> Grid<TreeT)",
    "insertText": "Grid(TreePtrType tree, const MetaMap& meta, math::Transform::Ptr xform): GridBase(meta, xform), mTree(tree)"
  },
  {
    "label": "Grid()",
    "kind": "Method",
    "detail": "Function (} # endif template<TreeT> Grid<TreeT)",
    "insertText": "Grid(const Grid& other): GridBase(other), mTree(StaticPtrCast<TreeType>(other.mTree->copy()))"
  },
  {
    "label": "Grid()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> template<OtherTreeType> Grid<TreeT)",
    "insertText": "Grid(const Grid<OtherTreeType>& other): GridBase(other), mTree(new TreeType(other.constTree()))"
  },
  {
    "label": "Grid()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> Grid<TreeT)",
    "insertText": "Grid(Grid& other, ShallowCopy): GridBase(other), mTree(other.mTree)"
  },
  {
    "label": "Grid()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> Grid<TreeT)",
    "insertText": "Grid(const GridBase& other): GridBase(other), mTree(new TreeType)"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> Grid<TreeT>::Ptr Grid<TreeT)",
    "insertText": "create(TreePtrType tree)"
  },
  {
    "label": "Transform()",
    "kind": "Method",
    "detail": "Function (math::Transform::Ptr transformPtr = ConstPtrCast<)",
    "insertText": "Transform(this->constTransformPtr())"
  },
  {
    "label": "TreeT()",
    "kind": "Method",
    "detail": "Function (TreePtrType treePtr = ConstPtrCast<)",
    "insertText": "TreeT(this->constTreePtr())"
  },
  {
    "label": "Grid()",
    "kind": "Method",
    "detail": "Function (Ptr result { new Grid {* const_cast<)",
    "insertText": "Grid(this)"
  },
  {
    "label": "setTree()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> void Grid<TreeT)",
    "insertText": "setTree(TreeBase::Ptr tree)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(TypeError, \"Cannot assign a tree of type \" + tree->type() + \" to a grid of type \" + this->type())"
  },
  {
    "label": "TreeType()",
    "kind": "Method",
    "detail": "Function (} mTree = StaticPtrCast<)",
    "insertText": "TreeType(tree)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (mTree .)",
    "insertText": "reset(new TreeType(this->background()))"
  },
  {
    "label": "sparseFill()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> void Grid<TreeT)",
    "insertText": "sparseFill(const CoordBBox& bbox, const ValueType& value, bool active)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tree().sparseFill(bbox, value, active)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> void Grid<TreeT)",
    "insertText": "fill(const CoordBBox& bbox, const ValueType& value, bool active)"
  },
  {
    "label": "sparseFill()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "sparseFill(bbox, value, active)"
  },
  {
    "label": "denseFill()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> void Grid<TreeT)",
    "insertText": "denseFill(const CoordBBox& bbox, const ValueType& value, bool active)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tree().denseFill(bbox, value, active)"
  },
  {
    "label": "pruneGrid()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> void Grid<TreeT)",
    "insertText": "pruneGrid(float tolerance)"
  },
  {
    "label": "cwiseAdd()",
    "kind": "Method",
    "detail": "Function (const auto value =)",
    "insertText": "cwiseAdd(zeroVal<ValueType>(), tolerance)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "tree().prune(static_cast<ValueType>(value))"
  },
  {
    "label": "clip()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> void Grid<TreeT)",
    "insertText": "clip(const CoordBBox& bbox)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tree().clip(bbox)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> void Grid<TreeT)",
    "insertText": "merge(Grid& other, MergePolicy policy)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tree().merge(other.tree(), policy)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tree().topologyUnion(other.tree())"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tree().topologyIntersection(other.tree())"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tree().topologyDifference(other.tree())"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tree().evalMinMax(minVal, maxVal)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (CoordBBox bbox ;)",
    "insertText": "tree().evalActiveVoxelBoundingBox(bbox)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (Coord dim ; const bool nonempty =)",
    "insertText": "tree().evalActiveVoxelDim(dim)"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> void Grid<TreeT)",
    "insertText": "readTopology(std::istream& is)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tree().readTopology(is, saveFloatAsHalf())"
  },
  {
    "label": "writeTopology()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> void Grid<TreeT)",
    "insertText": "writeTopology(std::ostream& os)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tree().writeTopology(os, saveFloatAsHalf())"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> void Grid<TreeT)",
    "insertText": "readBuffers(std::istream& is)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tree().readBuffers(is, saveFloatAsHalf())"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (} else { uint16_t numPasses = 1 ; is .)",
    "insertText": "read(reinterpret_cast<char*>(&numPasses), sizeof(uint16_t))"
  },
  {
    "label": "getStreamMetadataPtr()",
    "kind": "Method",
    "detail": "Function (const io::StreamMetadata::Ptr meta =)",
    "insertText": "getStreamMetadataPtr(is)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(bool(meta))"
  },
  {
    "label": "pass()",
    "kind": "Method",
    "detail": "Function (uint32_t)",
    "insertText": "pass(uint32_t(numPasses) << 16) | uint32_t(passIndex)"
  },
  {
    "label": "setPass()",
    "kind": "Method",
    "detail": "Function (meta ->)",
    "insertText": "setPass(pass)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (} } } template<TreeT> void Grid<TreeT)",
    "insertText": "readBuffers(std::istream& is, const CoordBBox& bbox)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tree().readBuffers(is, bbox, saveFloatAsHalf())"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tree().readNonresidentBuffers()"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> void Grid<TreeT)",
    "insertText": "writeBuffers(std::ostream& os)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tree().writeBuffers(os, saveFloatAsHalf())"
  },
  {
    "label": "getStreamMetadataPtr()",
    "kind": "Method",
    "detail": "Function (} else { const io::StreamMetadata::Ptr meta =)",
    "insertText": "getStreamMetadataPtr(os)"
  },
  {
    "label": "setCountingPasses()",
    "kind": "Method",
    "detail": "Function (uint16_t numPasses = 1 ; meta ->)",
    "insertText": "setCountingPasses(true)"
  },
  {
    "label": "setPass()",
    "kind": "Method",
    "detail": "Function (meta ->)",
    "insertText": "setPass(0)"
  },
  {
    "label": "uint16_t()",
    "kind": "Method",
    "detail": "Function (numPasses = static_cast<)",
    "insertText": "uint16_t(meta->pass())"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&numPasses), sizeof(uint16_t))"
  },
  {
    "label": "setCountingPasses()",
    "kind": "Method",
    "detail": "Function (meta ->)",
    "insertText": "setCountingPasses(false)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tree().print(os, verboseLevel)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (os<<\" Additional metadata : \"<<std::endl ;)",
    "insertText": "for(ConstMetaIterator it = beginMeta(), end = endMeta(); it != end; ++it)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (os<<\" \"<<it -> first ;)",
    "insertText": "if(it->second)"
  },
  {
    "label": "str()",
    "kind": "Method",
    "detail": "Function (const std::string value = it -> second ->)",
    "insertText": "str()"
  },
  {
    "label": "transform()",
    "kind": "Method",
    "detail": "Function (} os<<\" \\ n \" ; } } os<<\" Transform : \"<<std::endl ;)",
    "insertText": "transform().print(os, \" \")"
  },
  {
    "label": "createGrid()",
    "kind": "Method",
    "detail": "Function (} template<TreePtrType> Grid<TreePtrType::element_type>::Ptr)",
    "insertText": "createGrid(TreePtrType tree)"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (using TreeType = TreePtrType::element_type ; return Grid<TreeType)",
    "insertText": "create(tree)"
  },
  {
    "label": "createLevelSet()",
    "kind": "Method",
    "detail": "Function (} template<GridType> GridType::Ptr)",
    "insertText": "createLevelSet(Real voxelSize, Real halfWidth)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (using ValueType = GridType::ValueType ;)",
    "insertText": "static_assert(std::is_floating_point<ValueType>::value, \"level-set grids must be floating-point-valued\")"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (GridType::Ptr grid =)",
    "insertText": "create(static_cast<ValueType>(voxelSize * halfWidth))"
  },
  {
    "label": "setTransform()",
    "kind": "Method",
    "detail": "Function (grid ->)",
    "insertText": "setTransform(math::Transform::createLinearTransform(voxelSize))"
  },
  {
    "label": "setGridClass()",
    "kind": "Method",
    "detail": "Function (grid ->)",
    "insertText": "setGridClass(GRID_LEVEL_SET)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(static_cast<typename CopyConstness<GridBaseT, GridT>::Type&>(grid))"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (} } ; } template<GridTypeListT,OpT> bool)",
    "insertText": "apply(OpT& op)"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (} template<GridTypeListT,OpT> bool)",
    "insertText": "apply(const OpT& op)"
  }
]