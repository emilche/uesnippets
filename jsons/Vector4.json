[
  {
    "label": "alignas",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "alignas"
  },
  {
    "label": "TIsPODType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsPODType"
  },
  {
    "label": "TIsUECoreVariant",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsUECoreVariant"
  },
  {
    "label": "TCanBulkSerialize",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TCanBulkSerialize"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Misc / Crc . h \" # include \" Math / UnrealMathUtility . h \" # include \" Containers / UnrealString . h \" # include \" Misc / Parse . h \" # include \" Misc / LargeWorldCoordinatesSerializer . h \" # include \" Logging / LogMacros . h \" # include \" Math / Vector2D . h \" # include \" Math / Vector . h \" # include \" Serialization / MemoryLayout . h \" # include \" Templates / Requires . h \" # include<type_traits> namespace UE { namespace Math { template<T> struct)",
    "insertText": "alignas(16)"
  },
  {
    "label": "TVector4()",
    "kind": "Method",
    "detail": "Function (} ; public :)",
    "insertText": "TVector4(const UE::Math::TVector<T>& InVector)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (template<FArg)",
    "insertText": "UE_REQUIRES(std::is_arithmetic_v<FArg>)> FORCEINLINE TVector4(const UE::Math::TVector<T>& InVector, FArg InW) : X(InVector.X) , Y(InVector.Y) , Z(InVector.Z) , W((T)InW)"
  },
  {
    "label": "DiagnosticCheckNaN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DiagnosticCheckNaN()"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<FArg)",
    "insertText": "UE_REQUIRES(std::is_arithmetic_v<FArg>)> FORCEINLINE TVector4(const UE::Math::TVector4<T>& InVector, FArg OverrideW) : X(InVector.X) , Y(InVector.Y) , Z(InVector.Z) , W((T)OverrideW)"
  },
  {
    "label": "TVector4()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TVector4(const FLinearColor& InColor) : X(InColor.R) , Y(InColor.G) , Z(InColor.B) , W(InColor.A)"
  },
  {
    "label": "TVector4()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TVector4(const FLinearColor& InColor, T InOverrideW) : X(InColor.R) , Y(InColor.G) , Z(InColor.B) , W(InOverrideW)"
  },
  {
    "label": "TVector4()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TVector4(T InX = 0.0f, T InY = 0.0f, T InZ = 0.0f, T InW = 1.0f)"
  },
  {
    "label": "TVector4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TVector4(TVector2<T> InXY, TVector2<T> InZW)"
  },
  {
    "label": "TVector4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TVector4(const FIntVector4& InVector)"
  },
  {
    "label": "TVector4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TVector4(EForceInit)"
  },
  {
    "label": "TVector4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TVector4(ENoInit)"
  },
  {
    "label": "Zero()",
    "kind": "Method",
    "detail": "Function (public : TVector4<T>)",
    "insertText": "Zero()"
  },
  {
    "label": "One()",
    "kind": "Method",
    "detail": "Function (} TVector4<T>)",
    "insertText": "One()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "operator(int32 ComponentIndex)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (template<FArg)",
    "insertText": "UE_REQUIRES(std::is_arithmetic_v<FArg>)> FORCEINLINE TVector4<T> operator*(FArg Scale)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<FArg)",
    "insertText": "UE_REQUIRES(std::is_arithmetic_v<FArg>)> FORCEINLINE TVector4<T> operator/(FArg Scale)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T RScale =)",
    "insertText": "T(1.0f)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TVector4<T>)",
    "insertText": "operator(const TVector4<T>& V)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (template<FArg)",
    "insertText": "UE_REQUIRES(std::is_arithmetic_v<FArg>)> FORCEINLINE TVector4<T> operator*=(FArg Scale)"
  },
  {
    "label": "Component()",
    "kind": "Method",
    "detail": "Function (public : T&)",
    "insertText": "Component(int32 Index)"
  },
  {
    "label": "Equals()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Equals(const TVector4<T>& V, T Tolerance=UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "IsUnit3()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsUnit3(T LengthSquaredTolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "ToString()"
  },
  {
    "label": "InitFromString()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "InitFromString(const FString& InSourceString)"
  },
  {
    "label": "ToOrientationRotator()",
    "kind": "Method",
    "detail": "Function (TRotator<T>)",
    "insertText": "ToOrientationRotator()"
  },
  {
    "label": "ToOrientationQuat()",
    "kind": "Method",
    "detail": "Function (TQuat<T>)",
    "insertText": "ToOrientationQuat()"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Set(T InX, T InY, T InZ, T InW)"
  },
  {
    "label": "Size3()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "Size3()"
  },
  {
    "label": "SizeSquared3()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "SizeSquared3()"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "Size()"
  },
  {
    "label": "SizeSquared()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "SizeSquared()"
  },
  {
    "label": "ContainsNaN()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ContainsNaN()"
  },
  {
    "label": "IsNearlyZero3()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsNearlyZero3(T Tolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "Reflect3()",
    "kind": "Method",
    "detail": "Function (TVector4<T>)",
    "insertText": "Reflect3(const TVector4<T>& Normal)"
  },
  {
    "label": "FindBestAxisVectors3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindBestAxisVectors3(TVector4<T>& Axis1, TVector4<T>& Axis2)"
  },
  {
    "label": "logOrEnsureNanError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "logOrEnsureNanError(TEXT(\"FVector4 contains NaN: %s\"), *ToString())"
  },
  {
    "label": "TVector4()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "TVector4()"
  },
  {
    "label": "SerializeFromVector3()",
    "kind": "Method",
    "detail": "Function (} # endif private : bool)",
    "insertText": "SerializeFromVector3(FName StructTag, FArchive&Ar)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (public : bool)",
    "insertText": "Serialize(FArchive& Ar)"
  },
  {
    "label": "SerializeFromMismatchedTag()",
    "kind": "Method",
    "detail": "Function (Ar<<* this ; return true ; } bool)",
    "insertText": "SerializeFromMismatchedTag(FName StructTag, FArchive& Ar)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (template<FArg)",
    "insertText": "UE_REQUIRES(std::is_same_v<FArg, double> && std::is_same_v<T, float>)> explicit TVector4(const TVector4<FArg>& From) : TVector4<T>((T)From.X, (T)From.Y, (T)From.Z, (T)From.W)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<FArg)",
    "insertText": "UE_REQUIRES(std::is_same_v<FArg, float> && std::is_same_v<T, double>)> explicit TVector4(const TVector4<FArg>& From) : TVector4<T>((T)From.X, (T)From.Y, (T)From.Z, (T)From.W)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetTypeHash(const UE::Math::TVector4<T>& Vector)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; FArchive&)",
    "insertText": "operator(FArchive& Ar, TVector4<float>& V)"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (Ar<<V . X<<V . Y<<V . Z<<V . W ; } else {)",
    "insertText": "checkf(Ar.IsLoading(), TEXT(\"float -> double conversion applied outside of load!\"))"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (float X,Y,Z,W ; Ar<<X<<Y<<Z<<W ; V = TVector4<)",
    "insertText": "double(X, Y, Z, W)"
  },
  {
    "label": "TVector4()",
    "kind": "Method",
    "detail": "Function (} return Ar ; } template<T> TVector4<T)",
    "insertText": "TVector4(const UE::Math::TVector<T>& InVector) : X(InVector.X) , Y(InVector.Y) , Z(InVector.Z) , W(1.0f)"
  },
  {
    "label": "TVector4()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector4<T)",
    "insertText": "TVector4(T InX, T InY, T InZ, T InW) : X(InX) , Y(InY) , Z(InZ) , W(InW)"
  },
  {
    "label": "TVector4()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector4<T)",
    "insertText": "TVector4(EForceInit) : X(0.f) , Y(0.f) , Z(0.f) , W(0.f)"
  },
  {
    "label": "TVector4()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector4<T)",
    "insertText": "TVector4(TVector2<T> InXY, TVector2<T> InZW) : X(InXY.X) , Y(InXY.Y) , Z(InZW.X) , W(InZW.Y)"
  },
  {
    "label": "TVector4()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector4<T)",
    "insertText": "TVector4(const FIntVector4& InVector) : X((T)InVector.X) , Y((T)InVector.Y) , Z((T)InVector.Z) , W((T)InVector.W)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector4<T> TVector4<T)",
    "insertText": "operator()"
  },
  {
    "label": "Equals()",
    "kind": "Method",
    "detail": "Function (} template<T> bool TVector4<T)",
    "insertText": "Equals(const TVector4<T>& V, T Tolerance)"
  },
  {
    "label": "Value()",
    "kind": "Method",
    "detail": "Function (X = Y = Z = 0 ; W = 1 . 0 f ; const bool bSuccessful =)",
    "insertText": "Value(*InSourceString, TEXT(\"X=\") , X) && FParse::Value(*InSourceString, TEXT(\"Y=\"), Y) && FParse::Value(*InSourceString, TEXT(\"Z=\"), Z)"
  },
  {
    "label": "Value()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Value(*InSourceString, TEXT(\"W=\"), W)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const T SquareSum = X* X + Y* Y + Z* Z ;)",
    "insertText": "if(SquareSum > Tolerance)"
  },
  {
    "label": "InvSqrt()",
    "kind": "Method",
    "detail": "Function (const T Scale =)",
    "insertText": "InvSqrt(SquareSum)"
  },
  {
    "label": "TVector4()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "TVector4(T(0.f))"
  },
  {
    "label": "GetUnsafeNormal3()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector4<T> TVector4<T)",
    "insertText": "GetUnsafeNormal3()"
  },
  {
    "label": "InvSqrt()",
    "kind": "Method",
    "detail": "Function (const T Scale =)",
    "insertText": "InvSqrt(X*X+Y*Y+Z*Z)"
  },
  {
    "label": "IsNearlyZero3()",
    "kind": "Method",
    "detail": "Function (} template<T> bool TVector4<T)",
    "insertText": "IsNearlyZero3(T Tolerance)"
  },
  {
    "label": "SerializeFromVector3()",
    "kind": "Method",
    "detail": "Function (} template<T> bool TVector4<T)",
    "insertText": "SerializeFromVector3(FName StructTag, FArchive& Ar)"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (FVector3f AsVec ; Ar<<AsVec ;)",
    "insertText": "X(T)"
  },
  {
    "label": "Y()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Y(T)"
  },
  {
    "label": "Z()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Z(T)"
  },
  {
    "label": "DECLARE_INTRINSIC_TYPE_LAYOUT()",
    "kind": "Method",
    "detail": "Function (template<> struct TIsPODType<FVector4f> { enum { Value = true } ; } ; template<> struct TIsPODType<FVector4d> { enum { Value = true } ; } ; template<> struct TIsUECoreVariant<FVector4f> { enum { Value = true } ; } ; template<> struct TIsUECoreVariant<FVector4d> { enum { Value = true } ; } ; template<> struct TCanBulkSerialize<FVector4f> { enum { Value = true } ; } ; template<> struct TCanBulkSerialize<FVector4d> { enum { Value = true } ; } ;)",
    "insertText": "DECLARE_INTRINSIC_TYPE_LAYOUT(FVector4f)"
  },
  {
    "label": "DECLARE_INTRINSIC_TYPE_LAYOUT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_INTRINSIC_TYPE_LAYOUT(FVector4d)"
  },
  {
    "label": "Dot3()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "Dot3(const UE::Math::TVector4<T>& V1, const UE::Math::TVector4<T>& V2)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (const T NX =)",
    "insertText": "Abs(X)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (const T NY =)",
    "insertText": "Abs(Y)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (const T NZ =)",
    "insertText": "Abs(Z)"
  },
  {
    "label": "Axis1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Axis1(Axis1 - *this * Dot3(Axis1, *this)).GetSafeNormal()"
  },
  {
    "label": "TVector()",
    "kind": "Method",
    "detail": "Function (Axis2 = Axis1 ^* this ; } template<T> TVector<T)",
    "insertText": "TVector(const TVector4<T>& V ) : X(V.X), Y(V.Y), Z(V.Z)"
  },
  {
    "label": "TVector2()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector2<T)",
    "insertText": "TVector2(const TVector4<T>& V ) : X(V.X), Y(V.Y)"
  }
]