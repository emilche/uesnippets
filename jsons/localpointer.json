[
  {
    "label": "LocalPointerBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LocalPointerBase"
  },
  {
    "label": "LocalPointer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LocalPointer"
  },
  {
    "label": "LocalArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LocalArray"
  },
  {
    "label": "LocalPointerClassName",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LocalPointerClassName"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (# ifndef __LOCALPOINTER_H__ # define __LOCALPOINTER_H__ # include \" unicode / utypes . h \" # if # include<memory> U_NAMESPACE_BEGIN template<T> class LocalPointerBase { public : void* U_EXPORT2 operator)",
    "insertText": "new(size_t)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (# if U_HAVE_PLACEMENT_NEW void* U_EXPORT2 operator)",
    "insertText": "new(size_t, void*)"
  },
  {
    "label": "LocalPointerBase()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "LocalPointerBase(T *p=NULL) : ptr(p)"
  },
  {
    "label": "LocalPointerBase()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "LocalPointerBase()"
  },
  {
    "label": "isNull()",
    "kind": "Method",
    "detail": "Function (} UBool)",
    "insertText": "isNull()"
  },
  {
    "label": "adoptInstead()",
    "kind": "Method",
    "detail": "Function (T* p = ptr ; ptr = NULL ; return p ; } void)",
    "insertText": "adoptInstead(T *p)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ptr = p ; } protected : T* ptr ; private : bool)",
    "insertText": "operator(const LocalPointerBase<T> &other)"
  },
  {
    "label": "LocalPointerBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LocalPointerBase(const LocalPointerBase<T> &other)"
  },
  {
    "label": "LocalPointer()",
    "kind": "Method",
    "detail": "Function (} ; template<T> class LocalPointer : public LocalPointerBase<T> { public : using LocalPointerBase<T>::operator* ; using LocalPointerBase<T>::operator -> ;)",
    "insertText": "LocalPointer(T *p=NULL) : LocalPointerBase<T>(p)"
  },
  {
    "label": "LocalPointer()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "LocalPointer(T *p, UErrorCode &errorCode) : LocalPointerBase<T>(p)"
  },
  {
    "label": "LocalPointer()",
    "kind": "Method",
    "detail": "Function (errorCode = U_MEMORY_ALLOCATION_ERROR ; } })",
    "insertText": "LocalPointer(LocalPointer<T> &&src) U_NOEXCEPT : LocalPointerBase<T>(src.ptr)"
  },
  {
    "label": "LocalPointer()",
    "kind": "Method",
    "detail": "Function (src . ptr = NULL ; } # ifndef)",
    "insertText": "LocalPointer(std::unique_ptr<T> &&p) : LocalPointerBase<T>(p.release())"
  },
  {
    "label": "LocalPointer()",
    "kind": "Method",
    "detail": "Function (} # endif ~)",
    "insertText": "LocalPointer()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (delete LocalPointerBase<T>::ptr ; } LocalPointer<T>&)",
    "insertText": "operator(LocalPointer<T> &&src)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (delete LocalPointerBase<T>::ptr ; LocalPointerBase<T>::ptr = src . ptr ; src . ptr = NULL ; return* this ; } # ifndef LocalPointer<T>&)",
    "insertText": "operator(std::unique_ptr<T> &&p)"
  },
  {
    "label": "adoptInstead()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "adoptInstead(p.release())"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (T* temp = LocalPointerBase<T>::ptr ; LocalPointerBase<T>::ptr = other . ptr ; other . ptr = temp ; } void)",
    "insertText": "swap(LocalPointer<T> &p1, LocalPointer<T> &p2)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (p1 .)",
    "insertText": "swap(p2)"
  },
  {
    "label": "adoptInsteadAndCheckErrorCode()",
    "kind": "Method",
    "detail": "Function (delete LocalPointerBase<T>::ptr ; LocalPointerBase<T>::ptr = p ; } void)",
    "insertText": "adoptInsteadAndCheckErrorCode(T *p, UErrorCode &errorCode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (delete LocalPointerBase<T>::ptr ; LocalPointerBase<T>::ptr = p ;)",
    "insertText": "if(p==NULL)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (errorCode = U_MEMORY_ALLOCATION_ERROR ; } } else { delete p ; } } # ifndef operator std::unique_ptr<)",
    "insertText": "T()"
  },
  {
    "label": "LocalArray()",
    "kind": "Method",
    "detail": "Function (} # endif } ; template<T> class LocalArray : public LocalPointerBase<T> { public : using LocalPointerBase<T>::operator* ; using LocalPointerBase<T>::operator -> ;)",
    "insertText": "LocalArray(T *p=NULL) : LocalPointerBase<T>(p)"
  },
  {
    "label": "LocalArray()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "LocalArray(T *p, UErrorCode &errorCode) : LocalPointerBase<T>(p)"
  },
  {
    "label": "LocalArray()",
    "kind": "Method",
    "detail": "Function (errorCode = U_MEMORY_ALLOCATION_ERROR ; } })",
    "insertText": "LocalArray(LocalArray<T> &&src) U_NOEXCEPT : LocalPointerBase<T>(src.ptr)"
  },
  {
    "label": "LocalArray()",
    "kind": "Method",
    "detail": "Function (src . ptr = NULL ; } # ifndef)",
    "insertText": "LocalArray(std::unique_ptr<T[]> &&p) : LocalPointerBase<T>(p.release())"
  },
  {
    "label": "LocalArray()",
    "kind": "Method",
    "detail": "Function (} # endif ~)",
    "insertText": "LocalArray()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (delete [ ] LocalPointerBase<T>::ptr ; } LocalArray<T>&)",
    "insertText": "operator(LocalArray<T> &&src)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (delete [ ] LocalPointerBase<T>::ptr ; LocalPointerBase<T>::ptr = src . ptr ; src . ptr = NULL ; return* this ; } # ifndef LocalArray<T>&)",
    "insertText": "operator(std::unique_ptr<T[]> &&p)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (T* temp = LocalPointerBase<T>::ptr ; LocalPointerBase<T>::ptr = other . ptr ; other . ptr = temp ; } void)",
    "insertText": "swap(LocalArray<T> &p1, LocalArray<T> &p2)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (errorCode = U_MEMORY_ALLOCATION_ERROR ; } } else { delete [ ] p ; } } T&)",
    "insertText": "operator(ptrdiff_t i)"
  },
  {
    "label": "U_DEFINE_LOCAL_OPEN_POINTER()",
    "kind": "Method",
    "detail": "Function (} # endif } ; # define)",
    "insertText": "U_DEFINE_LOCAL_OPEN_POINTER(LocalPointerClassName, Type, closeFunction)"
  },
  {
    "label": "LocalPointerClassName()",
    "kind": "Method",
    "detail": "Function (\\ public : \\ using LocalPointerBase<Type>::operator* ; \\ using LocalPointerBase<Type>::operator -> ; \\)",
    "insertText": "LocalPointerClassName(Type *p=NULL) : LocalPointerBase<Type>(p)"
  },
  {
    "label": "LocalPointerClassName()",
    "kind": "Method",
    "detail": "Function (} \\)",
    "insertText": "LocalPointerClassName(LocalPointerClassName &&src) U_NOEXCEPT \\ : LocalPointerBase<Type>(src.ptr)"
  },
  {
    "label": "LocalPointerClassName()",
    "kind": "Method",
    "detail": "Function (\\ src . ptr = NULL ; \\ } \\ \\)",
    "insertText": "LocalPointerClassName(std::unique_ptr<Type, decltype(&closeFunction)> &&p) \\ : LocalPointerBase<Type>(p.release())"
  },
  {
    "label": "LocalPointerClassName()",
    "kind": "Method",
    "detail": "Function (} \\ ~)",
    "insertText": "LocalPointerClassName()"
  },
  {
    "label": "closeFunction()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "closeFunction(ptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } \\ LocalPointerClassName&)",
    "insertText": "operator(LocalPointerClassName &&src)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(ptr != NULL)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} \\ LocalPointerBase<Type>::ptr = src . ptr ; \\ src . ptr = NULL ; \\ return* this ; \\ } \\ \\ LocalPointerClassName&)",
    "insertText": "operator(std::unique_ptr<Type, decltype(&closeFunction)> &&p)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (\\ return* this ; \\ } \\ void)",
    "insertText": "swap(LocalPointerClassName &other)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (\\ Type* temp = LocalPointerBase<Type>::ptr ; \\ LocalPointerBase<Type>::ptr = other . ptr ; \\ other . ptr = temp ; \\ } \\ void)",
    "insertText": "swap(LocalPointerClassName &p1, LocalPointerClassName &p2)"
  },
  {
    "label": "adoptInstead()",
    "kind": "Method",
    "detail": "Function (\\ } \\ void)",
    "insertText": "adoptInstead(Type *p)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} \\ ptr = p ; \\ } \\ operator std::unique_ptr<Type,)",
    "insertText": "decltype(&closeFunction)> ()"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (\\ return std::unique_ptr<Type,)",
    "insertText": "decltype(&closeFunction)>(LocalPointerBase<Type>::orphan(), closeFunction)"
  }
]