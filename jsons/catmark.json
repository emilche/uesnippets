[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "HbrCatmarkSubdivision",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrCatmarkSubdivision"
  },
  {
    "label": "TriangleSubdivision",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "TriangleSubdivision"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENSUBDIV3_HBRCATMARK_H # define OPENSUBDIV3_HBRCATMARK_H # include \" . . / hbr / subdivision . h \" # include \" . . / version . h \" namespace OpenSubdiv { namespace OPENSUBDIV_VERSION { template<class T> class HbrCatmarkSubdivision : public HbrSubdivision<T> { public : HbrCatmarkSubdivision<)",
    "insertText": "T() : HbrSubdivision<T>(), triangleSubdivision(k_Normal)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} HbrCatmarkSubdivision<)",
    "insertText": "T(const HbrCatmarkSubdivision<T> &old) : HbrSubdivision<T>(), triangleSubdivision(old.triangleSubdivision)"
  },
  {
    "label": "Clone()",
    "kind": "Method",
    "detail": "Function (} HbrSubdivision<T>*)",
    "insertText": "Clone()"
  },
  {
    "label": "Refine()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Refine(HbrMesh<T>* mesh, HbrFace<T>* face)"
  },
  {
    "label": "RefineFaceAtVertex()",
    "kind": "Method",
    "detail": "Function (HbrFace<T>*)",
    "insertText": "RefineFaceAtVertex(HbrMesh<T>* mesh, HbrFace<T>* face, HbrVertex<T>* vertex)"
  },
  {
    "label": "GuaranteeNeighbor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GuaranteeNeighbor(HbrMesh<T>* mesh, HbrHalfedge<T>* edge)"
  },
  {
    "label": "GuaranteeNeighbors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GuaranteeNeighbors(HbrMesh<T>* mesh, HbrVertex<T>* vertex)"
  },
  {
    "label": "HasLimit()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasLimit(HbrMesh<T>* mesh, HbrFace<T>* face)"
  },
  {
    "label": "HasLimit()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasLimit(HbrMesh<T>* mesh, HbrHalfedge<T>* edge)"
  },
  {
    "label": "HasLimit()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasLimit(HbrMesh<T>* mesh, HbrVertex<T>* vertex)"
  },
  {
    "label": "Subdivide()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>*)",
    "insertText": "Subdivide(HbrMesh<T>* mesh, HbrFace<T>* face)"
  },
  {
    "label": "Subdivide()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>*)",
    "insertText": "Subdivide(HbrMesh<T>* mesh, HbrHalfedge<T>* edge)"
  },
  {
    "label": "Subdivide()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>*)",
    "insertText": "Subdivide(HbrMesh<T>* mesh, HbrVertex<T>* vertex)"
  },
  {
    "label": "VertexIsExtraordinary()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "VertexIsExtraordinary(HbrMesh<T> const * , HbrVertex<T>* vertex)"
  },
  {
    "label": "FaceIsExtraordinary()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "FaceIsExtraordinary(HbrMesh<T> const* , HbrFace<T>* face)"
  },
  {
    "label": "GetTriangleSubdivisionMethod()",
    "kind": "Method",
    "detail": "Function (} enum TriangleSubdivision { k_Normal,k_Old,k_New } ; TriangleSubdivision)",
    "insertText": "GetTriangleSubdivisionMethod()"
  },
  {
    "label": "GetFaceChildrenCount()",
    "kind": "Method",
    "detail": "Function (triangleSubdivision = method ; } int)",
    "insertText": "GetFaceChildrenCount(int nvertices)"
  },
  {
    "label": "transferEditsToChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transferEditsToChild(HbrFace<T>* face, HbrFace<T>* child, int index)"
  },
  {
    "label": "transferFVarToChild()",
    "kind": "Method",
    "detail": "Function (TriangleSubdivision triangleSubdivision ; } ; template<class T> void HbrCatmarkSubdivision<T)",
    "insertText": "transferFVarToChild(HbrMesh<T>* mesh, HbrFace<T>* face, HbrFace<T>* child, int index)"
  },
  {
    "label": "GetFVarInterpolateBoundaryMethod()",
    "kind": "Method",
    "detail": "Function (HbrMesh<T>::InterpolateBoundaryMethod fvarinterp = mesh ->)",
    "insertText": "GetFVarInterpolateBoundaryMethod()"
  },
  {
    "label": "GetFVarCount()",
    "kind": "Method",
    "detail": "Function (const int fvarcount = mesh ->)",
    "insertText": "GetFVarCount()"
  },
  {
    "label": "GetNumVertices()",
    "kind": "Method",
    "detail": "Function (int fvarindex = 0 ; const int nv = face ->)",
    "insertText": "GetNumVertices()"
  },
  {
    "label": "extraordinary()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "extraordinary(nv != 4)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>* v = face ->)",
    "insertText": "GetVertex(index)"
  },
  {
    "label": "GetFVarData()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* edge ; float weight = 1 . 0 f / nv ; HbrFVarData<T>& fv2 = child ->)",
    "insertText": "GetFVarData(extraordinary ? 2 : (index+2)%4)"
  },
  {
    "label": "GetTotalFVarWidth()",
    "kind": "Method",
    "detail": "Function (const int totalfvarwidth = mesh ->)",
    "insertText": "GetTotalFVarWidth()"
  },
  {
    "label": "ClearAll()",
    "kind": "Method",
    "detail": "Function (fv2 .)",
    "insertText": "ClearAll(totalfvarwidth)"
  },
  {
    "label": "AddWithWeightAll()",
    "kind": "Method",
    "detail": "Function (fv2 .)",
    "insertText": "AddWithWeightAll(face->GetFVarData(j), totalfvarwidth, weight)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "assert(fv2.IsInitialized())"
  },
  {
    "label": "GuaranteeNeighbors()",
    "kind": "Method",
    "detail": "Function (v ->)",
    "insertText": "GuaranteeNeighbors()"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (bool fv0IsSmooth,fv1IsSmooth,fv3IsSmooth ; childVertex = child ->)",
    "insertText": "GetVertex(extraordinary ? 0 : (index+0)%4)"
  },
  {
    "label": "IsFVarAllSmooth()",
    "kind": "Method",
    "detail": "Function (fv0IsSmooth = v ->)",
    "insertText": "IsFVarAllSmooth()"
  },
  {
    "label": "NewFVarData()",
    "kind": "Method",
    "detail": "Function (childVertex ->)",
    "insertText": "NewFVarData(child)"
  },
  {
    "label": "GetFVarData()",
    "kind": "Method",
    "detail": "Function (} HbrFVarData<T>& fv0 = childVertex ->)",
    "insertText": "GetFVarData(child)"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (edge = face ->)",
    "insertText": "GetEdge(index)"
  },
  {
    "label": "GuaranteeNeighbor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GuaranteeNeighbor(mesh, edge)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(edge->GetOrgVertex() == v)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (childVertex = child ->)",
    "insertText": "GetVertex(extraordinary ? 1 : (index+1)%4)"
  },
  {
    "label": "IsFVarInfiniteSharpAnywhere()",
    "kind": "Method",
    "detail": "Function (fv1IsSmooth = ! edge ->)",
    "insertText": "IsFVarInfiniteSharpAnywhere()"
  },
  {
    "label": "GetPrev()",
    "kind": "Method",
    "detail": "Function (edge = edge ->)",
    "insertText": "GetPrev()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(edge == face->GetEdge((index + nv - 1) % nv))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(edge->GetDestVertex() == v)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (childVertex = child ->)",
    "insertText": "GetVertex(extraordinary ? 3 : (index+3)%4)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (fvarindex = 0 ;)",
    "insertText": "for(int fvaritem = 0; fvaritem < fvarcount; ++fvaritem)"
  },
  {
    "label": "GetFVarWidths()",
    "kind": "Method",
    "detail": "Function (bool infcorner = false ; const int fvarwidth = mesh ->)",
    "insertText": "GetFVarWidths()"
  },
  {
    "label": "GetFVarMask()",
    "kind": "Method",
    "detail": "Function (const unsigned char fvarmask = v ->)",
    "insertText": "GetFVarMask(fvaritem)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (infcorner = true ; } else)",
    "insertText": "if(mesh->GetFVarPropagateCorners())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (infcorner = true ; } } else {)",
    "insertText": "if(face->GetEdge(index)->GetFVarSharpness(fvaritem, true) && face->GetEdge(index)->GetPrev()->GetFVarSharpness(fvaritem, true))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (infcorner = true ; } } })",
    "insertText": "if(fvarinterp == HbrMesh<T>::k_InterpolateBoundaryNone || (fvarinterp == HbrMesh<T>::k_InterpolateBoundaryAlwaysSharp && fvarmask >= 1) || v->GetSharpness() > HbrVertex<T>::k_Smooth || infcorner)"
  },
  {
    "label": "SetWithWeight()",
    "kind": "Method",
    "detail": "Function (fv0 .)",
    "insertText": "SetWithWeight(face->GetFVarData(index), fvarindex, fvarwidth, 1.0f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(fvarmask == 1)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!v->OnBoundary())"
  },
  {
    "label": "SetWithWeight()",
    "kind": "Method",
    "detail": "Function (fv0 .)",
    "insertText": "SetWithWeight(face->GetFVarData(index), fvarindex, fvarwidth, 0.75f)"
  },
  {
    "label": "GetIncidentEdge()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* start = v ->)",
    "insertText": "GetIncidentEdge()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (edge = start ;)",
    "insertText": "while(edge)"
  },
  {
    "label": "GetNextEdge()",
    "kind": "Method",
    "detail": "Function (break ; } nextedge = v ->)",
    "insertText": "GetNextEdge(edge)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } else)",
    "insertText": "if(!nextedge)"
  },
  {
    "label": "GetDestVertex()",
    "kind": "Method",
    "detail": "Function (break ; } else { edge = nextedge ; } } HbrVertex<T>* w = edge ->)",
    "insertText": "GetDestVertex()"
  },
  {
    "label": "GetLeftFace()",
    "kind": "Method",
    "detail": "Function (HbrFace<T>* bestface = edge ->)",
    "insertText": "GetLeftFace()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int j ;)",
    "insertText": "for(j = 0; j < bestface->GetNumVertices(); ++j)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "assert(j != bestface->GetNumVertices())"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv0 .)",
    "insertText": "AddWithWeight(bestface->GetFVarData(j), fvarindex, fvarwidth, 0.125f)"
  },
  {
    "label": "GetRightFace()",
    "kind": "Method",
    "detail": "Function (bestface = edge ->)",
    "insertText": "GetRightFace()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(fvarmask != 0)"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (HbrFace<T>* bestface = face ; HbrHalfedge<T>* bestedge = face ->)",
    "insertText": "GetEdge(index)->GetPrev()"
  },
  {
    "label": "GetOpposite()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* starte = bestedge ->)",
    "insertText": "GetOpposite()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>* w = 0 ;)",
    "insertText": "if(!starte)"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (w = face ->)",
    "insertText": "GetEdge(index)->GetPrev()->GetOrgVertex()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (} else { HbrHalfedge<T>* e = starte,* next ;)",
    "insertText": "assert(starte->GetOrgVertex() == v)"
  },
  {
    "label": "GetNextEdge()",
    "kind": "Method",
    "detail": "Function (bestedge = e ; break ; } next = v ->)",
    "insertText": "GetNextEdge(e)"
  },
  {
    "label": "GetPrev()",
    "kind": "Method",
    "detail": "Function (w = e ->)",
    "insertText": "GetPrev()->GetOrgVertex()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (break ; } e = next ; })",
    "insertText": "while(e && e != starte)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!w) w = bestedge->GetDestVertex()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (starte = bestedge ; w = 0 ;)",
    "insertText": "if(HbrHalfedge<T>* e = starte)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (bestedge = e ; break ; })",
    "insertText": "assert(e->GetOpposite())"
  },
  {
    "label": "GetPreviousEdge()",
    "kind": "Method",
    "detail": "Function (e = v ->)",
    "insertText": "GetPreviousEdge(e)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(!fv0IsSmooth || !fv0.IsInitialized())"
  },
  {
    "label": "GetValence()",
    "kind": "Method",
    "detail": "Function (int valence = v ->)",
    "insertText": "GetValence()"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (float invvalencesquared = 1 . 0)",
    "insertText": "f(valence * valence)"
  },
  {
    "label": "SetWithWeight()",
    "kind": "Method",
    "detail": "Function (fv0 .)",
    "insertText": "SetWithWeight(face->GetFVarData(index), fvarindex, fvarwidth, invvalencesquared * valence * (valence - 2))"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv0 .)",
    "insertText": "AddWithWeight(g->GetFVarData(j), fvarindex, fvarwidth, weight)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv0 .)",
    "insertText": "AddWithWeight(g->GetFVarData((j + 1) % g->GetNumVertices()), fvarindex, fvarwidth, invvalencesquared)"
  },
  {
    "label": "SetWithWeight()",
    "kind": "Method",
    "detail": "Function (fv1 .)",
    "insertText": "SetWithWeight(face->GetFVarData(index), fvarindex, fvarwidth, 0.5f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv1 .)",
    "insertText": "AddWithWeight(face->GetFVarData((index + 1) % nv), fvarindex, fvarwidth, 0.5f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(!fv1IsSmooth || !fv1.IsInitialized())"
  },
  {
    "label": "SetWithWeight()",
    "kind": "Method",
    "detail": "Function (fv1 .)",
    "insertText": "SetWithWeight(face->GetFVarData(index), fvarindex, fvarwidth, 0.25f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv1 .)",
    "insertText": "AddWithWeight(face->GetFVarData((index + 1) % nv), fvarindex, fvarwidth, 0.25f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv1 .)",
    "insertText": "AddWithWeight(fv2, fvarindex, fvarwidth, 0.25f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv1 .)",
    "insertText": "AddWithWeight(oppFace->GetFVarData(j), fvarindex, fvarwidth, weight)"
  },
  {
    "label": "SetWithWeight()",
    "kind": "Method",
    "detail": "Function (fv3 .)",
    "insertText": "SetWithWeight(face->GetFVarData((index + nv - 1) % nv), fvarindex, fvarwidth, 0.5f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv3 .)",
    "insertText": "AddWithWeight(face->GetFVarData(index), fvarindex, fvarwidth, 0.5f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(!fv3IsSmooth || !fv3.IsInitialized())"
  },
  {
    "label": "SetWithWeight()",
    "kind": "Method",
    "detail": "Function (fv3 .)",
    "insertText": "SetWithWeight(face->GetFVarData((index + nv - 1) % nv), fvarindex, fvarwidth, 0.25f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv3 .)",
    "insertText": "AddWithWeight(face->GetFVarData(index), fvarindex, fvarwidth, 0.25f)"
  },
  {
    "label": "SetInitialized()",
    "kind": "Method",
    "detail": "Function (} } fvarindex + = fvarwidth ; } fv0 .)",
    "insertText": "SetInitialized()"
  },
  {
    "label": "SetHole()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "SetHole(face->IsHole())"
  },
  {
    "label": "SetHierarchicalEdits()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "SetHierarchicalEdits(edits)"
  },
  {
    "label": "GetFirstEdge()",
    "kind": "Method",
    "detail": "Function (HbrFace<T>* child ; HbrVertex<T>* vertices [ 4 ] ; HbrHalfedge<T>* edge = face ->)",
    "insertText": "GetFirstEdge()"
  },
  {
    "label": "GetOrgVertex()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" Kid \"<<i<<\" \\ n \" ; # endif HbrVertex<T>* vertex = edge ->)",
    "insertText": "GetOrgVertex()"
  },
  {
    "label": "Subdivide()",
    "kind": "Method",
    "detail": "Function (vertices [ 0 ] = vertex ->)",
    "insertText": "Subdivide()"
  },
  {
    "label": "vertices()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vertices(i+1)%4] = edge->Subdivide()"
  },
  {
    "label": "vertices()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vertices(i+2)%4] = face->Subdivide()"
  },
  {
    "label": "vertices()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vertices(i+3)%4] = prevedge->Subdivide()"
  },
  {
    "label": "NewFace()",
    "kind": "Method",
    "detail": "Function (} child = mesh ->)",
    "insertText": "NewFace(4, vertices, face, i)"
  },
  {
    "label": "Subdivide()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" Creating face \"<<* child<<\" during refine \\ n \" ; # endif childedge = vertex ->)",
    "insertText": "Subdivide()->GetEdge(edge->Subdivide())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(childedge)"
  },
  {
    "label": "SubdivideCreaseWeight()",
    "kind": "Method",
    "detail": "Function (HbrSubdivision<T)",
    "insertText": "SubdivideCreaseWeight(edge, edge->GetOrgVertex(), childedge)"
  },
  {
    "label": "CopyFVarInfiniteSharpness()",
    "kind": "Method",
    "detail": "Function (} childedge ->)",
    "insertText": "CopyFVarInfiniteSharpness(edge)"
  },
  {
    "label": "Subdivide()",
    "kind": "Method",
    "detail": "Function (childedge = prevedge ->)",
    "insertText": "Subdivide()->GetEdge(vertex->Subdivide())"
  },
  {
    "label": "SubdivideCreaseWeight()",
    "kind": "Method",
    "detail": "Function (HbrSubdivision<T)",
    "insertText": "SubdivideCreaseWeight(prevedge, prevedge->GetDestVertex(), childedge)"
  },
  {
    "label": "CopyFVarInfiniteSharpness()",
    "kind": "Method",
    "detail": "Function (} childedge ->)",
    "insertText": "CopyFVarInfiniteSharpness(prevedge)"
  },
  {
    "label": "transferFVarToChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transferFVarToChild(mesh, face, child, i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(face->GetNumVertices() != 4 && face->GetPtexIndex() != -1)"
  },
  {
    "label": "SetPtexIndex()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "SetPtexIndex(face->GetPtexIndex() + i)"
  },
  {
    "label": "transferEditsToChild()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "transferEditsToChild(face, child, i)"
  },
  {
    "label": "GetNext()",
    "kind": "Method",
    "detail": "Function (} prevedge = edge ; edge = edge ->)",
    "insertText": "GetNext()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (HbrFace<T>* child ; HbrVertex<T>* vertices [ 4 ] ;)",
    "insertText": "if(extraordinary)"
  },
  {
    "label": "GetDestVertex()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* parentEdge = edge ->)",
    "insertText": "GetDestVertex()->GetParentEdge()"
  },
  {
    "label": "GetDestVertex()",
    "kind": "Method",
    "detail": "Function (destParentWasEdge = false ; parentFace = edge ->)",
    "insertText": "GetDestVertex()->GetParentFace()"
  },
  {
    "label": "GetOrgVertex()",
    "kind": "Method",
    "detail": "Function (parentEdge = edge ->)",
    "insertText": "GetOrgVertex()->GetParentEdge()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(parentFace)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "assert(parentEdge && parentEdge->GetFace() == parentFace)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" \\ nparent edge is \"<<* parentEdge<<\" \\ n \" ; # endif)",
    "insertText": "if(destParentWasEdge)"
  },
  {
    "label": "RefineFaceAtVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefineFaceAtVertex(mesh, parentFace, parentEdge->GetOrgVertex())"
  },
  {
    "label": "RefineFaceAtVertex()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "RefineFaceAtVertex(mesh, parentFace, parentEdge->GetDestVertex())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "assert(edge->GetOpposite())"
  },
  {
    "label": "GetOrgVertex()",
    "kind": "Method",
    "detail": "Function (} else { HbrVertex<T>* parentVertex = edge ->)",
    "insertText": "GetOrgVertex()->GetParentVertex()"
  },
  {
    "label": "GetDestVertex()",
    "kind": "Method",
    "detail": "Function (parentVertex = edge ->)",
    "insertText": "GetDestVertex()->GetParentVertex()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(parentVertex)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(parentEdge)"
  },
  {
    "label": "GetFace()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" \\ nparent edge is \"<<* parentEdge<<\" \\ n \" ; # endif parentFace = edge ->)",
    "insertText": "GetFace()->GetParent()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(parentEdge->GetFace() == parentFace)"
  },
  {
    "label": "GuaranteeNeighbor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GuaranteeNeighbor(mesh, parentEdge)"
  },
  {
    "label": "RefineFaceAtVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefineFaceAtVertex(mesh, parentEdge->GetRightFace(), parentVertex)"
  },
  {
    "label": "GetParentFace()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" \\ n \\ nneighbor guarantee at \"<<* vertex<<\" invoked \\ n \" ; # endif HbrFace<T>* parentFace = vertex ->)",
    "insertText": "GetParentFace()"
  },
  {
    "label": "Refine()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" forcing full refine on parent face \\ n \" ; # endif)",
    "insertText": "Refine(mesh, parentFace)"
  },
  {
    "label": "RefineFaceAtVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefineFaceAtVertex(mesh, parentFace, dest)"
  },
  {
    "label": "RefineFaceAtVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefineFaceAtVertex(mesh, parentFace, org)"
  },
  {
    "label": "GetParentVertex()",
    "kind": "Method",
    "detail": "Function (} # ifdef HBR_DEBUG std::cerr<<\" end force \\ n \" ; # endif return ; } HbrVertex<T>* parentVertex = vertex ->)",
    "insertText": "GetParentVertex()"
  },
  {
    "label": "RefineFaceAtVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefineFaceAtVertex(mesh, f, parentVertex)"
  },
  {
    "label": "HasLimit()",
    "kind": "Method",
    "detail": "Function (} template<class T> bool HbrCatmarkSubdivision<T)",
    "insertText": "HasLimit(HbrMesh<T>* , HbrVertex<T>* vertex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case HbrVertex<T>::k_Crease : case HbrVertex<T>::k_Corner : default :)",
    "insertText": "if(vertex->IsVolatile())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } else)",
    "insertText": "if(!next)"
  },
  {
    "label": "NewVertex()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>* v = mesh ->)",
    "insertText": "NewVertex()"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (T& data = v ->)",
    "insertText": "GetData()"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (} data .)",
    "insertText": "AddWithWeight(w->GetData(), weight)"
  },
  {
    "label": "AddVaryingWithWeight()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "AddVaryingWithWeight(w->GetData(), weight)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # ifdef HBR_DEBUG std::cerr<<\" Subdividing at \"<<* face<<\" \\ n \" ; # endif)",
    "insertText": "if(nv != 4) v->SetExtraordinary()"
  },
  {
    "label": "OldTriangleSubdivide()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" created \"<<* v<<\" \\ n \" ; # endif return v ; } # if 0 template<class T> HbrVertex<T>* HbrCatmarkSubdivision<T)",
    "insertText": "OldTriangleSubdivide(HbrMesh<T>* mesh, HbrFace<T>* face)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(face->GetNumVertices() == 3 && triangleSubdivision == k_Old)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "Clear()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (float weight = 1 . 0 f / 6 . 0 f ;)",
    "insertText": "for(int i = 0; i < 3; ++i)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>* w = face ->)",
    "insertText": "GetVertex(i)"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* e = face ->)",
    "insertText": "GetEdge(i)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "AddWithWeight(w->Subdivide()->GetData(), weight)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "AddWithWeight(e->Subdivide()->GetData(), weight)"
  },
  {
    "label": "GetSharpness()",
    "kind": "Method",
    "detail": "Function (float esharp = edge ->)",
    "insertText": "GetSharpness()"
  },
  {
    "label": "edge()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" Subdividing at \"<<*)",
    "insertText": "edge(sharpness = \" << esharp << \")"
  },
  {
    "label": "GetOrgVertex()",
    "kind": "Method",
    "detail": "Function (edge ->)",
    "insertText": "GetOrgVertex()->GuaranteeNeighbors()"
  },
  {
    "label": "GetDestVertex()",
    "kind": "Method",
    "detail": "Function (edge ->)",
    "insertText": "GetDestVertex()->GuaranteeNeighbors()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!edge->IsBoundary() && esharp <= 1.0f)"
  },
  {
    "label": "leftWeight()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "leftWeight(triangleSubdivision == k_New && lf->GetNumVertices() == 3)"
  },
  {
    "label": "rightWeight()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rightWeight(triangleSubdivision == k_New && rf->GetNumVertices() == 3)"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (faceWeight = 0 . 5)",
    "insertText": "f(leftWeight + rightWeight)"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (vertWeight = 0 . 5)",
    "insertText": "f(1.0f - 2.0f * faceWeight)"
  },
  {
    "label": "faceWeight()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "faceWeight(1.0f - esharp)"
  },
  {
    "label": "esharp()",
    "kind": "Method",
    "detail": "Function (vertWeight = 0 . 5 f*)",
    "insertText": "esharp(1.0f - esharp)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "AddWithWeight(edge->GetOrgVertex()->GetData(), vertWeight)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "AddWithWeight(edge->GetDestVertex()->GetData(), vertWeight)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "AddWithWeight(lf->Subdivide()->GetData(), faceWeight)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "AddWithWeight(rf->Subdivide()->GetData(), faceWeight)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (} else { data .)",
    "insertText": "AddWithWeight(edge->GetOrgVertex()->GetData(), 0.5f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "AddWithWeight(edge->GetDestVertex()->GetData(), 0.5f)"
  },
  {
    "label": "AddVaryingWithWeight()",
    "kind": "Method",
    "detail": "Function (} data .)",
    "insertText": "AddVaryingWithWeight(edge->GetOrgVertex()->GetData(), 0.5f)"
  },
  {
    "label": "AddVaryingWithWeight()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "AddVaryingWithWeight(edge->GetDestVertex()->GetData(), 0.5f)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (float valence = static_cast<)",
    "insertText": "float(vertex->GetValence())"
  },
  {
    "label": "GetMask()",
    "kind": "Method",
    "detail": "Function (int masks [ 2 ] ; float weights [ 2 ] ; int passes ; masks [ 0 ] = vertex ->)",
    "insertText": "GetMask(false)"
  },
  {
    "label": "GetMask()",
    "kind": "Method",
    "detail": "Function (masks [ 1 ] = vertex ->)",
    "insertText": "GetMask(true)"
  },
  {
    "label": "GetFractionalMask()",
    "kind": "Method",
    "detail": "Function (weights [ 1 ] = vertex ->)",
    "insertText": "GetFractionalMask()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (weights [ 0 ] = 1 . 0 f - weights [ 1 ] ; passes = 2 ; } else { weights [ 0 ] = 1 . 0 f ; weights [ 1 ] = 0 . 0 f ; passes = 1 ; })",
    "insertText": "for(int i = 0; i < passes; ++i)"
  },
  {
    "label": "AddSurroundingVerticesWithWeight()",
    "kind": "Method",
    "detail": "Function (HbrSubdivision<T)",
    "insertText": "AddSurroundingVerticesWithWeight(mesh, vertex, weights[i] * invvalencesquared, &data)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "AddWithWeight(f->Subdivide()->GetData(), weights[i] * invvalencesquared)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (} break ; } case HbrVertex<T>::k_Crease : { data .)",
    "insertText": "AddWithWeight(vertex->GetData(), weights[i] * 0.75f)"
  },
  {
    "label": "AddCreaseEdgesWithWeight()",
    "kind": "Method",
    "detail": "Function (HbrSubdivision<T)",
    "insertText": "AddCreaseEdgesWithWeight(mesh, vertex, i == 1, weights[i] * 0.125f, &data)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (break ; } case HbrVertex<T>::k_Corner : default : { data .)",
    "insertText": "AddWithWeight(vertex->GetData(), weights[i])"
  },
  {
    "label": "AddVaryingWithWeight()",
    "kind": "Method",
    "detail": "Function (break ; } } } data .)",
    "insertText": "AddVaryingWithWeight(vertex->GetData(), 1.0f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" Subdividing at \"<<* vertex<<\" \\ n \" ; std::cerr<<\" created \"<<* v<<\" \\ n \" ; # endif)",
    "insertText": "if(vertex->IsExtraordinary()) v->SetExtraordinary()"
  },
  {
    "label": "SetSharpness()",
    "kind": "Method",
    "detail": "Function (v ->)",
    "insertText": "SetSharpness(HbrVertex<T>::k_InfinitelySharp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(sharp > HbrVertex<T>::k_Smooth)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (sharp - = 1 . 0 f ;)",
    "insertText": "if(sharp < (float) HbrVertex<T>::k_Smooth)"
  },
  {
    "label": "sharp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sharp(float)"
  },
  {
    "label": "SetSharpness()",
    "kind": "Method",
    "detail": "Function (} v ->)",
    "insertText": "SetSharpness(sharp)"
  },
  {
    "label": "SetSharpness()",
    "kind": "Method",
    "detail": "Function (} else { v ->)",
    "insertText": "SetSharpness(HbrVertex<T>::k_Smooth)"
  }
]