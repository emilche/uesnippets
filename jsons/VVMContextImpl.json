[
  {
    "label": "FConservativeStackEntryFrame",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FConservativeStackEntryFrame"
  },
  {
    "label": "FConservativeStackExitFrame",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FConservativeStackExitFrame"
  },
  {
    "label": "FHandshakeContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FHandshakeContext"
  },
  {
    "label": "FHardHandshakeContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FHardHandshakeContext"
  },
  {
    "label": "FIOContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FIOContext"
  },
  {
    "label": "FIOContextScope",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FIOContextScope"
  },
  {
    "label": "FRunningContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRunningContext"
  },
  {
    "label": "FStoppedWorld",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FStoppedWorld"
  },
  {
    "label": "FThreadLocalContextHolder",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FThreadLocalContextHolder"
  },
  {
    "label": "FTransaction",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTransaction"
  },
  {
    "label": "VCell",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VCell"
  },
  {
    "label": "VValue",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VValue"
  },
  {
    "label": "VFailureContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VFailureContext"
  },
  {
    "label": "VTask",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VTask"
  },
  {
    "label": "TWriteBarrier",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TWriteBarrier"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FNativeContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FNativeContext"
  },
  {
    "label": "FContextImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FContextImpl"
  },
  {
    "label": "FAccessContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAccessContext"
  },
  {
    "label": "FAllocationContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAllocationContext"
  },
  {
    "label": "FHeap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FHeap"
  },
  {
    "label": "FScopedThreadContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FScopedThreadContext"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# pragma once # if WITH_VERSE_VM | |)",
    "insertText": "defined(__INTELLISENSE__)"
  },
  {
    "label": "FLocalAllocator()",
    "kind": "Method",
    "detail": "Function (struct FConservativeStackEntryFrame ; struct FConservativeStackExitFrame ; struct FHandshakeContext ; struct FHardHandshakeContext ; struct FIOContext ; struct FIOContextScope ; struct FRunningContext ; struct FStoppedWorld ; struct FThreadLocalContextHolder ; struct FTransaction ; struct VCell ; struct VValue ; struct VFailureContext ; struct VTask ; template<T> struct TWriteBarrier ; typedef std::array<)",
    "insertText": "FLocalAllocator(416 >> VERSE_HEAP_MIN_ALIGN_SHIFT)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (enum class EContextHeapRole { Mutator,Collector } ; enum class EContextLifecycleState { Free,LiveButUnused,LiveAndInUse } ; struct FNativeContext { VFailureContext* FailureContext ; VTask* Task ; bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "Commit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Commit(FRunningContext Context)"
  },
  {
    "label": "EnterConservativeStack()",
    "kind": "Method",
    "detail": "Function (} ; struct FContextImpl { typedef uint8 TState ; void)",
    "insertText": "EnterConservativeStack(TFunctionRef<void()>)"
  },
  {
    "label": "ExitConservativeStack()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExitConservativeStack(TFunctionRef<void()>)"
  },
  {
    "label": "InConservativeStack()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "InConservativeStack()"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} else { return true ; } } else {)",
    "insertText": "check(!TopExitFrame)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TState Expected = 0 ;)",
    "insertText": "if(!State.compare_exchange_weak(Expected, HasAccessBit, std::memory_order_acquire))"
  },
  {
    "label": "AcquireAccessSlow()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AcquireAccessSlow()"
  },
  {
    "label": "RelinquishAccess()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "RelinquishAccess()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TState Expected = HasAccessBit ;)",
    "insertText": "if(!State.compare_exchange_weak(Expected, 0, std::memory_order_release))"
  },
  {
    "label": "RelinquishAccessSlow()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RelinquishAccessSlow()"
  },
  {
    "label": "CheckForHandshake()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "CheckForHandshake()"
  },
  {
    "label": "atomic_signal_fence()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "atomic_signal_fence(std::memory_order_seq_cst)"
  },
  {
    "label": "RequestStop()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "RequestStop()"
  },
  {
    "label": "WaitForStop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WaitForStop()"
  },
  {
    "label": "CancelStop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CancelStop()"
  },
  {
    "label": "PairHandshake()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PairHandshake(FContextImpl* TargetContext, TFunctionRef<void(FHandshakeContext)> HandshakeAction)"
  },
  {
    "label": "SoftHandshake()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SoftHandshake(TFunctionRef<void(FHandshakeContext)> HandshakeAction)"
  },
  {
    "label": "HardHandshake()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HardHandshake(TFunctionRef<void(FHardHandshakeContext)> HandshakeAction)"
  },
  {
    "label": "StopTheWorld()",
    "kind": "Method",
    "detail": "Function (FStoppedWorld)",
    "insertText": "StopTheWorld()"
  },
  {
    "label": "IsLive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsLive()"
  },
  {
    "label": "IsHandshakeRequested()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsHandshakeRequested()"
  },
  {
    "label": "IsStopRequested()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsStopRequested()"
  },
  {
    "label": "RunWriteBarrierNonNull()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RunWriteBarrierNonNull(const VCell* Cell)"
  },
  {
    "label": "MarkNonNull()",
    "kind": "Method",
    "detail": "Function (MarkStack .)",
    "insertText": "MarkNonNull(Cell)"
  },
  {
    "label": "RunWriteBarrier()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "RunWriteBarrier(VCell* Cell)"
  },
  {
    "label": "RunWriteBarrierNonNull()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RunWriteBarrierNonNull(Cell)"
  },
  {
    "label": "RunWriteBarrierNonNullDuringMarking()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "RunWriteBarrierNonNullDuringMarking(VCell* Cell)"
  },
  {
    "label": "RunWriteBarrierDuringMarking()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RunWriteBarrierDuringMarking(VCell* Cell)"
  },
  {
    "label": "RunWeakReadBarrier()",
    "kind": "Method",
    "detail": "Function (} } VCell*)",
    "insertText": "RunWeakReadBarrier(VCell* Cell)"
  },
  {
    "label": "RunAuxWriteBarrierNonNull()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "RunAuxWriteBarrierNonNull(const void* Aux)"
  },
  {
    "label": "MarkAuxNonNull()",
    "kind": "Method",
    "detail": "Function (MarkStack .)",
    "insertText": "MarkAuxNonNull(Aux)"
  },
  {
    "label": "RunAuxWriteBarrier()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "RunAuxWriteBarrier(void* Aux)"
  },
  {
    "label": "RunAuxWriteBarrierNonNull()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RunAuxWriteBarrierNonNull(Aux)"
  },
  {
    "label": "RunAuxWriteBarrierNonNullDuringMarking()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "RunAuxWriteBarrierNonNullDuringMarking(void* Aux)"
  },
  {
    "label": "RunAuxWriteBarrierDuringMarking()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RunAuxWriteBarrierDuringMarking(void* Aux)"
  },
  {
    "label": "RunAuxWeakReadBarrier()",
    "kind": "Method",
    "detail": "Function (} } void*)",
    "insertText": "RunAuxWeakReadBarrier(void* Aux)"
  },
  {
    "label": "RunWeakReadBarrierUnmarkedWhenActive()",
    "kind": "Method",
    "detail": "Function (} } template<T,MarkFunction> T*)",
    "insertText": "RunWeakReadBarrierUnmarkedWhenActive(T* Cell, MarkFunction&& MarkFunc)"
  },
  {
    "label": "GetWeakBarrierState()",
    "kind": "Method",
    "detail": "Function (using namespace UE ; EWeakBarrierState WeakBarrierState =)",
    "insertText": "GetWeakBarrierState()"
  },
  {
    "label": "MarkFunc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MarkFunc(Cell)"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (TUniqueLock)",
    "insertText": "Lock(FHeap::Mutex)"
  },
  {
    "label": "TryAllocateFastCell()",
    "kind": "Method",
    "detail": "Function (} std::byte*)",
    "insertText": "TryAllocateFastCell(size_t NumBytes)"
  },
  {
    "label": "AllocateAuxCell()",
    "kind": "Method",
    "detail": "Function (} std::byte*)",
    "insertText": "AllocateAuxCell(size_t NumBytes)"
  },
  {
    "label": "TryAllocateAuxCell()",
    "kind": "Method",
    "detail": "Function (} std::byte*)",
    "insertText": "TryAllocateAuxCell(size_t NumBytes)"
  },
  {
    "label": "StopAllocators()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "StopAllocators()"
  },
  {
    "label": "EnableManualStackScanning()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnableManualStackScanning()"
  },
  {
    "label": "UsesManualStackScanning()",
    "kind": "Method",
    "detail": "Function (bUsesManualStackScanning = true ; } bool)",
    "insertText": "UsesManualStackScanning()"
  },
  {
    "label": "MarkReferencedCells()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MarkReferencedCells()"
  },
  {
    "label": "ClearManualStackScanRequest()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearManualStackScanRequest()"
  },
  {
    "label": "GetHeapRole()",
    "kind": "Method",
    "detail": "Function (FMarkStack MarkStack ; EContextHeapRole)",
    "insertText": "GetHeapRole()"
  },
  {
    "label": "NativeContext()",
    "kind": "Method",
    "detail": "Function (_CurrentTransaction = Transaction ; } const FNativeContext&)",
    "insertText": "NativeContext()"
  },
  {
    "label": "TransactInNewNativeContext()",
    "kind": "Method",
    "detail": "Function (template<TFunctor> void)",
    "insertText": "TransactInNewNativeContext(const TFunctor& F)"
  },
  {
    "label": "AllocateFastCell_Internal()",
    "kind": "Method",
    "detail": "Function (private : struct FAccessContext ; struct FAllocationContext ; struct FIOContext ; struct FIOContextScope ; class FHeap ; struct FRunningContext ; struct FScopedThreadContext ; struct FStoppedWorld ; struct FThreadLocalContextHolder ; struct TWriteBarrier<VValue> ; std::byte*)",
    "insertText": "AllocateFastCell_Internal(size_t NumBytes, FastAllocatorArray& Allocators, FSubspace* Subspace)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "Index(NumBytes + VERSE_HEAP_MIN_ALIGN - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (std::byte* Result ;)",
    "insertText": "if(Index >= Allocators.size())"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (Result = Subspace ->)",
    "insertText": "Allocate(NumBytes)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (} else { Result = Allocators [ Index ] .)",
    "insertText": "Allocate()"
  },
  {
    "label": "TryAllocateFastCell_Internal()",
    "kind": "Method",
    "detail": "Function (} return Result ; } std::byte*)",
    "insertText": "TryAllocateFastCell_Internal(size_t NumBytes, FastAllocatorArray& Allocators, FSubspace* Subspace)"
  },
  {
    "label": "TryAllocate()",
    "kind": "Method",
    "detail": "Function (Result = Subspace ->)",
    "insertText": "TryAllocate(NumBytes)"
  },
  {
    "label": "TryAllocate()",
    "kind": "Method",
    "detail": "Function (} else { Result = Allocators [ Index ] .)",
    "insertText": "TryAllocate()"
  },
  {
    "label": "ClaimOrAllocateContext()",
    "kind": "Method",
    "detail": "Function (} return Result ; } FContextImpl*)",
    "insertText": "ClaimOrAllocateContext(EContextHeapRole)"
  },
  {
    "label": "ReleaseContext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseContext()"
  },
  {
    "label": "FreeContextDueToThreadDeath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeContextDueToThreadDeath()"
  },
  {
    "label": "ValidateUnclaimedContext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ValidateUnclaimedContext()"
  },
  {
    "label": "ValidateContextHasEmptyStack()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ValidateContextHasEmptyStack()"
  },
  {
    "label": "FContextImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FContextImpl()"
  },
  {
    "label": "GetCurrentImpl()",
    "kind": "Method",
    "detail": "Function (FContextImpl*)",
    "insertText": "GetCurrentImpl()"
  },
  {
    "label": "CheckForHandshakeSlow()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CheckForHandshakeSlow()"
  },
  {
    "label": "RunWeakReadBarrierNonNullSlow()",
    "kind": "Method",
    "detail": "Function (VCell*)",
    "insertText": "RunWeakReadBarrierNonNullSlow(VCell* Cell)"
  },
  {
    "label": "RunAuxWeakReadBarrierNonNullSlow()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "RunAuxWeakReadBarrierNonNullSlow(void* Aux)"
  },
  {
    "label": "RequestHandshake()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RequestHandshake(TUniqueFunction<void(FHandshakeContext)>&& HandshakeAction)"
  },
  {
    "label": "AttemptHandshakeAcknowledgement()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AttemptHandshakeAcknowledgement()"
  },
  {
    "label": "WaitForHandshakeAcknowledgement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WaitForHandshakeAcknowledgement()"
  },
  {
    "label": "AcknowledgeHandshakeRequest()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AcknowledgeHandshakeRequest()"
  },
  {
    "label": "AcknowledgeHandshakeRequestWhileHoldingLock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AcknowledgeHandshakeRequestWhileHoldingLock()"
  },
  {
    "label": "ClearManualStackScanRequestWhileHoldingLock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearManualStackScanRequestWhileHoldingLock()"
  },
  {
    "label": "MakeNewNativeContext()",
    "kind": "Method",
    "detail": "Function (FNativeContext)",
    "insertText": "MakeNewNativeContext()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (EContextLifecycleState LifecycleState = EContextLifecycleState::Free ; TState HasAccessBit = 1 ; TState HandshakeRequestedBit = 2 ; TState StopRequestedBit = 4 ; std::atomic<TState> State = 0 ; size_t StopRequestCount = 0 ; bool bUsesManualStackScanning = false ; bool bManualStackScanRequested = false ; bool bIsInManuallyEmptyStack = false ; UE::FMutex StateMutex ; UE::FConditionVariable StateConditionVariable ; UE::FMutex HandshakeMutex ; TUniqueFunction<)",
    "insertText": "void(FHandshakeContext)"
  }
]