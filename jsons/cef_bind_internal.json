[
  {
    "label": "ComPtr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ComPtr"
  },
  {
    "label": "IsWeakReceiver",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsWeakReceiver"
  },
  {
    "label": "BindUnwrapTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BindUnwrapTraits"
  },
  {
    "label": "CallbackCancellationTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CallbackCancellationTraits"
  },
  {
    "label": "FunctorTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FunctorTraits"
  },
  {
    "label": "UnretainedWrapper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UnretainedWrapper"
  },
  {
    "label": "RetainedRefWrapper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RetainedRefWrapper"
  },
  {
    "label": "IgnoreResultHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IgnoreResultHelper"
  },
  {
    "label": "OwnedWrapper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OwnedWrapper"
  },
  {
    "label": "OwnedRefWrapper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OwnedRefWrapper"
  },
  {
    "label": "PassedWrapper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PassedWrapper"
  },
  {
    "label": "IsWeakMethod",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsWeakMethod"
  },
  {
    "label": "TypeList",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TypeList"
  },
  {
    "label": "DropTypeListItemImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DropTypeListItemImpl"
  },
  {
    "label": "TakeTypeListItemImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TakeTypeListItemImpl"
  },
  {
    "label": "ConcatTypeListsImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ConcatTypeListsImpl"
  },
  {
    "label": "MakeFunctionTypeImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MakeFunctionTypeImpl"
  },
  {
    "label": "ExtractArgsImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExtractArgsImpl"
  },
  {
    "label": "ExtractCallableRunTypeImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExtractCallableRunTypeImpl"
  },
  {
    "label": "IsCallableObject",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsCallableObject"
  },
  {
    "label": "HasRefCountedTypeAsRawPtr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HasRefCountedTypeAsRawPtr"
  },
  {
    "label": "ForceVoidReturn",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ForceVoidReturn"
  },
  {
    "label": "InvokeHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "InvokeHelper"
  },
  {
    "label": "Invoker",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Invoker"
  },
  {
    "label": "BindTypeHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BindTypeHelper"
  },
  {
    "label": "BindState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BindState"
  },
  {
    "label": "MakeBindStateTypeImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MakeBindStateTypeImpl"
  },
  {
    "label": "TransformToUnwrappedTypeImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TransformToUnwrappedTypeImpl"
  },
  {
    "label": "MakeUnwrappedTypeListImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MakeUnwrappedTypeListImpl"
  },
  {
    "label": "IsOnceCallback",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsOnceCallback"
  },
  {
    "label": "BindArgument",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BindArgument"
  },
  {
    "label": "ForwardedAs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ForwardedAs"
  },
  {
    "label": "ToParamWithType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ToParamWithType"
  },
  {
    "label": "BoundAs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BoundAs"
  },
  {
    "label": "StoredAs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StoredAs"
  },
  {
    "label": "AssertConstructible",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AssertConstructible"
  },
  {
    "label": "AssertBindArgsValidity",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AssertBindArgsValidity"
  },
  {
    "label": "AssertBindArgIsNotBasePassed",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AssertBindArgIsNotBasePassed"
  },
  {
    "label": "CallbackT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CallbackT"
  },
  {
    "label": "MaybeValidTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MaybeValidTraits"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef CEF_INCLUDE_BASE_INTERNAL_CEF_BIND_INTERNAL_H_ # define CEF_INCLUDE_BASE_INTERNAL_CEF_BIND_INTERNAL_H_ # include<stddef . h> # include<functional> # include<memory> # include<tuple> # include<type_traits> # include<utility> # include \" include / base / cef_build . h \" # include \" include / base / cef_compiler_specific . h \" # include \" include / base / cef_logging . h \" # include \" include / base / cef_template_util . h \" # include \" include / base / cef_weak_ptr . h \" # include \" include / base / internal / cef_callback_internal . h \" # include \" include / base / internal / cef_raw_scoped_refptr_mismatch_checker . h \" # if)",
    "insertText": "defined(OS_APPLE) && !HAS_FEATURE(objc_arc) #include \"include/base/internal/cef_scoped_block_mac.h\" #endif #if defined(OS_WIN)"
  },
  {
    "label": "UnretainedWrapper()",
    "kind": "Method",
    "detail": "Function (namespace WRL { template<> class ComPtr ; } } # endif namespace base { template<T> struct IsWeakReceiver ; template<> struct BindUnwrapTraits ; template<Functor,BoundArgsTuple,SFINAE = void> struct CallbackCancellationTraits ; namespace internal { template<Functor,SFINAE = void> struct FunctorTraits ; template<T> class UnretainedWrapper { public :)",
    "insertText": "UnretainedWrapper(T* o) : ptr_(o)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} T*)",
    "insertText": "get()"
  },
  {
    "label": "RetainedRefWrapper()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RetainedRefWrapper(scoped_refptr<T> o) : ptr_(std::move(o))"
  },
  {
    "label": "IgnoreResultHelper()",
    "kind": "Method",
    "detail": "Function (} private : scoped_refptr<T> ptr_ ; } ; template<T> struct IgnoreResultHelper {)",
    "insertText": "IgnoreResultHelper(T functor) : functor_(std::move(functor))"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "OwnedWrapper()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "OwnedWrapper(std::unique_ptr<T, Deleter>&& ptr) : ptr_(std::move(ptr))"
  },
  {
    "label": "OwnedRefWrapper()",
    "kind": "Method",
    "detail": "Function (} private : std::unique_ptr<T,Deleter> ptr_ ; } ; template<T> class OwnedRefWrapper { public :)",
    "insertText": "OwnedRefWrapper(const T& t) : t_(t)"
  },
  {
    "label": "OwnedRefWrapper()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "OwnedRefWrapper(T&& t) : t_(std::move(t))"
  },
  {
    "label": "PassedWrapper()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PassedWrapper(PassedWrapper&& other) : is_valid_(other.is_valid_), scoper_(std::move(other.scoper_))"
  },
  {
    "label": "Take()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "Take()"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (is_valid_ = false ; return)",
    "insertText": "move(scoper_)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} private : bool is_valid_ ; T scoper_ ; } ; template<T> using Unwrapper = BindUnwrapTraits<std::decay_t<T>> ; template<T>)",
    "insertText": "decltype(auto) Unwrap(T&& o)"
  },
  {
    "label": "Type()",
    "kind": "Method",
    "detail": "Function (} template<bool is_method,. . . Args> struct IsWeakMethod : std::false_type { } ; template<T,. . . Args> struct IsWeakMethod<true,T,Args . . .> : IsWeakReceiver<T> { } ; template<. . . Types> struct TypeList { } ; template<size_t n,List> struct DropTypeListItemImpl ; template<size_t n,T,. . . List> struct DropTypeListItemImpl<n,TypeList<T,List . . .>> : DropTypeListItemImpl<n - 1,TypeList<List . . .>> { } ; template<T,. . . List> struct DropTypeListItemImpl<0,TypeList<T,List . . .>> { using Type = TypeList<T,List . . .> ; } ; template<> struct DropTypeListItemImpl<0,TypeList<>> { using Type = TypeList<> ; } ; template<size_t n,List> using DropTypeListItem = DropTypeListItemImpl<n,List>::Type ; template<size_t n,List,. . . Accum> struct TakeTypeListItemImpl ; template<size_t n,T,. . . List,. . . Accum> struct TakeTypeListItemImpl<n,TypeList<T,List . . .>,Accum . . .> : TakeTypeListItemImpl<n - 1,TypeList<List . . .>,Accum . . .,T> { } ; template<T,. . . List,. . . Accum> struct TakeTypeListItemImpl<0,TypeList<T,List . . .>,Accum . . .> { using Type = TypeList<Accum . . .> ; } ; template<. . . Accum> struct TakeTypeListItemImpl<0,TypeList<>,Accum . . .> { using Type = TypeList<Accum . . .> ; } ; template<size_t n,List> using TakeTypeListItem = TakeTypeListItemImpl<n,List>::Type ; template<List1,List2> struct ConcatTypeListsImpl ; template<. . . Types1,. . . Types2> struct ConcatTypeListsImpl<TypeList<Types1 . . .>,TypeList<Types2 . . .>> { using Type = TypeList<Types1 . . .,Types2 . . .> ; } ; template<List1,List2> using ConcatTypeLists = ConcatTypeListsImpl<List1,List2>::Type ; template<R,ArgList> struct MakeFunctionTypeImpl ; template<R,. . . Args> struct MakeFunctionTypeImpl<R,TypeList<Args . . .>> { typedef R)",
    "insertText": "Type(Args...)"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (} ; template<R,ArgList> using MakeFunctionType = MakeFunctionTypeImpl<R,ArgList>::Type ; template<Signature> struct ExtractArgsImpl ; template<R,. . . Args> struct ExtractArgsImpl<)",
    "insertText": "R(Args...)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (using ReturnType = R ; using ArgsList = TypeList<Args . . .> ; } ; template<Signature> using ExtractArgs = ExtractArgsImpl<Signature>::ArgsList ; template<Signature> using ExtractReturnType = ExtractArgsImpl<Signature>::ReturnType ; template<Callable,Signature =)",
    "insertText": "decltype(&Callable::operator())"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (template<Callable,R,. . . Args> struct ExtractCallableRunTypeImpl<Callable,)",
    "insertText": "R(Callable::*)(Args...)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (using RunType =)",
    "insertText": "void(Args...)"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (} ; template<Functor,SFINAE> struct FunctorTraits ; template<Functor> struct FunctorTraits<Functor,std::enable_if_t<IsCallableObject<Functor>::value&& std::is_empty<Functor>::value>> { using RunType = ExtractCallableRunType<Functor> ; bool is_method = false ; bool is_nullable = false ; bool is_callback = false ; template<RunFunctor,. . . RunArgs> ExtractReturnType<RunType>)",
    "insertText": "Invoke(RunFunctor&& functor, RunArgs&&... args)"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (} } ; template<R,. . . Args> struct FunctorTraits<)",
    "insertText": "R(*)(Args...)"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (bool is_method = false ; bool is_nullable = true ; bool is_callback = false ; template<Function,. . . RunArgs> R)",
    "insertText": "Invoke(Function&& function, RunArgs&&... args)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } ; # if)",
    "insertText": "defined(OS_WIN) && !defined(ARCH_CPU_64_BITS) template <typename R, typename... Args> struct FunctorTraits<R(__stdcall*)(Args...)"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (bool is_method = false ; bool is_nullable = true ; bool is_callback = false ; template<. . . RunArgs> R)",
    "insertText": "Invoke(R(__stdcall* function)(Args...), RunArgs&&... args)"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (} } ; template<R,. . . Args> struct FunctorTraits<)",
    "insertText": "R(__fastcall*)(Args...)"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (bool is_method = false ; bool is_nullable = true ; bool is_callback = false ; template<. . . RunArgs> R)",
    "insertText": "Invoke(R(__fastcall* function)(Args...), RunArgs&&... args)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } ; # endif # if)",
    "insertText": "defined(OS_APPLE) #if HAS_FEATURE(objc_arc) template <typename R, typename... Args> struct FunctorTraits<R (^)(Args...)"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (bool is_method = false ; bool is_nullable = true ; bool is_callback = false ; template<BlockType,. . . RunArgs> R)",
    "insertText": "Invoke(BlockType&& block, RunArgs&&... args)"
  },
  {
    "label": "__attribute__()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__attribute__((objc_precise_lifetime)) R (^scoped_block)(Args...)"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (} } ; # else template<R,. . . Args> struct FunctorTraits<base::mac::ScopedBlock<)",
    "insertText": "R(^)(Args...)"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (base::mac::ScopedBlock<)",
    "insertText": "R(^)(Args...)> scoped_block(block)"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (} } ; # endif # endif template<R,Receiver,. . . Args> struct FunctorTraits<)",
    "insertText": "R(Receiver::*)(Args...)"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (using RunType =)",
    "insertText": "R(Receiver*, Args...)"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (bool is_method = true ; bool is_nullable = true ; bool is_callback = false ; template<Method,ReceiverPtr,. . . RunArgs> R)",
    "insertText": "Invoke(Method method, ReceiverPtr&& receiver_ptr, RunArgs&&... args)"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (using RunType =)",
    "insertText": "R(const Receiver*, Args...)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } ; # if)",
    "insertText": "defined(OS_WIN) && !defined(ARCH_CPU_64_BITS) template <typename R, typename Receiver, typename... Args> struct FunctorTraits<R (__stdcall Receiver::*)(Args...)"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (} } ; template<R,Receiver,. . . Args> struct FunctorTraits<)",
    "insertText": "R(__stdcall Receiver::*)(Args...)"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (} } ; # endif # ifdef __cpp_noexcept_function_type template<R,. . . Args> struct FunctorTraits<)",
    "insertText": "R(*)(Args...) noexcept> : FunctorTraits<R (*)(Args...)"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (} ; template<R,Receiver,. . . Args> struct FunctorTraits<)",
    "insertText": "R(Receiver::*)(Args...) noexcept> : FunctorTraits<R (Receiver::*)(Args...)"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (} ; template<R,Receiver,. . . Args> struct FunctorTraits<)",
    "insertText": "R(Receiver::*)(Args...) const noexcept> : FunctorTraits<R (Receiver::*)(Args...)"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (} ; # endif template<T> struct FunctorTraits<IgnoreResultHelper<T>> : FunctorTraits<T> { using RunType = ForceVoidReturn<FunctorTraits<T>::RunType>::RunType ; template<IgnoreResultType,. . . RunArgs> void)",
    "insertText": "Invoke(IgnoreResultType&& ignore_result_helper, RunArgs&&... args)"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (FunctorTraits<T)",
    "insertText": "Invoke(std::forward<IgnoreResultType>(ignore_result_helper).functor_, std::forward<RunArgs>(args)...)"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (bool is_method = false ; bool is_nullable = true ; bool is_callback = true ; template<CallbackType,. . . RunArgs> R)",
    "insertText": "Invoke(CallbackType&& callback, RunArgs&&... args)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(!callback.is_null())"
  },
  {
    "label": "MakeItSo()",
    "kind": "Method",
    "detail": "Function (} } ; template<Functor> using MakeFunctorTraits = FunctorTraits<std::decay_t<Functor>> ; template<bool is_weak_call,ReturnType> struct InvokeHelper ; template<ReturnType> struct InvokeHelper<false,ReturnType> { template<Functor,. . . RunArgs> ReturnType)",
    "insertText": "MakeItSo(Functor&& functor, RunArgs&&... args)"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (using Traits = MakeFunctorTraits<Functor> ; return)",
    "insertText": "Invoke(std::forward<Functor>(functor), std::forward<RunArgs>(args)...)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} } ; template<ReturnType> struct InvokeHelper<true,ReturnType> {)",
    "insertText": "static_assert(std::is_void<ReturnType>::value, \"weak_ptrs can only bind to methods without return values\")"
  },
  {
    "label": "MakeItSo()",
    "kind": "Method",
    "detail": "Function (template<Functor,BoundWeakPtr,. . . RunArgs> void)",
    "insertText": "MakeItSo(Functor&& functor, BoundWeakPtr&& weak_ptr, RunArgs&&... args)"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (using Traits = MakeFunctorTraits<Functor> ;)",
    "insertText": "Invoke(std::forward<Functor>(functor), std::forward<BoundWeakPtr>(weak_ptr), std::forward<RunArgs>(args)...)"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (} } ; template<StorageType,UnboundRunType> struct Invoker ; template<StorageType,R,. . . UnboundArgs> struct Invoker<StorageType,)",
    "insertText": "R(UnboundArgs...)"
  },
  {
    "label": "RunOnce()",
    "kind": "Method",
    "detail": "Function (R)",
    "insertText": "RunOnce(BindStateBase* base, PassingType<UnboundArgs>... unbound_args)"
  },
  {
    "label": "StorageType()",
    "kind": "Method",
    "detail": "Function (StorageType* storage = static_cast<)",
    "insertText": "StorageType(base)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (size_t num_bound_args = std::tuple_size<)",
    "insertText": "decltype(storage->bound_args_)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (} R)",
    "insertText": "Run(BindStateBase* base, PassingType<UnboundArgs>... unbound_args)"
  },
  {
    "label": "RunImpl()",
    "kind": "Method",
    "detail": "Function (} private : template<Functor,BoundArgsTuple,size_t . . . indices> R)",
    "insertText": "RunImpl(Functor&& functor, BoundArgsTuple&& bound, std::index_sequence<indices...>, UnboundArgs&&... unbound_args)"
  },
  {
    "label": "DecayedArgsTuple()",
    "kind": "Method",
    "detail": "Function (bool is_method = MakeFunctorTraits<Functor>::is_method ; using DecayedArgsTuple = std::decay_t<BoundArgsTuple> ; bool is_weak_call = IsWeakMethod<is_method,std::tuple_element_t<indices,)",
    "insertText": "DecayedArgsTuple()"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} } ; template<Functor,. . . BoundArgs> struct BindTypeHelper { size_t num_bounds =)",
    "insertText": "sizeof(BoundArgs)"
  },
  {
    "label": "IsNull()",
    "kind": "Method",
    "detail": "Function (using FunctorTraits = MakeFunctorTraits<Functor> ; using RunType = FunctorTraits::RunType ; using ReturnType = ExtractReturnType<RunType> ; using RunParamsList = ExtractArgs<RunType> ; using BoundParamsList = TakeTypeListItem<num_bounds,RunParamsList> ; using UnboundParamsList = DropTypeListItem<num_bounds,RunParamsList> ; using BoundArgsList = TypeList<BoundArgs . . .> ; using UnboundRunType = MakeFunctionType<ReturnType,UnboundParamsList> ; } ; template<Functor> std::enable_if_t<FunctorTraits<Functor>::is_nullable,bool>)",
    "insertText": "IsNull(const Functor& functor)"
  },
  {
    "label": "NOTREACHED()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "NOTREACHED()"
  },
  {
    "label": "BindStateType()",
    "kind": "Method",
    "detail": "Function (const BindStateType* storage = static_cast<const)",
    "insertText": "BindStateType(base)"
  },
  {
    "label": "enable_if_t()",
    "kind": "Method",
    "detail": "Function (} template<Functor,Receiver,. . . Unused>)",
    "insertText": "enable_if_t(MakeFunctorTraits<Functor>::is_method && std::is_pointer<std::decay_t<Receiver>>::value && IsRefCountedType<std::remove_pointer_t<std::decay_t<Receiver>>>::value)> BanUnconstructedRefCountedReceiver(const Receiver& receiver, Unused&&...)"
  },
  {
    "label": "BanUnconstructedRefCountedReceiver()",
    "kind": "Method",
    "detail": "Function (} template<Functor> void)",
    "insertText": "BanUnconstructedRefCountedReceiver()"
  },
  {
    "label": "BanUnconstructedRefCountedReceiver()",
    "kind": "Method",
    "detail": "Function (} template<Functor,Receiver,. . . Unused> std::enable_if_t<MakeFunctorTraits<Functor>::is_method&& std::is_pointer<std::decay_t<Receiver>>::value&& IsRefCountedType<std::remove_pointer_t<std::decay_t<Receiver>>>::value>)",
    "insertText": "BanUnconstructedRefCountedReceiver(const Receiver& receiver, Unused&&...)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(receiver)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(receiver->HasAtLeastOneRef())"
  },
  {
    "label": "Repeating()",
    "kind": "Method",
    "detail": "Function (Once,)",
    "insertText": "Repeating() refuses to create the first reference \" \"to ref-counted objects. That typically happens around PostTask()"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (} template<Functor,. . . BoundArgs> struct BindState final : BindStateBase { using IsCancellable = bool_constant<CallbackCancellationTraits<Functor,std::tuple<BoundArgs . . .>>::is_cancellable> ; template<ForwardFunctor,. . . ForwardBoundArgs> BindState*)",
    "insertText": "Create(BindStateBase::InvokeFuncStorage invoke_func, ForwardFunctor&& functor, ForwardBoundArgs&&... bound_args)"
  },
  {
    "label": "ForwardFunctor()",
    "kind": "Method",
    "detail": "Function (BanUnconstructedRefCountedReceiver<)",
    "insertText": "ForwardFunctor(bound_args...)"
  },
  {
    "label": "BindState()",
    "kind": "Method",
    "detail": "Function (} Functor functor_ ; std::tuple<BoundArgs . . .> bound_args_ ; private : bool is_nested_callback = MakeFunctorTraits<Functor>::is_callback ; template<ForwardFunctor,. . . ForwardBoundArgs>)",
    "insertText": "BindState(std::true_type, BindStateBase::InvokeFuncStorage invoke_func, ForwardFunctor&& functor, ForwardBoundArgs&&... bound_args) : BindStateBase(invoke_func, &Destroy, &QueryCancellationTraits<BindState>), functor_(std::forward<ForwardFunctor>(functor)), bound_args_(std::forward<ForwardBoundArgs>(bound_args)...)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "DCHECK(!IsNull(functor_))"
  },
  {
    "label": "BindState()",
    "kind": "Method",
    "detail": "Function (} } template<ForwardFunctor,. . . ForwardBoundArgs>)",
    "insertText": "BindState(std::false_type, BindStateBase::InvokeFuncStorage invoke_func, ForwardFunctor&& functor, ForwardBoundArgs&&... bound_args) : BindStateBase(invoke_func, &Destroy), functor_(std::forward<ForwardFunctor>(functor)), bound_args_(std::forward<ForwardBoundArgs>(bound_args)...)"
  },
  {
    "label": "BindState()",
    "kind": "Method",
    "detail": "Function (} } ~)",
    "insertText": "BindState()"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destroy(const BindStateBase* self)"
  },
  {
    "label": "BindState()",
    "kind": "Method",
    "detail": "Function (delete static_cast<const)",
    "insertText": "BindState(self)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} } ; template<bool is_method,Functor,. . . BoundArgs> struct MakeBindStateTypeImpl ; template<Functor,. . . BoundArgs> struct MakeBindStateTypeImpl<false,Functor,BoundArgs . . .> {)",
    "insertText": "static_assert(!HasRefCountedTypeAsRawPtr<std::decay_t<BoundArgs>...>::value, \"A parameter is a refcounted type and needs scoped_refptr.\")"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (using Type = BindState<std::decay_t<Functor>,std::decay_t<BoundArgs> . . .> ; } ; template<Functor> struct MakeBindStateTypeImpl<true,Functor> { using Type = BindState<std::decay_t<Functor>> ; } ; template<Functor,Receiver,. . . BoundArgs> struct MakeBindStateTypeImpl<true,Functor,Receiver,BoundArgs . . .> { private : using DecayedReceiver = std::decay_t<Receiver> ;)",
    "insertText": "static_assert(!std::is_array<std::remove_reference_t<Receiver>>::value, \"First bound argument to a method cannot be an array.\")"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (public : using Type = BindState<std::decay_t<Functor>,std::conditional_t<std::is_pointer<DecayedReceiver>::value,scoped_refptr<std::remove_pointer_t<DecayedReceiver>>,DecayedReceiver>,std::decay_t<BoundArgs> . . .> ; } ; template<Functor,. . . BoundArgs> using MakeBindStateType = MakeBindStateTypeImpl<MakeFunctorTraits<Functor>::is_method,Functor,BoundArgs . . .>::Type ; template<Functor,. . . BoundArgs> using MakeUnboundRunType = BindTypeHelper<Functor,BoundArgs . . .>::UnboundRunType ; template<bool is_once,T> struct TransformToUnwrappedTypeImpl ; template<T> struct TransformToUnwrappedTypeImpl<true,T> { using StoredType = std::decay_t<T> ; using ForwardType = StoredType&& ; using Unwrapped =)",
    "insertText": "decltype(Unwrap(std::declval<ForwardType>()))"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} ; template<bool is_once,T> using TransformToUnwrappedType = TransformToUnwrappedTypeImpl<is_once,T>::Unwrapped ; template<bool is_once,bool is_method,. . . Args> struct MakeUnwrappedTypeListImpl { using Type = TypeList<TransformToUnwrappedType<is_once,Args> . . .> ; } ; template<bool is_once,Receiver,. . . Args> struct MakeUnwrappedTypeListImpl<is_once,true,Receiver,Args . . .> { using UnwrappedReceiver = TransformToUnwrappedType<is_once,Receiver> ; using Type = TypeList<)",
    "insertText": "decltype(&*std::declval<UnwrappedReceiver>())"
  },
  {
    "label": "kCanBeForwardedToBoundFunctor()",
    "kind": "Method",
    "detail": "Function (} ; template<bool is_once,bool is_method,. . . Args> using MakeUnwrappedTypeList = MakeUnwrappedTypeListImpl<is_once,is_method,Args . . .>::Type ; template<T> struct IsOnceCallback : std::false_type { } ; template<Signature> struct IsOnceCallback<OnceCallback<Signature>> : std::true_type { } ; template<int i> struct BindArgument { template<ForwardingType> struct ForwardedAs { template<FunctorParamType> struct ToParamWithType { bool kCanBeForwardedToBoundFunctor = std::is_constructible<FunctorParamType,ForwardingType>::value ; bool kNonConstRefParamMustBeWrapped =)",
    "insertText": "kCanBeForwardedToBoundFunctor(std::is_lvalue_reference<FunctorParamType>::value && !std::is_const<std::remove_reference_t<FunctorParamType>>::value && std::is_convertible<std::decay_t<ForwardingType>&, FunctorParamType>::value)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (bool kMoveOnlyTypeMustUseBasePassed = kCanBeForwardedToBoundFunctor | | ! std::is_constructible<FunctorParamType,std::decay_t<ForwardingType>&&>::value ; } ; } ; template<BoundAsType> struct BoundAs { template<StorageType> struct StoredAs { bool kBindArgumentCanBeCaptured = std::is_constructible<StorageType,BoundAsType>::value ; bool kMoveOnlyTypeMustUseStdMove = kBindArgumentCanBeCaptured | | ! std::is_constructible<StorageType,std::decay_t<BoundAsType>&&>::value ; } ; } ; } ; template<int i,Arg,Storage,Unwrapped,Param> struct AssertConstructible { private :)",
    "insertText": "static_assert(BindArgument<i>::template ForwardedAs<Unwrapped>:: template ToParamWithType<Param>::kMoveOnlyTypeMustUseBasePassed, \"base::BindRepeating() argument is a move-only type. Use base::Passed() \" \"instead of std::move() to transfer ownership from the callback to the \" \"bound functor.\")"
  },
  {
    "label": "GetInvokeFunc()",
    "kind": "Method",
    "detail": "Function (} ; template<Index,Args,UnwrappedTypeList,ParamsList> struct AssertBindArgsValidity ; template<size_t . . . Ns,. . . Args,. . . Unwrapped,. . . Params> struct AssertBindArgsValidity<std::index_sequence<Ns . . .>,TypeList<Args . . .>,TypeList<Unwrapped . . .>,TypeList<Params . . .>> : AssertConstructible<Ns,Args,std::decay_t<Args>,Unwrapped,Params> . . . { bool ok = true ; } ; template<T> struct AssertBindArgIsNotBasePassed : public std::true_type { } ; template<T> struct AssertBindArgIsNotBasePassed<PassedWrapper<T>> : public std::false_type { } ; template<Invoker> auto)",
    "insertText": "GetInvokeFunc(std::true_type)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (bool kIsOnce = IsOnceCallback<CallbackT<)",
    "insertText": "void()"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (using Helper = BindTypeHelper<Functor,Args . . .> ; using FunctorTraits = Helper::FunctorTraits ; using BoundArgsList = Helper::BoundArgsList ; using UnwrappedArgsList = MakeUnwrappedTypeList<kIsOnce,FunctorTraits::is_method,Args&& . . .> ; using BoundParamsList = Helper::BoundParamsList ;)",
    "insertText": "static_assert(AssertBindArgsValidity<std::make_index_sequence<Helper::num_bounds>, BoundArgsList, UnwrappedArgsList, BoundParamsList>::ok, \"The bound args need to be convertible to the target params.\")"
  },
  {
    "label": "Invoker()",
    "kind": "Method",
    "detail": "Function (using BindState = MakeBindStateType<Functor,Args . . .> ; using UnboundRunType = MakeUnboundRunType<Functor,Args . . .> ; using Invoker = Invoker<BindState,UnboundRunType> ; using CallbackType = CallbackT<UnboundRunType> ; using PolymorphicInvoke = CallbackType::PolymorphicInvoke ; PolymorphicInvoke invoke_func = GetInvokeFunc<)",
    "insertText": "Invoker(bool_constant<kIsOnce>())"
  },
  {
    "label": "CallbackType()",
    "kind": "Method",
    "detail": "Function (using InvokeFuncStorage = BindStateBase::InvokeFuncStorage ; return)",
    "insertText": "CallbackType(BindState::Create( reinterpret_cast<InvokeFuncStorage>(invoke_func), std::forward<Functor>(functor), std::forward<Args>(args)...))"
  },
  {
    "label": "MaybeValid()",
    "kind": "Method",
    "detail": "Function (} } template<T> struct IsWeakReceiver : std::false_type { } ; template<T> struct IsWeakReceiver<std::reference_wrapper<T>> : IsWeakReceiver<T> { } ; template<T> struct IsWeakReceiver<WeakPtr<T>> : std::true_type { } ; template<> struct MaybeValidTraits { template<T> bool)",
    "insertText": "MaybeValid(const T& o)"
  },
  {
    "label": "Unwrap()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct BindUnwrapTraits { template<T> T&&)",
    "insertText": "Unwrap(T&& o)"
  },
  {
    "label": "Unwrap()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> struct BindUnwrapTraits<internal::UnretainedWrapper<T>> { T*)",
    "insertText": "Unwrap(const internal::UnretainedWrapper<T>& o)"
  },
  {
    "label": "Unwrap()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> struct BindUnwrapTraits<internal::RetainedRefWrapper<T>> { T*)",
    "insertText": "Unwrap(const internal::RetainedRefWrapper<T>& o)"
  },
  {
    "label": "Unwrap()",
    "kind": "Method",
    "detail": "Function (} } ; template<T,Deleter> struct BindUnwrapTraits<internal::OwnedWrapper<T,Deleter>> { T*)",
    "insertText": "Unwrap(const internal::OwnedWrapper<T, Deleter>& o)"
  },
  {
    "label": "Unwrap()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> struct BindUnwrapTraits<internal::OwnedRefWrapper<T>> { T&)",
    "insertText": "Unwrap(const internal::OwnedRefWrapper<T>& o)"
  },
  {
    "label": "Unwrap()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> struct BindUnwrapTraits<internal::PassedWrapper<T>> { T)",
    "insertText": "Unwrap(const internal::PassedWrapper<T>& o)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } ; # if)",
    "insertText": "defined(OS_WIN)"
  },
  {
    "label": "Unwrap()",
    "kind": "Method",
    "detail": "Function (T*)",
    "insertText": "Unwrap(const Microsoft::WRL::ComPtr<T>& ptr)"
  },
  {
    "label": "IsCancelled()",
    "kind": "Method",
    "detail": "Function (} } ; # endif template<Functor,BoundArgsTuple,SFINAE> struct CallbackCancellationTraits { bool is_cancellable = false ; } ; template<Functor,. . . BoundArgs> struct CallbackCancellationTraits<Functor,std::tuple<BoundArgs . . .>,std::enable_if_t<internal::IsWeakMethod<internal::FunctorTraits<Functor>::is_method,BoundArgs . . .>::value>> { bool is_cancellable = true ; template<Receiver,. . . Args> bool)",
    "insertText": "IsCancelled(const Functor&, const Receiver& receiver, const Args&...)"
  },
  {
    "label": "IsCancelled()",
    "kind": "Method",
    "detail": "Function (} } ; template<Signature,. . . BoundArgs> struct CallbackCancellationTraits<OnceCallback<Signature>,std::tuple<BoundArgs . . .>> { bool is_cancellable = true ; template<Functor> bool)",
    "insertText": "IsCancelled(const Functor& functor, const BoundArgs&...)"
  },
  {
    "label": "MaybeValid()",
    "kind": "Method",
    "detail": "Function (} template<Functor> bool)",
    "insertText": "MaybeValid(const Functor& functor, const BoundArgs&...)"
  }
]