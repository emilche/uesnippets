[
  {
    "label": "parallel_do_feeder_impl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "parallel_do_feeder_impl"
  },
  {
    "label": "parallel_do_feeder",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "parallel_do_feeder"
  },
  {
    "label": "internal",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "internal"
  },
  {
    "label": "do_group_task",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "do_group_task"
  },
  {
    "label": "Body",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Body"
  },
  {
    "label": "parallel_do_operator_selector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "parallel_do_operator_selector"
  },
  {
    "label": "do_iteration_task",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "do_iteration_task"
  },
  {
    "label": "do_iteration_task_iter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "do_iteration_task_iter"
  },
  {
    "label": "do_group_task_forward",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "do_group_task_forward"
  },
  {
    "label": "do_group_task_input",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "do_group_task_input"
  },
  {
    "label": "do_task_iter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "do_task_iter"
  },
  {
    "label": "parallel_do_feeder()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_parallel_do_H # define __TBB_parallel_do_H # include \" internal / _range_iterator . h \" # include \" internal / _template_helpers . h \" # include \" task . h \" # include \" aligned_space . h \" # include<iterator> namespace tbb { namespace interface9 { namespace internal { template<Body,Item> class parallel_do_feeder_impl ; } template<Item> class parallel_do_feeder :::tbb::internal::no_copy {)",
    "insertText": "parallel_do_feeder()"
  },
  {
    "label": "internal_add_copy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_add_copy(const Item& item)"
  },
  {
    "label": "internal_add_move()",
    "kind": "Method",
    "detail": "Function (# if __TBB_CPP11_RVALUE_REF_PRESENT void)",
    "insertText": "internal_add_move(Item&& item)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (# endif template<Body_,Item_> class internal::parallel_do_feeder_impl ; public : void)",
    "insertText": "add(const Item& item)"
  },
  {
    "label": "internal_add_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_add_copy(item)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_CPP11_RVALUE_REF_PRESENT void)",
    "insertText": "add(Item&& item)"
  },
  {
    "label": "internal_add_move()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_add_move(std::move(item))"
  },
  {
    "label": "internal_call()",
    "kind": "Method",
    "detail": "Function (} # endif } ; namespace internal { template<Body> class do_group_task ; template<class Body,Item> class parallel_do_operator_selector { typedef parallel_do_feeder<Item> Feeder ; template<A1,A2,CvItem> void)",
    "insertText": "internal_call(const Body& obj, __TBB_FORWARDING_REF(A1) arg1, A2&, void (Body::*)(CvItem) const)"
  },
  {
    "label": "obj()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "obj(tbb::internal::forward<A1>(arg1))"
  },
  {
    "label": "internal_call()",
    "kind": "Method",
    "detail": "Function (} template<A1,A2,CvItem> void)",
    "insertText": "internal_call(const Body& obj, __TBB_FORWARDING_REF(A1) arg1, A2& arg2, void (Body::*)(CvItem, parallel_do_feeder<Item>&) const)"
  },
  {
    "label": "obj()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "obj(tbb::internal::forward<A1>(arg1), arg2)"
  },
  {
    "label": "internal_call()",
    "kind": "Method",
    "detail": "Function (} template<A1,A2,CvItem> void)",
    "insertText": "internal_call(const Body& obj, __TBB_FORWARDING_REF(A1) arg1, A2&, void (Body::*)(CvItem&) const)"
  },
  {
    "label": "obj()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "obj(arg1)"
  },
  {
    "label": "internal_call()",
    "kind": "Method",
    "detail": "Function (} template<A1,A2,CvItem> void)",
    "insertText": "internal_call(const Body& obj, __TBB_FORWARDING_REF(A1) arg1, A2& arg2, void (Body::*)(CvItem&, parallel_do_feeder<Item>&) const)"
  },
  {
    "label": "obj()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "obj(arg1, arg2)"
  },
  {
    "label": "call()",
    "kind": "Method",
    "detail": "Function (} public : template<A1,A2> void)",
    "insertText": "call(const Body& obj, __TBB_FORWARDING_REF(A1) arg1, A2& arg2)"
  },
  {
    "label": "internal_call()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_call(obj, tbb::internal::forward<A1>(arg1), arg2, &Body::operator())"
  },
  {
    "label": "do_iteration_task()",
    "kind": "Method",
    "detail": "Function (} } ; template<Body,Item> class do_iteration_task : public task { typedef parallel_do_feeder_impl<Body,Item> feeder_type ; Item my_value ; feeder_type& my_feeder ;)",
    "insertText": "do_iteration_task(const Item& value, feeder_type& feeder ) : my_value(value), my_feeder(feeder)"
  },
  {
    "label": "do_iteration_task()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_CPP11_RVALUE_REF_PRESENT)",
    "insertText": "do_iteration_task(Item&& value, feeder_type& feeder ) : my_value(std::move(value)), my_feeder(feeder)"
  },
  {
    "label": "execute()",
    "kind": "Method",
    "detail": "Function (} # endif task*)",
    "insertText": "execute()"
  },
  {
    "label": "call()",
    "kind": "Method",
    "detail": "Function (parallel_do_operator_selector<Body,Item)",
    "insertText": "call(*my_feeder.my_body, tbb::internal::move(my_value), my_feeder)"
  },
  {
    "label": "call()",
    "kind": "Method",
    "detail": "Function (parallel_do_operator_selector<Body,Item)",
    "insertText": "call(*my_feeder.my_body, *my_iter, my_feeder)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (typedef do_iteration_task<Body,Item> iteration_type ; iteration_type& t =*)",
    "insertText": "new(task::allocate_additional_child_of(*my_barrier)) iteration_type(item, *this)"
  },
  {
    "label": "spawn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "spawn(t)"
  },
  {
    "label": "internal_add_copy_impl()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_add_copy_impl(std::false_type, const Item&)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(false, \"Overloading for r-value reference doesn't work or it's not movable and not copyable object\")"
  },
  {
    "label": "internal_add_copy_impl()",
    "kind": "Method",
    "detail": "Function (# if __TBB_CPP11_IS_COPY_CONSTRUCTIBLE_PRESENT)",
    "insertText": "internal_add_copy_impl(typename std::is_copy_constructible<Item>::type(), item)"
  },
  {
    "label": "internal_add_copy_impl()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "internal_add_copy_impl(std::true_type(), item)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (typedef do_iteration_task<Body,Item> iteration_type ; iteration_type& t =*)",
    "insertText": "new(task::allocate_additional_child_of(*my_barrier)) iteration_type(std::move(item), *this)"
  },
  {
    "label": "parallel_do_feeder_impl()",
    "kind": "Method",
    "detail": "Function (} # endif public : const Body* my_body ; empty_task* my_barrier ;)",
    "insertText": "parallel_do_feeder_impl()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (my_barrier =)",
    "insertText": "new(task::allocate_root() ) empty_task()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_barrier, \"root task allocation failed\")"
  },
  {
    "label": "parallel_do_feeder_impl()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_TASK_GROUP_CONTEXT)",
    "insertText": "parallel_do_feeder_impl(tbb::task_group_context &context)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (my_barrier =)",
    "insertText": "new(task::allocate_root(context) ) empty_task()"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (my_barrier ->)",
    "insertText": "destroy(*my_barrier)"
  },
  {
    "label": "do_group_task_forward()",
    "kind": "Method",
    "detail": "Function (} } ; template<Iterator,Body,Item> class do_group_task_forward : public task { const size_t max_arg_size = 4 ; typedef parallel_do_feeder_impl<Body,Item> feeder_type ; feeder_type& my_feeder ; Iterator my_first ; size_t my_size ;)",
    "insertText": "do_group_task_forward(Iterator first, size_t size, feeder_type& feeder ) : my_feeder(feeder), my_first(first), my_size(size)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (typedef do_iteration_task_iter<Iterator,Body,Item> iteration_type ;)",
    "insertText": "__TBB_ASSERT(my_size>0, NULL)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (task_list list ; task* t ; size_t k = 0 ;)",
    "insertText": "for(;;)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (t =)",
    "insertText": "new(allocate_child() ) iteration_type( my_first, my_feeder)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + my_first ;)",
    "insertText": "if(++k==my_size)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (list .)",
    "insertText": "push_back(*t)"
  },
  {
    "label": "set_ref_count()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "set_ref_count(int(k+1))"
  },
  {
    "label": "spawn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "spawn(list)"
  },
  {
    "label": "spawn_and_wait_for_all()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "spawn_and_wait_for_all(*t)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (t =)",
    "insertText": "new(allocate_child() ) iteration_type( Item_iterator(my_arg.begin() + k), my_feeder)"
  },
  {
    "label": "do_task_iter()",
    "kind": "Method",
    "detail": "Function (} template<Iterator_,Body_,Item_> class do_task_iter ; } ; template<Iterator,Body,Item> class do_task_iter : public task { typedef parallel_do_feeder_impl<Body,Item> feeder_type ; public :)",
    "insertText": "do_task_iter(Iterator first, Iterator last , feeder_type& feeder ) : my_first(first), my_last(last), my_feeder(feeder)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (typedef std::iterator_traits<Iterator>::iterator_category iterator_tag ; return)",
    "insertText": "run((iterator_tag*)NULL)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} task*)",
    "insertText": "run(void*)"
  },
  {
    "label": "run_for_input_iterator()",
    "kind": "Method",
    "detail": "Function (} task*)",
    "insertText": "run_for_input_iterator()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (typedef do_group_task_input<Body,Item> block_type ; block_type& t =*)",
    "insertText": "new(allocate_additional_child_of(*my_feeder.my_barrier) ) block_type(my_feeder)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (size_t k = 0 ;)",
    "insertText": "while(!(my_first == my_last))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(t.my_arg.begin() + k) Item(*my_first)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + my_first ;)",
    "insertText": "if(++k==block_type::max_arg_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } })",
    "insertText": "if(k==0)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy(t)"
  },
  {
    "label": "run_for_forward_iterator()",
    "kind": "Method",
    "detail": "Function (} task*)",
    "insertText": "run_for_forward_iterator()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (typedef do_group_task_forward<Iterator,Body,Item> block_type ; Iterator first = my_first ; size_t k = 0 ;)",
    "insertText": "while(!(my_first==my_last))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (break ; } } return k = = 0 ? NULL :)",
    "insertText": "new(allocate_additional_child_of(*my_feeder.my_barrier) ) block_type(first, k, my_feeder)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} task*)",
    "insertText": "run(std::random_access_iterator_tag*)"
  },
  {
    "label": "run_for_random_access_iterator()",
    "kind": "Method",
    "detail": "Function (} task*)",
    "insertText": "run_for_random_access_iterator()"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (typedef do_group_task_forward<Iterator,Body,Item> block_type ; typedef do_iteration_task_iter<Iterator,Body,Item> iteration_type ; size_t k = static_cast<)",
    "insertText": "size_t(my_last-my_first)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (Iterator middle = my_first + k / 2 ; empty_task& c =*)",
    "insertText": "new(allocate_continuation())"
  },
  {
    "label": "recycle_as_child_of()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "recycle_as_child_of(c)"
  },
  {
    "label": "set_ref_count()",
    "kind": "Method",
    "detail": "Function (my_last = middle ; c .)",
    "insertText": "set_ref_count(2)"
  },
  {
    "label": "spawn()",
    "kind": "Method",
    "detail": "Function (c .)",
    "insertText": "spawn(b)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (t =)",
    "insertText": "new(allocate_child() ) iteration_type(my_first, my_feeder)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + my_first ;)",
    "insertText": "if(++k1==k)"
  },
  {
    "label": "run_parallel_do()",
    "kind": "Method",
    "detail": "Function (} return NULL ; } } ; template<Iterator,Body,Item> void)",
    "insertText": "run_parallel_do(Iterator first, Iterator last, const Body& body #if __TBB_TASK_GROUP_CONTEXT , task_group_context& context #endif)"
  },
  {
    "label": "feeder()",
    "kind": "Method",
    "detail": "Function (typedef do_task_iter<Iterator,Body,Item> root_iteration_task ; # if __TBB_TASK_GROUP_CONTEXT parallel_do_feeder_impl<Body,Item>)",
    "insertText": "feeder(context)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (# else parallel_do_feeder_impl<Body,Item> feeder ; # endif feeder . my_body =& body ; root_iteration_task& t =*)",
    "insertText": "new(feeder.my_barrier->allocate_child() ) root_iteration_task(first, last, feeder)"
  },
  {
    "label": "spawn_and_wait_for_all()",
    "kind": "Method",
    "detail": "Function (feeder . my_barrier ->)",
    "insertText": "spawn_and_wait_for_all(t)"
  },
  {
    "label": "select_parallel_do()",
    "kind": "Method",
    "detail": "Function (} template<Iterator,Body,Item> void)",
    "insertText": "select_parallel_do(Iterator first, Iterator last, const Body& body, void (Body::*)(Item) const #if __TBB_TASK_GROUP_CONTEXT , task_group_context& context #endif)"
  },
  {
    "label": "type()",
    "kind": "Method",
    "detail": "Function (run_parallel_do<Iterator,Body,::tbb::internal::strip<Item)",
    "insertText": "type(first, last, body #if __TBB_TASK_GROUP_CONTEXT , context #endif)"
  },
  {
    "label": "select_parallel_do()",
    "kind": "Method",
    "detail": "Function (} template<Iterator,Body,Item,_Item> void)",
    "insertText": "select_parallel_do(Iterator first, Iterator last, const Body& body, void (Body::*)(Item, parallel_do_feeder<_Item>&) const #if __TBB_TASK_GROUP_CONTEXT , task_group_context& context #endif)"
  },
  {
    "label": "parallel_do()",
    "kind": "Method",
    "detail": "Function (} } } template<Iterator,Body> void)",
    "insertText": "parallel_do(Iterator first, Iterator last, const Body& body)"
  },
  {
    "label": "context()",
    "kind": "Method",
    "detail": "Function (# if __TBB_TASK_GROUP_CONTEXT task_group_context)",
    "insertText": "context(internal::PARALLEL_DO)"
  },
  {
    "label": "select_parallel_do()",
    "kind": "Method",
    "detail": "Function (# endif interface9::)",
    "insertText": "select_parallel_do(first, last, body, &Body::operator() #if __TBB_TASK_GROUP_CONTEXT , context #endif)"
  },
  {
    "label": "parallel_do()",
    "kind": "Method",
    "detail": "Function (} template<Range,Body> void)",
    "insertText": "parallel_do(Range& rng, const Body& body)"
  },
  {
    "label": "parallel_do()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_do(tbb::internal::first(rng), tbb::internal::last(rng), body)"
  },
  {
    "label": "parallel_do()",
    "kind": "Method",
    "detail": "Function (} template<Range,Body> void)",
    "insertText": "parallel_do(const Range& rng, const Body& body)"
  },
  {
    "label": "parallel_do()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_TASK_GROUP_CONTEXT template<Iterator,Body> void)",
    "insertText": "parallel_do(Iterator first, Iterator last, const Body& body, task_group_context& context)"
  },
  {
    "label": "select_parallel_do()",
    "kind": "Method",
    "detail": "Function (interface9::)",
    "insertText": "select_parallel_do(first, last, body, &Body::operator(), context)"
  },
  {
    "label": "parallel_do()",
    "kind": "Method",
    "detail": "Function (} template<Range,Body> void)",
    "insertText": "parallel_do(Range& rng, const Body& body, task_group_context& context)"
  },
  {
    "label": "parallel_do()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_do(tbb::internal::first(rng), tbb::internal::last(rng), body, context)"
  },
  {
    "label": "parallel_do()",
    "kind": "Method",
    "detail": "Function (} template<Range,Body> void)",
    "insertText": "parallel_do(const Range& rng, const Body& body, task_group_context& context)"
  }
]