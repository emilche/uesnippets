[
  {
    "label": "FVulkanCommandListContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FVulkanCommandListContext"
  },
  {
    "label": "FVulkanDevice",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FVulkanDevice"
  },
  {
    "label": "FVulkanQueue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FVulkanQueue"
  },
  {
    "label": "FVulkanCmdBuffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FVulkanCmdBuffer"
  },
  {
    "label": "FVulkanTexture",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FVulkanTexture"
  },
  {
    "label": "TVulkanTrackBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TVulkanTrackBase"
  },
  {
    "label": "FFenceManager",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FFenceManager"
  },
  {
    "label": "FDeviceMemoryManager",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDeviceMemoryManager"
  },
  {
    "label": "FDeviceMemoryAllocation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDeviceMemoryAllocation"
  },
  {
    "label": "FVulkanSubresourceAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FVulkanSubresourceAllocator"
  },
  {
    "label": "FVulkanResourceHeap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FVulkanResourceHeap"
  },
  {
    "label": "FMemoryManager",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMemoryManager"
  },
  {
    "label": "FRange",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRange"
  },
  {
    "label": "FVulkanAllocation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FVulkanAllocation"
  },
  {
    "label": "FVulkanAllocationInternal",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FVulkanAllocationInternal"
  },
  {
    "label": "FResourceHeapStats",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FResourceHeapStats"
  },
  {
    "label": "FVulkanEvictable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FVulkanEvictable"
  },
  {
    "label": "FVulkanTrackInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FVulkanTrackInfo"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "EVulkanAllocationType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EVulkanAllocationType"
  },
  {
    "label": "EVulkanAllocationMetaType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EVulkanAllocationMetaType"
  },
  {
    "label": "ELegacyVulkanAllocationFlags",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ELegacyVulkanAllocationFlags"
  },
  {
    "label": "FRefCount",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRefCount"
  },
  {
    "label": "FDeviceChild",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDeviceChild"
  },
  {
    "label": "FDeviceMemoryBlockKey",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDeviceMemoryBlockKey"
  },
  {
    "label": "FDeviceMemoryBlock",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDeviceMemoryBlock"
  },
  {
    "label": "FFreeBlock",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFreeBlock"
  },
  {
    "label": "FHeapInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FHeapInfo"
  },
  {
    "label": "FVulkanPageSizeBucket",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FVulkanPageSizeBucket"
  },
  {
    "label": "EVulkanFreeFlags",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EVulkanFreeFlags"
  },
  {
    "label": "FUBPendingFree",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FUBPendingFree"
  },
  {
    "label": "FStagingBuffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FStagingBuffer"
  },
  {
    "label": "FStagingManager",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FStagingManager"
  },
  {
    "label": "FPendingItemsPerCmdBuffer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPendingItemsPerCmdBuffer"
  },
  {
    "label": "FPendingItems",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPendingItems"
  },
  {
    "label": "FFreeEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFreeEntry"
  },
  {
    "label": "FFence",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FFence"
  },
  {
    "label": "FGPUEvent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FGPUEvent"
  },
  {
    "label": "FTempBlockAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTempBlockAllocator"
  },
  {
    "label": "FTempMemoryBlock",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTempMemoryBlock"
  },
  {
    "label": "FInternalAlloc",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FInternalAlloc"
  },
  {
    "label": "VULKANRHI_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VULKANRHI_API"
  },
  {
    "label": "FVulkanCustomMemManager",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FVulkanCustomMemManager"
  },
  {
    "label": "FType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FType"
  },
  {
    "label": "VULKAN_TRACK_OBJECT_CREATE()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Map . h \" # include \" Misc / ScopeRWLock . h \" # include \" VulkanConfiguration . h \" # include \" VulkanThirdParty . h \" # if ! UE_BUILD_SHIPPING # define VULKAN_MEMORY_TRACK 1 # else # define VULKAN_MEMORY_TRACK 0 # endif # define VULKAN_MEMORY_LOW_PRIORITY 0 . f # define VULKAN_MEMORY_MEDIUM_PRIORITY 0 . 5 f # define VULKAN_MEMORY_HIGHER_PRIORITY 0 . 7 5 f # define VULKAN_MEMORY_HIGHEST_PRIORITY 1 . f class FVulkanCommandListContext ; class FVulkanDevice ; class FVulkanQueue ; class FVulkanCmdBuffer ; class FVulkanTexture ; # if ! VULKAN_OBJECT_TRACKING # define)",
    "insertText": "VULKAN_TRACK_OBJECT_CREATE(Type, Ptr)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(0) #define VULKAN_TRACK_OBJECT_DELETE(Type, Ptr)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(0) #else #define VULKAN_TRACK_OBJECT_CREATE(Type, Ptr)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (TVulkanTrackBase<Type)",
    "insertText": "Add(Ptr)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (TVulkanTrackBase<Type)",
    "insertText": "Remove(Ptr)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(0)"
  },
  {
    "label": "CollectAll()",
    "kind": "Method",
    "detail": "Function (public : FCriticalSection Lock ; TSet<Type*> Objects ; template<Callback> uint32)",
    "insertText": "CollectAll(Callback CB)"
  },
  {
    "label": "L()",
    "kind": "Method",
    "detail": "Function (uint32 Count = 0 ; FScopeLock)",
    "insertText": "L(&Lock)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TArray<Type*> Temp ;)",
    "insertText": "for(Type* Object : Objects)"
  },
  {
    "label": "DumpMemory()",
    "kind": "Method",
    "detail": "Function (Object ->)",
    "insertText": "DumpMemory(CB)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Count + + ; } return Count ; } void)",
    "insertText": "Add(Type* Object)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Objects .)",
    "insertText": "Add(Object)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Remove(Type* Object)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (Objects .)",
    "insertText": "Remove(Object)"
  },
  {
    "label": "CanMove()",
    "kind": "Method",
    "detail": "Function (} } ; template<Type> FCriticalSection TVulkanTrackBase<Type>::Lock ; template<Type> TSet<Type*> TVulkanTrackBase<Type>::Objects ; # endif namespace VulkanRHI { class FFenceManager ; class FDeviceMemoryManager ; class FDeviceMemoryAllocation ; class FVulkanSubresourceAllocator ; class FVulkanResourceHeap ; class FMemoryManager ; struct FRange ; class FVulkanAllocation ; struct FVulkanAllocationInternal ; struct FResourceHeapStats ; } class FVulkanEvictable { public : bool)",
    "insertText": "CanMove()"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Move(FVulkanDevice& Device, FVulkanCommandListContext& Context, VulkanRHI::FVulkanAllocation& Allocation)"
  },
  {
    "label": "GetEvictableTexture()",
    "kind": "Method",
    "detail": "Function (} FVulkanTexture*)",
    "insertText": "GetEvictableTexture()"
  },
  {
    "label": "FRefCount()",
    "kind": "Method",
    "detail": "Function (void* Data ; int32 SizeOrLine ; } ; enum class EDelayAcquireImageType { None,DelayAcquire,LazyAcquire,} ; EDelayAcquireImageType GVulkanDelayAcquireImage ; int32 GVulkanUseBufferBinning ; namespace VulkanRHI { enum { NUM_FRAMES_TO_WAIT_BEFORE_RELEASING_TO_OS = 3,} ; enum EVulkanAllocationType : uint8 { EVulkanAllocationEmpty,EVulkanAllocationPooledBuffer,EVulkanAllocationBuffer,EVulkanAllocationImage,EVulkanAllocationImageDedicated,EVulkanAllocationSize,} ; enum EVulkanAllocationMetaType : uint8 { EVulkanAllocationMetaUnknown,EVulkanAllocationMetaUniformBuffer,EVulkanAllocationMetaMultiBuffer,EVulkanAllocationMetaRingBuffer,EVulkanAllocationMetaFrameTempBuffer,EVulkanAllocationMetaImageRenderTarget,EVulkanAllocationMetaImageOther,EVulkanAllocationMetaBufferUAV,EVulkanAllocationMetaBufferStaging,EVulkanAllocationMetaBufferOther,EVulkanAllocationMetaSize,} ; enum ELegacyVulkanAllocationFlags { VulkanAllocationFlagsMapped = 0 x1,VulkanAllocationFlagsCanEvict = 0 x2,} ; enum class EType { Image,Buffer,} ; class FRefCount { public :)",
    "insertText": "FRefCount()"
  },
  {
    "label": "AddRef()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "AddRef()"
  },
  {
    "label": "Increment()",
    "kind": "Method",
    "detail": "Function (int32 NewValue = NumRefs .)",
    "insertText": "Increment()"
  },
  {
    "label": "Release()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "Release()"
  },
  {
    "label": "Decrement()",
    "kind": "Method",
    "detail": "Function (int32 NewValue = NumRefs .)",
    "insertText": "Decrement()"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (delete this ; })",
    "insertText": "check(NewValue >= 0)"
  },
  {
    "label": "GetRefCount()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetRefCount()"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (int32 Value = NumRefs .)",
    "insertText": "GetValue()"
  },
  {
    "label": "FDeviceChild()",
    "kind": "Method",
    "detail": "Function (} private : FThreadSafeCounter NumRefs ; } ; class FDeviceChild { public :)",
    "insertText": "FDeviceChild(FVulkanDevice* InDevice) : Device(InDevice)"
  },
  {
    "label": "GetParent()",
    "kind": "Method",
    "detail": "Function (} FVulkanDevice*)",
    "insertText": "GetParent()"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (} void*)",
    "insertText": "Map(VkDeviceSize Size, VkDeviceSize Offset)"
  },
  {
    "label": "Unmap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unmap()"
  },
  {
    "label": "CanBeMapped()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CanBeMapped()"
  },
  {
    "label": "InvalidateMappedMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InvalidateMappedMemory(VkDeviceSize InOffset, VkDeviceSize InSize)"
  },
  {
    "label": "GetHandle()",
    "kind": "Method",
    "detail": "Function (VkDeviceMemory)",
    "insertText": "GetHandle()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (class FDeviceMemoryManager ; } ; struct FDeviceMemoryBlockKey { uint32 MemoryTypeIndex ; VkDeviceSize BlockSize ; bool)",
    "insertText": "operator(const FDeviceMemoryBlockKey& Other)"
  },
  {
    "label": "UpdateMemoryProperties()",
    "kind": "Method",
    "detail": "Function (} struct FDeviceMemoryBlock { FDeviceMemoryBlockKey Key ; struct FFreeBlock { FDeviceMemoryAllocation* Allocation ; uint32 FrameFreed ; } ; TArray<FFreeBlock> Allocations ; } ; class FDeviceMemoryManager { TMap<FDeviceMemoryBlockKey,FDeviceMemoryBlock> Allocations ; void)",
    "insertText": "UpdateMemoryProperties()"
  },
  {
    "label": "FDeviceMemoryManager()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "FDeviceMemoryManager()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(FVulkanDevice* InDevice)"
  },
  {
    "label": "Deinit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Deinit()"
  },
  {
    "label": "GetEvictedMemoryProperties()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetEvictedMemoryProperties()"
  },
  {
    "label": "HasUnifiedMemory()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasUnifiedMemory()"
  },
  {
    "label": "GetPrimaryHeapStatus()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPrimaryHeapStatus(uint64& OutAllocated, uint64& OutLimit)"
  },
  {
    "label": "GetMemoryTypeFromProperties()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "GetMemoryTypeFromProperties(uint32 TypeBits, VkMemoryPropertyFlags Properties, uint32* OutTypeIndex)"
  },
  {
    "label": "GetMemoryTypeFromPropertiesExcluding()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "GetMemoryTypeFromPropertiesExcluding(uint32 TypeBits, VkMemoryPropertyFlags Properties, uint32 ExcludeTypeIndex, uint32* OutTypeIndex)"
  },
  {
    "label": "GetMemoryProperties()",
    "kind": "Method",
    "detail": "Function (const VkPhysicalDeviceMemoryProperties&)",
    "insertText": "GetMemoryProperties()"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (FDeviceMemoryAllocation*)",
    "insertText": "Alloc(bool bCanFail, VkDeviceSize AllocationSize, uint32 MemoryTypeIndex, void* DedicatedAllocateInfo, float Priority, bool bExternal, const char* File, uint32 Line)"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (FDeviceMemoryAllocation*)",
    "insertText": "Alloc(bool bCanFail, VkDeviceSize AllocationSize, uint32 MemoryTypeBits, VkMemoryPropertyFlags MemoryPropertyFlags, void* DedicatedAllocateInfo, float Priority, bool bExternal, const char* File, uint32 Line)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(FDeviceMemoryAllocation*& Allocation)"
  },
  {
    "label": "GetTotalMemory()",
    "kind": "Method",
    "detail": "Function (uint64)",
    "insertText": "GetTotalMemory(bool bGPU)"
  },
  {
    "label": "GetBaseHeapSize()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize)",
    "insertText": "GetBaseHeapSize(uint32 HeapIndex)"
  },
  {
    "label": "GetHeapIndex()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetHeapIndex(uint32 MemoryTypeIndex)"
  },
  {
    "label": "FreeInternal()",
    "kind": "Method",
    "detail": "Function (protected : void)",
    "insertText": "FreeInternal(FDeviceMemoryAllocation* Allocation)"
  },
  {
    "label": "TrimMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TrimMemory(bool bFullTrim)"
  },
  {
    "label": "GetMemoryDump()",
    "kind": "Method",
    "detail": "Function (class FMemoryManager ; void)",
    "insertText": "GetMemoryDump(TArray<FResourceHeapStats>& OutDeviceHeapsStats)"
  },
  {
    "label": "DumpMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DumpMemory()"
  },
  {
    "label": "PrintMemInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintMemInfo()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; TArray<FHeapInfo> HeapInfos ; int32 PrimaryHeapIndex ; FCriticalSection DeviceMemLock ; } ; struct FRange { uint32 Offset ; uint32 Size ; bool)",
    "insertText": "operator(const FRange& In)"
  },
  {
    "label": "InsertAndTryToMerge()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "InsertAndTryToMerge(TArray<FRange>& Ranges, const FRange& Item, int32 ProposedIndex)"
  },
  {
    "label": "AppendAndTryToMerge()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "AppendAndTryToMerge(TArray<FRange>& Ranges, const FRange& Item)"
  },
  {
    "label": "AllocateFromEntry()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AllocateFromEntry(TArray<FRange>& Ranges, int32 Index, uint32 SizeToAllocate)"
  },
  {
    "label": "SanityCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SanityCheck(TArray<FRange>& Ranges)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Add(TArray<FRange>& Ranges, const FRange& Item)"
  },
  {
    "label": "FVulkanAllocation()",
    "kind": "Method",
    "detail": "Function (} ; struct FVulkanPageSizeBucket { uint64 AllocationMax ; uint32 PageSize ; enum { BUCKET_MASK_IMAGE = 0 x1,BUCKET_MASK_BUFFER = 0 x2,} ; uint32 BucketMask ; } ; class FVulkanAllocation { public :)",
    "insertText": "FVulkanAllocation()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(EVulkanAllocationType Type, EVulkanAllocationMetaType MetaType, uint64 Handle, uint32 InSize, uint32 AlignedOffset, uint32 AllocatorIndex, uint32 AllocationIndex, uint32 BufferId)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(FVulkanDevice& Device)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(FVulkanAllocation& Other)"
  },
  {
    "label": "Reference()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reference(const FVulkanAllocation& Other)"
  },
  {
    "label": "HasAllocation()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasAllocation()"
  },
  {
    "label": "Disown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Disown()"
  },
  {
    "label": "Own()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Own()"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (uint64 VulkanHandle = 0 ; uint32 HandleId = 0 ; uint32 Size = 0 ; uint32 Offset = 0 ; uint32 AllocationIndex = 0 ; uint16 AllocatorIndex = 0 ; EVulkanAllocationMetaType MetaType = EVulkanAllocationMetaUnknown ; uint8 Type : 7 ; uint8 bHasOwnership : 1 ;)",
    "insertText": "static_assert(EVulkanAllocationSize < 128, \"Not enough bits to hold EVulkanAllocationType\")"
  },
  {
    "label": "GetType()",
    "kind": "Method",
    "detail": "Function (EVulkanAllocationType)",
    "insertText": "GetType()"
  },
  {
    "label": "SetType()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetType(EVulkanAllocationType InType)"
  },
  {
    "label": "Type()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Type(uint8)"
  },
  {
    "label": "GetMappedPointer()",
    "kind": "Method",
    "detail": "Function (} void*)",
    "insertText": "GetMappedPointer(FVulkanDevice* Device)"
  },
  {
    "label": "FlushMappedMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FlushMappedMemory(FVulkanDevice* Device)"
  },
  {
    "label": "InvalidateMappedMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InvalidateMappedMemory(FVulkanDevice* Device)"
  },
  {
    "label": "GetBufferHandle()",
    "kind": "Method",
    "detail": "Function (VkBuffer)",
    "insertText": "GetBufferHandle()"
  },
  {
    "label": "GetBufferAlignment()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetBufferAlignment(FVulkanDevice* Device)"
  },
  {
    "label": "GetDeviceMemoryHandle()",
    "kind": "Method",
    "detail": "Function (VkDeviceMemory)",
    "insertText": "GetDeviceMemoryHandle(FVulkanDevice* Device)"
  },
  {
    "label": "GetSubresourceAllocator()",
    "kind": "Method",
    "detail": "Function (FVulkanSubresourceAllocator*)",
    "insertText": "GetSubresourceAllocator(FVulkanDevice* Device)"
  },
  {
    "label": "BindBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BindBuffer(FVulkanDevice* Device, VkBuffer Buffer)"
  },
  {
    "label": "BindImage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BindImage(FVulkanDevice* Device, VkImage Image)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} ; struct FVulkanAllocationInternal { enum { EUNUSED,EALLOCATED,EFREED,EFREEPENDING,EFREEDISCARDED,} ; int State = EUNUSED ; void)",
    "insertText": "Init(const FVulkanAllocation& Alloc, FVulkanEvictable* InAllocationOwner, uint32 AllocationOffset, uint32 AllocationSize, uint32 Alignment)"
  },
  {
    "label": "SetLLMTrackerID()",
    "kind": "Method",
    "detail": "Function (EVulkanAllocationType Type = EVulkanAllocationEmpty ; EVulkanAllocationMetaType MetaType = EVulkanAllocationMetaUnknown ; uint32 Size = 0 ; uint32 AllocationSize = 0 ; uint32 AllocationOffset = 0 ; FVulkanEvictable* AllocationOwner = 0 ; uint32 Alignment = 0 ; int32 NextFree = - 1 ; # if VULKAN_MEMORY_TRACK FVulkanTrackInfo Track ; # endif # if VULKAN_USE_LLM uint64 LLMTrackerID ; void)",
    "insertText": "SetLLMTrackerID(uint64 InTrackerID)"
  },
  {
    "label": "GetLLMTrackerID()",
    "kind": "Method",
    "detail": "Function (LLMTrackerID = InTrackerID ; } uint64)",
    "insertText": "GetLLMTrackerID()"
  },
  {
    "label": "FVulkanSubresourceAllocator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FVulkanSubresourceAllocator(EVulkanAllocationType InType, FMemoryManager* InOwner, uint8 InSubResourceAllocatorFlags, FDeviceMemoryAllocation* InDeviceMemoryAllocation, uint32 InMemoryTypeIndex, uint32 BufferId = 0xffffffff)"
  },
  {
    "label": "FVulkanSubresourceAllocator()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FVulkanSubresourceAllocator()"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destroy(FVulkanDevice* Device)"
  },
  {
    "label": "TryAllocate2()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TryAllocate2(FVulkanAllocation& OutAllocation, FVulkanEvictable* Owner, uint32 InSize, uint32 InAlignment, EVulkanAllocationMetaType InMetaType, const char* File, uint32 Line)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(FVulkanAllocation& Allocation)"
  },
  {
    "label": "GetAlignment()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetAlignment()"
  },
  {
    "label": "Flush()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Flush(VkDeviceSize Offset, VkDeviceSize AllocationSize)"
  },
  {
    "label": "Invalidate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Invalidate(VkDeviceSize Offset, VkDeviceSize AllocationSize)"
  },
  {
    "label": "GetMaxSize()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetMaxSize()"
  },
  {
    "label": "GetNumSubAllocations()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetNumSubAllocations()"
  },
  {
    "label": "GetSubresourceAllocatorFlags()",
    "kind": "Method",
    "detail": "Function (uint8)",
    "insertText": "GetSubresourceAllocatorFlags()"
  },
  {
    "label": "DumpFullHeap()",
    "kind": "Method",
    "detail": "Function (bIsDefragging = bInIsDefragging ; } void)",
    "insertText": "DumpFullHeap()"
  },
  {
    "label": "DefragTick()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "DefragTick(FVulkanDevice& Device, FVulkanCommandListContext& Context, FVulkanResourceHeap* Heap, uint32 Count)"
  },
  {
    "label": "CanDefrag()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CanDefrag()"
  },
  {
    "label": "EvictToHost()",
    "kind": "Method",
    "detail": "Function (uint64)",
    "insertText": "EvictToHost(FVulkanDevice& Device, FVulkanCommandListContext& Context)"
  },
  {
    "label": "SetFreePending()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetFreePending(FVulkanAllocation& Allocation)"
  },
  {
    "label": "FreeInternalData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeInternalData(int32 Index)"
  },
  {
    "label": "AllocateInternalData()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "AllocateInternalData()"
  },
  {
    "label": "JoinFreeBlocks()",
    "kind": "Method",
    "detail": "Function (uint32 MemoryUsed [ EVulkanAllocationMetaSize ] ; EVulkanAllocationType Type ; FMemoryManager* Owner ; uint32 MemoryTypeIndex ; VkMemoryPropertyFlags MemoryPropertyFlags ; FDeviceMemoryAllocation* MemoryAllocation ; uint32 MaxSize ; uint32 Alignment ; uint32 FrameFreed ; uint32 LastDefragFrame = 0 ; int64 UsedSize ; VkBufferUsageFlags BufferUsageFlags ; VkBuffer Buffer ; uint32 BufferId ; int32 PoolSizeIndex ; uint32 AllocatorIndex ; uint8 SubresourceAllocatorFlags ; uint8 BucketId ; bool bIsEvicting = false ; bool bLocked = false ; bool bIsDefragging = false ; uint32 NumSubAllocations = 0 ; uint32 AllocCalls = 0 ; uint32 FreeCalls = 0 ; TArray<FRange> FreeList ; bool)",
    "insertText": "JoinFreeBlocks()"
  },
  {
    "label": "GetAllocatorIndex()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetAllocatorIndex()"
  },
  {
    "label": "FVulkanResourceHeap()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FVulkanResourceHeap()"
  },
  {
    "label": "FreePage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreePage(FVulkanSubresourceAllocator* InPage)"
  },
  {
    "label": "ReleasePage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleasePage(FVulkanSubresourceAllocator* InPage)"
  },
  {
    "label": "GetOwner()",
    "kind": "Method",
    "detail": "Function (FMemoryManager*)",
    "insertText": "GetOwner()"
  },
  {
    "label": "DefragTick()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DefragTick(FVulkanDevice& Device, FVulkanCommandListContext& Context, uint32 Count)"
  },
  {
    "label": "DumpMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DumpMemory(FResourceHeapStats& Stats)"
  },
  {
    "label": "SetDefragging()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDefragging(FVulkanSubresourceAllocator* Allocator)"
  },
  {
    "label": "GetIsDefragging()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetIsDefragging(FVulkanSubresourceAllocator* Allocator)"
  },
  {
    "label": "GetPageSizeBucket()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetPageSizeBucket(FVulkanPageSizeBucket& BucketOut, EType Type, uint32 AllocationSize, bool bForceSingleAllocation)"
  },
  {
    "label": "GetPageSize()",
    "kind": "Method",
    "detail": "Function (protected : enum { MAX_BUCKETS = 5,} ; TArray<FVulkanPageSizeBucket,TFixedAllocator<MAX_BUCKETS>> PageSizeBuckets ; uint32)",
    "insertText": "GetPageSize()"
  },
  {
    "label": "TryRealloc()",
    "kind": "Method",
    "detail": "Function (FMemoryManager* Owner ; uint16 MemoryTypeIndex ; const uint16 HeapIndex ; bool bIsHostCachedSupported ; bool bIsLazilyAllocatedSupported ; uint8 DefragCountDown = 0 ; uint32 OverridePageSize ; uint32 PeakPageSize ; uint64 UsedMemory ; uint32 PageIDCounter ; FCriticalSection PagesLock ; TArray<FVulkanSubresourceAllocator*> ActivePages [ MAX_BUCKETS ] ; TArray<FVulkanSubresourceAllocator*> UsedDedicatedImagePages ; bool)",
    "insertText": "TryRealloc(FVulkanAllocation& OutAllocation, FVulkanEvictable* AllocationOwner, EType Type, uint32 Size, uint32 Alignment, EVulkanAllocationMetaType MetaType)"
  },
  {
    "label": "AllocateResource()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AllocateResource(FVulkanAllocation& OutAllocation, FVulkanEvictable* AllocationOwner, EType Type, uint32 Size, uint32 Alignment, bool bMapAllocation, bool bForceSeparateAllocation, EVulkanAllocationMetaType MetaType, bool bExternal, const char* File, uint32 Line)"
  },
  {
    "label": "AllocateDedicatedImage()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AllocateDedicatedImage(FVulkanAllocation& OutAllocation, FVulkanEvictable* AllocationOwner, VkImage Image, uint32 Size, uint32 Alignment, EVulkanAllocationMetaType MetaType, bool bExternal, const char* File, uint32 Line)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (class FMemoryManager ; class FVulkanSubresourceAllocator ; } ; enum EVulkanFreeFlags { EVulkanFreeFlag_None = 0 x0,EVulkanFreeFlag_DontDefer = 0 x1,} ; enum class EVulkanAllocationFlags : uint16 { None = 0 x0000,HostVisible = 0 x0001,HostCached = 0 x0002,PreferBAR = 0 x0004,Dedicated = 0 x0008,External = 0 x0010,Memoryless = 0 x0020,NoError = 0 x0040,AutoBind = 0 x0080,} ;)",
    "insertText": "ENUM_CLASS_FLAGS(EVulkanAllocationFlags)"
  },
  {
    "label": "FMemoryManager()",
    "kind": "Method",
    "detail": "Function (class FMemoryManager : public FDeviceChild { class FVulkanAllocation ; public :)",
    "insertText": "FMemoryManager(FVulkanDevice* InDevice)"
  },
  {
    "label": "FMemoryManager()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FMemoryManager()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init()"
  },
  {
    "label": "CalculateBufferAlignment()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "CalculateBufferAlignment(FVulkanDevice& InDevice, EBufferUsageFlags InUEUsage, bool bZeroSize)"
  },
  {
    "label": "CalculateBufferPriority()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "CalculateBufferPriority(const VkBufferUsageFlags BufferUsageFlags)"
  },
  {
    "label": "FreeVulkanAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeVulkanAllocation(FVulkanAllocation& Allocation, EVulkanFreeFlags FreeFlags = EVulkanFreeFlag_None)"
  },
  {
    "label": "FreeVulkanAllocationPooledBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeVulkanAllocationPooledBuffer(FVulkanAllocation& Allocation)"
  },
  {
    "label": "FreeVulkanAllocationBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeVulkanAllocationBuffer(FVulkanAllocation& Allocation)"
  },
  {
    "label": "FreeVulkanAllocationImage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeVulkanAllocationImage(FVulkanAllocation& Allocation)"
  },
  {
    "label": "FreeVulkanAllocationImageDedicated()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeVulkanAllocationImageDedicated(FVulkanAllocation& Allocation)"
  },
  {
    "label": "AllocateBufferPooled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AllocateBufferPooled(FVulkanAllocation& Allocation, FVulkanEvictable* AllocationOwner, uint32 Size, uint32 MinAlignment, VkBufferUsageFlags BufferUsageFlags, VkMemoryPropertyFlags MemoryPropertyFlags, EVulkanAllocationMetaType MetaType, const char* File, uint32 Line)"
  },
  {
    "label": "AllocateImageMemory()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AllocateImageMemory(FVulkanAllocation& Allocation, FVulkanEvictable* AllocationOwner, const VkMemoryRequirements& MemoryReqs, VkMemoryPropertyFlags MemoryPropertyFlags, EVulkanAllocationMetaType MetaType, bool bExternal, const char* File, uint32 Line)"
  },
  {
    "label": "AllocateDedicatedImageMemory()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AllocateDedicatedImageMemory(FVulkanAllocation& Allocation, FVulkanEvictable* AllocationOwner, VkImage Image, const VkMemoryRequirements& MemoryReqs, VkMemoryPropertyFlags MemoryPropertyFlags, EVulkanAllocationMetaType MetaType, bool bExternal, const char* File, uint32 Line)"
  },
  {
    "label": "AllocateBufferMemory()",
    "kind": "Method",
    "detail": "Function (private : bool)",
    "insertText": "AllocateBufferMemory(FVulkanAllocation& Allocation, FVulkanEvictable* AllocationOwner, const VkMemoryRequirements& MemoryReqs, VkMemoryPropertyFlags MemoryPropertyFlags, EVulkanAllocationMetaType MetaType, bool bExternal, bool bForceSeparateAllocation, const char* File, uint32 Line)"
  },
  {
    "label": "AllocateBufferMemory()",
    "kind": "Method",
    "detail": "Function (public : bool)",
    "insertText": "AllocateBufferMemory(FVulkanAllocation& OutAllocation, VkBuffer InBuffer, EVulkanAllocationFlags InAllocFlags, const TCHAR* InDebugName, uint32 InForceMinAlignment = 1)"
  },
  {
    "label": "RegisterSubresourceAllocator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterSubresourceAllocator(FVulkanSubresourceAllocator* SubresourceAllocator)"
  },
  {
    "label": "UnregisterSubresourceAllocator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnregisterSubresourceAllocator(FVulkanSubresourceAllocator* SubresourceAllocator)"
  },
  {
    "label": "ReleaseSubresourceAllocator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ReleaseSubresourceAllocator(FVulkanSubresourceAllocator* SubresourceAllocator)"
  },
  {
    "label": "ReleaseFreedPages()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseFreedPages(FVulkanCommandListContext& Context)"
  },
  {
    "label": "DumpMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DumpMemory(bool bFullDump = true)"
  },
  {
    "label": "AllocUniformBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AllocUniformBuffer(FVulkanAllocation& OutAllocation, uint32 Size)"
  },
  {
    "label": "FreeUniformBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeUniformBuffer(FVulkanAllocation& InAllocation)"
  },
  {
    "label": "HandleOOM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleOOM(bool bCanResume = false, VkResult Result = VK_SUCCESS, uint64 AllocationSize = 0, uint32 MemoryTypeIndex = 0)"
  },
  {
    "label": "UpdateEvictThreshold()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "UpdateEvictThreshold(bool bLog)"
  },
  {
    "label": "PoolSizes()",
    "kind": "Method",
    "detail": "Function (protected : FDeviceMemoryManager* DeviceMemoryManager ; TArray<FVulkanResourceHeap*> ResourceTypeHeaps ; enum { BufferAllocationSize = 1* 1 0 2 4* 1 0 2 4,UniformBufferAllocationSize = 2* 1 0 2 4* 1 0 2 4,} ; enum class EPoolSizes : uint8 { E128,E256,E512,E1k,E2k,E8k,E16k,SizesCount,} ; uint32)",
    "insertText": "PoolSizes(int32)"
  },
  {
    "label": "BufferSizes()",
    "kind": "Method",
    "detail": "Function (1 2 8,2 5 6,5 1 2,1 0 2 4,2 0 4 8,8 1 9 2,} ; uint32)",
    "insertText": "BufferSizes(int32)"
  },
  {
    "label": "GetPoolTypeForAlloc()",
    "kind": "Method",
    "detail": "Function (1 2 8* 1 0 2 4,1 2 8* 1 0 2 4,2 5 6* 1 0 2 4,2 5 6* 1 0 2 4,5 1 2* 1 0 2 4,5 1 2* 1 0 2 4,1 0 2 4* 1 0 2 4,1* 1 0 2 4* 1 0 2 4,} ; EPoolSizes)",
    "insertText": "GetPoolTypeForAlloc(uint32 Size, uint32 Alignment)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (EPoolSizes PoolSize = EPoolSizes::SizesCount ;)",
    "insertText": "if(GVulkanUseBufferBinning != 0)"
  },
  {
    "label": "PoolSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PoolSize(EPoolSizes)"
  },
  {
    "label": "UsedBufferAllocations()",
    "kind": "Method",
    "detail": "Function (break ; } } } return PoolSize ; } FCriticalSection UsedFreeBufferAllocationsLock ; TArray<FVulkanSubresourceAllocator*>)",
    "insertText": "UsedBufferAllocations(int32)"
  },
  {
    "label": "FreeBufferAllocations()",
    "kind": "Method",
    "detail": "Function (TArray<FVulkanSubresourceAllocator*>)",
    "insertText": "FreeBufferAllocations(int32)"
  },
  {
    "label": "AllBufferAllocationsFreeListHead()",
    "kind": "Method",
    "detail": "Function (FRWLock AllBufferAllocationsLock ; TArray<FVulkanSubresourceAllocator*> AllBufferAllocations ; PTRINT)",
    "insertText": "AllBufferAllocationsFreeListHead(PTRINT)"
  },
  {
    "label": "GetSubresourceAllocator()",
    "kind": "Method",
    "detail": "Function (FVulkanSubresourceAllocator*)",
    "insertText": "GetSubresourceAllocator(const uint32 AllocatorIndex)"
  },
  {
    "label": "ScopedReadLock()",
    "kind": "Method",
    "detail": "Function (FRWScopeLock)",
    "insertText": "ScopedReadLock(AllBufferAllocationsLock, SLT_ReadOnly)"
  },
  {
    "label": "DestroyResourceAllocations()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestroyResourceAllocations()"
  },
  {
    "label": "ProcessPendingUBFreesNoLock()",
    "kind": "Method",
    "detail": "Function (struct FUBPendingFree { FVulkanAllocation Allocation ; uint64 Frame = 0 ; } ; struct { FCriticalSection CS ; TArray<FUBPendingFree> PendingFree ; uint32 Peak = 0 ; } UBAllocations ; void)",
    "insertText": "ProcessPendingUBFreesNoLock(bool bForce)"
  },
  {
    "label": "ProcessPendingUBFrees()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ProcessPendingUBFrees(bool bForce)"
  },
  {
    "label": "FStagingBuffer()",
    "kind": "Method",
    "detail": "Function (} ; class FStagingBuffer : public FRefCount { public :)",
    "insertText": "FStagingBuffer(FVulkanDevice* InDevice)"
  },
  {
    "label": "GetMappedPointer()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "GetMappedPointer()"
  },
  {
    "label": "GetSize()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetSize()"
  },
  {
    "label": "GetDeviceMemoryHandle()",
    "kind": "Method",
    "detail": "Function (VkDeviceMemory)",
    "insertText": "GetDeviceMemoryHandle()"
  },
  {
    "label": "FlushMappedMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FlushMappedMemory()"
  },
  {
    "label": "InvalidateMappedMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InvalidateMappedMemory()"
  },
  {
    "label": "FStagingBuffer()",
    "kind": "Method",
    "detail": "Function (# if VULKAN_MEMORY_TRACK FVulkanTrackInfo Track ; # endif protected : FVulkanDevice* Device ; FVulkanAllocation Allocation ; VkBuffer Buffer ; VkMemoryPropertyFlagBits MemoryReadFlags ; uint32 BufferSize ; ~)",
    "insertText": "FStagingBuffer()"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destroy()"
  },
  {
    "label": "FStagingManager()",
    "kind": "Method",
    "detail": "Function (class FStagingManager ; } ; class FStagingManager { public :)",
    "insertText": "FStagingManager() : PeakUsedMemory(0), UsedMemory(0), Device(nullptr)"
  },
  {
    "label": "FStagingManager()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FStagingManager()"
  },
  {
    "label": "AcquireBuffer()",
    "kind": "Method",
    "detail": "Function (FStagingBuffer*)",
    "insertText": "AcquireBuffer(uint32 Size, VkBufferUsageFlags InUsageFlags = VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VkMemoryPropertyFlagBits InMemoryReadFlags = VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)"
  },
  {
    "label": "ReleaseBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseBuffer(FVulkanCmdBuffer* CmdBuffer, FStagingBuffer*& StagingBuffer)"
  },
  {
    "label": "ProcessPendingFree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ProcessPendingFree(bool bImmediately, bool bFreeToOS)"
  },
  {
    "label": "GetMemoryDump()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetMemoryDump(FResourceHeapStats& Stats)"
  },
  {
    "label": "FindOrAddItemsForFence()",
    "kind": "Method",
    "detail": "Function (protected : class FMemoryManager ; struct FPendingItemsPerCmdBuffer { FVulkanCmdBuffer* CmdBuffer ; struct FPendingItems { uint64 FenceCounter ; TArray<FStagingBuffer*> Resources ; } ; FPendingItems*)",
    "insertText": "FindOrAddItemsForFence(uint64 Fence)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (TArray<FPendingItems> PendingItems ; } ; FCriticalSection StagingLock ; TArray<FStagingBuffer*> UsedStagingBuffers ; TArray<FPendingItemsPerCmdBuffer> PendingFreeStagingBuffers ; struct FFreeEntry { FStagingBuffer* StagingBuffer ; uint32 FrameNumber ; } ; TArray<FFreeEntry> FreeStagingBuffers ; uint64 PeakUsedMemory ; uint64 UsedMemory ; FPendingItemsPerCmdBuffer*)",
    "insertText": "FindOrAdd(FVulkanCmdBuffer* CmdBuffer)"
  },
  {
    "label": "ProcessPendingFreeNoLock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ProcessPendingFreeNoLock(bool bImmediately, bool bFreeToOS)"
  },
  {
    "label": "FFence()",
    "kind": "Method",
    "detail": "Function (FVulkanDevice* Device ; } ; class FFence { public :)",
    "insertText": "FFence(FVulkanDevice* InDevice, FFenceManager* InOwner, bool bCreateSignaled)"
  },
  {
    "label": "FFenceManager()",
    "kind": "Method",
    "detail": "Function (class FFenceManager ; } ; class FFenceManager { public :)",
    "insertText": "FFenceManager() : Device(nullptr)"
  },
  {
    "label": "FFenceManager()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FFenceManager()"
  },
  {
    "label": "AllocateFence()",
    "kind": "Method",
    "detail": "Function (FFence*)",
    "insertText": "AllocateFence(bool bCreateSignaled = false)"
  },
  {
    "label": "IsFenceSignaled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsFenceSignaled(FFence* Fence)"
  },
  {
    "label": "WaitForFence()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "WaitForFence(FFence* Fence, uint64 TimeInNanoseconds)"
  },
  {
    "label": "ResetFence()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetFence(FFence* Fence)"
  },
  {
    "label": "ReleaseFence()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseFence(FFence*& Fence)"
  },
  {
    "label": "WaitAndReleaseFence()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WaitAndReleaseFence(FFence*& Fence, uint64 TimeInNanoseconds)"
  },
  {
    "label": "CheckFenceState()",
    "kind": "Method",
    "detail": "Function (protected : FVulkanDevice* Device ; FCriticalSection FenceLock ; TArray<FFence*> FreeFences ; TArray<FFence*> UsedFences ; bool)",
    "insertText": "CheckFenceState(FFence* Fence)"
  },
  {
    "label": "DestroyFence()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestroyFence(FFence* Fence)"
  },
  {
    "label": "FGPUEvent()",
    "kind": "Method",
    "detail": "Function (} ; class FGPUEvent : public FDeviceChild,public FRefCount { public :)",
    "insertText": "FGPUEvent(FVulkanDevice* InDevice)"
  },
  {
    "label": "FGPUEvent()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FGPUEvent()"
  },
  {
    "label": "FTempBlockAllocator()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FTempBlockAllocator()"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (uint8*)",
    "insertText": "Alloc(uint32 InSize, FVulkanCmdBuffer* CmdBuffer, VkDescriptorBufferBindingInfoEXT& OutBindingInfo, VkDeviceSize& OutOffset)"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (uint8*)",
    "insertText": "Alloc(uint32 InSize, uint32 InAlignment, FVulkanCmdBuffer* CmdBuffer, FVulkanAllocation& OutAllocation, VkDescriptorAddressInfoEXT* OutDescriptorAddressInfo = nullptr)"
  },
  {
    "label": "UpdateBlocks()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateBlocks()"
  },
  {
    "label": "AllocBlock()",
    "kind": "Method",
    "detail": "Function (protected : FTempMemoryBlock*)",
    "insertText": "AllocBlock()"
  },
  {
    "label": "InternalAlloc()",
    "kind": "Method",
    "detail": "Function (FInternalAlloc)",
    "insertText": "InternalAlloc(uint32 InSize, FVulkanCmdBuffer* CmdBuffer)"
  },
  {
    "label": "FSemaphore()",
    "kind": "Method",
    "detail": "Function (const uint32 BlockSize ; const uint32 BlockAlignment ; const VkBufferUsageFlags BufferUsage ; FTempMemoryBlock* CurrentBlock = nullptr ; TArray<FTempMemoryBlock*> BusyBlocks ; TArray<FTempMemoryBlock*> AvailableBlocks ; FRWLock RWLock ; } ; class FSemaphore : public FRefCount { public :)",
    "insertText": "FSemaphore(FVulkanDevice& InDevice)"
  },
  {
    "label": "FSemaphore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FSemaphore(FVulkanDevice& InDevice, const VkSemaphore& InExternalSemaphore)"
  },
  {
    "label": "FSemaphore()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FSemaphore()"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (VKAPI_ATTR void)",
    "insertText": "Free(void* pUserData, void* pMem)"
  },
  {
    "label": "Realloc()",
    "kind": "Method",
    "detail": "Function (VKAPI_ATTR void*)",
    "insertText": "Realloc(void* pUserData, void* pOriginal, size_t size, size_t alignment, VkSystemAllocationScope allocScope)"
  },
  {
    "label": "InternalAllocationNotification()",
    "kind": "Method",
    "detail": "Function (VKAPI_ATTR void)",
    "insertText": "InternalAllocationNotification(void* pUserData, size_t size, VkInternalAllocationType allocationType, VkSystemAllocationScope allocationScope)"
  },
  {
    "label": "InternalFreeNotification()",
    "kind": "Method",
    "detail": "Function (VKAPI_ATTR void)",
    "insertText": "InternalFreeNotification(void* pUserData, size_t size, VkInternalAllocationType allocationType, VkSystemAllocationScope allocationScope)"
  },
  {
    "label": "FVulkanCustomMemManager()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FVulkanCustomMemManager()"
  },
  {
    "label": "GetType()",
    "kind": "Method",
    "detail": "Function (enum { VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE = 5,} ; struct FType { size_t UsedMemory = 0 ; size_t MaxAllocSize = 0 ; TMap<void*,size_t> Allocs ; } ; TStaticArray<FType,VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE> Types ; FType&)",
    "insertText": "GetType(void* pUserData, VkSystemAllocationScope AllocScope)"
  }
]