[
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "NoThrowTag",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NoThrowTag"
  },
  {
    "label": "StrongGuaranteeTagType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StrongGuaranteeTagType"
  },
  {
    "label": "TestException",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TestException"
  },
  {
    "label": "TestBadAllocException",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TestBadAllocException"
  },
  {
    "label": "TrackedAddress",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TrackedAddress"
  },
  {
    "label": "ConstructorTracker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConstructorTracker"
  },
  {
    "label": "TrackedObject",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TrackedObject"
  },
  {
    "label": "ThrowingBool",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ThrowingBool"
  },
  {
    "label": "ThrowingValue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ThrowingValue"
  },
  {
    "label": "ThrowingAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ThrowingAllocator"
  },
  {
    "label": "rebind",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "rebind"
  },
  {
    "label": "Cleanup",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Cleanup"
  },
  {
    "label": "UninitializedT",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UninitializedT"
  },
  {
    "label": "DefaultFactory",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DefaultFactory"
  },
  {
    "label": "ExceptionSafetyTestBuilder",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ExceptionSafetyTestBuilder"
  },
  {
    "label": "IsUniquePtr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsUniquePtr"
  },
  {
    "label": "FactoryPtrTypeHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FactoryPtrTypeHelper"
  },
  {
    "label": "ExceptionSafetyTest",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ExceptionSafetyTest"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_BASE_INTERNAL_EXCEPTION_SAFETY_TESTING_H_ # define ABSL_BASE_INTERNAL_EXCEPTION_SAFETY_TESTING_H_ # include \" absl / base / config . h \" # ifdef ABSL_HAVE_EXCEPTIONS # include<cstddef> # include<cstdint> # include<functional> # include<initializer_list> # include<iosfwd> # include<string> # include<tuple> # include<unordered_map> # include \" gtest / gtest . h \" # include \" absl / base / internal / pretty_function . h \" # include \" absl / memory / memory . h \" # include \" absl / meta / type_traits . h \" # include \" absl / strings / string_view . h \" # include \" absl / strings / substitute . h \" # include \" absl / utility / utility . h \" namespace testing { enum class TypeSpec ; enum class AllocSpec ; TypeSpec)",
    "insertText": "operator(TypeSpec a, TypeSpec b)"
  },
  {
    "label": "TypeSpec()",
    "kind": "Method",
    "detail": "Function (using T = absl::underlying_type_t<TypeSpec> ; return static_cast<)",
    "insertText": "TypeSpec(static_cast<T>(a) | static_cast<T>(b))"
  },
  {
    "label": "TypeSpec()",
    "kind": "Method",
    "detail": "Function (using T = absl::underlying_type_t<TypeSpec> ; return static_cast<)",
    "insertText": "TypeSpec(static_cast<T>(a) & static_cast<T>(b))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} AllocSpec)",
    "insertText": "operator(AllocSpec a, AllocSpec b)"
  },
  {
    "label": "AllocSpec()",
    "kind": "Method",
    "detail": "Function (using T = absl::underlying_type_t<AllocSpec> ; return static_cast<)",
    "insertText": "AllocSpec(static_cast<T>(a) | static_cast<T>(b))"
  },
  {
    "label": "AllocSpec()",
    "kind": "Method",
    "detail": "Function (using T = absl::underlying_type_t<AllocSpec> ; return static_cast<)",
    "insertText": "AllocSpec(static_cast<T>(a) & static_cast<T>(b))"
  },
  {
    "label": "GetSpecString()",
    "kind": "Method",
    "detail": "Function (} namespace exceptions_internal { std::string)",
    "insertText": "GetSpecString(TypeSpec)"
  },
  {
    "label": "GetSpecString()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "GetSpecString(AllocSpec)"
  },
  {
    "label": "TestException()",
    "kind": "Method",
    "detail": "Function (struct NoThrowTag { } ; struct StrongGuaranteeTagType { } ; class TestException { public :)",
    "insertText": "TestException(absl::string_view msg) : msg_(msg)"
  },
  {
    "label": "TestException()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TestException()"
  },
  {
    "label": "what()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "what()"
  },
  {
    "label": "TestBadAllocException()",
    "kind": "Method",
    "detail": "Function (} private : std::string msg_ ; } ; class TestBadAllocException : public std::bad_alloc,public TestException { public :)",
    "insertText": "TestBadAllocException(absl::string_view msg) : TestException(msg)"
  },
  {
    "label": "SetCountdown()",
    "kind": "Method",
    "detail": "Function (} using TestException::what ; } ; int countdown ; void)",
    "insertText": "SetCountdown(int i = 0)"
  },
  {
    "label": "UnsetCountdown()",
    "kind": "Method",
    "detail": "Function (countdown = i ; } void)",
    "insertText": "UnsetCountdown()"
  },
  {
    "label": "SetCountdown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCountdown(-1)"
  },
  {
    "label": "MaybeThrow()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MaybeThrow(absl::string_view msg, bool throw_bad_alloc = false)"
  },
  {
    "label": "FailureMessage()",
    "kind": "Method",
    "detail": "Function (testing::AssertionResult)",
    "insertText": "FailureMessage(const TestException& e, int countdown)"
  },
  {
    "label": "ConstructorTracker()",
    "kind": "Method",
    "detail": "Function (struct TrackedAddress { bool is_alive ; std::string description ; } ; class ConstructorTracker { public :)",
    "insertText": "ConstructorTracker(int count) : countdown_(count)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(current_tracker_instance_ == nullptr)"
  },
  {
    "label": "ConstructorTracker()",
    "kind": "Method",
    "detail": "Function (current_tracker_instance_ = this ; } ~)",
    "insertText": "ConstructorTracker()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(current_tracker_instance_ == this)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (current_tracker_instance_ = nullptr ;)",
    "insertText": "for(auto& it : address_map_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (void* address = it . first ; TrackedAddress& tracked_address = it . second ;)",
    "insertText": "if(tracked_address.is_alive)"
  },
  {
    "label": "ADD_FAILURE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ADD_FAILURE() << ErrorMessage(address, tracked_address.description, countdown_, \"Object was not destroyed.\")"
  },
  {
    "label": "ObjectConstructed()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "ObjectConstructed(void* address, std::string description)"
  },
  {
    "label": "ADD_FAILURE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ADD_FAILURE() << ErrorMessage( address, tracked_address.description, current_tracker_instance_->countdown_, \"Object was re-constructed. Current object was constructed by \" + description)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (} tracked_address = { true,)",
    "insertText": "move(description)"
  },
  {
    "label": "ObjectDestructed()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ObjectDestructed(void* address)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (auto it = current_tracker_instance_ -> address_map_ .)",
    "insertText": "find(address)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TrackedAddress& tracked_address = it -> second ;)",
    "insertText": "if(!tracked_address.is_alive)"
  },
  {
    "label": "ADD_FAILURE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ADD_FAILURE() << ErrorMessage(address, tracked_address.description, current_tracker_instance_->countdown_, \"Object was re-destroyed.\")"
  },
  {
    "label": "CurrentlyTracking()",
    "kind": "Method",
    "detail": "Function (} tracked_address . is_alive = false ; } private : bool)",
    "insertText": "CurrentlyTracking()"
  },
  {
    "label": "TrackedObject()",
    "kind": "Method",
    "detail": "Function (} std::unordered_map<void*,TrackedAddress> address_map_ ; int countdown_ ; ConstructorTracker* current_tracker_instance_ ; } ; class TrackedObject { public :)",
    "insertText": "TrackedObject(const TrackedObject&)"
  },
  {
    "label": "TrackedObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TrackedObject(TrackedObject&&)"
  },
  {
    "label": "TrackedObject()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "TrackedObject(std::string description)"
  },
  {
    "label": "ObjectConstructed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ObjectConstructed(this, std::move(description))"
  },
  {
    "label": "TrackedObject()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TrackedObject()"
  },
  {
    "label": "ObjectDestructed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ObjectDestructed(this)"
  },
  {
    "label": "ThrowingBool()",
    "kind": "Method",
    "detail": "Function (} } ; } exceptions_internal::NoThrowTag nothrow_ctor ; exceptions_internal::StrongGuaranteeTagType strong_guarantee ; class ThrowingBool { public :)",
    "insertText": "ThrowingBool(bool b) noexcept : b_(b)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "MaybeThrow()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MaybeThrow(ABSL_PRETTY_FUNCTION)"
  },
  {
    "label": "ThrowingValue()",
    "kind": "Method",
    "detail": "Function (} int kDefaultValue = 0 ; int kBadValue = 9 3 8 5 5 0 6 2 0 ; public :)",
    "insertText": "ThrowingValue() : TrackedObject(GetInstanceString(kDefaultValue))"
  },
  {
    "label": "ThrowingValue()",
    "kind": "Method",
    "detail": "Function (dummy_ = kDefaultValue ; })",
    "insertText": "ThrowingValue(const ThrowingValue& other) noexcept( IsSpecified(TypeSpec::kNoThrowCopy)) : TrackedObject(GetInstanceString(other.dummy_))"
  },
  {
    "label": "ThrowingValue()",
    "kind": "Method",
    "detail": "Function (} dummy_ = other . dummy_ ; })",
    "insertText": "ThrowingValue(ThrowingValue&& other) noexcept( IsSpecified(TypeSpec::kNoThrowMove)) : TrackedObject(GetInstanceString(other.dummy_))"
  },
  {
    "label": "ThrowingValue()",
    "kind": "Method",
    "detail": "Function (} dummy_ = other . dummy_ ; })",
    "insertText": "ThrowingValue(int i) : TrackedObject(GetInstanceString(i))"
  },
  {
    "label": "ThrowingValue()",
    "kind": "Method",
    "detail": "Function (dummy_ = i ; })",
    "insertText": "ThrowingValue(int i, exceptions_internal::NoThrowTag) noexcept : TrackedObject(GetInstanceString(i)), dummy_(i)"
  },
  {
    "label": "ThrowingValue()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ThrowingValue()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ThrowingValue&)",
    "insertText": "operator(const ThrowingValue& other) noexcept( IsSpecified(TypeSpec::kNoThrowCopy))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (dummy_ = kBadValue ;)",
    "insertText": "if(!IsSpecified(TypeSpec::kNoThrowCopy))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} dummy_ = other . dummy_ ; return* this ; } ThrowingValue&)",
    "insertText": "operator(ThrowingValue&& other) noexcept( IsSpecified(TypeSpec::kNoThrowMove))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (dummy_ = kBadValue ;)",
    "insertText": "if(!IsSpecified(TypeSpec::kNoThrowMove))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} dummy_ = other . dummy_ ; return* this ; } ThrowingValue)",
    "insertText": "operator(const ThrowingValue& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ThrowingValue)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (+ + dummy_ ; return* this ; } ThrowingValue)",
    "insertText": "operator(int)"
  },
  {
    "label": "ThrowingValue()",
    "kind": "Method",
    "detail": "Function (auto out =)",
    "insertText": "ThrowingValue(dummy_, nothrow_ctor)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ThrowingValue)",
    "insertText": "operator(int shift)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ThrowingBool)",
    "insertText": "operator(const ThrowingValue& a, const ThrowingValue& b)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (std::ostream&)",
    "insertText": "operator(std::ostream& os, const ThrowingValue& tv)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} std::istream&)",
    "insertText": "operator(std::istream& is, const ThrowingValue&)"
  },
  {
    "label": "MaybeThrow()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MaybeThrow(ABSL_PRETTY_FUNCTION, true)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (} return::operator)",
    "insertText": "new(s)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (} void* operator)",
    "insertText": "new(size_t s) noexcept( IsSpecified(TypeSpec::kNoThrowNew))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (} template<. . . Args> void* operator)",
    "insertText": "new(size_t s, Args&&... args) noexcept( IsSpecified(TypeSpec::kNoThrowNew))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (} return::operator)",
    "insertText": "new(s, std::forward<Args>(args)...)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (} void operator)",
    "insertText": "delete(void* p)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (::operator)",
    "insertText": "delete(p)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (} template<. . . Args> void operator)",
    "insertText": "delete(void* p, Args&&... args)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (::operator)",
    "insertText": "delete(p, std::forward<Args>(args)...)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} int&)",
    "insertText": "Get()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} int dummy_ ; } ; template<TypeSpec Spec,T> void)",
    "insertText": "operator(const ThrowingValue<Spec>&, T&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<TypeSpec Spec,T> void)",
    "insertText": "operator(T&&, const ThrowingValue<Spec>&)"
  },
  {
    "label": "IsSpecified()",
    "kind": "Method",
    "detail": "Function (enum class AllocSpec { kEverythingThrows = 0,kNoThrowAllocate = 1,} ; template<T,AllocSpec Spec = AllocSpec::kEverythingThrows> class ThrowingAllocator : private exceptions_internal::TrackedObject { bool)",
    "insertText": "IsSpecified(AllocSpec spec)"
  },
  {
    "label": "ThrowingAllocator()",
    "kind": "Method",
    "detail": "Function (} public : using pointer = T* ; using const_pointer = const T* ; using reference = T& ; using const_reference = const T& ; using void_pointer = void* ; using const_void_pointer = const void* ; using value_type = T ; using size_type = size_t ; using difference_type = ptrdiff_t ; using is_nothrow = std::integral_constant<bool,Spec = = AllocSpec::kNoThrowAllocate> ; using propagate_on_container_copy_assignment = std::true_type ; using propagate_on_container_move_assignment = std::true_type ; using propagate_on_container_swap = std::true_type ; using is_always_equal = std::false_type ;)",
    "insertText": "ThrowingAllocator() : TrackedObject(GetInstanceString(next_id_))"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (dummy_ = std::make_shared<const)",
    "insertText": "int(next_id_++)"
  },
  {
    "label": "ThrowingAllocator()",
    "kind": "Method",
    "detail": "Function (} template<U>)",
    "insertText": "ThrowingAllocator(const ThrowingAllocator<U, Spec>& other) noexcept : TrackedObject(GetInstanceString(*other.State())), dummy_(other.State())"
  },
  {
    "label": "ThrowingAllocator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ThrowingAllocator(const ThrowingAllocator& other) noexcept : TrackedObject(GetInstanceString(*other.State())), dummy_(other.State())"
  },
  {
    "label": "ThrowingAllocator()",
    "kind": "Method",
    "detail": "Function (} template<U>)",
    "insertText": "ThrowingAllocator(ThrowingAllocator<U, Spec>&& other) noexcept : TrackedObject(GetInstanceString(*other.State())), dummy_(std::move(other.State()))"
  },
  {
    "label": "ThrowingAllocator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ThrowingAllocator(ThrowingAllocator&& other) noexcept : TrackedObject(GetInstanceString(*other.State())), dummy_(std::move(other.State()))"
  },
  {
    "label": "ThrowingAllocator()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ThrowingAllocator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ThrowingAllocator&)",
    "insertText": "operator(const ThrowingAllocator& other)"
  },
  {
    "label": "State()",
    "kind": "Method",
    "detail": "Function (dummy_ = other .)",
    "insertText": "State()"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (dummy_ =)",
    "insertText": "move(other.State())"
  },
  {
    "label": "ReadStateAndMaybeThrow()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReadStateAndMaybeThrow(ABSL_PRETTY_FUNCTION)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (} pointer)",
    "insertText": "allocate(size_type n, const_void_pointer) noexcept( IsSpecified(AllocSpec::kNoThrowAllocate))"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "deallocate(pointer ptr, size_type)"
  },
  {
    "label": "ReadState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReadState()"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (::operator)",
    "insertText": "delete(static_cast<void*>(ptr))"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (} template<U,. . . Args> void)",
    "insertText": "construct(U* ptr, Args&&... args) noexcept( IsSpecified(AllocSpec::kNoThrowAllocate))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(static_cast<void*>(ptr)) U(std::forward<Args>(args)...)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (} template<U> void)",
    "insertText": "destroy(U* p)"
  },
  {
    "label": "U()",
    "kind": "Method",
    "detail": "Function (p -> ~)",
    "insertText": "U()"
  },
  {
    "label": "max_size()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "max_size()"
  },
  {
    "label": "select_on_container_copy_construction()",
    "kind": "Method",
    "detail": "Function (} ThrowingAllocator)",
    "insertText": "select_on_container_copy_construction() noexcept( IsSpecified(AllocSpec::kNoThrowAllocate))"
  },
  {
    "label": "ReadStateAndMaybeThrow()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ReadStateAndMaybeThrow(absl::string_view msg)"
  },
  {
    "label": "MaybeThrow()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MaybeThrow(absl::Substitute(\"Allocator id $0 threw from $1\", *dummy_, msg))"
  },
  {
    "label": "TestThrowingCtor()",
    "kind": "Method",
    "detail": "Function (} } int next_id_ ; std::shared_ptr<const int> dummy_ ; } ; template<T,AllocSpec Spec> int ThrowingAllocator<T,Spec>::next_id_ = 0 ; template<T,. . . Args> void)",
    "insertText": "TestThrowingCtor(Args&&... args)"
  },
  {
    "label": "Cleanup()",
    "kind": "Method",
    "detail": "Function (struct Cleanup { ~)",
    "insertText": "Cleanup()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } c ;)",
    "insertText": "for(int count = 0;; ++count)"
  },
  {
    "label": "ct()",
    "kind": "Method",
    "detail": "Function (exceptions_internal::ConstructorTracker)",
    "insertText": "ct(count)"
  },
  {
    "label": "SetCountdown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCountdown(count)"
  },
  {
    "label": "temp()",
    "kind": "Method",
    "detail": "Function (try { T)",
    "insertText": "temp(std::forward<Args>(args)...)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "void(temp)"
  },
  {
    "label": "catch()",
    "kind": "Method",
    "detail": "Function (break ; })",
    "insertText": "catch(const exceptions_internal::TestException&)"
  },
  {
    "label": "TestNothrowOp()",
    "kind": "Method",
    "detail": "Function (} } } template<Operation> testing::AssertionResult)",
    "insertText": "TestNothrowOp(const Operation& operation)"
  },
  {
    "label": "SetCountdown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCountdown()"
  },
  {
    "label": "operation()",
    "kind": "Method",
    "detail": "Function (} } c ; try {)",
    "insertText": "operation()"
  },
  {
    "label": "catch()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "catch(...)"
  },
  {
    "label": "DefaultFactory()",
    "kind": "Method",
    "detail": "Function (} } namespace exceptions_internal { struct UninitializedT { } ; template<T> class DefaultFactory { public :)",
    "insertText": "DefaultFactory(const T& t) : t_(t)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} std::unique_ptr<T>)",
    "insertText": "operator()()"
  },
  {
    "label": "MakeExceptionSafetyTester()",
    "kind": "Method",
    "detail": "Function (} private : T t_ ; } ; template<size_t LazyContractsCount,LazyFactory,LazyOperation> using EnableIfTestable = absl::enable_if_t<LazyContractsCount ! = 0&& ! std::is_same<LazyFactory,UninitializedT>::value&& ! std::is_same<LazyOperation,UninitializedT>::value> ; template<Factory = UninitializedT,Operation = UninitializedT,. . . Contracts> class ExceptionSafetyTestBuilder ; } exceptions_internal::ExceptionSafetyTestBuilder<>)",
    "insertText": "MakeExceptionSafetyTester()"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (namespace exceptions_internal { template<T> struct IsUniquePtr : std::false_type { } ; template<T,D> struct IsUniquePtr<std::unique_ptr<T,D>> : std::true_type { } ; template<Factory> struct FactoryPtrTypeHelper { using type =)",
    "insertText": "decltype(std::declval<const Factory&>()())"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} ; template<Factory> using FactoryPtrType = FactoryPtrTypeHelper<Factory>::type ; template<Factory> using FactoryElementType = FactoryPtrType<Factory>::element_type ; template<T> class ExceptionSafetyTest { using Factory = std::function<std::unique_ptr<)",
    "insertText": "T()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (using Operation = std::function<)",
    "insertText": "void(T*)"
  },
  {
    "label": "AssertionResult()",
    "kind": "Method",
    "detail": "Function (using Contract = std::function<)",
    "insertText": "AssertionResult(T*)"
  },
  {
    "label": "ExceptionSafetyTest()",
    "kind": "Method",
    "detail": "Function (public : template<. . . Contracts>)",
    "insertText": "ExceptionSafetyTest(const Factory& f, const Operation& op, const Contracts&... contracts) : factory_(f), operation_(op)"
  },
  {
    "label": "WrapContract()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WrapContract(contracts)"
  },
  {
    "label": "Test()",
    "kind": "Method",
    "detail": "Function (} AssertionResult)",
    "insertText": "Test()"
  },
  {
    "label": "factory_()",
    "kind": "Method",
    "detail": "Function (auto t_ptr =)",
    "insertText": "factory_()"
  },
  {
    "label": "operation_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operation_(t_ptr.get())"
  },
  {
    "label": "catch()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "catch(const exceptions_internal::TestException& e)"
  },
  {
    "label": "WrapContract()",
    "kind": "Method",
    "detail": "Function (} } } } } private : template<ContractFn> Contract)",
    "insertText": "WrapContract(const ContractFn& contract)"
  },
  {
    "label": "WrapContract()",
    "kind": "Method",
    "detail": "Function (} ; } Contract)",
    "insertText": "WrapContract(StrongGuaranteeTagType)"
  },
  {
    "label": "WithInitialValue()",
    "kind": "Method",
    "detail": "Function (} ; } Factory factory_ ; Operation operation_ ; std::vector<Contract> contracts_ ; } ; template<Factory,Operation,. . . Contracts> class ExceptionSafetyTestBuilder { public : template<T> ExceptionSafetyTestBuilder<DefaultFactory<T>,Operation,Contracts . . .>)",
    "insertText": "WithInitialValue(const T& t)"
  },
  {
    "label": "WithFactory()",
    "kind": "Method",
    "detail": "Function (} template<NewFactory> ExceptionSafetyTestBuilder<absl::decay_t<NewFactory>,Operation,Contracts . . .>)",
    "insertText": "WithFactory(const NewFactory& new_factory)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} template<NewOperation,= EnableIfTestable<)",
    "insertText": "sizeof(Contracts), Factory, NewOperation>> testing::AssertionResult Test(const NewOperation& new_operation)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} template<LazyOperation = Operation,= EnableIfTestable<)",
    "insertText": "sizeof(Contracts), Factory, LazyOperation>> testing::AssertionResult Test()"
  },
  {
    "label": "ExceptionSafetyTestBuilder()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExceptionSafetyTestBuilder()"
  },
  {
    "label": "ExceptionSafetyTestBuilder()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ExceptionSafetyTestBuilder(const Factory& f, const Operation& o, const std::tuple<Contracts...>& i) : factory_(f), operation_(o), contracts_(i)"
  },
  {
    "label": "TestImpl()",
    "kind": "Method",
    "detail": "Function (} template<SelectedOperation,size_t . . . Indices> testing::AssertionResult)",
    "insertText": "TestImpl(SelectedOperation selected_operation, absl::index_sequence<Indices...>)"
  }
]