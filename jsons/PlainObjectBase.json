[
  {
    "label": "check_rows_cols_for_overflow",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "check_rows_cols_for_overflow"
  },
  {
    "label": "conservative_resize_like_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "conservative_resize_like_impl"
  },
  {
    "label": "matrix_swap_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "matrix_swap_impl"
  },
  {
    "label": "dense_xpr_base_dispatcher",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "dense_xpr_base_dispatcher"
  },
  {
    "label": "PlainObjectBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PlainObjectBase"
  },
  {
    "label": "StridedMapType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StridedMapType"
  },
  {
    "label": "StridedConstMapType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StridedConstMapType"
  },
  {
    "label": "StridedAlignedMapType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StridedAlignedMapType"
  },
  {
    "label": "StridedConstAlignedMapType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StridedConstAlignedMapType"
  },
  {
    "label": "internal",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "internal"
  },
  {
    "label": "Eigen",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Eigen"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_DENSESTORAGEBASE_H # define EIGEN_DENSESTORAGEBASE_H # if)",
    "insertText": "defined(EIGEN_INITIALIZE_MATRICES_BY_ZERO) # define EIGEN_INITIALIZE_COEFFS # define EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED for(Index i=0;i<base().size();++i) coeffRef(i)=Scalar(0)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# elif)",
    "insertText": "defined(EIGEN_INITIALIZE_MATRICES_BY_NAN) # define EIGEN_INITIALIZE_COEFFS # define EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED for(Index i=0;i<base().size();++i) coeffRef(i)=std::numeric_limits<Scalar>::quiet_NaN()"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (# else # undef EIGEN_INITIALIZE_COEFFS # define EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED # endif namespace Eigen { namespace internal { template<int MaxSizeAtCompileTime> struct check_rows_cols_for_overflow { template<Index> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void)",
    "insertText": "run(Index, Index)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct check_rows_cols_for_overflow<Dynamic> { template<Index> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void)",
    "insertText": "run(Index rows, Index cols)"
  },
  {
    "label": "max_index()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "max_index(std::size_t(1) << (8 * sizeof(Index) - 1))"
  },
  {
    "label": "error()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "error(rows == 0 || cols == 0) ? false : (rows > max_index / cols)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} } ; template<Derived,OtherDerived = Derived,bool IsVector =)",
    "insertText": "bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)"
  },
  {
    "label": "NeedsToAlign()",
    "kind": "Method",
    "detail": "Function (template<MatrixTypeA,MatrixTypeB,bool SwapPointers> struct matrix_swap_impl ; } # ifdef EIGEN_PARSED_BY_DOXYGEN namespace doxygen { template<Derived> struct dense_xpr_base_dispatcher ; template<_Scalar,int _Rows,int _Cols,int _Options,int _MaxRows,int _MaxCols> struct dense_xpr_base_dispatcher<Matrix<_Scalar,_Rows,_Cols,_Options,_MaxRows,_MaxCols>> : public MatrixBase { } ; template<_Scalar,int _Rows,int _Cols,int _Options,int _MaxRows,int _MaxCols> struct dense_xpr_base_dispatcher<Array<_Scalar,_Rows,_Cols,_Options,_MaxRows,_MaxCols>> : public ArrayBase { } ; } template<Derived> class PlainObjectBase : public doxygen::dense_xpr_base_dispatcher<Derived> # else template<Derived> class PlainObjectBase : public internal::dense_xpr_base<Derived>::type # endif { public : enum { Options = internal::traits<Derived>::Options } ; typedef internal::dense_xpr_base<Derived>::type Base ; typedef internal::traits<Derived>::StorageKind StorageKind ; typedef internal::traits<Derived>::Scalar Scalar ; typedef internal::packet_traits<Scalar>::type PacketScalar ; typedef NumTraits<Scalar>::Real RealScalar ; typedef Derived DenseType ; using Base::RowsAtCompileTime ; using Base::ColsAtCompileTime ; using Base::SizeAtCompileTime ; using Base::MaxRowsAtCompileTime ; using Base::MaxColsAtCompileTime ; using Base::MaxSizeAtCompileTime ; using Base::IsVectorAtCompileTime ; using Base::Flags ; typedef Eigen::Map<Derived,Unaligned> MapType ; typedef const Eigen::Map<const Derived,Unaligned> ConstMapType ; typedef Eigen::Map<Derived,AlignedMax> AlignedMapType ; typedef const Eigen::Map<const Derived,AlignedMax> ConstAlignedMapType ; template<StrideType> struct StridedMapType { typedef Eigen::Map<Derived,Unaligned,StrideType> type ; } ; template<StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived,Unaligned,StrideType> type ; } ; template<StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived,AlignedMax,StrideType> type ; } ; template<StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived,AlignedMax,StrideType> type ; } ; protected : DenseStorage<Scalar,Base::MaxSizeAtCompileTime,Base::RowsAtCompileTime,Base::ColsAtCompileTime,Options> m_storage ; public : enum {)",
    "insertText": "NeedsToAlign(SizeAtCompileTime != Dynamic) && (internal::traits<Derived>::Alignment>0)"
  },
  {
    "label": "EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign) EIGEN_DEVICE_FUNC Base& base()"
  },
  {
    "label": "base()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC const Base&)",
    "insertText": "base()"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR Index)",
    "insertText": "rows()"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR Index)",
    "insertText": "cols()"
  },
  {
    "label": "coeff()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar&)",
    "insertText": "coeff(Index rowId, Index colId)"
  },
  {
    "label": "coeff()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar&)",
    "insertText": "coeff(Index index)"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar&)",
    "insertText": "coeffRef(Index rowId, Index colId)"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar&)",
    "insertText": "coeffRef(Index index)"
  },
  {
    "label": "packet()",
    "kind": "Method",
    "detail": "Function (} template<int LoadMode> EIGEN_STRONG_INLINE PacketScalar)",
    "insertText": "packet(Index rowId, Index colId)"
  },
  {
    "label": "packet()",
    "kind": "Method",
    "detail": "Function (} template<int LoadMode> EIGEN_STRONG_INLINE PacketScalar)",
    "insertText": "packet(Index index)"
  },
  {
    "label": "writePacket()",
    "kind": "Method",
    "detail": "Function (} template<int StoreMode> EIGEN_STRONG_INLINE void)",
    "insertText": "writePacket(Index rowId, Index colId, const PacketScalar& val)"
  },
  {
    "label": "StoreMode()",
    "kind": "Method",
    "detail": "Function (internal::pstoret<Scalar,PacketScalar,)",
    "insertText": "StoreMode(m_storage.data() + (Flags & RowMajorBit ? colId + rowId * m_storage.cols() : rowId + colId * m_storage.rows()), val)"
  },
  {
    "label": "writePacket()",
    "kind": "Method",
    "detail": "Function (} template<int StoreMode> EIGEN_STRONG_INLINE void)",
    "insertText": "writePacket(Index index, const PacketScalar& val)"
  },
  {
    "label": "StoreMode()",
    "kind": "Method",
    "detail": "Function (internal::pstoret<Scalar,PacketScalar,)",
    "insertText": "StoreMode(m_storage.data() + index, val)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar*)",
    "insertText": "data()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "resize(Index rows, Index cols)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,rows==RowsAtCompileTime) && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,cols==ColsAtCompileTime) && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,rows<=MaxRowsAtCompileTime) && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,cols<=MaxColsAtCompileTime) && rows>=0 && cols>=0 && \"Invalid sizes when resizing a matrix or array.\")"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime)",
    "insertText": "run(rows, cols)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_INITIALIZE_COEFFS Index size = rows* cols ; bool size_changed = size ! = this ->)",
    "insertText": "size()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_storage .)",
    "insertText": "resize(size, rows, cols)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (# endif } EIGEN_DEVICE_FUNC void)",
    "insertText": "resize(Index size)"
  },
  {
    "label": "EIGEN_STATIC_ASSERT_VECTOR_ONLY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT_VECTOR_ONLY(PlainObjectBase) eigen_assert(((SizeAtCompileTime == Dynamic && (MaxSizeAtCompileTime==Dynamic || size<=MaxSizeAtCompileTime)) || SizeAtCompileTime == size) && size>=0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(RowsAtCompileTime == 1) m_storage.resize(size, 1, size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_INITIALIZE_COEFFS)",
    "insertText": "if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED #endif } EIGEN_DEVICE_FUNC inline void resize(NoChange_t, Index cols)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(rows(), cols)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC void)",
    "insertText": "resize(Index rows, NoChange_t)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(rows, cols())"
  },
  {
    "label": "resizeLike()",
    "kind": "Method",
    "detail": "Function (} template<OtherDerived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "resizeLike(const EigenBase<OtherDerived>& _other)"
  },
  {
    "label": "derived()",
    "kind": "Method",
    "detail": "Function (const OtherDerived& other = _other .)",
    "insertText": "derived()"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime)",
    "insertText": "run(other.rows(), other.cols())"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (const Index othersize = other .)",
    "insertText": "rows()*other.cols()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(other.rows() == 1 || other.cols() == 1)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(1, othersize)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(ColsAtCompileTime == 1)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(othersize, 1)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "resize(other.rows(), other.cols())"
  },
  {
    "label": "conservativeResize()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "conservativeResize(Index rows, Index cols)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (internal::conservative_resize_like_impl<Derived)",
    "insertText": "run(*this, rows, cols)"
  },
  {
    "label": "conservativeResize()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "conservativeResize(Index rows, NoChange_t)"
  },
  {
    "label": "conservativeResize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "conservativeResize(rows, cols())"
  },
  {
    "label": "conservativeResize()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "conservativeResize(NoChange_t, Index cols)"
  },
  {
    "label": "conservativeResize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "conservativeResize(rows(), cols)"
  },
  {
    "label": "conservativeResize()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "conservativeResize(Index size)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (internal::conservative_resize_like_impl<Derived)",
    "insertText": "run(*this, size)"
  },
  {
    "label": "conservativeResizeLike()",
    "kind": "Method",
    "detail": "Function (} template<OtherDerived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "conservativeResizeLike(const DenseBase<OtherDerived>& other)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (internal::conservative_resize_like_impl<Derived,OtherDerived)",
    "insertText": "run(*this, other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived&)",
    "insertText": "operator(const PlainObjectBase& other)"
  },
  {
    "label": "lazyAssign()",
    "kind": "Method",
    "detail": "Function (} template<OtherDerived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived&)",
    "insertText": "lazyAssign(const DenseBase<OtherDerived>& other)"
  },
  {
    "label": "_resize_to_match()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_resize_to_match(other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<OtherDerived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived&)",
    "insertText": "operator(const ReturnByValue<OtherDerived>& func)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(func.rows(), func.cols())"
  },
  {
    "label": "PlainObjectBase()",
    "kind": "Method",
    "detail": "Function (} protected : EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "PlainObjectBase() : m_storage()"
  },
  {
    "label": "PlainObjectBase()",
    "kind": "Method",
    "detail": "Function (} # ifndef EIGEN_PARSED_BY_DOXYGEN EIGEN_DEVICE_FUNC)",
    "insertText": "PlainObjectBase(internal::constructor_without_unaligned_array_assert) : m_storage(internal::constructor_without_unaligned_array_assert())"
  },
  {
    "label": "PlainObjectBase()",
    "kind": "Method",
    "detail": "Function (} # endif # if EIGEN_HAS_RVALUE_REFERENCES EIGEN_DEVICE_FUNC)",
    "insertText": "PlainObjectBase(PlainObjectBase&& other) EIGEN_NOEXCEPT : m_storage( std::move(other.m_storage))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC PlainObjectBase&)",
    "insertText": "operator(PlainObjectBase&& other)"
  },
  {
    "label": "_check_template_params()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_check_template_params()"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (m_storage =)",
    "insertText": "move(other.m_storage)"
  },
  {
    "label": "PlainObjectBase()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "PlainObjectBase(Index size, Index rows, Index cols) : m_storage(size, rows, cols)"
  },
  {
    "label": "PlainObjectBase()",
    "kind": "Method",
    "detail": "Function (} # if EIGEN_HAS_CXX11 template<. . . ArgTypes> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "PlainObjectBase(const Scalar& a0, const Scalar& a1, const Scalar& a2, const Scalar& a3, const ArgTypes&... args) : m_storage()"
  },
  {
    "label": "EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, sizeof...(args) + 4)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (Index i = 4 ; auto)",
    "insertText": "x(m_storage.data()[i++] = args, 0)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "void(x)"
  },
  {
    "label": "PlainObjectBase()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "PlainObjectBase(const std::initializer_list<std::initializer_list<Scalar>>& list) : m_storage()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t list_size = 0 ;)",
    "insertText": "if(list.begin() != list.end())"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (list_size = list .)",
    "insertText": "begin()->size()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ColsAtCompileTime == 1 && list.size() == 1)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(list_size == static_cast<size_t>(RowsAtCompileTime) || RowsAtCompileTime == Dynamic)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(list_size, ColsAtCompileTime)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copy(list.begin()->begin(), list.begin()->end(), m_storage.data())"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "eigen_assert(list.size() == static_cast<size_t>(RowsAtCompileTime) || RowsAtCompileTime == Dynamic)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(list_size == static_cast<size_t>(ColsAtCompileTime) || ColsAtCompileTime == Dynamic)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(list.size(), list_size)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index row_index = 0 ;)",
    "insertText": "for(const std::initializer_list<Scalar>& row : list)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(list_size == row.size())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index col_index = 0 ;)",
    "insertText": "for(const Scalar& e : row)"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "coeffRef(row_index, col_index)"
  },
  {
    "label": "PlainObjectBase()",
    "kind": "Method",
    "detail": "Function (+ + col_index ; } + + row_index ; } } } # endif template<OtherDerived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "PlainObjectBase(const DenseBase<OtherDerived> &other) : m_storage()"
  },
  {
    "label": "resizeLike()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resizeLike(other)"
  },
  {
    "label": "_set_noalias()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_set_noalias(other)"
  },
  {
    "label": "PlainObjectBase()",
    "kind": "Method",
    "detail": "Function (} template<OtherDerived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "PlainObjectBase(const EigenBase<OtherDerived> &other) : m_storage()"
  },
  {
    "label": "PlainObjectBase()",
    "kind": "Method",
    "detail": "Function (} template<OtherDerived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "PlainObjectBase(const ReturnByValue<OtherDerived>& other)"
  },
  {
    "label": "evalTo()",
    "kind": "Method",
    "detail": "Function (other .)",
    "insertText": "evalTo(this->derived())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} public : template<OtherDerived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived&)",
    "insertText": "operator(const EigenBase<OtherDerived> &other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(other.derived())"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (} ConstMapType)",
    "insertText": "Map(const Scalar* data)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (} MapType)",
    "insertText": "Map(Scalar* data)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (} ConstMapType)",
    "insertText": "Map(const Scalar* data, Index size)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (} MapType)",
    "insertText": "Map(Scalar* data, Index size)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (} ConstMapType)",
    "insertText": "Map(const Scalar* data, Index rows, Index cols)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (} MapType)",
    "insertText": "Map(Scalar* data, Index rows, Index cols)"
  },
  {
    "label": "MapAligned()",
    "kind": "Method",
    "detail": "Function (} ConstAlignedMapType)",
    "insertText": "MapAligned(const Scalar* data)"
  },
  {
    "label": "MapAligned()",
    "kind": "Method",
    "detail": "Function (} AlignedMapType)",
    "insertText": "MapAligned(Scalar* data)"
  },
  {
    "label": "MapAligned()",
    "kind": "Method",
    "detail": "Function (} ConstAlignedMapType)",
    "insertText": "MapAligned(const Scalar* data, Index size)"
  },
  {
    "label": "MapAligned()",
    "kind": "Method",
    "detail": "Function (} AlignedMapType)",
    "insertText": "MapAligned(Scalar* data, Index size)"
  },
  {
    "label": "MapAligned()",
    "kind": "Method",
    "detail": "Function (} ConstAlignedMapType)",
    "insertText": "MapAligned(const Scalar* data, Index rows, Index cols)"
  },
  {
    "label": "MapAligned()",
    "kind": "Method",
    "detail": "Function (} AlignedMapType)",
    "insertText": "MapAligned(Scalar* data, Index rows, Index cols)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (} template<int Outer,int Inner> StridedConstMapType<Stride<Outer,Inner>>::type)",
    "insertText": "Map(const Scalar* data, const Stride<Outer, Inner>& stride)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (} template<int Outer,int Inner> StridedMapType<Stride<Outer,Inner>>::type)",
    "insertText": "Map(Scalar* data, const Stride<Outer, Inner>& stride)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (} template<int Outer,int Inner> StridedConstMapType<Stride<Outer,Inner>>::type)",
    "insertText": "Map(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (} template<int Outer,int Inner> StridedMapType<Stride<Outer,Inner>>::type)",
    "insertText": "Map(Scalar* data, Index size, const Stride<Outer, Inner>& stride)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (} template<int Outer,int Inner> StridedConstMapType<Stride<Outer,Inner>>::type)",
    "insertText": "Map(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (} template<int Outer,int Inner> StridedMapType<Stride<Outer,Inner>>::type)",
    "insertText": "Map(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)"
  },
  {
    "label": "MapAligned()",
    "kind": "Method",
    "detail": "Function (} template<int Outer,int Inner> StridedConstAlignedMapType<Stride<Outer,Inner>>::type)",
    "insertText": "MapAligned(const Scalar* data, const Stride<Outer, Inner>& stride)"
  },
  {
    "label": "MapAligned()",
    "kind": "Method",
    "detail": "Function (} template<int Outer,int Inner> StridedAlignedMapType<Stride<Outer,Inner>>::type)",
    "insertText": "MapAligned(Scalar* data, const Stride<Outer, Inner>& stride)"
  },
  {
    "label": "MapAligned()",
    "kind": "Method",
    "detail": "Function (} template<int Outer,int Inner> StridedConstAlignedMapType<Stride<Outer,Inner>>::type)",
    "insertText": "MapAligned(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)"
  },
  {
    "label": "MapAligned()",
    "kind": "Method",
    "detail": "Function (} template<int Outer,int Inner> StridedAlignedMapType<Stride<Outer,Inner>>::type)",
    "insertText": "MapAligned(Scalar* data, Index size, const Stride<Outer, Inner>& stride)"
  },
  {
    "label": "MapAligned()",
    "kind": "Method",
    "detail": "Function (} template<int Outer,int Inner> StridedConstAlignedMapType<Stride<Outer,Inner>>::type)",
    "insertText": "MapAligned(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)"
  },
  {
    "label": "MapAligned()",
    "kind": "Method",
    "detail": "Function (} template<int Outer,int Inner> StridedAlignedMapType<Stride<Outer,Inner>>::type)",
    "insertText": "MapAligned(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)"
  },
  {
    "label": "setConstant()",
    "kind": "Method",
    "detail": "Function (} using Base::setConstant ; EIGEN_DEVICE_FUNC Derived&)",
    "insertText": "setConstant(Index size, const Scalar& val)"
  },
  {
    "label": "setConstant()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC Derived&)",
    "insertText": "setConstant(Index rows, Index cols, const Scalar& val)"
  },
  {
    "label": "setConstant()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC Derived&)",
    "insertText": "setConstant(NoChange_t, Index cols, const Scalar& val)"
  },
  {
    "label": "setConstant()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC Derived&)",
    "insertText": "setConstant(Index rows, NoChange_t, const Scalar& val)"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (using Base::setZero ; EIGEN_DEVICE_FUNC Derived&)",
    "insertText": "setZero(Index size)"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC Derived&)",
    "insertText": "setZero(Index rows, Index cols)"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC Derived&)",
    "insertText": "setZero(NoChange_t, Index cols)"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC Derived&)",
    "insertText": "setZero(Index rows, NoChange_t)"
  },
  {
    "label": "setOnes()",
    "kind": "Method",
    "detail": "Function (using Base::setOnes ; EIGEN_DEVICE_FUNC Derived&)",
    "insertText": "setOnes(Index size)"
  },
  {
    "label": "setOnes()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC Derived&)",
    "insertText": "setOnes(Index rows, Index cols)"
  },
  {
    "label": "setOnes()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC Derived&)",
    "insertText": "setOnes(NoChange_t, Index cols)"
  },
  {
    "label": "setOnes()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC Derived&)",
    "insertText": "setOnes(Index rows, NoChange_t)"
  },
  {
    "label": "setRandom()",
    "kind": "Method",
    "detail": "Function (using Base::setRandom ; Derived&)",
    "insertText": "setRandom(Index size)"
  },
  {
    "label": "setRandom()",
    "kind": "Method",
    "detail": "Function (Derived&)",
    "insertText": "setRandom(Index rows, Index cols)"
  },
  {
    "label": "setRandom()",
    "kind": "Method",
    "detail": "Function (Derived&)",
    "insertText": "setRandom(NoChange_t, Index cols)"
  },
  {
    "label": "setRandom()",
    "kind": "Method",
    "detail": "Function (Derived&)",
    "insertText": "setRandom(Index rows, NoChange_t)"
  },
  {
    "label": "_resize_to_match()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_PLAINOBJECTBASE_PLUGIN # include EIGEN_PLAINOBJECTBASE_PLUGIN # endif protected : template<OtherDerived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "_resize_to_match(const EigenBase<OtherDerived>& other)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_NO_AUTOMATIC_RESIZING)",
    "insertText": "eigen_assert((this->size()==0 || (IsVectorAtCompileTime ? (this->size() == other.size()) : (rows() == other.rows() && cols() == other.cols()))) && \"Size mismatch. Automatic resizing is disabled because EIGEN_NO_AUTOMATIC_RESIZING is defined\")"
  },
  {
    "label": "EIGEN_ONLY_USED_FOR_DEBUG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_ONLY_USED_FOR_DEBUG(other)"
  },
  {
    "label": "_set()",
    "kind": "Method",
    "detail": "Function (# endif } template<OtherDerived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived&)",
    "insertText": "_set(const DenseBase<OtherDerived>& other)"
  },
  {
    "label": "call_assignment()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "call_assignment(this->derived(), other.derived())"
  },
  {
    "label": "_set_noalias()",
    "kind": "Method",
    "detail": "Function (} template<OtherDerived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived&)",
    "insertText": "_set_noalias(const DenseBase<OtherDerived>& other)"
  },
  {
    "label": "call_assignment_no_alias()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "call_assignment_no_alias(this->derived(), other.derived(), internal::assign_op<Scalar,typename OtherDerived::Scalar>())"
  },
  {
    "label": "_init2()",
    "kind": "Method",
    "detail": "Function (} template<T0,T1> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "_init2(Index rows, Index cols, typename internal::enable_if<Base::SizeAtCompileTime!=2,T0>::type* = 0)"
  },
  {
    "label": "EIGEN_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (const bool t0_is_integer_alike = internal::is_valid_index_type<T0>::value ; const bool t1_is_integer_alike = internal::is_valid_index_type<T1>::value ;)",
    "insertText": "EIGEN_STATIC_ASSERT(t0_is_integer_alike && t1_is_integer_alike, FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED) resize(rows,cols)"
  },
  {
    "label": "_init2()",
    "kind": "Method",
    "detail": "Function (} template<T0,T1> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "_init2(const T0& val0, const T1& val1, typename internal::enable_if<Base::SizeAtCompileTime==2,T0>::type* = 0)"
  },
  {
    "label": "EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, 2) m_storage.data()[0] = Scalar(val0)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (m_storage .)",
    "insertText": "data()[1] = Scalar(val1)"
  },
  {
    "label": "_init2()",
    "kind": "Method",
    "detail": "Function (} template<T0,T1> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "_init2(const Index& val0, const Index& val1, typename internal::enable_if< (!internal::is_same<Index,Scalar>::value) && (internal::is_same<T0,Index>::value) && (internal::is_same<T1,Index>::value) && Base::SizeAtCompileTime==2,T1>::type* = 0)"
  },
  {
    "label": "_init1()",
    "kind": "Method",
    "detail": "Function (} template<T> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "_init1(Index size, typename internal::enable_if< (Base::SizeAtCompileTime!=1 || !internal::is_convertible<T, Scalar>::value) && ((!internal::is_same<typename internal::traits<Derived>::XprKind,ArrayXpr>::value || Base::SizeAtCompileTime==Dynamic)),T>::type* = 0)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (const bool is_integer_alike = internal::is_valid_index_type<T>::value ;)",
    "insertText": "EIGEN_UNUSED_VARIABLE(is_integer_alike)"
  },
  {
    "label": "EIGEN_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT(is_integer_alike, FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED) resize(size)"
  },
  {
    "label": "_init1()",
    "kind": "Method",
    "detail": "Function (} template<T> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "_init1(const Scalar& val0, typename internal::enable_if<Base::SizeAtCompileTime==1 && internal::is_convertible<T, Scalar>::value,T>::type* = 0)"
  },
  {
    "label": "EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, 1) m_storage.data()"
  },
  {
    "label": "_init1()",
    "kind": "Method",
    "detail": "Function (} template<T> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "_init1(const Index& val0, typename internal::enable_if< (!internal::is_same<Index,Scalar>::value) && (internal::is_same<Index,T>::value) && Base::SizeAtCompileTime==1 && internal::is_convertible<T, Scalar>::value,T*>::type* = 0)"
  },
  {
    "label": "EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, 1) m_storage.data()[0] = Scalar(val0)"
  },
  {
    "label": "_init1()",
    "kind": "Method",
    "detail": "Function (} template<T> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "_init1(const Scalar* data)"
  },
  {
    "label": "_set_noalias()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "_set_noalias(ConstMapType(data))"
  },
  {
    "label": "_init1()",
    "kind": "Method",
    "detail": "Function (} template<T,OtherDerived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "_init1(const DenseBase<OtherDerived>& other)"
  },
  {
    "label": "_init1()",
    "kind": "Method",
    "detail": "Function (} template<T> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "_init1(const Derived& other)"
  },
  {
    "label": "_init1()",
    "kind": "Method",
    "detail": "Function (} template<T,OtherDerived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "_init1(const EigenBase<OtherDerived>& other)"
  },
  {
    "label": "_init1()",
    "kind": "Method",
    "detail": "Function (} template<T,OtherDerived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "_init1(const ReturnByValue<OtherDerived>& other)"
  },
  {
    "label": "_init1()",
    "kind": "Method",
    "detail": "Function (} template<T,OtherDerived,int ColsAtCompileTime> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "_init1(const RotationBase<OtherDerived,ColsAtCompileTime>& r)"
  },
  {
    "label": "_init1()",
    "kind": "Method",
    "detail": "Function (} template<T> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "_init1(const Scalar& val0, typename internal::enable_if< Base::SizeAtCompileTime!=Dynamic && Base::SizeAtCompileTime!=1 && internal::is_convertible<T, Scalar>::value && internal::is_same<typename internal::traits<Derived>::XprKind,ArrayXpr>::value,T>::type* = 0)"
  },
  {
    "label": "setConstant()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setConstant(val0)"
  },
  {
    "label": "_init1()",
    "kind": "Method",
    "detail": "Function (} template<T> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "_init1(const Index& val0, typename internal::enable_if< (!internal::is_same<Index,Scalar>::value) && (internal::is_same<Index,T>::value) && Base::SizeAtCompileTime!=Dynamic && Base::SizeAtCompileTime!=1 && internal::is_convertible<T, Scalar>::value && internal::is_same<typename internal::traits<Derived>::XprKind,ArrayXpr>::value,T*>::type* = 0)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} template<MatrixTypeA,MatrixTypeB,bool SwapPointers> struct internal::matrix_swap_impl ; public : # ifndef EIGEN_PARSED_BY_DOXYGEN template<OtherDerived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "swap(DenseBase<OtherDerived> & other)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (enum { SwapPointers = internal::is_same<Derived,OtherDerived>::value&& Base::SizeAtCompileTime = = Dynamic } ; internal::matrix_swap_impl<Derived,OtherDerived,)",
    "insertText": "bool(SwapPointers)>::run(this->derived(), other.derived())"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} template<OtherDerived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "swap(DenseBase<OtherDerived> const & other)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(other.derived())"
  },
  {
    "label": "EIGEN_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT((EIGEN_IMPLIES(MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1, (int(Options)&RowMajor)==RowMajor) && EIGEN_IMPLIES(MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1, (int(Options)&RowMajor)==0) && ((RowsAtCompileTime == Dynamic) || (RowsAtCompileTime >= 0)) && ((ColsAtCompileTime == Dynamic) || (ColsAtCompileTime >= 0)) && ((MaxRowsAtCompileTime == Dynamic) || (MaxRowsAtCompileTime >= 0)) && ((MaxColsAtCompileTime == Dynamic) || (MaxColsAtCompileTime >= 0)) && (MaxRowsAtCompileTime == RowsAtCompileTime || RowsAtCompileTime==Dynamic) && (MaxColsAtCompileTime == ColsAtCompileTime || ColsAtCompileTime==Dynamic) && (Options & (DontAlign|RowMajor)) == Options), INVALID_MATRIX_TEMPLATE_PARAMETERS)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (IsPlainObjectBase = 1 } ; # endif public : template<PlainObjectType,int MapOptions,StrideType> class Eigen::Map ; class Eigen::Map<Derived,Unaligned> ; class Eigen::Map<const Derived,Unaligned> ; # if EIGEN_MAX_ALIGN_BYTES> 0 class Eigen::Map<Derived,AlignedMax> ; class Eigen::Map<const Derived,AlignedMax> ; # endif } ; namespace internal { template<Derived,OtherDerived,bool IsVector> struct conservative_resize_like_impl { # if EIGEN_HAS_TYPE_TRAITS const bool IsRelocatable = std::is_trivially_copyable<Derived::Scalar>::value ; # else const bool IsRelocatable = ! NumTraits<Derived::Scalar>::RequireInitialization ; # endif void)",
    "insertText": "run(DenseBase<Derived>& _this, Index rows, Index cols)"
  },
  {
    "label": "EIGEN_STATIC_ASSERT_DYNAMIC_SIZE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT_DYNAMIC_SIZE(Derived) if ( IsRelocatable && (( Derived::IsRowMajor && _this.cols() == cols) || (!Derived::IsRowMajor && _this.rows() == rows) ))"
  },
  {
    "label": "derived()",
    "kind": "Method",
    "detail": "Function (_this .)",
    "insertText": "derived().m_storage.conservativeResize(rows*cols,rows,cols)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (} else { Derived)",
    "insertText": "tmp(rows,cols)"
  },
  {
    "label": "mini()",
    "kind": "Method",
    "detail": "Function (const Index common_rows =)",
    "insertText": "mini(rows, _this.rows())"
  },
  {
    "label": "mini()",
    "kind": "Method",
    "detail": "Function (const Index common_cols =)",
    "insertText": "mini(cols, _this.cols())"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (tmp .)",
    "insertText": "block(0,0,common_rows,common_cols) = _this.block(0,0,common_rows,common_cols)"
  },
  {
    "label": "derived()",
    "kind": "Method",
    "detail": "Function (_this .)",
    "insertText": "derived().swap(tmp)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "run(DenseBase<Derived>& _this, const DenseBase<OtherDerived>& other)"
  },
  {
    "label": "EIGEN_STATIC_ASSERT_DYNAMIC_SIZE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT_DYNAMIC_SIZE(Derived) EIGEN_STATIC_ASSERT_DYNAMIC_SIZE(OtherDerived) if ( IsRelocatable && (( Derived::IsRowMajor && _this.cols() == other.cols()) || (!Derived::IsRowMajor && _this.rows() == other.rows()) ))"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (const Index new_rows = other .)",
    "insertText": "rows() - _this.rows()"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (const Index new_cols = other .)",
    "insertText": "cols() - _this.cols()"
  },
  {
    "label": "derived()",
    "kind": "Method",
    "detail": "Function (_this .)",
    "insertText": "derived().m_storage.conservativeResize(other.size(),other.rows(),other.cols())"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (} else { Derived)",
    "insertText": "tmp(other)"
  },
  {
    "label": "mini()",
    "kind": "Method",
    "detail": "Function (const Index common_rows =)",
    "insertText": "mini(tmp.rows(), _this.rows())"
  },
  {
    "label": "mini()",
    "kind": "Method",
    "detail": "Function (const Index common_cols =)",
    "insertText": "mini(tmp.cols(), _this.cols())"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } } ; template<Derived,OtherDerived> struct conservative_resize_like_impl<Derived,OtherDerived,true> : conservative_resize_like_impl<Derived,OtherDerived,false> { typedef conservative_resize_like_impl<Derived,OtherDerived,false> Base ; using Base::run ; using Base::IsRelocatable ; void)",
    "insertText": "run(DenseBase<Derived>& _this, Index size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Index new_rows = Derived::RowsAtCompileTime = = 1 ? 1 : size ; const Index new_cols = Derived::RowsAtCompileTime = = 1 ? size : 1 ;)",
    "insertText": "if(IsRelocatable) _this.derived().m_storage.conservativeResize(size,new_rows,new_cols)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (const Index num_new_elements = other .)",
    "insertText": "size() - _this.size()"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<MatrixTypeA,MatrixTypeB,bool SwapPointers> struct matrix_swap_impl { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "run(MatrixTypeA& a, MatrixTypeB& b)"
  },
  {
    "label": "base()",
    "kind": "Method",
    "detail": "Function (a .)",
    "insertText": "base().swap(b)"
  },
  {
    "label": "Base()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "Base(a).m_storage.swap(static_cast<typename MatrixTypeB::Base&>(b).m_storage)"
  }
]