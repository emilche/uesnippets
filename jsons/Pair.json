[
  {
    "label": "__non_trivially_copyable_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__non_trivially_copyable_base"
  },
  {
    "label": "_T1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_T1"
  },
  {
    "label": "_T2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_T2"
  },
  {
    "label": "_LIBCPP_TEMPLATE_VIS",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_LIBCPP_TEMPLATE_VIS"
  },
  {
    "label": "_U1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_U1"
  },
  {
    "label": "_U2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_U2"
  },
  {
    "label": "_CheckArgs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_CheckArgs"
  },
  {
    "label": "_CheckTupleLikeConstructor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_CheckTupleLikeConstructor"
  },
  {
    "label": "_Tuple",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tuple"
  },
  {
    "label": "_TQual",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_TQual"
  },
  {
    "label": "_UQual",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_UQual"
  },
  {
    "label": "basic_common_reference",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "basic_common_reference"
  },
  {
    "label": "common_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "common_type"
  },
  {
    "label": "__get_pair",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__get_pair"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___UTILITY_PAIR_H # define _LIBCPP___UTILITY_PAIR_H # include<__compare / common_comparison_category . h> # include<__compare / synth_three_way . h> # include<__config> # include<__functional / unwrap_ref . h> # include<__tuple> # include<__utility / forward . h> # include<__utility / move . h> # include<__utility / piecewise_construct . h> # include<cstddef> # include<type_traits> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER) # pragma GCC system_header #endif _LIBCPP_BEGIN_NAMESPACE_STD #if defined(_LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR)"
  },
  {
    "label": "__non_trivially_copyable_base()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__non_trivially_copyable_base()"
  },
  {
    "label": "__non_trivially_copyable_base()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__non_trivially_copyable_base(__non_trivially_copyable_base const&)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } ; # endif template<class _T1,class _T2> struct _LIBCPP_TEMPLATE_VIS pair # if)",
    "insertText": "defined(_LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (typedef _T1 first_type ; typedef _T2 second_type ; _T1 first ; _T2 second ; # if !)",
    "insertText": "defined(_LIBCPP_CXX03_LANG) pair(pair const&)"
  },
  {
    "label": "pair()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pair(pair&&)"
  },
  {
    "label": "pair()",
    "kind": "Method",
    "detail": "Function (# else # endif # ifdef _LIBCPP_CXX03_LANG _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "pair() : first(), second()"
  },
  {
    "label": "pair()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "pair(_T1 const& __t1, _T2 const& __t2) : first(__t1), second(__t2)"
  },
  {
    "label": "pair()",
    "kind": "Method",
    "detail": "Function (} template<class _U1,class _U2> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY pair&)",
    "insertText": "operator(pair const& __p)"
  },
  {
    "label": "__enable_explicit_default()",
    "kind": "Method",
    "detail": "Function (first = __p . first ; second = __p . second ; return* this ; } # else struct _CheckArgs { template<int& . . .> bool)",
    "insertText": "__enable_explicit_default()"
  },
  {
    "label": "__enable_implicit_default()",
    "kind": "Method",
    "detail": "Function (} template<int& . . .> bool)",
    "insertText": "__enable_implicit_default()"
  },
  {
    "label": "__enable_implicit()",
    "kind": "Method",
    "detail": "Function (} template<class _U1,class _U2> bool)",
    "insertText": "__enable_implicit()"
  },
  {
    "label": "__enable_implicit_default()",
    "kind": "Method",
    "detail": "Function (} template<bool _Dummy = true,enable_if<_CheckArgsDep<_Dummy)",
    "insertText": "__enable_implicit_default() >::type* = nullptr> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR pair() _NOEXCEPT_(is_nothrow_default_constructible<first_type>::value && is_nothrow_default_constructible<second_type>::value) : first(), second()"
  },
  {
    "label": "const()",
    "kind": "Method",
    "detail": "Function (} template<bool _Dummy = true,enable_if<_CheckArgsDep<_Dummy>::template __enable_explicit<_T1 const&,_T2)",
    "insertText": "const() >::type* = nullptr> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 explicit pair(_T1 const& __t1, _T2 const& __t2) _NOEXCEPT_(is_nothrow_copy_constructible<first_type>::value && is_nothrow_copy_constructible<second_type>::value) : first(__t1), second(__t2)"
  },
  {
    "label": "const()",
    "kind": "Method",
    "detail": "Function (} template<bool _Dummy = true,enable_if<_CheckArgsDep<_Dummy>::template __enable_implicit<_T1 const&,_T2)",
    "insertText": "const() >::type* = nullptr> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 pair(_T1 const& __t1, _T2 const& __t2) _NOEXCEPT_(is_nothrow_copy_constructible<first_type>::value && is_nothrow_copy_constructible<second_type>::value) : first(__t1), second(__t2)"
  },
  {
    "label": "_U2()",
    "kind": "Method",
    "detail": "Function (} template<# if _LIBCPP_STD_VER> 2 0 class _U1 = _T1,class _U2 = _T2,# else class _U1,class _U2,# endif enable_if<_CheckArgs::template __enable_explicit<_U1,)",
    "insertText": "_U2()>::type* = nullptr > _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 explicit pair(_U1&& __u1, _U2&& __u2) _NOEXCEPT_((is_nothrow_constructible<first_type, _U1>::value && is_nothrow_constructible<second_type, _U2>::value)) : first(_VSTD::forward<_U1>(__u1)), second(_VSTD::forward<_U2>(__u2))"
  },
  {
    "label": "_U2()",
    "kind": "Method",
    "detail": "Function (} template<# if _LIBCPP_STD_VER> 2 0 class _U1 = _T1,class _U2 = _T2,# else class _U1,class _U2,# endif enable_if<_CheckArgs::template __enable_implicit<_U1,)",
    "insertText": "_U2()>::type* = nullptr > _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 pair(_U1&& __u1, _U2&& __u2) _NOEXCEPT_((is_nothrow_constructible<first_type, _U1>::value && is_nothrow_constructible<second_type, _U2>::value)) : first(_VSTD::forward<_U1>(__u1)), second(_VSTD::forward<_U2>(__u2))"
  },
  {
    "label": "const()",
    "kind": "Method",
    "detail": "Function (} template<class _U1,class _U2,enable_if<_CheckArgs::template __enable_explicit<_U1 const&,_U2)",
    "insertText": "const() >::type* = nullptr> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 explicit pair(pair<_U1, _U2> const& __p) _NOEXCEPT_((is_nothrow_constructible<first_type, _U1 const&>::value && is_nothrow_constructible<second_type, _U2 const&>::value)) : first(__p.first), second(__p.second)"
  },
  {
    "label": "const()",
    "kind": "Method",
    "detail": "Function (} template<class _U1,class _U2,enable_if<_CheckArgs::template __enable_implicit<_U1 const&,_U2)",
    "insertText": "const() >::type* = nullptr> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 pair(pair<_U1, _U2> const& __p) _NOEXCEPT_((is_nothrow_constructible<first_type, _U1 const&>::value && is_nothrow_constructible<second_type, _U2 const&>::value)) : first(__p.first), second(__p.second)"
  },
  {
    "label": "_U2()",
    "kind": "Method",
    "detail": "Function (} template<class _U1,class _U2,enable_if<_CheckArgs::template __enable_explicit<_U1,)",
    "insertText": "_U2() >::type* = nullptr> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 explicit pair(pair<_U1, _U2>&&__p) _NOEXCEPT_((is_nothrow_constructible<first_type, _U1&&>::value && is_nothrow_constructible<second_type, _U2&&>::value)) : first(_VSTD::forward<_U1>(__p.first)), second(_VSTD::forward<_U2>(__p.second))"
  },
  {
    "label": "_U2()",
    "kind": "Method",
    "detail": "Function (} template<class _U1,class _U2,enable_if<_CheckArgs::template __enable_implicit<_U1,)",
    "insertText": "_U2() >::type* = nullptr> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 pair(pair<_U1, _U2>&& __p) _NOEXCEPT_((is_nothrow_constructible<first_type, _U1&&>::value && is_nothrow_constructible<second_type, _U2&&>::value)) : first(_VSTD::forward<_U1>(__p.first)), second(_VSTD::forward<_U2>(__p.second))"
  },
  {
    "label": "_Tuple()",
    "kind": "Method",
    "detail": "Function (} template<class _Tuple,enable_if<_CheckTLC<_Tuple>::template __enable_explicit<)",
    "insertText": "_Tuple() >::type* = nullptr> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 explicit pair(_Tuple&& __p) : first(_VSTD::get<0>(_VSTD::forward<_Tuple>(__p))), second(_VSTD::get<1>(_VSTD::forward<_Tuple>(__p)))"
  },
  {
    "label": "_Tuple()",
    "kind": "Method",
    "detail": "Function (} template<class _Tuple,enable_if<_CheckTLC<_Tuple>::template __enable_implicit<)",
    "insertText": "_Tuple() >::type* = nullptr> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 pair(_Tuple&& __p) : first(_VSTD::get<0>(_VSTD::forward<_Tuple>(__p))), second(_VSTD::get<1>(_VSTD::forward<_Tuple>(__p)))"
  },
  {
    "label": "pair()",
    "kind": "Method",
    "detail": "Function (} template<class . . . _Args1,class . . . _Args2> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17)",
    "insertText": "pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args) _NOEXCEPT_((is_nothrow_constructible<first_type, _Args1...>::value && is_nothrow_constructible<second_type, _Args2...>::value)) : pair(__pc, __first_args, __second_args, typename __make_tuple_indices<sizeof...(_Args1)>::type(), typename __make_tuple_indices<sizeof...(_Args2) >::type())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17 pair&)",
    "insertText": "operator(typename conditional< is_copy_assignable<first_type>::value && is_copy_assignable<second_type>::value, pair, __nat>::type const& __p) _NOEXCEPT_(is_nothrow_copy_assignable<first_type>::value && is_nothrow_copy_assignable<second_type>::value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (first = __p . first ; second = __p . second ; return* this ; } _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17 pair&)",
    "insertText": "operator(typename conditional< is_move_assignable<first_type>::value && is_move_assignable<second_type>::value, pair, __nat>::type&& __p) _NOEXCEPT_(is_nothrow_move_assignable<first_type>::value && is_nothrow_move_assignable<second_type>::value)"
  },
  {
    "label": "first_type()",
    "kind": "Method",
    "detail": "Function (first = _VSTD::forward<)",
    "insertText": "first_type(__p.first)"
  },
  {
    "label": "second_type()",
    "kind": "Method",
    "detail": "Function (second = _VSTD::forward<)",
    "insertText": "second_type(__p.second)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (first =)",
    "insertText": "get(_VSTD::forward<_Tuple>(__p))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (using _VSTD::swap ;)",
    "insertText": "swap(first, __p.first)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(second, __p.second)"
  },
  {
    "label": "pair()",
    "kind": "Method",
    "detail": "Function (} private : # ifndef _LIBCPP_CXX03_LANG template<class . . . _Args1,class . . . _Args2,size_t . . . _I1,size_t . . . _I2> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17)",
    "insertText": "pair(piecewise_construct_t, tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args, __tuple_indices<_I1...>, __tuple_indices<_I2...>)"
  },
  {
    "label": "pair()",
    "kind": "Method",
    "detail": "Function (pair<_T1, _T2>)",
    "insertText": "pair(_T1, _T2)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# endif template<class _T1,class _T2> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 bool)",
    "insertText": "operator(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} # endif # if _LIBCPP_STD_VER> 2 0 template<class _T1,class _T2,class _U1,class _U2,template<class> class _TQual,template<class> class _UQual> requires requires { pair<common_reference_t<_TQual<_T1>,_UQual<_U1>>,common_reference_t<_TQual<_T2>,_UQual<_U2>>> ; } struct basic_common_reference<pair<_T1,_T2>,pair<_U1,_U2>,_TQual,_UQual> { using type = pair<common_reference_t<_TQual<_T1>,_UQual<_U1>>,common_reference_t<_TQual<_T2>,_UQual<_U2>>> ; } ; template<class _T1,class _T2,class _U1,class _U2> requires requires { pair<common_type_t<_T1,_U1>,common_type_t<_T2,_U2>> ; } struct common_type<pair<_T1,_T2>,pair<_U1,_U2>> { using type = pair<common_type_t<_T1,_U1>,common_type_t<_T2,_U2>> ; } ; # endif template<class _T1,class _T2> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17 enable_if<__is_swappable<_T1>::value&& __is_swappable<_T2>::value,void>::type)",
    "insertText": "swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y) _NOEXCEPT_((__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (__x .)",
    "insertText": "swap(__y)"
  },
  {
    "label": "make_pair()",
    "kind": "Method",
    "detail": "Function (} # ifndef _LIBCPP_CXX03_LANG template<class _T1,class _T2> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 pair<__unwrap_ref_decay<_T1>::type,__unwrap_ref_decay<_T2>::type>)",
    "insertText": "make_pair(_T1&& __t1, _T2&& __t2)"
  },
  {
    "label": "make_pair()",
    "kind": "Method",
    "detail": "Function (} # else template<class _T1,class _T2> _LIBCPP_INLINE_VISIBILITY pair<_T1,_T2>)",
    "insertText": "make_pair(_T1 __x, _T2 __y)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} # endif template<class _T1,class _T2> struct _LIBCPP_TEMPLATE_VIS tuple_size<pair<_T1,_T2>> : public integral_constant<size_t,2> { } ; template<size_t _Ip,class _T1,class _T2> struct _LIBCPP_TEMPLATE_VIS tuple_element<_Ip,pair<_T1,_T2>> {)",
    "insertText": "static_assert(_Ip < 2, \"Index out of bounds in std::tuple_element<std::pair<T1, T2>>\")"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} ; template<class _T1,class _T2> struct _LIBCPP_TEMPLATE_VIS tuple_element<0,pair<_T1,_T2>> { typedef _LIBCPP_NODEBUG _T1 type ; } ; template<class _T1,class _T2> struct _LIBCPP_TEMPLATE_VIS tuple_element<1,pair<_T1,_T2>> { typedef _LIBCPP_NODEBUG _T2 type ; } ; template<size_t _Ip> struct __get_pair ; template<> struct __get_pair<0> { template<class _T1,class _T2> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 _T1&)",
    "insertText": "get(pair<_T1, _T2>& __p)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} template<class _T1,class _T2> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _T1&&)",
    "insertText": "get(const pair<_T1, _T2>&& __p)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} template<size_t _Ip,class _T1,class _T2> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const tuple_element<_Ip,pair<_T1,_T2>>::type&)",
    "insertText": "get(const pair<_T1, _T2>& __p)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} # ifndef _LIBCPP_CXX03_LANG template<size_t _Ip,class _T1,class _T2> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 tuple_element<_Ip,pair<_T1,_T2>>::type&&)",
    "insertText": "get(pair<_T1, _T2>&& __p)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} template<class _T1,class _T2> _LIBCPP_INLINE_VISIBILITY _T1 const&)",
    "insertText": "get(pair<_T1, _T2> const& __p)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} template<class _T1,class _T2> _LIBCPP_INLINE_VISIBILITY _T1 const&&)",
    "insertText": "get(pair<_T1, _T2> const&& __p)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} template<class _T1,class _T2> _LIBCPP_INLINE_VISIBILITY _T1&)",
    "insertText": "get(pair<_T2, _T1>& __p)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} template<class _T1,class _T2> _LIBCPP_INLINE_VISIBILITY _T1 const&)",
    "insertText": "get(pair<_T2, _T1> const& __p)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} template<class _T1,class _T2> _LIBCPP_INLINE_VISIBILITY _T1&&)",
    "insertText": "get(pair<_T2, _T1>&& __p)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} template<class _T1,class _T2> _LIBCPP_INLINE_VISIBILITY _T1 const&&)",
    "insertText": "get(pair<_T2, _T1> const&& __p)"
  }
]