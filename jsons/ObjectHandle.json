[
  {
    "label": "UClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UClass"
  },
  {
    "label": "UPackage",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UPackage"
  },
  {
    "label": "FObjectHandlePrivate",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FObjectHandlePrivate"
  },
  {
    "label": "FObjectHandlePackageDebugData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FObjectHandlePackageDebugData"
  },
  {
    "label": "FObjectHandleDataClassDescriptor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FObjectHandleDataClassDescriptor"
  },
  {
    "label": "FObjectPathIdDebug",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FObjectPathIdDebug"
  },
  {
    "label": "FObjectDescriptorDebug",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FObjectDescriptorDebug"
  },
  {
    "label": "FStoredObjectPathDebug",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FStoredObjectPathDebug"
  },
  {
    "label": "IsObjectHandleNull()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Map . h \" # include \" Containers / ScriptArray . h \" # include \" CoreTypes . h \" # include \" HAL / CriticalSection . h \" # include \" HAL / Platform . h \" # include \" Misc / AssertionMacros . h \" # include \" Templates / TypeHash . h \" # include \" UObject / NameTypes . h \" # include \" UObject / ObjectHandleTracking . h \" # include \" UObject / ObjectMacros . h \" # include \" UObject / ObjectRef . h \" # include \" UObject / PackedObjectRef . h \" class UClass ; class UPackage ; # if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE namespace UE::CoreUObject::Private { struct FObjectHandlePrivate ; } using FObjectHandle = UE::CoreUObject::Private::FObjectHandlePrivate ; # else using FObjectHandle = UObject* ; # endif bool)",
    "insertText": "IsObjectHandleNull(FObjectHandle Handle)"
  },
  {
    "label": "IsObjectHandleResolved()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsObjectHandleResolved(FObjectHandle Handle)"
  },
  {
    "label": "IsObjectHandleTypeSafe()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsObjectHandleTypeSafe(FObjectHandle Handle)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (namespace UE::CoreUObject::Private { # if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE struct FObjectHandlePrivate { UPTRINT PointerOrRef ; operator)",
    "insertText": "bool()"
  },
  {
    "label": "MakeObjectRef()",
    "kind": "Method",
    "detail": "Function (FObjectRef)",
    "insertText": "MakeObjectRef(FPackedObjectRef Handle)"
  },
  {
    "label": "MakeObjectHandle()",
    "kind": "Method",
    "detail": "Function (# endif FObjectHandle)",
    "insertText": "MakeObjectHandle(UObject* Object)"
  },
  {
    "label": "ResolveObjectHandle()",
    "kind": "Method",
    "detail": "Function (UObject*)",
    "insertText": "ResolveObjectHandle(FObjectHandle& Handle)"
  },
  {
    "label": "ResolveObjectHandleClass()",
    "kind": "Method",
    "detail": "Function (UClass*)",
    "insertText": "ResolveObjectHandleClass(FObjectHandle Handle)"
  },
  {
    "label": "ResolveObjectHandleNoRead()",
    "kind": "Method",
    "detail": "Function (UObject*)",
    "insertText": "ResolveObjectHandleNoRead(FObjectHandle& Handle)"
  },
  {
    "label": "ResolveObjectHandleNoReadNoCheck()",
    "kind": "Method",
    "detail": "Function (UObject*)",
    "insertText": "ResolveObjectHandleNoReadNoCheck(FObjectHandle& Handle)"
  },
  {
    "label": "ReadObjectHandlePointerNoCheck()",
    "kind": "Method",
    "detail": "Function (UObject*)",
    "insertText": "ReadObjectHandlePointerNoCheck(FObjectHandle Handle)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (# if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE)",
    "insertText": "return(Handle.PointerOrRef & 1)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (# if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE&& UE_WITH_OBJECT_HANDLE_TYPE_SAFETY)",
    "insertText": "return((Handle.PointerOrRef & 3) == 3)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# else return true ; # endif } # if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE bool)",
    "insertText": "operator(UE::CoreUObject::Private::FObjectHandlePrivate LHS, UE::CoreUObject::Private::FObjectHandlePrivate RHS)"
  },
  {
    "label": "IsObjectHandleResolved()",
    "kind": "Method",
    "detail": "Function (using namespace UE::CoreUObject::Private ; bool LhsResolved =)",
    "insertText": "IsObjectHandleResolved(LHS)"
  },
  {
    "label": "IsObjectHandleResolved()",
    "kind": "Method",
    "detail": "Function (bool RhsResolved =)",
    "insertText": "IsObjectHandleResolved(RHS)"
  },
  {
    "label": "ReadObjectHandlePointerNoCheck()",
    "kind": "Method",
    "detail": "Function (const UObject* Obj =)",
    "insertText": "ReadObjectHandlePointerNoCheck(LHS)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetTypeHash(UE::CoreUObject::Private::FObjectHandlePrivate Handle)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using namespace UE::CoreUObject::Private ;)",
    "insertText": "if(Handle.PointerOrRef == 0)"
  },
  {
    "label": "ReadObjectHandlePointerNoCheck()",
    "kind": "Method",
    "detail": "Function (const UObject* Obj =)",
    "insertText": "ReadObjectHandlePointerNoCheck(Handle)"
  },
  {
    "label": "FindExistingPackedObjectRef()",
    "kind": "Method",
    "detail": "Function (FPackedObjectRef PackedObjectRef =)",
    "insertText": "FindExistingPackedObjectRef(Obj)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "GetTypeHash(PackedObjectRef.EncodedRef)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "GetTypeHash(Handle.PointerOrRef)"
  },
  {
    "label": "UPTRINT()",
    "kind": "Method",
    "detail": "Function (# if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE { return {)",
    "insertText": "UPTRINT(Object)"
  },
  {
    "label": "ResolveObjectHandleNoRead()",
    "kind": "Method",
    "detail": "Function (# if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE | | UE_WITH_OBJECT_HANDLE_TRACKING UObject* ResolvedObject =)",
    "insertText": "ResolveObjectHandleNoRead(Handle)"
  },
  {
    "label": "OnHandleRead()",
    "kind": "Method",
    "detail": "Function (UE::CoreUObject::)",
    "insertText": "OnHandleRead(ResolvedObject)"
  },
  {
    "label": "ReadObjectHandlePackedObjectRefNoCheck()",
    "kind": "Method",
    "detail": "Function (# endif } # if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE FPackedObjectRef)",
    "insertText": "ReadObjectHandlePackedObjectRefNoCheck(FObjectHandle Handle)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE)",
    "insertText": "if(IsObjectHandleResolved(Handle))"
  },
  {
    "label": "ReadObjectHandlePackedObjectRefNoCheck()",
    "kind": "Method",
    "detail": "Function (} else { FPackedObjectRef PackedObjectRef =)",
    "insertText": "ReadObjectHandlePackedObjectRefNoCheck(Handle)"
  },
  {
    "label": "MakeObjectRef()",
    "kind": "Method",
    "detail": "Function (FObjectRef ObjectRef =)",
    "insertText": "MakeObjectRef(PackedObjectRef)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE FObjectHandle LocalHandle = Handle ;)",
    "insertText": "if(IsObjectHandleResolved(LocalHandle))"
  },
  {
    "label": "ReadObjectHandlePointerNoCheck()",
    "kind": "Method",
    "detail": "Function (UObject* ResolvedObject =)",
    "insertText": "ReadObjectHandlePointerNoCheck(LocalHandle)"
  },
  {
    "label": "Resolve()",
    "kind": "Method",
    "detail": "Function (UObject* ResolvedObject = ObjectRef .)",
    "insertText": "Resolve()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if UE_WITH_OBJECT_HANDLE_TYPE_SAFETY)",
    "insertText": "if(IsObjectHandleTypeSafe(LocalHandle))"
  },
  {
    "label": "MakeObjectHandle()",
    "kind": "Method",
    "detail": "Function (Handle =)",
    "insertText": "MakeObjectHandle(ResolvedObject)"
  },
  {
    "label": "ReadObjectHandlePackedObjectRefNoCheck()",
    "kind": "Method",
    "detail": "Function (# if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE FObjectHandle LocalHandle = Handle ; FPackedObjectRef PackedObjectRef =)",
    "insertText": "ReadObjectHandlePackedObjectRefNoCheck(LocalHandle)"
  },
  {
    "label": "UObject()",
    "kind": "Method",
    "detail": "Function (# if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE return reinterpret_cast<)",
    "insertText": "UObject(Handle.PointerOrRef)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (# else return Handle ; # endif } struct FObjectHandlePackageDebugData { FMinimalName PackageName ; FScriptArray ObjectDescriptors ; uint8 _Padding [)",
    "insertText": "sizeof(FRWLock)"
  },
  {
    "label": "WeakObjectMask()",
    "kind": "Method",
    "detail": "Function (} ; struct FObjectHandleDataClassDescriptor { FMinimalName PackageName ; FMinimalName ClassName ; } ; struct FObjectPathIdDebug { uint32 Index = 0 ; uint32 Number = 0 ; uint32)",
    "insertText": "WeakObjectMask((~0u) >> 1)"
  },
  {
    "label": "InitObjectHandles()",
    "kind": "Method",
    "detail": "Function (uint32 SimpleNameMask = WeakObjectMask>> 1 ; } ; struct FObjectDescriptorDebug { FObjectPathIdDebug ObjectPath ; FObjectHandleDataClassDescriptor ClassDescriptor ; } ; struct FStoredObjectPathDebug { const int32 NumInlineElements = 3 ; int32 NumElements ; union { FMinimalName Short [ NumInlineElements ] ; FMinimalName* Long ; } ; } ; uint32 TypeIdShift = 1 ; uint32 ObjectIdShift = 2 ; uint32 PackageIdShift = 3 4 ; uint32 PackageIdMask = 0 x3FFF ' FFFF ; # if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE void)",
    "insertText": "InitObjectHandles(int32 Size)"
  },
  {
    "label": "FreeObjectHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeObjectHandle(const UObjectBase* Object)"
  },
  {
    "label": "UpdateRenamedObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateRenamedObject(const UObject* Obj, FName NewName, UObject* NewOuter)"
  },
  {
    "label": "MakePackedObjectRef()",
    "kind": "Method",
    "detail": "Function (UE::CoreUObject::Private::FPackedObjectRef)",
    "insertText": "MakePackedObjectRef(const UObject* Object)"
  }
]