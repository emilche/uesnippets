[
  {
    "label": "RefCountedBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RefCountedBase"
  },
  {
    "label": "RefCountedThreadSafeBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RefCountedThreadSafeBase"
  },
  {
    "label": "ScopedAllowCrossThreadRefCountAccess",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScopedAllowCrossThreadRefCountAccess"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "RefCounted",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RefCounted"
  },
  {
    "label": "DefaultRefCountedTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DefaultRefCountedTraits"
  },
  {
    "label": "RefCountedThreadSafe",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RefCountedThreadSafe"
  },
  {
    "label": "DefaultRefCountedThreadSafeTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DefaultRefCountedThreadSafeTraits"
  },
  {
    "label": "RefCountedData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RefCountedData"
  },
  {
    "label": "base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "base"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef CEF_INCLUDE_BASE_CEF_REF_COUNTED_H_ # define CEF_INCLUDE_BASE_CEF_REF_COUNTED_H_ # pragma once # if)",
    "insertText": "defined(USING_CHROMIUM_INCLUDES)"
  },
  {
    "label": "HasOneRef()",
    "kind": "Method",
    "detail": "Function (namespace cef_subtle { class RefCountedBase { public : bool)",
    "insertText": "HasOneRef()"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON() thread_checker_.DetachFromThread()"
  },
  {
    "label": "RefCountedBase()",
    "kind": "Method",
    "detail": "Function (# endif })",
    "insertText": "RefCountedBase(StartRefCountFromOneTag) : ref_count_(1)"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON()"
  },
  {
    "label": "DetachFromThread()",
    "kind": "Method",
    "detail": "Function (thread_checker_ .)",
    "insertText": "DetachFromThread()"
  },
  {
    "label": "RefCountedBase()",
    "kind": "Method",
    "detail": "Function (# endif } ~)",
    "insertText": "RefCountedBase()"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON() DCHECK(in_dtor_) << \"RefCounted object deleted without calling Release()"
  },
  {
    "label": "AddRef()",
    "kind": "Method",
    "detail": "Function (# endif } void)",
    "insertText": "AddRef()"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON() DCHECK(!in_dtor_)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(!needs_adopt_ref_)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(CalledOnValidThread())"
  },
  {
    "label": "AddRefImpl()",
    "kind": "Method",
    "detail": "Function (} # endif)",
    "insertText": "AddRefImpl()"
  },
  {
    "label": "Release()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Release()"
  },
  {
    "label": "ReleaseImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseImpl()"
  },
  {
    "label": "IsOnValidThread()",
    "kind": "Method",
    "detail": "Function (# endif return ref_count_ = = 0 ; } bool)",
    "insertText": "IsOnValidThread()"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON() return ref_count_ <= 1 || CalledOnValidThread()"
  },
  {
    "label": "AdoptRef()",
    "kind": "Method",
    "detail": "Function (# else return true ; # endif } private : template<U> scoped_refptr<U>)",
    "insertText": "AdoptRef(U*)"
  },
  {
    "label": "Adopted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Adopted()"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON() DCHECK(needs_adopt_ref_)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (needs_adopt_ref_ = false ; # endif } # if)",
    "insertText": "defined(ARCH_CPU_64_BITS) void AddRefImpl()"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (- - ref_count_ ; } # endif # if)",
    "insertText": "DCHECK_IS_ON() bool CalledOnValidThread()"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# endif uint32_t ref_count_ = 0 ;)",
    "insertText": "static_assert(std::is_unsigned<decltype(ref_count_)>::value, \"ref_count_ must be an unsigned type.\")"
  },
  {
    "label": "DISALLOW_COPY_AND_ASSIGN()",
    "kind": "Method",
    "detail": "Function (bool in_dtor_ = false ; ThreadChecker thread_checker_ ; # endif)",
    "insertText": "DISALLOW_COPY_AND_ASSIGN(RefCountedBase)"
  },
  {
    "label": "HasAtLeastOneRef()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasAtLeastOneRef()"
  },
  {
    "label": "RefCountedThreadSafeBase()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "RefCountedThreadSafeBase(StartRefCountFromZeroTag)"
  },
  {
    "label": "RefCountedThreadSafeBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RefCountedThreadSafeBase(StartRefCountFromOneTag) : ref_count_(1)"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# endif } # if)",
    "insertText": "DCHECK_IS_ON() ~RefCountedThreadSafeBase()"
  },
  {
    "label": "RefCountedThreadSafeBase()",
    "kind": "Method",
    "detail": "Function (# else ~)",
    "insertText": "RefCountedThreadSafeBase()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # if)",
    "insertText": "defined(ARCH_CPU_X86_FAMILY) bool Release()"
  },
  {
    "label": "AddRefWithCheck()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddRefWithCheck()"
  },
  {
    "label": "AddRefWithCheckImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddRefWithCheckImpl()"
  },
  {
    "label": "Increment()",
    "kind": "Method",
    "detail": "Function (# endif ref_count_ .)",
    "insertText": "Increment()"
  },
  {
    "label": "CHECK()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "CHECK(ref_count_.Increment() > 0)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(!ref_count_.IsZero())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(!ref_count_.Decrement())"
  },
  {
    "label": "DISALLOW_COPY_AND_ASSIGN()",
    "kind": "Method",
    "detail": "Function (bool in_dtor_ = false ; # endif)",
    "insertText": "DISALLOW_COPY_AND_ASSIGN(RefCountedThreadSafeBase)"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (} ; class ScopedAllowCrossThreadRefCountAccess final { public : # if)",
    "insertText": "DCHECK_IS_ON() ScopedAllowCrossThreadRefCountAccess()"
  },
  {
    "label": "ScopedAllowCrossThreadRefCountAccess()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "ScopedAllowCrossThreadRefCountAccess()"
  },
  {
    "label": "REQUIRE_ADOPTION_FOR_REFCOUNTED_TYPE()",
    "kind": "Method",
    "detail": "Function (} # endif } ; } using ScopedAllowCrossThreadRefCountAccess = cef_subtle::ScopedAllowCrossThreadRefCountAccess ; # define)",
    "insertText": "REQUIRE_ADOPTION_FOR_REFCOUNTED_TYPE()"
  },
  {
    "label": "Destruct()",
    "kind": "Method",
    "detail": "Function (template<T> struct DefaultRefCountedTraits { void)",
    "insertText": "Destruct(const T* x)"
  },
  {
    "label": "DeleteInternal()",
    "kind": "Method",
    "detail": "Function (RefCounted<T,DefaultRefCountedTraits)",
    "insertText": "DeleteInternal(x)"
  },
  {
    "label": "RefCounted()",
    "kind": "Method",
    "detail": "Function (} } ; template<class T,Traits = DefaultRefCountedTraits<T>> class RefCounted : public cef_subtle::RefCountedBase { public : cef_subtle::StartRefCountFromZeroTag kRefCountPreference = cef_subtle::kStartRefCountFromZeroTag ;)",
    "insertText": "RefCounted() : cef_subtle::RefCountedBase(T::kRefCountPreference)"
  },
  {
    "label": "ANALYZER_SKIP_THIS_PATH()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ANALYZER_SKIP_THIS_PATH()"
  },
  {
    "label": "Destruct()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destruct(static_cast<const T*>(this))"
  },
  {
    "label": "RefCounted()",
    "kind": "Method",
    "detail": "Function (} } protected : ~)",
    "insertText": "RefCounted()"
  },
  {
    "label": "DeleteInternal()",
    "kind": "Method",
    "detail": "Function (private : struct DefaultRefCountedTraits<T> ; template<U> void)",
    "insertText": "DeleteInternal(const U* x)"
  },
  {
    "label": "DISALLOW_COPY_AND_ASSIGN()",
    "kind": "Method",
    "detail": "Function (delete x ; })",
    "insertText": "DISALLOW_COPY_AND_ASSIGN(RefCounted)"
  },
  {
    "label": "RefCountedThreadSafe()",
    "kind": "Method",
    "detail": "Function (} } ; template<class T,Traits = DefaultRefCountedThreadSafeTraits<T>> class RefCountedThreadSafe : public cef_subtle::RefCountedThreadSafeBase { public : cef_subtle::StartRefCountFromZeroTag kRefCountPreference = cef_subtle::kStartRefCountFromZeroTag ;)",
    "insertText": "RefCountedThreadSafe() : cef_subtle::RefCountedThreadSafeBase(T::kRefCountPreference)"
  },
  {
    "label": "AddRefImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddRefImpl(T::kRefCountPreference)"
  },
  {
    "label": "RefCountedThreadSafe()",
    "kind": "Method",
    "detail": "Function (} } protected : ~)",
    "insertText": "RefCountedThreadSafe()"
  },
  {
    "label": "AddRefImpl()",
    "kind": "Method",
    "detail": "Function (delete x ; } void)",
    "insertText": "AddRefImpl(cef_subtle::StartRefCountFromZeroTag)"
  },
  {
    "label": "AddRefImpl()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddRefImpl(cef_subtle::StartRefCountFromOneTag)"
  },
  {
    "label": "DISALLOW_COPY_AND_ASSIGN()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "DISALLOW_COPY_AND_ASSIGN(RefCountedThreadSafe)"
  },
  {
    "label": "RefCountedData()",
    "kind": "Method",
    "detail": "Function (} ; template<T> class RefCountedData : public base::RefCountedThreadSafe<base::RefCountedData<T>> { public :)",
    "insertText": "RefCountedData() : data()"
  },
  {
    "label": "RefCountedData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RefCountedData(const T& in_value) : data(in_value)"
  },
  {
    "label": "RefCountedData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RefCountedData(T&& in_value) : data(std::move(in_value))"
  },
  {
    "label": "RefCountedData()",
    "kind": "Method",
    "detail": "Function (} template<. . . Args>)",
    "insertText": "RefCountedData(in_place_t, Args&&... args) : data(std::forward<Args>(args)...)"
  },
  {
    "label": "RefCountedData()",
    "kind": "Method",
    "detail": "Function (} T data ; private : class base::RefCountedThreadSafe<base::RefCountedData<T>> ; ~)",
    "insertText": "RefCountedData()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<T> bool)",
    "insertText": "operator(const RefCountedData<T>& lhs, const RefCountedData<T>& rhs)"
  }
]