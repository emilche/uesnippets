[
  {
    "label": "BASE_I18N_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_I18N_EXPORT"
  },
  {
    "label": "BreakType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "BreakType"
  },
  {
    "label": "WordBreakStatus",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "WordBreakStatus"
  },
  {
    "label": "BreakIterator()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_I18N_BREAK_ITERATOR_H_ # define BASE_I18N_BREAK_ITERATOR_H_ # include<stddef . h> # include<string> # include \" base / i18n / base_i18n_export . h \" # include \" base / memory / raw_ptr . h \" # include \" base / strings / string_piece . h \" namespace base { namespace i18n { class BASE_I18N_EXPORT BreakIterator { public : enum BreakType { BREAK_WORD,BREAK_LINE,BREAK_SPACE = BREAK_LINE,BREAK_NEWLINE,BREAK_CHARACTER,RULE_BASED,BREAK_SENTENCE,} ; enum WordBreakStatus { IS_WORD_BREAK,IS_SKIPPABLE_WORD,IS_LINE_OR_CHAR_BREAK } ;)",
    "insertText": "BreakIterator(const StringPiece16& str, BreakType break_type)"
  },
  {
    "label": "BreakIterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BreakIterator(const StringPiece16& str, const std::u16string& rules)"
  },
  {
    "label": "BreakIterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BreakIterator(const BreakIterator&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (BreakIterator&)",
    "insertText": "operator(const BreakIterator&)"
  },
  {
    "label": "BreakIterator()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "BreakIterator()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Init()"
  },
  {
    "label": "Advance()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Advance()"
  },
  {
    "label": "SetText()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SetText(const char16_t* text, const size_t length)"
  },
  {
    "label": "IsWord()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsWord()"
  },
  {
    "label": "GetWordBreakStatus()",
    "kind": "Method",
    "detail": "Function (BreakIterator::WordBreakStatus)",
    "insertText": "GetWordBreakStatus()"
  },
  {
    "label": "IsEndOfWord()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsEndOfWord(size_t position)"
  },
  {
    "label": "IsStartOfWord()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsStartOfWord(size_t position)"
  },
  {
    "label": "IsSentenceBoundary()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSentenceBoundary(size_t position)"
  },
  {
    "label": "IsGraphemeBoundary()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsGraphemeBoundary(size_t position)"
  },
  {
    "label": "GetString()",
    "kind": "Method",
    "detail": "Function (std::u16string)",
    "insertText": "GetString()"
  },
  {
    "label": "GetStringPiece()",
    "kind": "Method",
    "detail": "Function (StringPiece16)",
    "insertText": "GetStringPiece()"
  },
  {
    "label": "prev()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "prev()"
  }
]