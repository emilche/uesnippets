[
  {
    "label": "Appendable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Appendable"
  },
  {
    "label": "UCharsTrieBuilder",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UCharsTrieBuilder"
  },
  {
    "label": "UVector32",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UVector32"
  },
  {
    "label": "U_COMMON_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "U_COMMON_API"
  },
  {
    "label": "State",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "State"
  },
  {
    "label": "UCharsTrie",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UCharsTrie"
  },
  {
    "label": "UCharsTrie()",
    "kind": "Method",
    "detail": "Function (# ifndef __UCHARSTRIE_H__ # define __UCHARSTRIE_H__ # include \" unicode / utypes . h \" # include \" unicode / unistr . h \" # include \" unicode / uobject . h \" # include \" unicode / ustringtrie . h \" U_NAMESPACE_BEGIN class Appendable ; class UCharsTrieBuilder ; class UVector32 ; class UCharsTrie : public UMemory { public :)",
    "insertText": "UCharsTrie(ConstChar16Ptr trieUChars) : ownedArray_(NULL), uchars_(trieUChars), pos_(uchars_), remainingMatchLength_(-1)"
  },
  {
    "label": "UCharsTrie()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "UCharsTrie()"
  },
  {
    "label": "UCharsTrie()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UCharsTrie(const UCharsTrie &other) : ownedArray_(NULL), uchars_(other.uchars_), pos_(other.pos_), remainingMatchLength_(other.remainingMatchLength_)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (} UCharsTrie&)",
    "insertText": "reset()"
  },
  {
    "label": "State()",
    "kind": "Method",
    "detail": "Function (pos_ = uchars_ ; remainingMatchLength_ = - 1 ; return* this ; } class State : public UMemory { public :)",
    "insertText": "State()"
  },
  {
    "label": "saveState()",
    "kind": "Method",
    "detail": "Function (uchars = NULL ; } private : class UCharsTrie ; const char16_t* uchars ; const char16_t* pos ; int32_t remainingMatchLength ; } ; const UCharsTrie&)",
    "insertText": "saveState(State &state)"
  },
  {
    "label": "resetToState()",
    "kind": "Method",
    "detail": "Function (state . uchars = uchars_ ; state . pos = pos_ ; state . remainingMatchLength = remainingMatchLength_ ; return* this ; } UCharsTrie&)",
    "insertText": "resetToState(const State &state)"
  },
  {
    "label": "current()",
    "kind": "Method",
    "detail": "Function (pos_ = state . pos ; remainingMatchLength_ = state . remainingMatchLength ; } return* this ; } UStringTrieResult)",
    "insertText": "current()"
  },
  {
    "label": "first()",
    "kind": "Method",
    "detail": "Function (UStringTrieResult)",
    "insertText": "first(int32_t uchar)"
  },
  {
    "label": "nextImpl()",
    "kind": "Method",
    "detail": "Function (remainingMatchLength_ = - 1 ; return)",
    "insertText": "nextImpl(uchars_, uchar)"
  },
  {
    "label": "firstForCodePoint()",
    "kind": "Method",
    "detail": "Function (} UStringTrieResult)",
    "insertText": "firstForCodePoint(UChar32 cp)"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (UStringTrieResult)",
    "insertText": "next(int32_t uchar)"
  },
  {
    "label": "nextForCodePoint()",
    "kind": "Method",
    "detail": "Function (UStringTrieResult)",
    "insertText": "nextForCodePoint(UChar32 cp)"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (UStringTrieResult)",
    "insertText": "next(ConstChar16Ptr s, int32_t length)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "getValue()"
  },
  {
    "label": "readValue()",
    "kind": "Method",
    "detail": "Function (const char16_t* pos = pos_ ; int32_t leadUnit =* pos + + ; return leadUnit& kValueIsFinal ?)",
    "insertText": "readValue(pos, leadUnit&0x7fff) : readNodeValue(pos, leadUnit)"
  },
  {
    "label": "hasUniqueValue()",
    "kind": "Method",
    "detail": "Function (} UBool)",
    "insertText": "hasUniqueValue(int32_t &uniqueValue)"
  },
  {
    "label": "findUniqueValue()",
    "kind": "Method",
    "detail": "Function (const char16_t* pos = pos_ ; return pos ! = NULL&&)",
    "insertText": "findUniqueValue(pos+remainingMatchLength_+1, FALSE, uniqueValue)"
  },
  {
    "label": "getNextUChars()",
    "kind": "Method",
    "detail": "Function (} int32_t)",
    "insertText": "getNextUChars(Appendable &out)"
  },
  {
    "label": "Iterator()",
    "kind": "Method",
    "detail": "Function (class Iterator : public UMemory { public :)",
    "insertText": "Iterator(ConstChar16Ptr trieUChars, int32_t maxStringLength, UErrorCode &errorCode)"
  },
  {
    "label": "Iterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Iterator(const UCharsTrie &trie, int32_t maxStringLength, UErrorCode &errorCode)"
  },
  {
    "label": "Iterator()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "Iterator()"
  },
  {
    "label": "hasNext()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "hasNext()"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "next(UErrorCode &errorCode)"
  },
  {
    "label": "getString()",
    "kind": "Method",
    "detail": "Function (const UnicodeString&)",
    "insertText": "getString()"
  },
  {
    "label": "branchNext()",
    "kind": "Method",
    "detail": "Function (pos_ = NULL ; value_ = - 1 ; return TRUE ; } const char16_t*)",
    "insertText": "branchNext(const char16_t *pos, int32_t length, UErrorCode &errorCode)"
  },
  {
    "label": "UCharsTrie()",
    "kind": "Method",
    "detail": "Function (const char16_t* uchars_ ; const char16_t* pos_ ; const char16_t* initialPos_ ; int32_t remainingMatchLength_ ; int32_t initialRemainingMatchLength_ ; UBool skipValue_ ; UnicodeString str_ ; int32_t maxLength_ ; int32_t value_ ; UVector32* stack_ ; } ; private : class UCharsTrieBuilder ;)",
    "insertText": "UCharsTrie(char16_t *adoptUChars, const char16_t *trieUChars) : ownedArray_(adoptUChars), uchars_(trieUChars), pos_(uchars_), remainingMatchLength_(-1)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} UCharsTrie&)",
    "insertText": "operator(const UCharsTrie &other)"
  },
  {
    "label": "stop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stop()"
  },
  {
    "label": "readValue()",
    "kind": "Method",
    "detail": "Function (pos_ = NULL ; } int32_t)",
    "insertText": "readValue(const char16_t *pos, int32_t leadUnit)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32_t value ;)",
    "insertText": "if(leadUnit<kMinTwoUnitValueLead)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (value = leadUnit ; } else)",
    "insertText": "if(leadUnit<kThreeUnitValueLead)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "value((leadUnit-kMinTwoUnitValueLead)<<16)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "value(pos[0]<<16)"
  },
  {
    "label": "skipValue()",
    "kind": "Method",
    "detail": "Function (} return value ; } const char16_t*)",
    "insertText": "skipValue(const char16_t *pos, int32_t leadUnit)"
  },
  {
    "label": "skipValue()",
    "kind": "Method",
    "detail": "Function (+ + pos ; } else { pos + = 2 ; } } return pos ; } const char16_t*)",
    "insertText": "skipValue(const char16_t *pos)"
  },
  {
    "label": "skipValue()",
    "kind": "Method",
    "detail": "Function (int32_t leadUnit =* pos + + ; return)",
    "insertText": "skipValue(pos, leadUnit&0x7fff)"
  },
  {
    "label": "readNodeValue()",
    "kind": "Method",
    "detail": "Function (} int32_t)",
    "insertText": "readNodeValue(const char16_t *pos, int32_t leadUnit)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32_t value ;)",
    "insertText": "if(leadUnit<kMinTwoUnitNodeValueLead)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "value(leadUnit>>6)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(leadUnit<kThreeUnitNodeValueLead)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "value(((leadUnit&0x7fc0)-kMinTwoUnitNodeValueLead)<<10)"
  },
  {
    "label": "skipNodeValue()",
    "kind": "Method",
    "detail": "Function (} return value ; } const char16_t*)",
    "insertText": "skipNodeValue(const char16_t *pos, int32_t leadUnit)"
  },
  {
    "label": "jumpByDelta()",
    "kind": "Method",
    "detail": "Function (+ + pos ; } else { pos + = 2 ; } } return pos ; } const char16_t*)",
    "insertText": "jumpByDelta(const char16_t *pos)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32_t delta =* pos + + ;)",
    "insertText": "if(delta>=kMinTwoUnitDeltaLead)"
  },
  {
    "label": "delta()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "delta(pos[0]<<16)"
  },
  {
    "label": "delta()",
    "kind": "Method",
    "detail": "Function (pos + = 2 ; } else {)",
    "insertText": "delta((delta-kMinTwoUnitDeltaLead)<<16)"
  },
  {
    "label": "skipDelta()",
    "kind": "Method",
    "detail": "Function (} } return pos + delta ; } const char16_t*)",
    "insertText": "skipDelta(const char16_t *pos)"
  },
  {
    "label": "valueResult()",
    "kind": "Method",
    "detail": "Function (pos + = 2 ; } else { + + pos ; } } return pos ; } UStringTrieResult)",
    "insertText": "valueResult(int32_t node)"
  },
  {
    "label": "branchNext()",
    "kind": "Method",
    "detail": "Function (} UStringTrieResult)",
    "insertText": "branchNext(const char16_t *pos, int32_t length, int32_t uchar)"
  },
  {
    "label": "nextImpl()",
    "kind": "Method",
    "detail": "Function (UStringTrieResult)",
    "insertText": "nextImpl(const char16_t *pos, int32_t uchar)"
  },
  {
    "label": "findUniqueValueFromBranch()",
    "kind": "Method",
    "detail": "Function (const char16_t*)",
    "insertText": "findUniqueValueFromBranch(const char16_t *pos, int32_t length, UBool haveUniqueValue, int32_t &uniqueValue)"
  },
  {
    "label": "findUniqueValue()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "findUniqueValue(const char16_t *pos, UBool haveUniqueValue, int32_t &uniqueValue)"
  },
  {
    "label": "getNextBranchUChars()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getNextBranchUChars(const char16_t *pos, int32_t length, Appendable &out)"
  },
  {
    "label": "kMaxTwoUnitValue()",
    "kind": "Method",
    "detail": "Function (const int32_t kMaxBranchLinearSubNodeLength = 5 ; const int32_t kMinLinearMatch = 0 x30 ; const int32_t kMaxLinearMatchLength = 0 x10 ; const int32_t kMinValueLead = kMinLinearMatch + kMaxLinearMatchLength ; const int32_t kNodeTypeMask = kMinValueLead - 1 ; const int32_t kValueIsFinal = 0 x8000 ; const int32_t kMaxOneUnitValue = 0 x3fff ; const int32_t kMinTwoUnitValueLead = kMaxOneUnitValue + 1 ; const int32_t kThreeUnitValueLead = 0 x7fff ; const int32_t)",
    "insertText": "kMaxTwoUnitValue((kThreeUnitValueLead-kMinTwoUnitValueLead)<<16)"
  },
  {
    "label": "kMinValueLead()",
    "kind": "Method",
    "detail": "Function (const int32_t kMaxOneUnitNodeValue = 0 xff ; const int32_t kMinTwoUnitNodeValueLead =)",
    "insertText": "kMinValueLead((kMaxOneUnitNodeValue+1)<<6)"
  },
  {
    "label": "kMaxTwoUnitNodeValue()",
    "kind": "Method",
    "detail": "Function (const int32_t kThreeUnitNodeValueLead = 0 x7fc0 ; const int32_t)",
    "insertText": "kMaxTwoUnitNodeValue((kThreeUnitNodeValueLead-kMinTwoUnitNodeValueLead)<<10)"
  },
  {
    "label": "kMaxTwoUnitDelta()",
    "kind": "Method",
    "detail": "Function (const int32_t kMaxOneUnitDelta = 0 xfbff ; const int32_t kMinTwoUnitDeltaLead = kMaxOneUnitDelta + 1 ; const int32_t kThreeUnitDeltaLead = 0 xffff ; const int32_t)",
    "insertText": "kMaxTwoUnitDelta((kThreeUnitDeltaLead-kMinTwoUnitDeltaLead)<<16)"
  }
]