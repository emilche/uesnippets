[
  {
    "label": "Ty",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Ty"
  },
  {
    "label": "identity",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "identity"
  },
  {
    "label": "less_ptr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "less_ptr"
  },
  {
    "label": "greater_ptr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "greater_ptr"
  },
  {
    "label": "function_ref",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "function_ref"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "RootIt",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RootIt"
  },
  {
    "label": "UnaryFunc",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UnaryFunc"
  },
  {
    "label": "mapped_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "mapped_iterator"
  },
  {
    "label": "Iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Iterator"
  },
  {
    "label": "Func",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Func"
  },
  {
    "label": "ItTy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ItTy"
  },
  {
    "label": "FuncTy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FuncTy"
  },
  {
    "label": "has_rbegin_impl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "has_rbegin_impl"
  },
  {
    "label": "has_rbegin",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "has_rbegin"
  },
  {
    "label": "filter_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "filter_iterator"
  },
  {
    "label": "PayloadType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PayloadType"
  },
  {
    "label": "UnaryPredicate",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UnaryPredicate"
  },
  {
    "label": "index_sequence",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "index_sequence"
  },
  {
    "label": "index_sequence_for",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "index_sequence_for"
  },
  {
    "label": "zip_first",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "zip_first"
  },
  {
    "label": "zip_shortest",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "zip_shortest"
  },
  {
    "label": "ItType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ItType"
  },
  {
    "label": "zippy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "zippy"
  },
  {
    "label": "less_first",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "less_first"
  },
  {
    "label": "less_second",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "less_second"
  },
  {
    "label": "integer_sequence",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "integer_sequence"
  },
  {
    "label": "build_index_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "build_index_impl"
  },
  {
    "label": "IteratorTy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IteratorTy"
  },
  {
    "label": "FreeDeleter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FreeDeleter"
  },
  {
    "label": "pair_hash",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "pair_hash"
  },
  {
    "label": "less",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "less"
  },
  {
    "label": "equal",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "equal"
  },
  {
    "label": "deref",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "deref"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_ADT_STLEXTRAS_H # define LLVM_ADT_STLEXTRAS_H # include \" dxc / WinAdapter . h \" # include \" llvm / Support / Compiler . h \" # include<algorithm> # include<cassert> # include<cstddef> # include<cstdlib> # include<functional> # include<iterator> # include<memory> # include<utility> # include \" llvm / ADT / Optional . h \" # include \" llvm / ADT / iterator . h \" # include \" llvm / ADT / iterator_range . h \" # include \" llvm / Support / Compiler . h \" namespace llvm { namespace detail { template<RangeT> using IterOfRange =)",
    "insertText": "decltype(std::begin(std::declval<RangeT>()))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class Ty> struct identity { using argument_type = Ty ; Ty&)",
    "insertText": "operator()(Ty &self)"
  },
  {
    "label": "Ret()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Ret(*callback)(intptr_t callable, Params ...params)"
  },
  {
    "label": "callback_fn()",
    "kind": "Method",
    "detail": "Function (intptr_t callable ; template<Callable> Ret)",
    "insertText": "callback_fn(intptr_t callable, Params ...params)"
  },
  {
    "label": "function_ref()",
    "kind": "Method",
    "detail": "Function (} public : template<Callable>)",
    "insertText": "function_ref(Callable &&callable, typename std::enable_if< !std::is_same<typename std::remove_reference<Callable>::type, function_ref>::value>::type * = nullptr) : callback(callback_fn<typename std::remove_reference<Callable>::type>), callable(reinterpret_cast<intptr_t>(&callable))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Ret)",
    "insertText": "operator()(Params ...params)"
  },
  {
    "label": "deleter()",
    "kind": "Method",
    "detail": "Function (} } ; template<class T> void)",
    "insertText": "deleter(T *Ptr)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (delete Ptr ; } template<class RootIt,class UnaryFunc> class mapped_iterator { RootIt current ; UnaryFunc Fn ; public : typedef std::iterator_traits<RootIt>::iterator_category iterator_category ; typedef std::iterator_traits<RootIt>::difference_type difference_type ; typedef)",
    "insertText": "decltype(std::declval<UnaryFunc>()(*std::declval<RootIt>()))"
  },
  {
    "label": "getCurrent()",
    "kind": "Method",
    "detail": "Function (typedef void pointer ; typedef void reference ; typedef RootIt iterator_type ; const RootIt&)",
    "insertText": "getCurrent()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} value_type)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (- - current ; return* this ; } mapped_iterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (mapped_iterator __tmp =* this ; - - current ; return __tmp ; } mapped_iterator)",
    "insertText": "operator(difference_type n)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const mapped_iterator &X)"
  },
  {
    "label": "map_iterator()",
    "kind": "Method",
    "detail": "Function (} template<class ItTy,class FuncTy> mapped_iterator<ItTy,FuncTy>)",
    "insertText": "map_iterator(const ItTy &I, FuncTy F)"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (} template<Ty> class has_rbegin_impl { typedef char yes [ 1 ] ; typedef char no [ 2 ] ; template<Inner> yes&)",
    "insertText": "test(Inner *I, decltype(I->rbegin()) * = nullptr)"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (template<> no&)",
    "insertText": "test(...)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (public : const bool value =)",
    "insertText": "sizeof(test<Ty>(nullptr)) == sizeof(yes)"
  },
  {
    "label": "reverse()",
    "kind": "Method",
    "detail": "Function (} ; template<Ty> struct has_rbegin : has_rbegin_impl<std::remove_reference<Ty>::type> { } ; template<ContainerTy> auto)",
    "insertText": "reverse(ContainerTy &&C, typename std::enable_if<has_rbegin<ContainerTy>::value>::type * = nullptr) -> decltype(make_range(C.rbegin(), C.rend()))"
  },
  {
    "label": "make_reverse_iterator()",
    "kind": "Method",
    "detail": "Function (} template<IteratorTy> std::reverse_iterator<IteratorTy>)",
    "insertText": "make_reverse_iterator(IteratorTy It)"
  },
  {
    "label": "reverse()",
    "kind": "Method",
    "detail": "Function (} template<ContainerTy> auto)",
    "insertText": "reverse(ContainerTy &&C, typename std::enable_if<!has_rbegin<ContainerTy>::value>::type * = nullptr) -> decltype(make_range(make_reverse_iterator(std::end(C)), make_reverse_iterator(std::begin(C))))"
  },
  {
    "label": "findNextValid()",
    "kind": "Method",
    "detail": "Function (} template<WrappedIteratorT,PredicateT> class filter_iterator : public iterator_adaptor_base<filter_iterator<WrappedIteratorT,PredicateT>,WrappedIteratorT,std::common_type<std::forward_iterator_tag,std::iterator_traits<WrappedIteratorT>::iterator_category>::type> { using BaseT = iterator_adaptor_base<filter_iterator<WrappedIteratorT,PredicateT>,WrappedIteratorT,std::common_type<std::forward_iterator_tag,std::iterator_traits<WrappedIteratorT>::iterator_category>::type> ; struct PayloadType { WrappedIteratorT End ; PredicateT Pred ; } ; Optional<PayloadType> Payload ; void)",
    "insertText": "findNextValid()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Payload && \"Payload should be engaged when findNextValid is called\")"
  },
  {
    "label": "filter_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "filter_iterator(WrappedIteratorT Begin, WrappedIteratorT End, PredicateT Pred) : BaseT(std::move(Begin)), Payload(PayloadType{std::move(End), std::move(Pred)})"
  },
  {
    "label": "filter_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "filter_iterator(WrappedIteratorT End) : BaseT(End)"
  },
  {
    "label": "make_filter_range()",
    "kind": "Method",
    "detail": "Function (} ; template<RangeT,PredicateT> iterator_range<filter_iterator<detail::IterOfRange<RangeT>,PredicateT>>)",
    "insertText": "make_filter_range(RangeT &&Range, PredicateT Pred)"
  },
  {
    "label": "make_range()",
    "kind": "Method",
    "detail": "Function (using FilterIteratorT = filter_iterator<detail::IterOfRange<RangeT>,PredicateT> ; return)",
    "insertText": "make_range(FilterIteratorT(std::begin(std::forward<RangeT>(Range)), std::end(std::forward<RangeT>(Range)), std::move(Pred)), FilterIteratorT(std::end(std::forward<RangeT>(Range))))"
  },
  {
    "label": "all_of()",
    "kind": "Method",
    "detail": "Function (} template<R,class UnaryPredicate> bool)",
    "insertText": "all_of(R &&range, UnaryPredicate &&P)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (template<size_t . . . I> struct index_sequence ; template<class . . . Ts> struct index_sequence_for ; namespace detail { template<. . . Iters> class zip_first { public : typedef std::input_iterator_tag iterator_category ; typedef std::tuple<)",
    "insertText": "decltype(*std::declval<Iters>())"
  },
  {
    "label": "deres()",
    "kind": "Method",
    "detail": "Function (std::tuple<Iters . . .> iterators ; private : template<size_t . . . Ns> value_type)",
    "insertText": "deres(index_sequence<Ns...>)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<size_t . . . Ns>)",
    "insertText": "decltype(iterators) tup_inc(index_sequence<Ns...>)"
  },
  {
    "label": "tup_inc()",
    "kind": "Method",
    "detail": "Function (iterators =)",
    "insertText": "tup_inc(index_sequence_for<Iters...>{})"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const zip_first<Iters...> &other)"
  },
  {
    "label": "zip_first()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "zip_first(Iters &&... ts) : iterators(std::forward<Iters>(ts)...)"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (} } ; template<. . . Iters> class zip_shortest : public zip_first<Iters . . .> { template<size_t . . . Ns> bool)",
    "insertText": "test(const zip_first<Iters...> &other, index_sequence<Ns...>)"
  },
  {
    "label": "zip_shortest()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "zip_shortest(Iters &&... ts) : zip_first<Iters...>(std::forward<Iters>(ts)...)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} } ; template<template<. . .> class ItType,. . . Args> class zippy { public : typedef ItType<)",
    "insertText": "decltype(std::begin(std::declval<Args>()))"
  },
  {
    "label": "begin_impl()",
    "kind": "Method",
    "detail": "Function (private : std::tuple<Args . . .> ts ; template<size_t . . . Ns> iterator)",
    "insertText": "begin_impl(index_sequence<Ns...>)"
  },
  {
    "label": "end_impl()",
    "kind": "Method",
    "detail": "Function (} template<size_t . . . Ns> iterator)",
    "insertText": "end_impl(index_sequence<Ns...>)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} public : iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "zippy()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "zippy(Args &&... ts_) : ts(std::forward<Args>(ts_)...)"
  },
  {
    "label": "zip()",
    "kind": "Method",
    "detail": "Function (} } ; } template<T,U,. . . Args> detail::zippy<detail::zip_shortest,T,U,Args . . .>)",
    "insertText": "zip(T &&t, U &&u, Args &&... args)"
  },
  {
    "label": "zip_first()",
    "kind": "Method",
    "detail": "Function (} template<T,U,. . . Args> detail::zippy<detail::zip_first,T,U,Args . . .>)",
    "insertText": "zip_first(T &&t, U &&u, Args &&... args)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} struct less_first { template<T> bool)",
    "insertText": "operator()(const T &lhs, const T &rhs)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} } ; template<size_t . . . I> struct index_sequence : integer_sequence<std::size_t,I . . .> { } ; template<std::size_t N,std::size_t . . . I> struct build_index_impl : build_index_impl<N - 1,N - 1,I . . .> { } ; template<std::size_t . . . I> struct build_index_impl<0,I . . .> : index_sequence<I . . .> { } ; template<class . . . Ts> struct index_sequence_for : build_index_impl<)",
    "insertText": "sizeof(Ts)"
  },
  {
    "label": "array_lengthof()",
    "kind": "Method",
    "detail": "Function (} ; template<class T,std::size_t N> LLVM_CONSTEXPR size_t)",
    "insertText": "array_lengthof(T (&)[N])"
  },
  {
    "label": "get_array_pod_sort_comparator()",
    "kind": "Method",
    "detail": "Function (template<T> llvm_cmp_func)",
    "insertText": "get_array_pod_sort_comparator(const T &)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (auto NElts = End - Start ;)",
    "insertText": "if(NElts <= 1)"
  },
  {
    "label": "qsort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "qsort(&*Start, NElts, sizeof(*Start), get_array_pod_sort_comparator(*Start))"
  },
  {
    "label": "array_pod_sort()",
    "kind": "Method",
    "detail": "Function (} template<class IteratorTy> void)",
    "insertText": "array_pod_sort(IteratorTy Start, IteratorTy End, int (__cdecl *Compare)( const typename std::iterator_traits<IteratorTy>::value_type *, const typename std::iterator_traits<IteratorTy>::value_type *))"
  },
  {
    "label": "qsort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "qsort(&*Start, NElts, sizeof(*Start), reinterpret_cast<int (__cdecl *)(const void *, const void *)>(Compare))"
  },
  {
    "label": "DeleteContainerPointers()",
    "kind": "Method",
    "detail": "Function (} template<Container> void)",
    "insertText": "DeleteContainerPointers(Container &C)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (C .)",
    "insertText": "clear()"
  },
  {
    "label": "DeleteContainerSeconds()",
    "kind": "Method",
    "detail": "Function (} template<Container> void)",
    "insertText": "DeleteContainerSeconds(Container &C)"
  },
  {
    "label": "all_of()",
    "kind": "Method",
    "detail": "Function (} template<R,class UnaryPredicate> bool)",
    "insertText": "all_of(R &&Range, UnaryPredicate &&P)"
  },
  {
    "label": "make_unique()",
    "kind": "Method",
    "detail": "Function (} template<class T,class . . . Args> std::enable_if<! std::is_array<T>::value,std::unique_ptr<T>>::type)",
    "insertText": "make_unique(Args &&... args)"
  },
  {
    "label": "make_unique()",
    "kind": "Method",
    "detail": "Function (} template<class T> std::enable_if<std::is_array<T>::value&& std::extent<T>::value = = 0,std::unique_ptr<T>>::type)",
    "insertText": "make_unique(size_t n)"
  },
  {
    "label": "make_unique()",
    "kind": "Method",
    "detail": "Function (} template<class T,class . . . Args> std::enable_if<std::extent<T>::value ! = 0>::type)",
    "insertText": "make_unique(Args &&...)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (struct FreeDeleter { void)",
    "insertText": "operator()(void* v)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<First,Second> struct pair_hash { size_t)",
    "insertText": "operator()(const std::pair<First, Second> &P)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; struct less { template<A,B> bool)",
    "insertText": "operator()(A &&a, B &&b)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> struct deref { T func ; template<A,B> auto)",
    "insertText": "operator()(A &lhs, B &rhs) const -> decltype(func(*lhs, *rhs))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(lhs)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(rhs)"
  }
]