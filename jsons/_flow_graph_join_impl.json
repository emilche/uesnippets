[
  {
    "label": "forwarding_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "forwarding_base"
  },
  {
    "label": "matching_forwarding_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "matching_forwarding_base"
  },
  {
    "label": "join_helper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "join_helper"
  },
  {
    "label": "reserving_port",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "reserving_port"
  },
  {
    "label": "op_type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "op_type"
  },
  {
    "label": "reserving_port_operation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "reserving_port_operation"
  },
  {
    "label": "internal",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "internal"
  },
  {
    "label": "run_and_put_task",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "run_and_put_task"
  },
  {
    "label": "queueing_port",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "queueing_port"
  },
  {
    "label": "queueing_port_operation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "queueing_port_operation"
  },
  {
    "label": "count_element",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "count_element"
  },
  {
    "label": "key_to_count_functor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "key_to_count_functor"
  },
  {
    "label": "TraitsType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TraitsType"
  },
  {
    "label": "key_matching_port",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "key_matching_port"
  },
  {
    "label": "key_matching_port_operation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "key_matching_port_operation"
  },
  {
    "label": "join_node_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "join_node_base"
  },
  {
    "label": "join_node_FE",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "join_node_FE"
  },
  {
    "label": "key_matching_FE_operation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "key_matching_FE_operation"
  },
  {
    "label": "join_node_base_operation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "join_node_base_operation"
  },
  {
    "label": "forward_task_bypass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "forward_task_bypass"
  },
  {
    "label": "PT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PT"
  },
  {
    "label": "join_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "join_base"
  },
  {
    "label": "unfolded_join_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "unfolded_join_node"
  },
  {
    "label": "key_from_message_body",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "key_from_message_body"
  },
  {
    "label": "forwarding_base()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB__flow_graph_join_impl_H # define __TBB__flow_graph_join_impl_H # ifndef __TBB_flow_graph_H # error Do not # include this internal file directly ; use public TBB headers instead . # endif namespace internal { struct forwarding_base : tbb::internal::no_assign {)",
    "insertText": "forwarding_base(graph &g) : graph_ref(g)"
  },
  {
    "label": "forwarding_base()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "forwarding_base()"
  },
  {
    "label": "decrement_port_count()",
    "kind": "Method",
    "detail": "Function (} task*)",
    "insertText": "decrement_port_count(bool handle_task)"
  },
  {
    "label": "increment_port_count()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "increment_port_count()"
  },
  {
    "label": "matching_forwarding_base()",
    "kind": "Method",
    "detail": "Function (graph& graph_ref ; } ; template<KeyType> struct matching_forwarding_base : public forwarding_base { typedef tbb::internal::strip<KeyType>::type current_key_type ;)",
    "insertText": "matching_forwarding_base(graph &g) : forwarding_base(g)"
  },
  {
    "label": "increment_key_count()",
    "kind": "Method",
    "detail": "Function (} task*)",
    "insertText": "increment_key_count(current_key_type const & , bool)"
  },
  {
    "label": "set_join_node_pointer()",
    "kind": "Method",
    "detail": "Function (current_key_type current_key ; } ; template<int N> struct join_helper { template<TupleType,PortType> void)",
    "insertText": "set_join_node_pointer(TupleType &my_input, PortType *port)"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (tbb::flow::get<)",
    "insertText": "N(my_input ).set_join_node_pointer(port)"
  },
  {
    "label": "set_join_node_pointer()",
    "kind": "Method",
    "detail": "Function (join_helper<N - 1)",
    "insertText": "set_join_node_pointer(my_input, port)"
  },
  {
    "label": "consume_reservations()",
    "kind": "Method",
    "detail": "Function (} template<TupleType> void)",
    "insertText": "consume_reservations(TupleType &my_input)"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (tbb::flow::get<)",
    "insertText": "N(my_input ).consume()"
  },
  {
    "label": "consume_reservations()",
    "kind": "Method",
    "detail": "Function (join_helper<N - 1)",
    "insertText": "consume_reservations(my_input)"
  },
  {
    "label": "release_my_reservation()",
    "kind": "Method",
    "detail": "Function (} template<TupleType> void)",
    "insertText": "release_my_reservation(TupleType &my_input)"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (tbb::flow::get<)",
    "insertText": "N(my_input ).release()"
  },
  {
    "label": "release_reservations()",
    "kind": "Method",
    "detail": "Function (} template<TupleType> void)",
    "insertText": "release_reservations(TupleType &my_input)"
  },
  {
    "label": "release_reservations()",
    "kind": "Method",
    "detail": "Function (join_helper<N - 1)",
    "insertText": "release_reservations(my_input)"
  },
  {
    "label": "release_my_reservation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "release_my_reservation(my_input)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (} template<InputTuple,OutputTuple> bool)",
    "insertText": "reserve(InputTuple &my_input, OutputTuple &out)"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (bool res = tbb::flow::get<)",
    "insertText": "N(my_input).get_item(tbb::flow::get<N-1>(out))"
  },
  {
    "label": "get_items()",
    "kind": "Method",
    "detail": "Function (} template<InputTuple,OutputTuple> bool)",
    "insertText": "get_items(InputTuple &my_input, OutputTuple &out)"
  },
  {
    "label": "reset_my_port()",
    "kind": "Method",
    "detail": "Function (} template<InputTuple> void)",
    "insertText": "reset_my_port(InputTuple &my_input)"
  },
  {
    "label": "reset_my_port()",
    "kind": "Method",
    "detail": "Function (join_helper<N - 1)",
    "insertText": "reset_my_port(my_input)"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (tbb::flow::get<)",
    "insertText": "N(my_input).reset_port()"
  },
  {
    "label": "reset_ports()",
    "kind": "Method",
    "detail": "Function (} template<InputTuple> void)",
    "insertText": "reset_ports(InputTuple& my_input)"
  },
  {
    "label": "set_key_functors()",
    "kind": "Method",
    "detail": "Function (} template<InputTuple,KeyFuncTuple> void)",
    "insertText": "set_key_functors(InputTuple &my_input, KeyFuncTuple &my_key_funcs)"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (tbb::flow::get<)",
    "insertText": "N(my_input).set_my_key_func(tbb::flow::get<N-1>(my_key_funcs))"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (tbb::flow::get<)",
    "insertText": "N(my_key_funcs)"
  },
  {
    "label": "set_key_functors()",
    "kind": "Method",
    "detail": "Function (join_helper<N - 1)",
    "insertText": "set_key_functors(my_input, my_key_funcs)"
  },
  {
    "label": "copy_key_functors()",
    "kind": "Method",
    "detail": "Function (} template<KeyFuncTuple> void)",
    "insertText": "copy_key_functors(KeyFuncTuple &my_inputs, KeyFuncTuple &other_inputs)"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (tbb::flow::get<)",
    "insertText": "N(my_inputs).set_my_key_func(tbb::flow::get<N-1>(other_inputs).get_my_key_func()->clone())"
  },
  {
    "label": "copy_key_functors()",
    "kind": "Method",
    "detail": "Function (} join_helper<N - 1)",
    "insertText": "copy_key_functors(my_inputs, other_inputs)"
  },
  {
    "label": "reset_inputs()",
    "kind": "Method",
    "detail": "Function (} template<InputTuple> void)",
    "insertText": "reset_inputs(InputTuple &my_input, reset_flags f)"
  },
  {
    "label": "reset_inputs()",
    "kind": "Method",
    "detail": "Function (join_helper<N - 1)",
    "insertText": "reset_inputs(my_input, f)"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (tbb::flow::get<)",
    "insertText": "N(my_input).reset_receiver(f)"
  },
  {
    "label": "extract_inputs()",
    "kind": "Method",
    "detail": "Function (} # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION template<InputTuple> void)",
    "insertText": "extract_inputs(InputTuple &my_input)"
  },
  {
    "label": "extract_inputs()",
    "kind": "Method",
    "detail": "Function (join_helper<N - 1)",
    "insertText": "extract_inputs(my_input)"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (tbb::flow::get<)",
    "insertText": "N(my_input).extract_receiver()"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "get(my_input ).set_join_node_pointer(port)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "get(my_input ).consume()"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "get(my_input ).release()"
  },
  {
    "label": "get_my_item()",
    "kind": "Method",
    "detail": "Function (} template<InputTuple,OutputTuple> bool)",
    "insertText": "get_my_item(InputTuple &my_input, OutputTuple &out)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "get(my_input).reset_port()"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "get(my_input).set_my_key_func(tbb::flow::get<0>(my_key_funcs))"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "get(my_key_funcs)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "get(my_inputs).set_my_key_func(tbb::flow::get<0>(other_inputs).get_my_key_func()->clone())"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "get(my_input).reset_receiver(f)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "get(my_input).extract_receiver()"
  },
  {
    "label": "reserving_port_operation()",
    "kind": "Method",
    "detail": "Function (} # endif } ; template<T> class reserving_port : public receiver<T> { public : typedef T input_type ; typedef receiver<input_type>::predecessor_type predecessor_type ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION typedef receiver<input_type>::predecessor_list_type predecessor_list_type ; typedef receiver<input_type>::built_predecessors_type built_predecessors_type ; # endif private : enum op_type { reg_pred,rem_pred,res_item,rel_res,con_res # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION,add_blt_pred,del_blt_pred,blt_pred_cnt,blt_pred_cpy # endif } ; typedef reserving_port<T> class_type ; class reserving_port_operation : public aggregated_operation<reserving_port_operation> { public : char type ; union { T* my_arg ; predecessor_type* my_pred ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION size_t cnt_val ; predecessor_list_type* plist ; # endif } ;)",
    "insertText": "reserving_port_operation(const T& e, op_type t) : type(char(t)), my_arg(const_cast<T*>(&e))"
  },
  {
    "label": "reserving_port_operation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "reserving_port_operation(const predecessor_type &s, op_type t) : type(char(t)), my_pred(const_cast<predecessor_type *>(&s))"
  },
  {
    "label": "reserving_port_operation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "reserving_port_operation(op_type t) : type(char(t))"
  },
  {
    "label": "handle_operations()",
    "kind": "Method",
    "detail": "Function (} } ; typedef internal::aggregating_functor<class_type,reserving_port_operation> handler_type ; class internal::aggregating_functor<class_type,reserving_port_operation> ; aggregator<handler_type,reserving_port_operation> my_aggregator ; void)",
    "insertText": "handle_operations(reserving_port_operation* op_list)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (reserving_port_operation* current ; bool no_predecessors ;)",
    "insertText": "while(op_list)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (current = op_list ; op_list = op_list -> next ;)",
    "insertText": "switch(current->type)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (my_predecessors .)",
    "insertText": "add(*(current->my_pred))"
  },
  {
    "label": "__TBB_store_with_release()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "__TBB_store_with_release(current->status, SUCCEEDED)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (break ; case rem_pred : my_predecessors .)",
    "insertText": "remove(*(current->my_pred))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case res_item :)",
    "insertText": "if(reserved)"
  },
  {
    "label": "__TBB_store_with_release()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_store_with_release(current->status, FAILED)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(my_predecessors.try_reserve( *(current->my_arg) ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(my_predecessors.empty())"
  },
  {
    "label": "try_release()",
    "kind": "Method",
    "detail": "Function (} break ; case rel_res : reserved = false ; my_predecessors .)",
    "insertText": "try_release()"
  },
  {
    "label": "try_consume()",
    "kind": "Method",
    "detail": "Function (break ; case con_res : reserved = false ; my_predecessors .)",
    "insertText": "try_consume()"
  },
  {
    "label": "internal_add_built_predecessor()",
    "kind": "Method",
    "detail": "Function (break ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION case add_blt_pred : my_predecessors .)",
    "insertText": "internal_add_built_predecessor(*(current->my_pred))"
  },
  {
    "label": "internal_delete_built_predecessor()",
    "kind": "Method",
    "detail": "Function (break ; case del_blt_pred : my_predecessors .)",
    "insertText": "internal_delete_built_predecessor(*(current->my_pred))"
  },
  {
    "label": "predecessor_count()",
    "kind": "Method",
    "detail": "Function (break ; case blt_pred_cnt : current -> cnt_val = my_predecessors .)",
    "insertText": "predecessor_count()"
  },
  {
    "label": "copy_predecessors()",
    "kind": "Method",
    "detail": "Function (break ; case blt_pred_cpy : my_predecessors .)",
    "insertText": "copy_predecessors(*(current->plist))"
  },
  {
    "label": "try_put_task()",
    "kind": "Method",
    "detail": "Function (break ; # endif } } } protected : template<R,B> class run_and_put_task ; template<X,Y> class internal::broadcast_cache ; template<X,Y> class internal::round_robin_cache ; task*)",
    "insertText": "try_put_task(const T &)"
  },
  {
    "label": "set_owner()",
    "kind": "Method",
    "detail": "Function (my_join = NULL ; my_predecessors .)",
    "insertText": "set_owner(this)"
  },
  {
    "label": "initialize_handler()",
    "kind": "Method",
    "detail": "Function (my_aggregator .)",
    "insertText": "initialize_handler(handler_type(this))"
  },
  {
    "label": "reserving_port()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "reserving_port(const reserving_port& ) : receiver<T>()"
  },
  {
    "label": "set_join_node_pointer()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_join_node_pointer(forwarding_base *join)"
  },
  {
    "label": "register_predecessor()",
    "kind": "Method",
    "detail": "Function (my_join = join ; } bool)",
    "insertText": "register_predecessor(predecessor_type &src)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (reserving_port_operation)",
    "insertText": "op_data(src, reg_pred)"
  },
  {
    "label": "execute()",
    "kind": "Method",
    "detail": "Function (my_aggregator .)",
    "insertText": "execute(&op_data)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (reserving_port_operation)",
    "insertText": "op_data(src, rem_pred)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (reserving_port_operation)",
    "insertText": "op_data(v, res_item)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (reserving_port_operation)",
    "insertText": "op_data(rel_res)"
  },
  {
    "label": "consume()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "consume()"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (reserving_port_operation)",
    "insertText": "op_data(con_res)"
  },
  {
    "label": "built_predecessors()",
    "kind": "Method",
    "detail": "Function (} # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION built_predecessors_type&)",
    "insertText": "built_predecessors()"
  },
  {
    "label": "internal_add_built_predecessor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_add_built_predecessor(predecessor_type &src)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (reserving_port_operation)",
    "insertText": "op_data(src, add_blt_pred)"
  },
  {
    "label": "internal_delete_built_predecessor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_delete_built_predecessor(predecessor_type &src)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (reserving_port_operation)",
    "insertText": "op_data(src, del_blt_pred)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (reserving_port_operation)",
    "insertText": "op_data(blt_pred_cnt)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (reserving_port_operation)",
    "insertText": "op_data(blt_pred_cpy)"
  },
  {
    "label": "extract_receiver()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "extract_receiver()"
  },
  {
    "label": "built_predecessors()",
    "kind": "Method",
    "detail": "Function (my_predecessors .)",
    "insertText": "built_predecessors().receiver_extract(*this)"
  },
  {
    "label": "reset_receiver()",
    "kind": "Method",
    "detail": "Function (} # endif void)",
    "insertText": "reset_receiver(reset_flags f)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (reserved = false ;)",
    "insertText": "__TBB_ASSERT(!(f&rf_clear_edges) || my_predecessors.empty(), \"port edges not removed\")"
  },
  {
    "label": "queueing_port_operation()",
    "kind": "Method",
    "detail": "Function (} private : forwarding_base* my_join ; reservable_predecessor_cache<T,null_mutex> my_predecessors ; bool reserved ; } ; template<T> class queueing_port : public receiver<T>,public item_buffer<T> { public : typedef T input_type ; typedef receiver<input_type>::predecessor_type predecessor_type ; typedef queueing_port<T> class_type ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION typedef receiver<input_type>::built_predecessors_type built_predecessors_type ; typedef receiver<input_type>::predecessor_list_type predecessor_list_type ; # endif private : enum op_type { get__item,res_port,try__put_task # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION,add_blt_pred,del_blt_pred,blt_pred_cnt,blt_pred_cpy # endif } ; class queueing_port_operation : public aggregated_operation<queueing_port_operation> { public : char type ; T my_val ; T* my_arg ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION predecessor_type* pred ; size_t cnt_val ; predecessor_list_type* plist ; # endif task* bypass_t ;)",
    "insertText": "queueing_port_operation(const T& e, op_type t) : type(char(t)), my_val(e) , bypass_t(NULL)"
  },
  {
    "label": "queueing_port_operation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "queueing_port_operation(const T* p, op_type t) : type(char(t)), my_arg(const_cast<T*>(p)) , bypass_t(NULL)"
  },
  {
    "label": "queueing_port_operation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "queueing_port_operation(op_type t) : type(char(t)) , bypass_t(NULL)"
  },
  {
    "label": "handle_operations()",
    "kind": "Method",
    "detail": "Function (} } ; typedef internal::aggregating_functor<class_type,queueing_port_operation> handler_type ; class internal::aggregating_functor<class_type,queueing_port_operation> ; aggregator<handler_type,queueing_port_operation> my_aggregator ; void)",
    "insertText": "handle_operations(queueing_port_operation* op_list)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "push_back(current->my_val)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} break ; case get__item :)",
    "insertText": "if(!this->buffer_empty())"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (} break ; case res_port :)",
    "insertText": "__TBB_ASSERT(this->my_item_valid(this->my_head), \"No item to reset\")"
  },
  {
    "label": "destroy_front()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "destroy_front()"
  },
  {
    "label": "add_edge()",
    "kind": "Method",
    "detail": "Function (break ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION case add_blt_pred : my_built_predecessors .)",
    "insertText": "add_edge(*(current->pred))"
  },
  {
    "label": "delete_edge()",
    "kind": "Method",
    "detail": "Function (break ; case del_blt_pred : my_built_predecessors .)",
    "insertText": "delete_edge(*(current->pred))"
  },
  {
    "label": "edge_count()",
    "kind": "Method",
    "detail": "Function (break ; case blt_pred_cnt : current -> cnt_val = my_built_predecessors .)",
    "insertText": "edge_count()"
  },
  {
    "label": "copy_edges()",
    "kind": "Method",
    "detail": "Function (break ; case blt_pred_cpy : my_built_predecessors .)",
    "insertText": "copy_edges(*(current->plist))"
  },
  {
    "label": "try_put_task()",
    "kind": "Method",
    "detail": "Function (break ; # endif } } } protected : template<R,B> class run_and_put_task ; template<X,Y> class internal::broadcast_cache ; template<X,Y> class internal::round_robin_cache ; task*)",
    "insertText": "try_put_task(const T &v)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (queueing_port_operation)",
    "insertText": "op_data(v, try__put_task)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(op_data.status == SUCCEEDED || !op_data.bypass_t, \"inconsistent return from aggregator\")"
  },
  {
    "label": "queueing_port()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "queueing_port(const queueing_port& ) : receiver<T>(), item_buffer<T>()"
  },
  {
    "label": "get_item()",
    "kind": "Method",
    "detail": "Function (my_join = join ; } bool)",
    "insertText": "get_item(T &v)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (queueing_port_operation)",
    "insertText": "op_data(&v, get__item)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (queueing_port_operation)",
    "insertText": "op_data(res_port)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (queueing_port_operation)",
    "insertText": "op_data(add_blt_pred)"
  },
  {
    "label": "internal_delete_built_predecessor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_delete_built_predecessor(predecessor_type &p)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (queueing_port_operation)",
    "insertText": "op_data(del_blt_pred)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (item_buffer<T)",
    "insertText": "reset()"
  },
  {
    "label": "receiver_extract()",
    "kind": "Method",
    "detail": "Function (my_built_predecessors .)",
    "insertText": "receiver_extract(*this)"
  },
  {
    "label": "suppress_unused_warning()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "suppress_unused_warning(f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if TBB_DEPRECATED_FLOW_NODE_EXTRACTION)",
    "insertText": "if(f & rf_clear_edges) my_built_predecessors.clear()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# endif } private : forwarding_base* my_join ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION edge_container<predecessor_type> my_built_predecessors ; # endif } ; # include \" _flow_graph_tagged_buffer_impl . h \" template<K> struct count_element { K my_key ; size_t my_value ; } ; template<K> struct key_to_count_functor { typedef count_element<K> table_item_type ; const K&)",
    "insertText": "operator()(const table_item_type& v)"
  },
  {
    "label": "key_matching_port_operation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "key_matching_port_operation(const input_type* p, op_type t) : type(char(t)), my_arg(const_cast<input_type*>(p))"
  },
  {
    "label": "key_matching_port_operation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "key_matching_port_operation(op_type t) : type(char(t))"
  },
  {
    "label": "handle_operations()",
    "kind": "Method",
    "detail": "Function (} } ; typedef internal::aggregating_functor<class_type,key_matching_port_operation> handler_type ; class internal::aggregating_functor<class_type,key_matching_port_operation> ; aggregator<handler_type,key_matching_port_operation> my_aggregator ; void)",
    "insertText": "handle_operations(key_matching_port_operation* op_list)"
  },
  {
    "label": "__TBB_store_with_release()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_store_with_release(current->status, was_inserted ? SUCCEEDED : FAILED)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} break ; case get__item :)",
    "insertText": "if(!this->find_with_key(my_join->current_key, *(current->my_arg)))"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(false, \"Failed to find item corresponding to current_key.\")"
  },
  {
    "label": "delete_with_key()",
    "kind": "Method",
    "detail": "Function (break ; case res_port : this ->)",
    "insertText": "delete_with_key(my_join->current_key)"
  },
  {
    "label": "try_put_task()",
    "kind": "Method",
    "detail": "Function (break ; # endif } } } protected : template<R,B> class run_and_put_task ; template<X,Y> class internal::broadcast_cache ; template<X,Y> class internal::round_robin_cache ; task*)",
    "insertText": "try_put_task(const input_type& v)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (key_matching_port_operation)",
    "insertText": "op_data(v, try__put)"
  },
  {
    "label": "increment_key_count()",
    "kind": "Method",
    "detail": "Function (rtask = my_join ->)",
    "insertText": "increment_key_count((*(this->get_key_func()))(v), false)"
  },
  {
    "label": "graph_reference()",
    "kind": "Method",
    "detail": "Function (} return rtask ; } graph&)",
    "insertText": "graph_reference()"
  },
  {
    "label": "key_matching_port()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "key_matching_port(const key_matching_port& ) : receiver<input_type>(), buffer_type()"
  },
  {
    "label": "key_matching_port()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "key_matching_port()"
  },
  {
    "label": "key_type()",
    "kind": "Method",
    "detail": "Function (my_join = dynamic_cast<matching_forwarding_base<)",
    "insertText": "key_type(join)"
  },
  {
    "label": "set_my_key_func()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_my_key_func(type_to_key_func_type *f)"
  },
  {
    "label": "set_key_func()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "set_key_func(f)"
  },
  {
    "label": "get_my_key_func()",
    "kind": "Method",
    "detail": "Function (} type_to_key_func_type*)",
    "insertText": "get_my_key_func()"
  },
  {
    "label": "get_item()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "get_item(input_type &v)"
  },
  {
    "label": "reset_port()",
    "kind": "Method",
    "detail": "Function (} # endif void)",
    "insertText": "reset_port()"
  },
  {
    "label": "join_node_FE()",
    "kind": "Method",
    "detail": "Function (# endif } private : matching_forwarding_base<key_type>* my_join ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION edge_container<predecessor_type> my_built_predecessors ; # endif } ; using namespace graph_policy_namespace ; template<JP,InputTuple,OutputTuple> class join_node_base ; template<JP,InputTuple,OutputTuple> class join_node_FE ; template<InputTuple,OutputTuple> class join_node_FE<reserving,InputTuple,OutputTuple> : public forwarding_base { public : const int N = tbb::flow::tuple_size<OutputTuple>::value ; typedef OutputTuple output_type ; typedef InputTuple input_type ; typedef join_node_base<reserving,InputTuple,OutputTuple> base_node_type ;)",
    "insertText": "join_node_FE(graph &g) : forwarding_base(g), my_node(NULL)"
  },
  {
    "label": "set_join_node_pointer()",
    "kind": "Method",
    "detail": "Function (ports_with_no_inputs = N ; join_helper<N)",
    "insertText": "set_join_node_pointer(my_inputs, this)"
  },
  {
    "label": "join_node_FE()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "join_node_FE(const join_node_FE& other) : forwarding_base((other.forwarding_base::graph_ref)), my_node(NULL)"
  },
  {
    "label": "set_my_node()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_my_node(base_node_type *new_my_node)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (task* rtask =)",
    "insertText": "new(task::allocate_additional_child_of( *(this->graph_ref.root_task()) ) ) forward_task_bypass<base_node_type>(*my_node)"
  },
  {
    "label": "spawn_in_graph_arena()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "spawn_in_graph_arena(this->graph_ref, *rtask)"
  },
  {
    "label": "input_ports()",
    "kind": "Method",
    "detail": "Function (} } return NULL ; } input_type&)",
    "insertText": "input_ports()"
  },
  {
    "label": "reset_inputs()",
    "kind": "Method",
    "detail": "Function (ports_with_no_inputs = N ; join_helper<N)",
    "insertText": "reset_inputs(my_inputs, f)"
  },
  {
    "label": "extract()",
    "kind": "Method",
    "detail": "Function (} # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION void)",
    "insertText": "extract()"
  },
  {
    "label": "extract_inputs()",
    "kind": "Method",
    "detail": "Function (ports_with_no_inputs = N ; join_helper<N)",
    "insertText": "extract_inputs(my_inputs)"
  },
  {
    "label": "tuple_build_may_succeed()",
    "kind": "Method",
    "detail": "Function (} # endif bool)",
    "insertText": "tuple_build_may_succeed()"
  },
  {
    "label": "tuple_accepted()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "tuple_accepted()"
  },
  {
    "label": "consume_reservations()",
    "kind": "Method",
    "detail": "Function (join_helper<N)",
    "insertText": "consume_reservations(my_inputs)"
  },
  {
    "label": "tuple_rejected()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "tuple_rejected()"
  },
  {
    "label": "release_reservations()",
    "kind": "Method",
    "detail": "Function (join_helper<N)",
    "insertText": "release_reservations(my_inputs)"
  },
  {
    "label": "reset_port_count()",
    "kind": "Method",
    "detail": "Function (my_node = new_my_node ; } void)",
    "insertText": "reset_port_count()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (task* rtask =)",
    "insertText": "new(task::allocate_additional_child_of( *(this->graph_ref.root_task()) ) ) forward_task_bypass <base_node_type>(*my_node)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(false, NULL)"
  },
  {
    "label": "reset_ports()",
    "kind": "Method",
    "detail": "Function (join_helper<N)",
    "insertText": "reset_ports(my_inputs)"
  },
  {
    "label": "key_matching_FE_operation()",
    "kind": "Method",
    "detail": "Function (} input_type my_inputs ; base_node_type* my_node ; atomic<size_t> ports_with_no_items ; } ; template<InputTuple,OutputTuple,K,KHash> class join_node_FE<key_matching<K,KHash>,InputTuple,OutputTuple> : public matching_forwarding_base<K>,public hash_buffer<tbb::internal::strip<K>::type&,count_element<tbb::internal::strip<K>::type>,internal::type_to_key_function_body<count_element<tbb::internal::strip<K>::type>,tbb::internal::strip<K>::type&>,KHash>,public item_buffer<OutputTuple> { public : const int N = tbb::flow::tuple_size<OutputTuple>::value ; typedef OutputTuple output_type ; typedef InputTuple input_type ; typedef K key_type ; typedef tbb::internal::strip<key_type>::type unref_key_type ; typedef KHash key_hash_compare ; typedef count_element<unref_key_type> count_element_type ; typedef key_to_count_functor<unref_key_type> key_to_count_func ; typedef internal::type_to_key_function_body<count_element_type,unref_key_type&> TtoK_function_body_type ; typedef internal::type_to_key_function_body_leaf<count_element_type,unref_key_type&,key_to_count_func> TtoK_function_body_leaf_type ; typedef hash_buffer<unref_key_type&,count_element_type,TtoK_function_body_type,key_hash_compare> key_to_count_buffer_type ; typedef item_buffer<output_type> output_buffer_type ; typedef join_node_base<key_matching<key_type,key_hash_compare>,InputTuple,OutputTuple> base_node_type ; typedef matching_forwarding_base<key_type> forwarding_base_type ; private : enum op_type { res_count,inc_count,may_succeed,try_make } ; typedef join_node_FE<key_matching<key_type,key_hash_compare>,InputTuple,OutputTuple> class_type ; class key_matching_FE_operation : public aggregated_operation<key_matching_FE_operation> { public : char type ; unref_key_type my_val ; output_type* my_output ; task* bypass_t ; bool enqueue_task ;)",
    "insertText": "key_matching_FE_operation(const unref_key_type& e , bool q_task , op_type t) : type(char(t)), my_val(e), my_output(NULL), bypass_t(NULL), enqueue_task(q_task)"
  },
  {
    "label": "key_matching_FE_operation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "key_matching_FE_operation(output_type *p, op_type t) : type(char(t)), my_output(p), bypass_t(NULL), enqueue_task(true)"
  },
  {
    "label": "key_matching_FE_operation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "key_matching_FE_operation(op_type t) : type(char(t)), my_output(NULL), bypass_t(NULL), enqueue_task(true)"
  },
  {
    "label": "fill_output_buffer()",
    "kind": "Method",
    "detail": "Function (} } ; typedef internal::aggregating_functor<class_type,key_matching_FE_operation> handler_type ; class internal::aggregating_functor<class_type,key_matching_FE_operation> ; aggregator<handler_type,key_matching_FE_operation> my_aggregator ; task*)",
    "insertText": "fill_output_buffer(unref_key_type &t, bool should_enqueue, bool handle_task)"
  },
  {
    "label": "buffer_empty()",
    "kind": "Method",
    "detail": "Function (output_type l_out ; task* rtask = NULL ; bool do_fwd = should_enqueue&& this ->)",
    "insertText": "buffer_empty() && internal::is_graph_active(this->graph_ref)"
  },
  {
    "label": "delete_with_key()",
    "kind": "Method",
    "detail": "Function (this -> current_key = t ; this ->)",
    "insertText": "delete_with_key(this->current_key)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "push_back(l_out)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "__TBB_ASSERT(false, \"should have had something to push\")"
  },
  {
    "label": "handle_operations()",
    "kind": "Method",
    "detail": "Function (} return rtask ; } void)",
    "insertText": "handle_operations(key_matching_FE_operation* op_list)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} break ; case inc_count : { count_element_type* p = 0 ; unref_key_type& t = current -> my_val ; bool do_enqueue = current -> enqueue_task ;)",
    "insertText": "if(!(this->find_ref_with_key(t,p)))"
  },
  {
    "label": "insert_with_key()",
    "kind": "Method",
    "detail": "Function (count_element_type ev ; ev . my_key = t ; ev . my_value = 0 ; this ->)",
    "insertText": "insert_with_key(ev)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(false, \"should find key after inserting it\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(++(p->my_value) == size_t(N))"
  },
  {
    "label": "fill_output_buffer()",
    "kind": "Method",
    "detail": "Function (task* rtask =)",
    "insertText": "fill_output_buffer(t, true, do_enqueue)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(!rtask || !do_enqueue, \"task should not be returned\")"
  },
  {
    "label": "__TBB_store_with_release()",
    "kind": "Method",
    "detail": "Function (break ; case may_succeed :)",
    "insertText": "__TBB_store_with_release(current->status, this->buffer_empty() ? FAILED : SUCCEEDED)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case try_make :)",
    "insertText": "if(this->buffer_empty())"
  },
  {
    "label": "else()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "else(current->my_output) = this->front()"
  },
  {
    "label": "join_node_FE()",
    "kind": "Method",
    "detail": "Function (} break ; } } } public : template<FunctionTuple>)",
    "insertText": "join_node_FE(graph &g, FunctionTuple &TtoK_funcs) : forwarding_base_type(g), my_node(NULL)"
  },
  {
    "label": "set_key_functors()",
    "kind": "Method",
    "detail": "Function (join_helper<N)",
    "insertText": "set_key_functors(my_inputs, TtoK_funcs)"
  },
  {
    "label": "TtoK_function_body_leaf_type()",
    "kind": "Method",
    "detail": "Function (TtoK_function_body_type* cfb = new)",
    "insertText": "TtoK_function_body_leaf_type(key_to_count_func())"
  },
  {
    "label": "set_key_func()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "set_key_func(cfb)"
  },
  {
    "label": "join_node_FE()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "join_node_FE(const join_node_FE& other) : forwarding_base_type((other.forwarding_base_type::graph_ref)), key_to_count_buffer_type(), output_buffer_type()"
  },
  {
    "label": "copy_key_functors()",
    "kind": "Method",
    "detail": "Function (join_helper<N)",
    "insertText": "copy_key_functors(my_inputs, const_cast<input_type &>(other.my_inputs))"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (key_matching_FE_operation)",
    "insertText": "op_data(res_count)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (key_matching_FE_operation)",
    "insertText": "op_data(t, handle_task, inc_count)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (key_matching_FE_operation)",
    "insertText": "op_data(may_succeed)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (key_matching_FE_operation)",
    "insertText": "op_data(&out,try_make)"
  },
  {
    "label": "join_node_base_operation()",
    "kind": "Method",
    "detail": "Function (} input_type my_inputs ; base_node_type* my_node ; } ; template<JP,InputTuple,OutputTuple> class join_node_base : public graph_node,public join_node_FE<JP,InputTuple,OutputTuple>,public sender<OutputTuple> { protected : using graph_node::my_graph ; public : typedef OutputTuple output_type ; typedef sender<output_type>::successor_type successor_type ; typedef join_node_FE<JP,InputTuple,OutputTuple> input_ports_type ; using input_ports_type::tuple_build_may_succeed ; using input_ports_type::try_to_make_tuple ; using input_ports_type::tuple_accepted ; using input_ports_type::tuple_rejected ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION typedef sender<output_type>::built_successors_type built_successors_type ; typedef sender<output_type>::successor_list_type successor_list_type ; # endif private : enum op_type { reg_succ,rem_succ,try__get,do_fwrd,do_fwrd_bypass # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION,add_blt_succ,del_blt_succ,blt_succ_cnt,blt_succ_cpy # endif } ; typedef join_node_base<JP,InputTuple,OutputTuple> class_type ; class join_node_base_operation : public aggregated_operation<join_node_base_operation> { public : char type ; union { output_type* my_arg ; successor_type* my_succ ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION size_t cnt_val ; successor_list_type* slist ; # endif } ; task* bypass_t ;)",
    "insertText": "join_node_base_operation(const output_type& e, op_type t) : type(char(t)), my_arg(const_cast<output_type*>(&e)), bypass_t(NULL)"
  },
  {
    "label": "join_node_base_operation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "join_node_base_operation(const successor_type &s, op_type t) : type(char(t)), my_succ(const_cast<successor_type *>(&s)), bypass_t(NULL)"
  },
  {
    "label": "join_node_base_operation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "join_node_base_operation(op_type t) : type(char(t)), bypass_t(NULL)"
  },
  {
    "label": "handle_operations()",
    "kind": "Method",
    "detail": "Function (} } ; typedef internal::aggregating_functor<class_type,join_node_base_operation> handler_type ; class internal::aggregating_functor<class_type,join_node_base_operation> ; bool forwarder_busy ; aggregator<handler_type,join_node_base_operation> my_aggregator ; void)",
    "insertText": "handle_operations(join_node_base_operation* op_list)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (task* rtask =)",
    "insertText": "new(task::allocate_additional_child_of(*(my_graph.root_task())) ) forward_task_bypass <join_node_base<JP,InputTuple,OutputTuple> >(*this)"
  },
  {
    "label": "spawn_in_graph_arena()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "spawn_in_graph_arena(my_graph, *rtask)"
  },
  {
    "label": "remove_successor()",
    "kind": "Method",
    "detail": "Function (} break ; case rem_succ : my_successors .)",
    "insertText": "remove_successor(*(current->my_succ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case try__get :)",
    "insertText": "if(tuple_build_may_succeed())"
  },
  {
    "label": "try_put_task()",
    "kind": "Method",
    "detail": "Function (task* new_task = my_successors .)",
    "insertText": "try_put_task(out)"
  },
  {
    "label": "combine_tasks()",
    "kind": "Method",
    "detail": "Function (last_task =)",
    "insertText": "combine_tasks(my_graph, last_task, new_task)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (build_succeeded = false ; } } })",
    "insertText": "while(build_succeeded)"
  },
  {
    "label": "internal_delete_built_successor()",
    "kind": "Method",
    "detail": "Function (break ; case del_blt_succ : my_successors .)",
    "insertText": "internal_delete_built_successor(*(current->my_succ))"
  },
  {
    "label": "successor_count()",
    "kind": "Method",
    "detail": "Function (break ; case blt_succ_cnt : current -> cnt_val = my_successors .)",
    "insertText": "successor_count()"
  },
  {
    "label": "copy_successors()",
    "kind": "Method",
    "detail": "Function (break ; case blt_succ_cpy : my_successors .)",
    "insertText": "copy_successors(*(current->slist))"
  },
  {
    "label": "join_node_base()",
    "kind": "Method",
    "detail": "Function (break ; # endif } } } public :)",
    "insertText": "join_node_base(graph &g) : graph_node(g), input_ports_type(g), forwarder_busy(false)"
  },
  {
    "label": "set_my_node()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_my_node(this)"
  },
  {
    "label": "join_node_base()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "join_node_base(const join_node_base& other) : graph_node(other.graph_node::my_graph), input_ports_type(other), sender<OutputTuple>(), forwarder_busy(false), my_successors()"
  },
  {
    "label": "join_node_base()",
    "kind": "Method",
    "detail": "Function (} template<FunctionTuple>)",
    "insertText": "join_node_base(graph &g, FunctionTuple f) : graph_node(g), input_ports_type(g, f), forwarder_busy(false)"
  },
  {
    "label": "register_successor()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "register_successor(successor_type &r)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (join_node_base_operation)",
    "insertText": "op_data(r, reg_succ)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (join_node_base_operation)",
    "insertText": "op_data(r, rem_succ)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (join_node_base_operation)",
    "insertText": "op_data(v, try__get)"
  },
  {
    "label": "internal_add_built_successor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_add_built_successor(successor_type &r)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (join_node_base_operation)",
    "insertText": "op_data(r, add_blt_succ)"
  },
  {
    "label": "internal_delete_built_successor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_delete_built_successor(successor_type &r)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (join_node_base_operation)",
    "insertText": "op_data(r, del_blt_succ)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (join_node_base_operation)",
    "insertText": "op_data(blt_succ_cnt)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (join_node_base_operation)",
    "insertText": "op_data(blt_succ_cpy)"
  },
  {
    "label": "built_successors()",
    "kind": "Method",
    "detail": "Function (my_successors .)",
    "insertText": "built_successors().sender_extract(*this)"
  },
  {
    "label": "reset_node()",
    "kind": "Method",
    "detail": "Function (} # endif protected : void)",
    "insertText": "reset_node(reset_flags f)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reset(f)"
  },
  {
    "label": "forward_task()",
    "kind": "Method",
    "detail": "Function (} private : broadcast_cache<output_type,null_rw_mutex> my_successors ; class forward_task_bypass<join_node_base<JP,InputTuple,OutputTuple>> ; task*)",
    "insertText": "forward_task()"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (join_node_base_operation)",
    "insertText": "op_data(do_fwrd_bypass)"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "unfolded_join_node(const unfolded_join_node &other) : base_type(other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; # if __TBB_PREVIEW_MESSAGE_BASED_KEY_MATCHING template<K,T> struct key_from_message_body { K)",
    "insertText": "operator()(const T& t)"
  },
  {
    "label": "K()",
    "kind": "Method",
    "detail": "Function (using tbb::flow::key_from_message ; return key_from_message<)",
    "insertText": "K(t)"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (} } ; # endif template<OutputTuple,K,KHash> class unfolded_join_node<2,key_matching_port,OutputTuple,key_matching<K,KHash>> : public join_base<2,key_matching_port,OutputTuple,key_matching<K,KHash>>::type { typedef tbb::flow::tuple_element<0,OutputTuple>::type T0 ; typedef tbb::flow::tuple_element<1,OutputTuple>::type T1 ; public : typedef wrap_key_tuple_elements<2,key_matching_port,key_matching<K,KHash>,OutputTuple>::type input_ports_type ; typedef OutputTuple output_type ; private : typedef join_node_base<key_matching<K,KHash>,input_ports_type,output_type> base_type ; typedef internal::type_to_key_function_body<T0,K>* f0_p ; typedef internal::type_to_key_function_body<T1,K>* f1_p ; typedef tbb::flow::tuple<f0_p,f1_p> func_initializer_type ; public : # if __TBB_PREVIEW_MESSAGE_BASED_KEY_MATCHING)",
    "insertText": "unfolded_join_node(graph &g) : base_type(g, func_initializer_type( new internal::type_to_key_function_body_leaf<T0, K, key_from_message_body<K,T0> >(key_from_message_body<K,T0>()), new internal::type_to_key_function_body_leaf<T1, K, key_from_message_body<K,T1> >(key_from_message_body<K,T1>()) ))"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (} # endif template<Body0,Body1>)",
    "insertText": "unfolded_join_node(graph &g, Body0 body0, Body1 body1) : base_type(g, func_initializer_type( new internal::type_to_key_function_body_leaf<T0, K, Body0>(body0), new internal::type_to_key_function_body_leaf<T1, K, Body1>(body1) ))"
  },
  {
    "label": "__TBB_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_STATIC_ASSERT(tbb::flow::tuple_size<OutputTuple>::value == 2, \"wrong number of body initializers\")"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (} } ; template<OutputTuple,K,KHash> class unfolded_join_node<3,key_matching_port,OutputTuple,key_matching<K,KHash>> : public join_base<3,key_matching_port,OutputTuple,key_matching<K,KHash>>::type { typedef tbb::flow::tuple_element<0,OutputTuple>::type T0 ; typedef tbb::flow::tuple_element<1,OutputTuple>::type T1 ; typedef tbb::flow::tuple_element<2,OutputTuple>::type T2 ; public : typedef wrap_key_tuple_elements<3,key_matching_port,key_matching<K,KHash>,OutputTuple>::type input_ports_type ; typedef OutputTuple output_type ; private : typedef join_node_base<key_matching<K,KHash>,input_ports_type,output_type> base_type ; typedef internal::type_to_key_function_body<T0,K>* f0_p ; typedef internal::type_to_key_function_body<T1,K>* f1_p ; typedef internal::type_to_key_function_body<T2,K>* f2_p ; typedef tbb::flow::tuple<f0_p,f1_p,f2_p> func_initializer_type ; public : # if __TBB_PREVIEW_MESSAGE_BASED_KEY_MATCHING)",
    "insertText": "unfolded_join_node(graph &g) : base_type(g, func_initializer_type( new internal::type_to_key_function_body_leaf<T0, K, key_from_message_body<K,T0> >(key_from_message_body<K,T0>()), new internal::type_to_key_function_body_leaf<T1, K, key_from_message_body<K,T1> >(key_from_message_body<K,T1>()), new internal::type_to_key_function_body_leaf<T2, K, key_from_message_body<K,T2> >(key_from_message_body<K,T2>()) ))"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (} # endif template<Body0,Body1,Body2>)",
    "insertText": "unfolded_join_node(graph &g, Body0 body0, Body1 body1, Body2 body2) : base_type(g, func_initializer_type( new internal::type_to_key_function_body_leaf<T0, K, Body0>(body0), new internal::type_to_key_function_body_leaf<T1, K, Body1>(body1), new internal::type_to_key_function_body_leaf<T2, K, Body2>(body2) ))"
  },
  {
    "label": "__TBB_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_STATIC_ASSERT(tbb::flow::tuple_size<OutputTuple>::value == 3, \"wrong number of body initializers\")"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (} } ; template<OutputTuple,K,KHash> class unfolded_join_node<4,key_matching_port,OutputTuple,key_matching<K,KHash>> : public join_base<4,key_matching_port,OutputTuple,key_matching<K,KHash>>::type { typedef tbb::flow::tuple_element<0,OutputTuple>::type T0 ; typedef tbb::flow::tuple_element<1,OutputTuple>::type T1 ; typedef tbb::flow::tuple_element<2,OutputTuple>::type T2 ; typedef tbb::flow::tuple_element<3,OutputTuple>::type T3 ; public : typedef wrap_key_tuple_elements<4,key_matching_port,key_matching<K,KHash>,OutputTuple>::type input_ports_type ; typedef OutputTuple output_type ; private : typedef join_node_base<key_matching<K,KHash>,input_ports_type,output_type> base_type ; typedef internal::type_to_key_function_body<T0,K>* f0_p ; typedef internal::type_to_key_function_body<T1,K>* f1_p ; typedef internal::type_to_key_function_body<T2,K>* f2_p ; typedef internal::type_to_key_function_body<T3,K>* f3_p ; typedef tbb::flow::tuple<f0_p,f1_p,f2_p,f3_p> func_initializer_type ; public : # if __TBB_PREVIEW_MESSAGE_BASED_KEY_MATCHING)",
    "insertText": "unfolded_join_node(graph &g) : base_type(g, func_initializer_type( new internal::type_to_key_function_body_leaf<T0, K, key_from_message_body<K,T0> >(key_from_message_body<K,T0>()), new internal::type_to_key_function_body_leaf<T1, K, key_from_message_body<K,T1> >(key_from_message_body<K,T1>()), new internal::type_to_key_function_body_leaf<T2, K, key_from_message_body<K,T2> >(key_from_message_body<K,T2>()), new internal::type_to_key_function_body_leaf<T3, K, key_from_message_body<K,T3> >(key_from_message_body<K,T3>()) ))"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (} # endif template<Body0,Body1,Body2,Body3>)",
    "insertText": "unfolded_join_node(graph &g, Body0 body0, Body1 body1, Body2 body2, Body3 body3) : base_type(g, func_initializer_type( new internal::type_to_key_function_body_leaf<T0, K, Body0>(body0), new internal::type_to_key_function_body_leaf<T1, K, Body1>(body1), new internal::type_to_key_function_body_leaf<T2, K, Body2>(body2), new internal::type_to_key_function_body_leaf<T3, K, Body3>(body3) ))"
  },
  {
    "label": "__TBB_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_STATIC_ASSERT(tbb::flow::tuple_size<OutputTuple>::value == 4, \"wrong number of body initializers\")"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (} } ; template<OutputTuple,K,KHash> class unfolded_join_node<5,key_matching_port,OutputTuple,key_matching<K,KHash>> : public join_base<5,key_matching_port,OutputTuple,key_matching<K,KHash>>::type { typedef tbb::flow::tuple_element<0,OutputTuple>::type T0 ; typedef tbb::flow::tuple_element<1,OutputTuple>::type T1 ; typedef tbb::flow::tuple_element<2,OutputTuple>::type T2 ; typedef tbb::flow::tuple_element<3,OutputTuple>::type T3 ; typedef tbb::flow::tuple_element<4,OutputTuple>::type T4 ; public : typedef wrap_key_tuple_elements<5,key_matching_port,key_matching<K,KHash>,OutputTuple>::type input_ports_type ; typedef OutputTuple output_type ; private : typedef join_node_base<key_matching<K,KHash>,input_ports_type,output_type> base_type ; typedef internal::type_to_key_function_body<T0,K>* f0_p ; typedef internal::type_to_key_function_body<T1,K>* f1_p ; typedef internal::type_to_key_function_body<T2,K>* f2_p ; typedef internal::type_to_key_function_body<T3,K>* f3_p ; typedef internal::type_to_key_function_body<T4,K>* f4_p ; typedef tbb::flow::tuple<f0_p,f1_p,f2_p,f3_p,f4_p> func_initializer_type ; public : # if __TBB_PREVIEW_MESSAGE_BASED_KEY_MATCHING)",
    "insertText": "unfolded_join_node(graph &g) : base_type(g, func_initializer_type( new internal::type_to_key_function_body_leaf<T0, K, key_from_message_body<K,T0> >(key_from_message_body<K,T0>()), new internal::type_to_key_function_body_leaf<T1, K, key_from_message_body<K,T1> >(key_from_message_body<K,T1>()), new internal::type_to_key_function_body_leaf<T2, K, key_from_message_body<K,T2> >(key_from_message_body<K,T2>()), new internal::type_to_key_function_body_leaf<T3, K, key_from_message_body<K,T3> >(key_from_message_body<K,T3>()), new internal::type_to_key_function_body_leaf<T4, K, key_from_message_body<K,T4> >(key_from_message_body<K,T4>()) ))"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (} # endif template<Body0,Body1,Body2,Body3,Body4>)",
    "insertText": "unfolded_join_node(graph &g, Body0 body0, Body1 body1, Body2 body2, Body3 body3, Body4 body4) : base_type(g, func_initializer_type( new internal::type_to_key_function_body_leaf<T0, K, Body0>(body0), new internal::type_to_key_function_body_leaf<T1, K, Body1>(body1), new internal::type_to_key_function_body_leaf<T2, K, Body2>(body2), new internal::type_to_key_function_body_leaf<T3, K, Body3>(body3), new internal::type_to_key_function_body_leaf<T4, K, Body4>(body4) ))"
  },
  {
    "label": "__TBB_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_STATIC_ASSERT(tbb::flow::tuple_size<OutputTuple>::value == 5, \"wrong number of body initializers\")"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (} } ; # if __TBB_VARIADIC_MAX> = 6 template<OutputTuple,K,KHash> class unfolded_join_node<6,key_matching_port,OutputTuple,key_matching<K,KHash>> : public join_base<6,key_matching_port,OutputTuple,key_matching<K,KHash>>::type { typedef tbb::flow::tuple_element<0,OutputTuple>::type T0 ; typedef tbb::flow::tuple_element<1,OutputTuple>::type T1 ; typedef tbb::flow::tuple_element<2,OutputTuple>::type T2 ; typedef tbb::flow::tuple_element<3,OutputTuple>::type T3 ; typedef tbb::flow::tuple_element<4,OutputTuple>::type T4 ; typedef tbb::flow::tuple_element<5,OutputTuple>::type T5 ; public : typedef wrap_key_tuple_elements<6,key_matching_port,key_matching<K,KHash>,OutputTuple>::type input_ports_type ; typedef OutputTuple output_type ; private : typedef join_node_base<key_matching<K,KHash>,input_ports_type,output_type> base_type ; typedef internal::type_to_key_function_body<T0,K>* f0_p ; typedef internal::type_to_key_function_body<T1,K>* f1_p ; typedef internal::type_to_key_function_body<T2,K>* f2_p ; typedef internal::type_to_key_function_body<T3,K>* f3_p ; typedef internal::type_to_key_function_body<T4,K>* f4_p ; typedef internal::type_to_key_function_body<T5,K>* f5_p ; typedef tbb::flow::tuple<f0_p,f1_p,f2_p,f3_p,f4_p,f5_p> func_initializer_type ; public : # if __TBB_PREVIEW_MESSAGE_BASED_KEY_MATCHING)",
    "insertText": "unfolded_join_node(graph &g) : base_type(g, func_initializer_type( new internal::type_to_key_function_body_leaf<T0, K, key_from_message_body<K,T0> >(key_from_message_body<K,T0>()), new internal::type_to_key_function_body_leaf<T1, K, key_from_message_body<K,T1> >(key_from_message_body<K,T1>()), new internal::type_to_key_function_body_leaf<T2, K, key_from_message_body<K,T2> >(key_from_message_body<K,T2>()), new internal::type_to_key_function_body_leaf<T3, K, key_from_message_body<K,T3> >(key_from_message_body<K,T3>()), new internal::type_to_key_function_body_leaf<T4, K, key_from_message_body<K,T4> >(key_from_message_body<K,T4>()), new internal::type_to_key_function_body_leaf<T5, K, key_from_message_body<K,T5> >(key_from_message_body<K,T5>()) ))"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (} # endif template<Body0,Body1,Body2,Body3,Body4,Body5>)",
    "insertText": "unfolded_join_node(graph &g, Body0 body0, Body1 body1, Body2 body2, Body3 body3, Body4 body4, Body5 body5) : base_type(g, func_initializer_type( new internal::type_to_key_function_body_leaf<T0, K, Body0>(body0), new internal::type_to_key_function_body_leaf<T1, K, Body1>(body1), new internal::type_to_key_function_body_leaf<T2, K, Body2>(body2), new internal::type_to_key_function_body_leaf<T3, K, Body3>(body3), new internal::type_to_key_function_body_leaf<T4, K, Body4>(body4), new internal::type_to_key_function_body_leaf<T5, K, Body5>(body5) ))"
  },
  {
    "label": "__TBB_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_STATIC_ASSERT(tbb::flow::tuple_size<OutputTuple>::value == 6, \"wrong number of body initializers\")"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (} } ; # endif # if __TBB_VARIADIC_MAX> = 7 template<OutputTuple,K,KHash> class unfolded_join_node<7,key_matching_port,OutputTuple,key_matching<K,KHash>> : public join_base<7,key_matching_port,OutputTuple,key_matching<K,KHash>>::type { typedef tbb::flow::tuple_element<0,OutputTuple>::type T0 ; typedef tbb::flow::tuple_element<1,OutputTuple>::type T1 ; typedef tbb::flow::tuple_element<2,OutputTuple>::type T2 ; typedef tbb::flow::tuple_element<3,OutputTuple>::type T3 ; typedef tbb::flow::tuple_element<4,OutputTuple>::type T4 ; typedef tbb::flow::tuple_element<5,OutputTuple>::type T5 ; typedef tbb::flow::tuple_element<6,OutputTuple>::type T6 ; public : typedef wrap_key_tuple_elements<7,key_matching_port,key_matching<K,KHash>,OutputTuple>::type input_ports_type ; typedef OutputTuple output_type ; private : typedef join_node_base<key_matching<K,KHash>,input_ports_type,output_type> base_type ; typedef internal::type_to_key_function_body<T0,K>* f0_p ; typedef internal::type_to_key_function_body<T1,K>* f1_p ; typedef internal::type_to_key_function_body<T2,K>* f2_p ; typedef internal::type_to_key_function_body<T3,K>* f3_p ; typedef internal::type_to_key_function_body<T4,K>* f4_p ; typedef internal::type_to_key_function_body<T5,K>* f5_p ; typedef internal::type_to_key_function_body<T6,K>* f6_p ; typedef tbb::flow::tuple<f0_p,f1_p,f2_p,f3_p,f4_p,f5_p,f6_p> func_initializer_type ; public : # if __TBB_PREVIEW_MESSAGE_BASED_KEY_MATCHING)",
    "insertText": "unfolded_join_node(graph &g) : base_type(g, func_initializer_type( new internal::type_to_key_function_body_leaf<T0, K, key_from_message_body<K,T0> >(key_from_message_body<K,T0>()), new internal::type_to_key_function_body_leaf<T1, K, key_from_message_body<K,T1> >(key_from_message_body<K,T1>()), new internal::type_to_key_function_body_leaf<T2, K, key_from_message_body<K,T2> >(key_from_message_body<K,T2>()), new internal::type_to_key_function_body_leaf<T3, K, key_from_message_body<K,T3> >(key_from_message_body<K,T3>()), new internal::type_to_key_function_body_leaf<T4, K, key_from_message_body<K,T4> >(key_from_message_body<K,T4>()), new internal::type_to_key_function_body_leaf<T5, K, key_from_message_body<K,T5> >(key_from_message_body<K,T5>()), new internal::type_to_key_function_body_leaf<T6, K, key_from_message_body<K,T6> >(key_from_message_body<K,T6>()) ))"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (} # endif template<Body0,Body1,Body2,Body3,Body4,Body5,Body6>)",
    "insertText": "unfolded_join_node(graph &g, Body0 body0, Body1 body1, Body2 body2, Body3 body3, Body4 body4, Body5 body5, Body6 body6) : base_type(g, func_initializer_type( new internal::type_to_key_function_body_leaf<T0, K, Body0>(body0), new internal::type_to_key_function_body_leaf<T1, K, Body1>(body1), new internal::type_to_key_function_body_leaf<T2, K, Body2>(body2), new internal::type_to_key_function_body_leaf<T3, K, Body3>(body3), new internal::type_to_key_function_body_leaf<T4, K, Body4>(body4), new internal::type_to_key_function_body_leaf<T5, K, Body5>(body5), new internal::type_to_key_function_body_leaf<T6, K, Body6>(body6) ))"
  },
  {
    "label": "__TBB_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_STATIC_ASSERT(tbb::flow::tuple_size<OutputTuple>::value == 7, \"wrong number of body initializers\")"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (} } ; # endif # if __TBB_VARIADIC_MAX> = 8 template<OutputTuple,K,KHash> class unfolded_join_node<8,key_matching_port,OutputTuple,key_matching<K,KHash>> : public join_base<8,key_matching_port,OutputTuple,key_matching<K,KHash>>::type { typedef tbb::flow::tuple_element<0,OutputTuple>::type T0 ; typedef tbb::flow::tuple_element<1,OutputTuple>::type T1 ; typedef tbb::flow::tuple_element<2,OutputTuple>::type T2 ; typedef tbb::flow::tuple_element<3,OutputTuple>::type T3 ; typedef tbb::flow::tuple_element<4,OutputTuple>::type T4 ; typedef tbb::flow::tuple_element<5,OutputTuple>::type T5 ; typedef tbb::flow::tuple_element<6,OutputTuple>::type T6 ; typedef tbb::flow::tuple_element<7,OutputTuple>::type T7 ; public : typedef wrap_key_tuple_elements<8,key_matching_port,key_matching<K,KHash>,OutputTuple>::type input_ports_type ; typedef OutputTuple output_type ; private : typedef join_node_base<key_matching<K,KHash>,input_ports_type,output_type> base_type ; typedef internal::type_to_key_function_body<T0,K>* f0_p ; typedef internal::type_to_key_function_body<T1,K>* f1_p ; typedef internal::type_to_key_function_body<T2,K>* f2_p ; typedef internal::type_to_key_function_body<T3,K>* f3_p ; typedef internal::type_to_key_function_body<T4,K>* f4_p ; typedef internal::type_to_key_function_body<T5,K>* f5_p ; typedef internal::type_to_key_function_body<T6,K>* f6_p ; typedef internal::type_to_key_function_body<T7,K>* f7_p ; typedef tbb::flow::tuple<f0_p,f1_p,f2_p,f3_p,f4_p,f5_p,f6_p,f7_p> func_initializer_type ; public : # if __TBB_PREVIEW_MESSAGE_BASED_KEY_MATCHING)",
    "insertText": "unfolded_join_node(graph &g) : base_type(g, func_initializer_type( new internal::type_to_key_function_body_leaf<T0, K, key_from_message_body<K,T0> >(key_from_message_body<K,T0>()), new internal::type_to_key_function_body_leaf<T1, K, key_from_message_body<K,T1> >(key_from_message_body<K,T1>()), new internal::type_to_key_function_body_leaf<T2, K, key_from_message_body<K,T2> >(key_from_message_body<K,T2>()), new internal::type_to_key_function_body_leaf<T3, K, key_from_message_body<K,T3> >(key_from_message_body<K,T3>()), new internal::type_to_key_function_body_leaf<T4, K, key_from_message_body<K,T4> >(key_from_message_body<K,T4>()), new internal::type_to_key_function_body_leaf<T5, K, key_from_message_body<K,T5> >(key_from_message_body<K,T5>()), new internal::type_to_key_function_body_leaf<T6, K, key_from_message_body<K,T6> >(key_from_message_body<K,T6>()), new internal::type_to_key_function_body_leaf<T7, K, key_from_message_body<K,T7> >(key_from_message_body<K,T7>()) ))"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (} # endif template<Body0,Body1,Body2,Body3,Body4,Body5,Body6,Body7>)",
    "insertText": "unfolded_join_node(graph &g, Body0 body0, Body1 body1, Body2 body2, Body3 body3, Body4 body4, Body5 body5, Body6 body6, Body7 body7) : base_type(g, func_initializer_type( new internal::type_to_key_function_body_leaf<T0, K, Body0>(body0), new internal::type_to_key_function_body_leaf<T1, K, Body1>(body1), new internal::type_to_key_function_body_leaf<T2, K, Body2>(body2), new internal::type_to_key_function_body_leaf<T3, K, Body3>(body3), new internal::type_to_key_function_body_leaf<T4, K, Body4>(body4), new internal::type_to_key_function_body_leaf<T5, K, Body5>(body5), new internal::type_to_key_function_body_leaf<T6, K, Body6>(body6), new internal::type_to_key_function_body_leaf<T7, K, Body7>(body7) ))"
  },
  {
    "label": "__TBB_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_STATIC_ASSERT(tbb::flow::tuple_size<OutputTuple>::value == 8, \"wrong number of body initializers\")"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (} } ; # endif # if __TBB_VARIADIC_MAX> = 9 template<OutputTuple,K,KHash> class unfolded_join_node<9,key_matching_port,OutputTuple,key_matching<K,KHash>> : public join_base<9,key_matching_port,OutputTuple,key_matching<K,KHash>>::type { typedef tbb::flow::tuple_element<0,OutputTuple>::type T0 ; typedef tbb::flow::tuple_element<1,OutputTuple>::type T1 ; typedef tbb::flow::tuple_element<2,OutputTuple>::type T2 ; typedef tbb::flow::tuple_element<3,OutputTuple>::type T3 ; typedef tbb::flow::tuple_element<4,OutputTuple>::type T4 ; typedef tbb::flow::tuple_element<5,OutputTuple>::type T5 ; typedef tbb::flow::tuple_element<6,OutputTuple>::type T6 ; typedef tbb::flow::tuple_element<7,OutputTuple>::type T7 ; typedef tbb::flow::tuple_element<8,OutputTuple>::type T8 ; public : typedef wrap_key_tuple_elements<9,key_matching_port,key_matching<K,KHash>,OutputTuple>::type input_ports_type ; typedef OutputTuple output_type ; private : typedef join_node_base<key_matching<K,KHash>,input_ports_type,output_type> base_type ; typedef internal::type_to_key_function_body<T0,K>* f0_p ; typedef internal::type_to_key_function_body<T1,K>* f1_p ; typedef internal::type_to_key_function_body<T2,K>* f2_p ; typedef internal::type_to_key_function_body<T3,K>* f3_p ; typedef internal::type_to_key_function_body<T4,K>* f4_p ; typedef internal::type_to_key_function_body<T5,K>* f5_p ; typedef internal::type_to_key_function_body<T6,K>* f6_p ; typedef internal::type_to_key_function_body<T7,K>* f7_p ; typedef internal::type_to_key_function_body<T8,K>* f8_p ; typedef tbb::flow::tuple<f0_p,f1_p,f2_p,f3_p,f4_p,f5_p,f6_p,f7_p,f8_p> func_initializer_type ; public : # if __TBB_PREVIEW_MESSAGE_BASED_KEY_MATCHING)",
    "insertText": "unfolded_join_node(graph &g) : base_type(g, func_initializer_type( new internal::type_to_key_function_body_leaf<T0, K, key_from_message_body<K,T0> >(key_from_message_body<K,T0>()), new internal::type_to_key_function_body_leaf<T1, K, key_from_message_body<K,T1> >(key_from_message_body<K,T1>()), new internal::type_to_key_function_body_leaf<T2, K, key_from_message_body<K,T2> >(key_from_message_body<K,T2>()), new internal::type_to_key_function_body_leaf<T3, K, key_from_message_body<K,T3> >(key_from_message_body<K,T3>()), new internal::type_to_key_function_body_leaf<T4, K, key_from_message_body<K,T4> >(key_from_message_body<K,T4>()), new internal::type_to_key_function_body_leaf<T5, K, key_from_message_body<K,T5> >(key_from_message_body<K,T5>()), new internal::type_to_key_function_body_leaf<T6, K, key_from_message_body<K,T6> >(key_from_message_body<K,T6>()), new internal::type_to_key_function_body_leaf<T7, K, key_from_message_body<K,T7> >(key_from_message_body<K,T7>()), new internal::type_to_key_function_body_leaf<T8, K, key_from_message_body<K,T8> >(key_from_message_body<K,T8>()) ))"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (} # endif template<Body0,Body1,Body2,Body3,Body4,Body5,Body6,Body7,Body8>)",
    "insertText": "unfolded_join_node(graph &g, Body0 body0, Body1 body1, Body2 body2, Body3 body3, Body4 body4, Body5 body5, Body6 body6, Body7 body7, Body8 body8) : base_type(g, func_initializer_type( new internal::type_to_key_function_body_leaf<T0, K, Body0>(body0), new internal::type_to_key_function_body_leaf<T1, K, Body1>(body1), new internal::type_to_key_function_body_leaf<T2, K, Body2>(body2), new internal::type_to_key_function_body_leaf<T3, K, Body3>(body3), new internal::type_to_key_function_body_leaf<T4, K, Body4>(body4), new internal::type_to_key_function_body_leaf<T5, K, Body5>(body5), new internal::type_to_key_function_body_leaf<T6, K, Body6>(body6), new internal::type_to_key_function_body_leaf<T7, K, Body7>(body7), new internal::type_to_key_function_body_leaf<T8, K, Body8>(body8) ))"
  },
  {
    "label": "__TBB_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_STATIC_ASSERT(tbb::flow::tuple_size<OutputTuple>::value == 9, \"wrong number of body initializers\")"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (} } ; # endif # if __TBB_VARIADIC_MAX> = 1 0 template<OutputTuple,K,KHash> class unfolded_join_node<1 0,key_matching_port,OutputTuple,key_matching<K,KHash>> : public join_base<1 0,key_matching_port,OutputTuple,key_matching<K,KHash>>::type { typedef tbb::flow::tuple_element<0,OutputTuple>::type T0 ; typedef tbb::flow::tuple_element<1,OutputTuple>::type T1 ; typedef tbb::flow::tuple_element<2,OutputTuple>::type T2 ; typedef tbb::flow::tuple_element<3,OutputTuple>::type T3 ; typedef tbb::flow::tuple_element<4,OutputTuple>::type T4 ; typedef tbb::flow::tuple_element<5,OutputTuple>::type T5 ; typedef tbb::flow::tuple_element<6,OutputTuple>::type T6 ; typedef tbb::flow::tuple_element<7,OutputTuple>::type T7 ; typedef tbb::flow::tuple_element<8,OutputTuple>::type T8 ; typedef tbb::flow::tuple_element<9,OutputTuple>::type T9 ; public : typedef wrap_key_tuple_elements<1 0,key_matching_port,key_matching<K,KHash>,OutputTuple>::type input_ports_type ; typedef OutputTuple output_type ; private : typedef join_node_base<key_matching<K,KHash>,input_ports_type,output_type> base_type ; typedef internal::type_to_key_function_body<T0,K>* f0_p ; typedef internal::type_to_key_function_body<T1,K>* f1_p ; typedef internal::type_to_key_function_body<T2,K>* f2_p ; typedef internal::type_to_key_function_body<T3,K>* f3_p ; typedef internal::type_to_key_function_body<T4,K>* f4_p ; typedef internal::type_to_key_function_body<T5,K>* f5_p ; typedef internal::type_to_key_function_body<T6,K>* f6_p ; typedef internal::type_to_key_function_body<T7,K>* f7_p ; typedef internal::type_to_key_function_body<T8,K>* f8_p ; typedef internal::type_to_key_function_body<T9,K>* f9_p ; typedef tbb::flow::tuple<f0_p,f1_p,f2_p,f3_p,f4_p,f5_p,f6_p,f7_p,f8_p,f9_p> func_initializer_type ; public : # if __TBB_PREVIEW_MESSAGE_BASED_KEY_MATCHING)",
    "insertText": "unfolded_join_node(graph &g) : base_type(g, func_initializer_type( new internal::type_to_key_function_body_leaf<T0, K, key_from_message_body<K,T0> >(key_from_message_body<K,T0>()), new internal::type_to_key_function_body_leaf<T1, K, key_from_message_body<K,T1> >(key_from_message_body<K,T1>()), new internal::type_to_key_function_body_leaf<T2, K, key_from_message_body<K,T2> >(key_from_message_body<K,T2>()), new internal::type_to_key_function_body_leaf<T3, K, key_from_message_body<K,T3> >(key_from_message_body<K,T3>()), new internal::type_to_key_function_body_leaf<T4, K, key_from_message_body<K,T4> >(key_from_message_body<K,T4>()), new internal::type_to_key_function_body_leaf<T5, K, key_from_message_body<K,T5> >(key_from_message_body<K,T5>()), new internal::type_to_key_function_body_leaf<T6, K, key_from_message_body<K,T6> >(key_from_message_body<K,T6>()), new internal::type_to_key_function_body_leaf<T7, K, key_from_message_body<K,T7> >(key_from_message_body<K,T7>()), new internal::type_to_key_function_body_leaf<T8, K, key_from_message_body<K,T8> >(key_from_message_body<K,T8>()), new internal::type_to_key_function_body_leaf<T9, K, key_from_message_body<K,T9> >(key_from_message_body<K,T9>()) ))"
  },
  {
    "label": "unfolded_join_node()",
    "kind": "Method",
    "detail": "Function (} # endif template<Body0,Body1,Body2,Body3,Body4,Body5,Body6,Body7,Body8,Body9>)",
    "insertText": "unfolded_join_node(graph &g, Body0 body0, Body1 body1, Body2 body2, Body3 body3, Body4 body4, Body5 body5, Body6 body6, Body7 body7, Body8 body8, Body9 body9) : base_type(g, func_initializer_type( new internal::type_to_key_function_body_leaf<T0, K, Body0>(body0), new internal::type_to_key_function_body_leaf<T1, K, Body1>(body1), new internal::type_to_key_function_body_leaf<T2, K, Body2>(body2), new internal::type_to_key_function_body_leaf<T3, K, Body3>(body3), new internal::type_to_key_function_body_leaf<T4, K, Body4>(body4), new internal::type_to_key_function_body_leaf<T5, K, Body5>(body5), new internal::type_to_key_function_body_leaf<T6, K, Body6>(body6), new internal::type_to_key_function_body_leaf<T7, K, Body7>(body7), new internal::type_to_key_function_body_leaf<T8, K, Body8>(body8), new internal::type_to_key_function_body_leaf<T9, K, Body9>(body9) ))"
  },
  {
    "label": "__TBB_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_STATIC_ASSERT(tbb::flow::tuple_size<OutputTuple>::value == 10, \"wrong number of body initializers\")"
  },
  {
    "label": "input_port()",
    "kind": "Method",
    "detail": "Function (} } ; # endif template<size_t N,JNT> tbb::flow::tuple_element<N,JNT::input_ports_type>::type&)",
    "insertText": "input_port(JNT &jn)"
  }
]