[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "IMATH_EXPORT_TEMPLATE_TYPE",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IMATH_EXPORT_TEMPLATE_TYPE"
  },
  {
    "label": "Sphere3()",
    "kind": "Method",
    "detail": "Function (# ifndef INCLUDED_IMATHSPHERE_H # define INCLUDED_IMATHSPHERE_H # include \" ImathExport . h \" # include \" ImathNamespace . h \" # include \" ImathBox . h \" # include \" ImathLine . h \" # include \" ImathVec . h \" IMATH_INTERNAL_NAMESPACE_HEADER_ENTER template<class T> class IMATH_EXPORT_TEMPLATE_TYPE Sphere3 { public : Vec3<T> center ; T radius ; IMATH_HOSTDEVICE)",
    "insertText": "Sphere3() : center (0, 0, 0), radius (0)"
  },
  {
    "label": "Sphere3()",
    "kind": "Method",
    "detail": "Function (} IMATH_HOSTDEVICE)",
    "insertText": "Sphere3(const Vec3<T>& c, T r) : center (c), radius (r)"
  },
  {
    "label": "circumscribe()",
    "kind": "Method",
    "detail": "Function (} IMATH_HOSTDEVICE void)",
    "insertText": "circumscribe(const Box<Vec3<T>>& box)"
  },
  {
    "label": "intersect()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "intersect(const Line3<T>& l, Vec3<T>& intersection)"
  },
  {
    "label": "intersectT()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "intersectT(const Line3<T>& l, T& t)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (center =)",
    "insertText": "T(0.5) * (box.min + box.max)"
  },
  {
    "label": "radius()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "radius(box.max - center).length()"
  },
  {
    "label": "intersectT()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool Sphere3<T)",
    "insertText": "intersectT(const Line3<T>& line, T& t)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (bool doesIntersect = true ; Vec3<T> v = line . pos - center ; T B =)",
    "insertText": "T(2.0) * (line.dir ^ v)"
  },
  {
    "label": "C()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "C(v ^ v) - (radius * radius)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T discr = B* B -)",
    "insertText": "T(4.0)"
  },
  {
    "label": "t()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "t(-B - sqroot) * T (0.5)"
  },
  {
    "label": "t()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "t(-B + sqroot) * T (0.5)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(t < 0.0)"
  },
  {
    "label": "intersect()",
    "kind": "Method",
    "detail": "Function (} return doesIntersect ; } template<class T> IMATH_CONSTEXPR14 bool Sphere3<T)",
    "insertText": "intersect(const Line3<T>& line, Vec3<T>& intersection)"
  },
  {
    "label": "t()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "t(0)"
  },
  {
    "label": "line()",
    "kind": "Method",
    "detail": "Function (intersection =)",
    "insertText": "line(t)"
  }
]