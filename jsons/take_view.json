[
  {
    "label": "take_view",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "take_view"
  },
  {
    "label": "__sentinel",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "__sentinel"
  },
  {
    "label": "_Range",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Range"
  },
  {
    "label": "_Tp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tp"
  },
  {
    "label": "_CharT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_CharT"
  },
  {
    "label": "_Traits",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Traits"
  },
  {
    "label": "_Iter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Iter"
  },
  {
    "label": "_Sent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Sent"
  },
  {
    "label": "_Np",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Np"
  },
  {
    "label": "_Bound",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Bound"
  },
  {
    "label": "__passthrough_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__passthrough_type"
  },
  {
    "label": "__fn",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__fn"
  },
  {
    "label": "_RawRange",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_RawRange"
  },
  {
    "label": "_Dist",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Dist"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___RANGES_TAKE_VIEW_H # define _LIBCPP___RANGES_TAKE_VIEW_H # include<__algorithm / min . h> # include<__algorithm / ranges_min . h> # include<__config> # include<__functional / bind_back . h> # include<__fwd / span . h> # include<__fwd / string_view . h> # include<__iterator / concepts . h> # include<__iterator / counted_iterator . h> # include<__iterator / default_sentinel . h> # include<__iterator / distance . h> # include<__iterator / iterator_traits . h> # include<__ranges / access . h> # include<__ranges / all . h> # include<__ranges / concepts . h> # include<__ranges / empty_view . h> # include<__ranges / enable_borrowed_range . h> # include<__ranges / iota_view . h> # include<__ranges / range_adaptor . h> # include<__ranges / size . h> # include<__ranges / subrange . h> # include<__ranges / view_interface . h> # include<__utility / auto_cast . h> # include<__utility / forward . h> # include<__utility / move . h> # include<concepts> # include<type_traits> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER) # pragma GCC system_header #endif _LIBCPP_PUSH_MACROS #include <__undef_macros> _LIBCPP_BEGIN_NAMESPACE_STD #if _LIBCPP_STD_VER > 17 && !defined(_LIBCPP_HAS_NO_INCOMPLETE_RANGES)"
  },
  {
    "label": "_View()",
    "kind": "Method",
    "detail": "Function (template<view _View> class take_view : public view_interface<take_view<_View>> { _LIBCPP_NO_UNIQUE_ADDRESS _View __base_ =)",
    "insertText": "_View()"
  },
  {
    "label": "take_view()",
    "kind": "Method",
    "detail": "Function (range_difference_t<_View> __count_ = 0 ; template<bool> class __sentinel ; public : _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "take_view()"
  },
  {
    "label": "take_view()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI)",
    "insertText": "take_view(_View __base, range_difference_t<_View> __count) : __base_(std::move(__base)), __count_(__count)"
  },
  {
    "label": "base()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI _View)",
    "insertText": "base()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "begin() requires (!__simple_view<_View>)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} else { using _DifferenceT = range_difference_t<_View> ; auto __size =)",
    "insertText": "size()"
  },
  {
    "label": "counted_iterator()",
    "kind": "Method",
    "detail": "Function (} } else { return)",
    "insertText": "counted_iterator(ranges::begin(__base_), __count_)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} } _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} } _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "end() requires (!__simple_view<_View>)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} else { return default_sentinel ; } } else { return __sentinel<false> {)",
    "insertText": "end(__base_)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} } _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "end()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (auto __n =)",
    "insertText": "size(__base_)"
  },
  {
    "label": "_Base()",
    "kind": "Method",
    "detail": "Function (} } ; template<view _View> template<bool _Const> class take_view<_View>::__sentinel { using _Base = __maybe_const<_Const,_View> ; template<bool _OtherConst> using _Iter = counted_iterator<iterator_t<__maybe_const<_OtherConst,_View>>> ; _LIBCPP_NO_UNIQUE_ADDRESS sentinel_t<_Base> __end_ = sentinel_t<)",
    "insertText": "_Base()"
  },
  {
    "label": "__sentinel()",
    "kind": "Method",
    "detail": "Function (template<bool> class take_view<_View>::__sentinel ; public : _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__sentinel()"
  },
  {
    "label": "__sentinel()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__sentinel(sentinel_t<_Base> __end) : __end_(std::move(__end))"
  },
  {
    "label": "__sentinel()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__sentinel(__sentinel<!_Const> __s) requires _Const && convertible_to<sentinel_t<_View>, sentinel_t<_Base>> : __end_(std::move(__s.__end_))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<bool _OtherConst = ! _Const> requires sentinel_for<sentinel_t<_Base>,iterator_t<__maybe_const<_OtherConst,_View>>> _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "operator(const _Iter<_Const>& __lhs, const __sentinel& __rhs)"
  },
  {
    "label": "take_view()",
    "kind": "Method",
    "detail": "Function (take_view<views::all_t<_Range>>)",
    "insertText": "take_view(_Range&&, range_difference_t<_Range>)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class _Tp> bool enable_borrowed_range<take_view<_Tp>> = enable_borrowed_range<_Tp> ; namespace views { namespace __take { template<class _Tp> bool __is_empty_view = false ; template<class _Tp> bool __is_empty_view<empty_view<_Tp>> = true ; template<class _Tp> bool __is_passthrough_specialization = false ; template<class _Tp,size_t _Extent> bool __is_passthrough_specialization<span<_Tp,_Extent>> = true ; template<class _CharT,class _Traits> bool __is_passthrough_specialization<basic_string_view<_CharT,_Traits>> = true ; template<class _Iter,class _Sent,subrange_kind _Kind> bool __is_passthrough_specialization<subrange<_Iter,_Sent,_Kind>> = true ; template<class _Tp> bool __is_iota_specialization = false ; template<class _Np,class _Bound> bool __is_iota_specialization<iota_view<_Np,_Bound>> = true ; template<class _Tp> struct __passthrough_type ; template<class _Tp,size_t _Extent> struct __passthrough_type<span<_Tp,_Extent>> { using type = span<_Tp> ; } ; template<class _CharT,class _Traits> struct __passthrough_type<basic_string_view<_CharT,_Traits>> { using type = basic_string_view<_CharT,_Traits> ; } ; template<class _Iter,class _Sent,subrange_kind _Kind> struct __passthrough_type<subrange<_Iter,_Sent,_Kind>> { using type = subrange<_Iter> ; } ; template<class _Tp> using __passthrough_type_t = __passthrough_type<_Tp>::type ; struct __fn { template<class _Range,convertible_to<range_difference_t<_Range>> _Np> requires __is_empty_view<remove_cvref_t<_Range>> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Range&& __range, _Np&&) const noexcept(noexcept(_LIBCPP_AUTO_CAST(std::forward<_Range>(__range)))) -> decltype( _LIBCPP_AUTO_CAST(std::forward<_Range>(__range)))"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (} template<class _Range,convertible_to<range_difference_t<_Range>> _Np,class _RawRange = remove_cvref_t<_Range>,class _Dist = range_difference_t<_Range>>)",
    "insertText": "requires(!__is_empty_view<_RawRange> && random_access_range<_RawRange> && sized_range<_RawRange> && __is_passthrough_specialization<_RawRange>) [[nodiscard]] _LIBCPP_HIDE_FROM_ABI constexpr auto operator()(_Range&& __rng, _Np&& __n) const noexcept(noexcept(__passthrough_type_t<_RawRange>( ranges::begin(__rng), ranges::begin(__rng) + std::min<_Dist>(ranges::distance(__rng), std::forward<_Np>(__n)) ))) -> decltype( __passthrough_type_t<_RawRange>( ranges::begin(__rng), ranges::begin(__rng) + std::min<_Dist>(ranges::distance(__rng), std::forward<_Np>(__n)) ))"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (} template<class _Range,convertible_to<range_difference_t<_Range>> _Np,class _RawRange = remove_cvref_t<_Range>,class _Dist = range_difference_t<_Range>>)",
    "insertText": "requires(!__is_empty_view<_RawRange> && random_access_range<_RawRange> && sized_range<_RawRange> && __is_iota_specialization<_RawRange>) [[nodiscard]] _LIBCPP_HIDE_FROM_ABI constexpr auto operator()(_Range&& __rng, _Np&& __n) const noexcept(noexcept(ranges::iota_view( *ranges::begin(__rng), *ranges::begin(__rng) + std::min<_Dist>(ranges::distance(__rng), std::forward<_Np>(__n)) ))) -> decltype( ranges::iota_view( *ranges::begin(__rng), *ranges::begin(__rng) + std::min<_Dist>(ranges::distance(__rng), std::forward<_Np>(__n)) ))"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (} template<class _Range,convertible_to<range_difference_t<_Range>> _Np,class _RawRange = remove_cvref_t<_Range>>)",
    "insertText": "requires(!(__is_empty_view<_RawRange> || (__is_iota_specialization<_RawRange> && sized_range<_RawRange> && random_access_range<_RawRange>) || (__is_passthrough_specialization<_RawRange> && sized_range<_RawRange> && random_access_range<_RawRange>) )) [[nodiscard]] _LIBCPP_HIDE_FROM_ABI constexpr auto operator()(_Range&& __range, _Np&& __n) const noexcept(noexcept(take_view(std::forward<_Range>(__range), std::forward<_Np>(__n)))) -> decltype( take_view(std::forward<_Range>(__range), std::forward<_Np>(__n)))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _Np> requires constructible_from<decay_t<_Np>,_Np> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Np&& __n) const noexcept(is_nothrow_constructible_v<decay_t<_Np>, _Np>)"
  }
]