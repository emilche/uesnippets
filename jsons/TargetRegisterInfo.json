[
  {
    "label": "BitVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BitVector"
  },
  {
    "label": "MachineFunction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineFunction"
  },
  {
    "label": "RegScavenger",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RegScavenger"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "SmallVectorImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SmallVectorImpl"
  },
  {
    "label": "VirtRegMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VirtRegMap"
  },
  {
    "label": "raw_ostream",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "raw_ostream"
  },
  {
    "label": "TargetRegisterClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetRegisterClass"
  },
  {
    "label": "TargetRegisterInfoDesc",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TargetRegisterInfoDesc"
  },
  {
    "label": "RegClassWeight",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RegClassWeight"
  },
  {
    "label": "TargetRegisterInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetRegisterInfo"
  },
  {
    "label": "SuperRegClassIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SuperRegClassIterator"
  },
  {
    "label": "VirtReg2IndexFunctor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VirtReg2IndexFunctor"
  },
  {
    "label": "PrintReg",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PrintReg"
  },
  {
    "label": "PrintRegUnit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PrintRegUnit"
  },
  {
    "label": "PrintVRegOrUnit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PrintVRegOrUnit"
  },
  {
    "label": "MCPhysReg()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_TARGET_TARGETREGISTERINFO_H # define LLVM_TARGET_TARGETREGISTERINFO_H # include \" llvm / ADT / ArrayRef . h \" # include \" llvm / CodeGen / MachineBasicBlock . h \" # include \" llvm / CodeGen / MachineValueType . h \" # include \" llvm / IR / CallingConv . h \" # include \" llvm / MC / MCRegisterInfo . h \" # include<cassert> # include<functional> namespace llvm { class BitVector ; class MachineFunction ; class RegScavenger ; template<class T> class SmallVectorImpl ; class VirtRegMap ; class raw_ostream ; class TargetRegisterClass { public : typedef const MCPhysReg* iterator ; typedef const MCPhysReg* const_iterator ; typedef const MVT::SimpleValueType* vt_iterator ; typedef const TargetRegisterClass* const* sc_iterator ; const MCRegisterClass* MC ; const vt_iterator VTs ; const uint32_t* SubClassMask ; const uint16_t* SuperRegIndices ; const unsigned LaneMask ; const uint8_t AllocationPriority ; const bool HasDisjunctSubRegs ; const sc_iterator SuperClasses ; ArrayRef<)",
    "insertText": "MCPhysReg(*OrderFunc)(const MachineFunction&)"
  },
  {
    "label": "getID()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getID()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "getNumRegs()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getNumRegs()"
  },
  {
    "label": "getRegister()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getRegister(unsigned i)"
  },
  {
    "label": "contains()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "contains(unsigned Reg)"
  },
  {
    "label": "contains()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "contains(unsigned Reg1, unsigned Reg2)"
  },
  {
    "label": "getSize()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getSize()"
  },
  {
    "label": "getAlignment()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getAlignment()"
  },
  {
    "label": "getCopyCost()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "getCopyCost()"
  },
  {
    "label": "isAllocatable()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isAllocatable()"
  },
  {
    "label": "hasType()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasType(MVT vt)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (vt_iterator I = VTs ;)",
    "insertText": "while(*I != MVT::Other)"
  },
  {
    "label": "hasSubClassEq()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasSubClassEq(const TargetRegisterClass *RC)"
  },
  {
    "label": "hasSuperClass()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasSuperClass(const TargetRegisterClass *RC)"
  },
  {
    "label": "hasSuperClassEq()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasSuperClassEq(const TargetRegisterClass *RC)"
  },
  {
    "label": "getSubClassMask()",
    "kind": "Method",
    "detail": "Function (} const uint32_t*)",
    "insertText": "getSubClassMask()"
  },
  {
    "label": "getLaneMask()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getLaneMask()"
  },
  {
    "label": "TargetRegisterInfo()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "TargetRegisterInfo()"
  },
  {
    "label": "isStackSlot()",
    "kind": "Method",
    "detail": "Function (public : bool)",
    "insertText": "isStackSlot(unsigned Reg)"
  },
  {
    "label": "stackSlot2Index()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "stackSlot2Index(unsigned Reg)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(isStackSlot(Reg) && \"Not a stack slot\")"
  },
  {
    "label": "index2StackSlot()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "index2StackSlot(int FI)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(FI >= 0 && \"Cannot hold a negative frame index.\")"
  },
  {
    "label": "isPhysicalRegister()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isPhysicalRegister(unsigned Reg)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!isStackSlot(Reg) && \"Not a register! Check isStackSlot() first.\")"
  },
  {
    "label": "isVirtualRegister()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isVirtualRegister(unsigned Reg)"
  },
  {
    "label": "virtReg2Index()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "virtReg2Index(unsigned Reg)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(isVirtualRegister(Reg) && \"Not a virtual register\")"
  },
  {
    "label": "index2VirtReg()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "index2VirtReg(unsigned Index)"
  },
  {
    "label": "getMinimalPhysRegClass()",
    "kind": "Method",
    "detail": "Function (} const TargetRegisterClass*)",
    "insertText": "getMinimalPhysRegClass(unsigned Reg, MVT VT = MVT::Other)"
  },
  {
    "label": "getAllocatableClass()",
    "kind": "Method",
    "detail": "Function (const TargetRegisterClass*)",
    "insertText": "getAllocatableClass(const TargetRegisterClass *RC)"
  },
  {
    "label": "getAllocatableSet()",
    "kind": "Method",
    "detail": "Function (BitVector)",
    "insertText": "getAllocatableSet(const MachineFunction &MF, const TargetRegisterClass *RC = nullptr)"
  },
  {
    "label": "getCostPerUse()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getCostPerUse(unsigned RegNo)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(SubIdx && SubIdx < getNumSubRegIndices() && \"This is not a subregister index\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(SubIdx < getNumSubRegIndices() && \"This is not a subregister index\")"
  },
  {
    "label": "RUA()",
    "kind": "Method",
    "detail": "Function (MCRegUnitIterator)",
    "insertText": "RUA(regA, this)"
  },
  {
    "label": "RUB()",
    "kind": "Method",
    "detail": "Function (MCRegUnitIterator)",
    "insertText": "RUB(regB, this)"
  },
  {
    "label": "getCallPreservedMask()",
    "kind": "Method",
    "detail": "Function (const uint32_t*)",
    "insertText": "getCallPreservedMask(const MachineFunction &MF, CallingConv::ID)"
  },
  {
    "label": "getRegMaskNames()",
    "kind": "Method",
    "detail": "Function (ArrayRef<const char*>)",
    "insertText": "getRegMaskNames()"
  },
  {
    "label": "getReservedRegs()",
    "kind": "Method",
    "detail": "Function (BitVector)",
    "insertText": "getReservedRegs(const MachineFunction &MF)"
  },
  {
    "label": "adjustStackMapLiveOutMask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "adjustStackMapLiveOutMask(uint32_t *Mask)"
  },
  {
    "label": "getMatchingSuperReg()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getMatchingSuperReg(unsigned Reg, unsigned SubIdx, const TargetRegisterClass *RC)"
  },
  {
    "label": "getMatchingSuperRegClass()",
    "kind": "Method",
    "detail": "Function (} const TargetRegisterClass*)",
    "insertText": "getMatchingSuperRegClass(const TargetRegisterClass *A, const TargetRegisterClass *B, unsigned Idx)"
  },
  {
    "label": "getSubClassWithSubReg()",
    "kind": "Method",
    "detail": "Function (const TargetRegisterClass*)",
    "insertText": "getSubClassWithSubReg(const TargetRegisterClass *RC, unsigned Idx)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Idx == 0 && \"Target has no sub-registers\")"
  },
  {
    "label": "composeSubRegIndexLaneMask()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "composeSubRegIndexLaneMask(unsigned IdxA, unsigned LaneMask)"
  },
  {
    "label": "dumpReg()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "dumpReg(unsigned Reg, unsigned SubRegIndex = 0, const TargetRegisterInfo* TRI = nullptr)"
  },
  {
    "label": "composeSubRegIndicesImpl()",
    "kind": "Method",
    "detail": "Function (protected : unsigned)",
    "insertText": "composeSubRegIndicesImpl(unsigned, unsigned)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Target has no sub-registers\")"
  },
  {
    "label": "composeSubRegIndexLaneMaskImpl()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "composeSubRegIndexLaneMaskImpl(unsigned, unsigned)"
  },
  {
    "label": "getCommonSuperRegClass()",
    "kind": "Method",
    "detail": "Function (} public : const TargetRegisterClass*)",
    "insertText": "getCommonSuperRegClass(const TargetRegisterClass *RCA, unsigned SubA, const TargetRegisterClass *RCB, unsigned SubB, unsigned &PreA, unsigned &PreB)"
  },
  {
    "label": "regclass_begin()",
    "kind": "Method",
    "detail": "Function (regclass_iterator)",
    "insertText": "regclass_begin()"
  },
  {
    "label": "getRegClass()",
    "kind": "Method",
    "detail": "Function (} const TargetRegisterClass*)",
    "insertText": "getRegClass(unsigned i)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i < getNumRegClasses() && \"Register Class ID out of range\")"
  },
  {
    "label": "getCommonSubClass()",
    "kind": "Method",
    "detail": "Function (} const TargetRegisterClass*)",
    "insertText": "getCommonSubClass(const TargetRegisterClass *A, const TargetRegisterClass *B)"
  },
  {
    "label": "getPointerRegClass()",
    "kind": "Method",
    "detail": "Function (const TargetRegisterClass*)",
    "insertText": "getPointerRegClass(const MachineFunction &MF, unsigned Kind=0)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Target didn't implement getPointerRegClass!\")"
  },
  {
    "label": "getCrossCopyRegClass()",
    "kind": "Method",
    "detail": "Function (} const TargetRegisterClass*)",
    "insertText": "getCrossCopyRegClass(const TargetRegisterClass *RC)"
  },
  {
    "label": "getRegUnitWeight()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getRegUnitWeight(unsigned RegUnit)"
  },
  {
    "label": "getNumRegPressureSets()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getNumRegPressureSets()"
  },
  {
    "label": "getRegPressureSetName()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "getRegPressureSetName(unsigned Idx)"
  },
  {
    "label": "getRegPressureSetLimit()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getRegPressureSetLimit(const MachineFunction &MF, unsigned Idx)"
  },
  {
    "label": "getRegClassPressureSets()",
    "kind": "Method",
    "detail": "Function (const int*)",
    "insertText": "getRegClassPressureSets(const TargetRegisterClass *RC)"
  },
  {
    "label": "getRegUnitPressureSets()",
    "kind": "Method",
    "detail": "Function (const int*)",
    "insertText": "getRegUnitPressureSets(unsigned RegUnit)"
  },
  {
    "label": "getRegAllocationHints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getRegAllocationHints(unsigned VirtReg, ArrayRef<MCPhysReg> Order, SmallVectorImpl<MCPhysReg> &Hints, const MachineFunction &MF, const VirtRegMap *VRM = nullptr)"
  },
  {
    "label": "updateRegAllocHint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "updateRegAllocHint(unsigned Reg, unsigned NewReg, MachineFunction &MF)"
  },
  {
    "label": "reverseLocalAssignment()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "reverseLocalAssignment()"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"materializeFrameBaseRegister does not exist on this \" \"target\")"
  },
  {
    "label": "resolveFrameIndex()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resolveFrameIndex(MachineInstr &MI, unsigned BaseReg, int64_t Offset)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"resolveFrameIndex does not exist on this target\")"
  },
  {
    "label": "isFrameOffsetLegal()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isFrameOffsetLegal(const MachineInstr *MI, unsigned BaseReg, int64_t Offset)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"isFrameOffsetLegal does not exist on this target\")"
  },
  {
    "label": "saveScavengerRegister()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "saveScavengerRegister(MachineBasicBlock &MBB, MachineBasicBlock::iterator I, MachineBasicBlock::iterator &UseMI, const TargetRegisterClass *RC, unsigned Reg)"
  },
  {
    "label": "shouldCoalesce()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "shouldCoalesce(MachineInstr *MI, const TargetRegisterClass *SrcRC, unsigned SubReg, const TargetRegisterClass *DstRC, unsigned DstSubReg, const TargetRegisterClass *NewRC)"
  },
  {
    "label": "SuperRegClassIterator()",
    "kind": "Method",
    "detail": "Function (} ; class SuperRegClassIterator { const unsigned RCMaskWords ; unsigned SubReg ; const uint16_t* Idx ; const uint32_t* Mask ; public :)",
    "insertText": "SuperRegClassIterator(const TargetRegisterClass *RC, const TargetRegisterInfo *TRI, bool IncludeSelf = false) : RCMaskWords((TRI->getNumRegClasses() + 31) / 32), SubReg(0), Idx(RC->getSuperRegIndices()), Mask(RC->getSubClassMask())"
  },
  {
    "label": "isValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValid()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(isValid() && \"Cannot move iterator past end.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Mask + = RCMaskWords ; SubReg =* Idx + + ;)",
    "insertText": "if(!SubReg)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; struct VirtReg2IndexFunctor { unsigned)",
    "insertText": "operator()(unsigned Reg)"
  },
  {
    "label": "PrintReg()",
    "kind": "Method",
    "detail": "Function (} } ; class PrintReg { const TargetRegisterInfo* TRI ; unsigned Reg ; unsigned SubIdx ; public :)",
    "insertText": "PrintReg(unsigned reg, const TargetRegisterInfo *tri = nullptr, unsigned subidx = 0) : TRI(tri), Reg(reg), SubIdx(subidx)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "print(raw_ostream&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; raw_ostream&)",
    "insertText": "operator(raw_ostream &OS, const PrintReg &PR)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (PR .)",
    "insertText": "print(OS)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; raw_ostream&)",
    "insertText": "operator(raw_ostream &OS, const PrintRegUnit &PR)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; raw_ostream&)",
    "insertText": "operator(raw_ostream &OS, const PrintVRegOrUnit &PR)"
  }
]