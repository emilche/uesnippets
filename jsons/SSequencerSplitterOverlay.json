[
  {
    "label": "SSequencerSplitterOverlay",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SSequencerSplitterOverlay"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Misc / Attribute . h \" # include \" Layout / Visibility . h \" # include \" Input / CursorReply . h \" # include \" Input / Reply . h \" # include \" Widgets / DeclarativeSyntaxSupport . h \" # include \" Layout / Margin . h \" # include \" Widgets / SOverlay . h \" # include \" Layout / ArrangedChildren . h \" # include \" Widgets / Layout / SBox . h \" # include \" Widgets / Layout / SSplitter . h \" class SSequencerSplitterOverlay : public SOverlay { public : typedef SSplitter::FArguments FArguments ; void)",
    "insertText": "Construct(const FArguments& InArgs)"
  },
  {
    "label": "SetVisibility()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetVisibility(EVisibility::SelfHitTestInvisible)"
  },
  {
    "label": "SArgumentNew()",
    "kind": "Method",
    "detail": "Function (Splitter =)",
    "insertText": "SArgumentNew(InArgs, SSplitter)"
  },
  {
    "label": "SetVisibility()",
    "kind": "Method",
    "detail": "Function (Splitter ->)",
    "insertText": "SetVisibility(EVisibility::HitTestInvisible)"
  },
  {
    "label": "AddSlot()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddSlot() [ Splitter.ToSharedRef()"
  },
  {
    "label": "AddSlot()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddSlot() .Padding(TAttribute<FMargin>::Create(TAttribute<FMargin>::FGetter::CreateSP(this, &SSequencerSplitterOverlay::GetSplitterHandlePadding, Index))) [ SNew(SBox) .Visibility(EVisibility::Visible)"
  },
  {
    "label": "OnArrangeChildren()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "OnArrangeChildren(const FGeometry& AllottedGeometry, FArrangedChildren& ArrangedChildren)"
  },
  {
    "label": "SplitterChildren()",
    "kind": "Method",
    "detail": "Function (FArrangedChildren)",
    "insertText": "SplitterChildren(ArrangedChildren.GetFilter())"
  },
  {
    "label": "ArrangeChildren()",
    "kind": "Method",
    "detail": "Function (Splitter ->)",
    "insertText": "ArrangeChildren(AllottedGeometry, SplitterChildren)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (SlotPadding .)",
    "insertText": "Reset()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const auto& ThisGeometry = SplitterChildren [ Index ] . Geometry ; const auto& NextGeometry = SplitterChildren [ Index + 1 ] . Geometry ;)",
    "insertText": "if(Splitter->GetOrientation() == EOrientation::Orient_Horizontal)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (SlotPadding .)",
    "insertText": "Add(FMargin( ThisGeometry.Position.X + ThisGeometry.GetLocalSize().X, 0, AllottedGeometry.Size.X - NextGeometry.Position.X, 0))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} else { SlotPadding .)",
    "insertText": "Add(FMargin( 0, ThisGeometry.Position.Y + ThisGeometry.GetLocalSize().Y, 0, AllottedGeometry.Size.Y - NextGeometry.Position.Y))"
  },
  {
    "label": "OnArrangeChildren()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "OnArrangeChildren(AllottedGeometry, ArrangedChildren)"
  },
  {
    "label": "GetSplitterHandlePadding()",
    "kind": "Method",
    "detail": "Function (} FMargin)",
    "insertText": "GetSplitterHandlePadding(int32 Index)"
  },
  {
    "label": "OnMouseButtonDown()",
    "kind": "Method",
    "detail": "Function (} FReply)",
    "insertText": "OnMouseButtonDown(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent)"
  },
  {
    "label": "OnMouseButtonDown()",
    "kind": "Method",
    "detail": "Function (FReply Reply = Splitter ->)",
    "insertText": "OnMouseButtonDown(MyGeometry, MouseEvent)"
  },
  {
    "label": "CaptureMouse()",
    "kind": "Method",
    "detail": "Function (Reply .)",
    "insertText": "CaptureMouse(SharedThis(this))"
  },
  {
    "label": "SetVisibility()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetVisibility(EVisibility::Visible)"
  },
  {
    "label": "OnMouseCaptureLost()",
    "kind": "Method",
    "detail": "Function (} return Reply ; } void)",
    "insertText": "OnMouseCaptureLost(const FCaptureLostEvent& CaptureLostEvent)"
  },
  {
    "label": "OnMouseCaptureLost()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnMouseCaptureLost(CaptureLostEvent)"
  },
  {
    "label": "OnMouseButtonUp()",
    "kind": "Method",
    "detail": "Function (} FReply)",
    "insertText": "OnMouseButtonUp(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent)"
  },
  {
    "label": "OnMouseButtonUp()",
    "kind": "Method",
    "detail": "Function (FReply Reply = Splitter ->)",
    "insertText": "OnMouseButtonUp(MyGeometry, MouseEvent)"
  },
  {
    "label": "OnMouseMove()",
    "kind": "Method",
    "detail": "Function (} return Reply ; } FReply)",
    "insertText": "OnMouseMove(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent)"
  },
  {
    "label": "OnMouseLeave()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnMouseLeave(const FPointerEvent& MouseEvent)"
  }
]