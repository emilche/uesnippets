[
  {
    "label": "TInstrusiveListIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TInstrusiveListIterator"
  },
  {
    "label": "TInstrusiveList",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TInstrusiveList"
  },
  {
    "label": "TInstrusiveListIterator()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Misc / AssertionMacros . h \" namespace UE::Private { template<TypeTraits> class TInstrusiveListIterator { public : using ElementType = TypeTraits::ElementType ;)",
    "insertText": "TInstrusiveListIterator(ElementType* InElement) : Element(InElement)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ElementType&)",
    "insertText": "operator()"
  },
  {
    "label": "GetNext()",
    "kind": "Method",
    "detail": "Function (Element =)",
    "insertText": "GetNext(Element)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TInstrusiveListIterator& Other)"
  },
  {
    "label": "TInstrusiveList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TInstrusiveList(const TInstrusiveList&)"
  },
  {
    "label": "TInstrusiveList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TInstrusiveList(TInstrusiveList&& Other) : Head(Other.Head) , Tail(Other.Tail)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Other . Head = Other . Tail = nullptr ; } TInstrusiveList&)",
    "insertText": "operator(const TInstrusiveList&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TInstrusiveList&)",
    "insertText": "operator(TInstrusiveList&& Other)"
  },
  {
    "label": "AddTail()",
    "kind": "Method",
    "detail": "Function (Head = Other . Head ; Tail = Other . Tail ; Other . Head = Other . Tail = nullptr ; return* this ; } void)",
    "insertText": "AddTail(ElementType* Element)"
  },
  {
    "label": "SetNext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetNext(Tail, Element)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (Tail = Element ; } else {)",
    "insertText": "check(Head == nullptr)"
  },
  {
    "label": "AddTail()",
    "kind": "Method",
    "detail": "Function (Head = Tail = Element ; } } void)",
    "insertText": "AddTail(ElementType* First, ElementType* Last)"
  },
  {
    "label": "SetNext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetNext(Tail, First)"
  },
  {
    "label": "AddTail()",
    "kind": "Method",
    "detail": "Function (Head = First ; Tail = Last ; } } void)",
    "insertText": "AddTail(TInstrusiveList&& Other)"
  },
  {
    "label": "AddTail()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTail(Other.Head, Other.Tail)"
  },
  {
    "label": "PopHead()",
    "kind": "Method",
    "detail": "Function (Other . Head = Other . Tail = nullptr ; } } ElementType*)",
    "insertText": "PopHead()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ElementType* Element = Head ;)",
    "insertText": "if(Element != nullptr)"
  },
  {
    "label": "SetNext()",
    "kind": "Method",
    "detail": "Function (Tail = nullptr ; })",
    "insertText": "SetNext(Element, nullptr)"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} return Element ; } bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} FConstIterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} FIterator)",
    "insertText": "end()"
  }
]