[
  {
    "label": "TIsSoftObjectPointerType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsSoftObjectPointerType"
  },
  {
    "label": "FSoftObjectPtr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSoftObjectPtr"
  },
  {
    "label": "TIsPODType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsPODType"
  },
  {
    "label": "TIsWeakPointerType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsWeakPointerType"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TSoftObjectPtr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TSoftObjectPtr"
  },
  {
    "label": "U",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "U"
  },
  {
    "label": "TCallTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TCallTraits"
  },
  {
    "label": "TClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TClass"
  },
  {
    "label": "TSoftClassPtr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSoftClassPtr"
  },
  {
    "label": "TClassA",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TClassA"
  },
  {
    "label": "FSoftObjectPtrFastLess",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSoftObjectPtrFastLess"
  },
  {
    "label": "FSoftObjectPtrLexicalLess",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSoftObjectPtrLexicalLess"
  },
  {
    "label": "UE_SOFTOBJECTPTR_CONVERSION_DEPRECATED()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" UObject / Object . h \" # include \" Templates / Casts . h \" # include \" UObject / PersistentObjectPtr . h \" # include \" UObject / SoftObjectPath . h \" # include \" Templates / Models . h \" # include \" Concepts / EqualityComparable . h \" # include<type_traits> # ifndef UE_DEPRECATE_SOFTOBJECTPTR_CONVERSIONS # define UE_DEPRECATE_SOFTOBJECTPTR_CONVERSIONS 1 # endif # if UE_DEPRECATE_SOFTOBJECTPTR_CONVERSIONS # define)",
    "insertText": "UE_SOFTOBJECTPTR_CONVERSION_DEPRECATED(Version, Message) UE_DEPRECATED(Version, Message) #else #define UE_SOFTOBJECTPTR_CONVERSION_DEPRECATED(Version, Message)"
  },
  {
    "label": "FSoftObjectPtr()",
    "kind": "Method",
    "detail": "Function (enum { Value = false } ; } ; struct FSoftObjectPtr : public TPersistentObjectPtr<FSoftObjectPath> { public :)",
    "insertText": "FSoftObjectPtr()"
  },
  {
    "label": "FSoftObjectPtr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FSoftObjectPtr(const FSoftObjectPath& ObjectPath) : TPersistentObjectPtr<FSoftObjectPath>(ObjectPath)"
  },
  {
    "label": "FSoftObjectPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FSoftObjectPtr(const UObject* Object)"
  },
  {
    "label": "FSoftObjectPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FSoftObjectPtr(TObjectPtr<UObject> Object)"
  },
  {
    "label": "LoadSynchronous()",
    "kind": "Method",
    "detail": "Function (} UObject*)",
    "insertText": "LoadSynchronous()"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (UObject* Asset =)",
    "insertText": "Get()"
  },
  {
    "label": "ToSoftObjectPath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ToSoftObjectPath().TryLoad()"
  },
  {
    "label": "ToSoftObjectPath()",
    "kind": "Method",
    "detail": "Function (} return Asset ; } const FSoftObjectPath&)",
    "insertText": "ToSoftObjectPath()"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "ToString()"
  },
  {
    "label": "GetLongPackageName()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "GetLongPackageName()"
  },
  {
    "label": "GetLongPackageFName()",
    "kind": "Method",
    "detail": "Function (} FName)",
    "insertText": "GetLongPackageFName()"
  },
  {
    "label": "GetAssetName()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "GetAssetName()"
  },
  {
    "label": "GetUniqueID()",
    "kind": "Method",
    "detail": "Function (TWeakObjectPtr<UObject> Result =)",
    "insertText": "GetUniqueID().ResolveObject()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif using TPersistentObjectPtr<FSoftObjectPath>::operator = ; FSoftObjectPtr&)",
    "insertText": "operator(TObjectPtr<UObject> Ptr)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (template<class U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U*, T*>) > FORCEINLINE TSoftObjectPtr(const TSoftObjectPtr<U>& Other) : SoftObjectPtr(Other.SoftObjectPtr)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<class U)",
    "insertText": "UE_REQUIRES(!std::is_convertible_v<U*, T*>) > UE_SOFTOBJECTPTR_CONVERSION_DEPRECATED(5.5, \"Constructing TSoftObjectPtr from an incompatible pointer type has been deprecated.\") FORCEINLINE TSoftObjectPtr(const TSoftObjectPtr<U>& Other) : SoftObjectPtr(Other.SoftObjectPtr)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<class U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U*, T*>) > FORCEINLINE TSoftObjectPtr(TSoftObjectPtr<U>&& Other) : SoftObjectPtr(MoveTemp(Other.SoftObjectPtr))"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<class U)",
    "insertText": "UE_REQUIRES(!std::is_convertible_v<U*, T*>) > UE_SOFTOBJECTPTR_CONVERSION_DEPRECATED(5.5, \"Constructing TSoftObjectPtr from an incompatible pointer type has been deprecated.\") FORCEINLINE TSoftObjectPtr(TSoftObjectPtr<U>&& Other) : SoftObjectPtr(MoveTemp(Other.SoftObjectPtr))"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U*, T*>) > FORCEINLINE TSoftObjectPtr(U* Object) : SoftObjectPtr(Object)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<U)",
    "insertText": "UE_REQUIRES(!std::is_convertible_v<U*, T*>) > UE_SOFTOBJECTPTR_CONVERSION_DEPRECATED(5.5, \"Constructing TSoftObjectPtr from an incompatible pointer type has been deprecated.\") FORCEINLINE TSoftObjectPtr(U* Object) : SoftObjectPtr(Object)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U*, T*>) > FORCEINLINE TSoftObjectPtr(const TObjectPtr<U> Object) : SoftObjectPtr(Object.Get())"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<U)",
    "insertText": "UE_REQUIRES(!std::is_convertible_v<U*, T*>) > UE_SOFTOBJECTPTR_CONVERSION_DEPRECATED(5.5, \"Constructing TSoftObjectPtr from an incompatible pointer type has been deprecated.\") FORCEINLINE TSoftObjectPtr(const TObjectPtr<U> Object) : SoftObjectPtr(Object.Get())"
  },
  {
    "label": "TSoftObjectPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TSoftObjectPtr(TYPE_OF_NULLPTR) : SoftObjectPtr(nullptr)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<SoftObjectPathType)",
    "insertText": "UE_REQUIRES(std::is_same_v<SoftObjectPathType, FSoftObjectPath>) > explicit FORCEINLINE TSoftObjectPtr(SoftObjectPathType ObjectPath) : SoftObjectPtr(MoveTemp(ObjectPath))"
  },
  {
    "label": "UE_SOFTOBJECTPTR_CONVERSION_DEPRECATED()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UE_SOFTOBJECTPTR_CONVERSION_DEPRECATED(5.5, \"Constructing TSoftObjectPtr from an FString has been deprecated - instead, explicitly construct a FSoftObjectPath.\") explicit TSoftObjectPtr(const FString& Path) : SoftObjectPtr(FSoftObjectPath(Path))"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset()"
  },
  {
    "label": "ResetWeakPtr()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ResetWeakPtr()"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U*, T*>) > FORCEINLINE TSoftObjectPtr& operator=(U* Object)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (SoftObjectPtr = Object ; return* this ; } template<U)",
    "insertText": "UE_REQUIRES(!std::is_convertible_v<U*, T*>) > UE_SOFTOBJECTPTR_CONVERSION_DEPRECATED(5.5, \"Assigning TSoftObjectPtr from an incompatible pointer type has been deprecated.\") FORCEINLINE TSoftObjectPtr& operator=(U* Object)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (SoftObjectPtr = Object ; return* this ; } template<U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U*, T*>) > FORCEINLINE TSoftObjectPtr& operator=(const TObjectPtr<U> Object)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (SoftObjectPtr = nullptr ; return* this ; } TSoftObjectPtr&)",
    "insertText": "operator(FSoftObjectPath ObjectPath)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (SoftObjectPtr =)",
    "insertText": "MoveTemp(ObjectPath)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (SoftObjectPtr = Other ; return* this ; } template<class U)",
    "insertText": "UE_REQUIRES(!std::is_convertible_v<U*, T*>) > UE_SOFTOBJECTPTR_CONVERSION_DEPRECATED(5.5, \"Assigning TSoftObjectPtr from an incompatible pointer type has been deprecated.\") FORCEINLINE TSoftObjectPtr& operator=(const TWeakObjectPtr<U>& Other)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (SoftObjectPtr = Other ; return* this ; } template<class U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U*, T*>) > FORCEINLINE TSoftObjectPtr& operator=(TSoftObjectPtr<U> Other)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (SoftObjectPtr =)",
    "insertText": "MoveTemp(Other.SoftObjectPtr)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<U)",
    "insertText": "UE_REQUIRES(!TModels_V<CEqualityComparableWith, T*, U*>) > UE_SOFTOBJECTPTR_CONVERSION_DEPRECATED(5.5, \"Comparing TSoftObjectPtrs of incompatible pointer types has been deprecated.\") FORCEINLINE bool operator==(U* Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(TYPE_OF_NULLPTR)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} T*)",
    "insertText": "operator()"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "IsPending()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsPending()"
  },
  {
    "label": "IsNull()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsNull()"
  },
  {
    "label": "GetUniqueID()",
    "kind": "Method",
    "detail": "Function (} const FSoftObjectPath&)",
    "insertText": "GetUniqueID()"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "GetPtrTypeHash()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetPtrTypeHash()"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Serialize(FArchive& Ar)"
  },
  {
    "label": "TSoftObjectPtr()",
    "kind": "Method",
    "detail": "Function (TSoftObjectPtr<T>)",
    "insertText": "TSoftObjectPtr(T*)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (# if ! PLATFORM_COMPILER_HAS_GENERATED_COMPARISON_OPERATORS template<LhsType,RhsType)",
    "insertText": "UE_REQUIRES(TModels_V<CEqualityComparableWith, LhsType*, RhsType*>) > FORCEINLINE bool operator==(LhsType* Lhs, const TSoftObjectPtr<RhsType>& Rhs)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<LhsType,RhsType)",
    "insertText": "UE_REQUIRES(!TModels_V<CEqualityComparableWith, LhsType*, RhsType*>) > UE_SOFTOBJECTPTR_CONVERSION_DEPRECATED(5.5, \"Comparing TSoftObjectPtrs of incompatible pointer types has been deprecated.\") FORCEINLINE bool operator!=(const TSoftObjectPtr<LhsType>& Lhs, const TSoftObjectPtr<RhsType>& Rhs)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<LhsType,RhsType)",
    "insertText": "UE_REQUIRES(TModels_V<CEqualityComparableWith, LhsType*, RhsType*>) > FORCEINLINE bool operator!=(const TSoftObjectPtr<LhsType>& Lhs, RhsType* Rhs)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<LhsType,RhsType)",
    "insertText": "UE_REQUIRES(!TModels_V<CEqualityComparableWith, LhsType*, RhsType*>) > UE_SOFTOBJECTPTR_CONVERSION_DEPRECATED(5.5, \"Comparing TSoftObjectPtrs of incompatible pointer types has been deprecated.\") FORCEINLINE bool operator!=(const TSoftObjectPtr<LhsType>& Lhs, RhsType* Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<LhsType> bool)",
    "insertText": "operator(const TSoftObjectPtr<LhsType>& Lhs, TYPE_OF_NULLPTR Rhs)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<LhsType,RhsType)",
    "insertText": "UE_REQUIRES(TModels_V<CEqualityComparableWith, LhsType*, RhsType*>) > FORCEINLINE bool operator!=(LhsType* Lhs, const TSoftObjectPtr<RhsType>& Rhs)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<LhsType,RhsType)",
    "insertText": "UE_REQUIRES(!TModels_V<CEqualityComparableWith, LhsType*, RhsType*>) > UE_SOFTOBJECTPTR_CONVERSION_DEPRECATED(5.5, \"Comparing TSoftObjectPtrs of incompatible pointer types has been deprecated.\") FORCEINLINE bool operator!=(LhsType* Lhs, const TSoftObjectPtr<RhsType>& Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<RhsType> bool)",
    "insertText": "operator(TYPE_OF_NULLPTR Lhs, const TSoftObjectPtr<RhsType>& Rhs)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} # endif template<class T> uint32)",
    "insertText": "GetTypeHash(const TSoftObjectPtr<T>& Ptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class T> FArchive&)",
    "insertText": "operator(FArchive& Ar, TSoftObjectPtr<T>& Ptr)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Ptr .)",
    "insertText": "Serialize(Ar)"
  },
  {
    "label": "MakeSoftObjectPtr()",
    "kind": "Method",
    "detail": "Function (} template<class T> TSoftObjectPtr<T>)",
    "insertText": "MakeSoftObjectPtr(TObjectPtr<T> Object)"
  },
  {
    "label": "TSoftClassPtr()",
    "kind": "Method",
    "detail": "Function (} template<class TClass = UObject> class TSoftClassPtr { template<class TClassA> class TSoftClassPtr ; public : using ElementType = TClass ;)",
    "insertText": "TSoftClassPtr()"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (template<class TClassA)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<TClassA*, TClass*>) > FORCEINLINE TSoftClassPtr(const TSoftClassPtr<TClassA>& Other) : SoftObjectPtr(Other.SoftObjectPtr)"
  },
  {
    "label": "TSoftClassPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TSoftClassPtr(const UClass* From) : SoftObjectPtr(From)"
  },
  {
    "label": "TSoftClassPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TSoftClassPtr(const FSoftObjectPath& ObjectPath) : SoftObjectPtr(ObjectPath)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator(const UClass* From)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (SoftObjectPtr = From ; } void)",
    "insertText": "operator(const FSoftObjectPath& ObjectPath)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (SoftObjectPtr = ObjectPath ; } template<class TClassA)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<TClassA*, TClass*>) > FORCEINLINE TSoftClassPtr& operator=(const TWeakObjectPtr<TClassA>& Other)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (SoftObjectPtr = Other ; return* this ; } template<class TClassA)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<TClassA*, TClass*>) > FORCEINLINE TSoftClassPtr& operator=(const TSoftObjectPtr<TClassA>& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (SoftObjectPtr = Other . SoftObjectPtr ; return* this ; } bool)",
    "insertText": "operator(const TSoftClassPtr& Rhs)"
  },
  {
    "label": "UClass()",
    "kind": "Method",
    "detail": "Function (UClass* Class = dynamic_cast<)",
    "insertText": "UClass(SoftObjectPtr.Get())"
  },
  {
    "label": "UClass()",
    "kind": "Method",
    "detail": "Function (UClass* Class = dynamic_cast<)",
    "insertText": "UClass(Asset)"
  },
  {
    "label": "FSoftObjectPtr()",
    "kind": "Method",
    "detail": "Function (Ar<<static_cast<)",
    "insertText": "FSoftObjectPtr(SoftObjectPtr)"
  },
  {
    "label": "MakeSoftClassPtr()",
    "kind": "Method",
    "detail": "Function (} private : FSoftObjectPtr SoftObjectPtr ; } ; template<class T> struct TIsPODType<TSoftClassPtr<T>> { enum { Value = TIsPODType<FSoftObjectPtr>::Value } ; } ; template<class T> struct TIsWeakPointerType<TSoftClassPtr<T>> { enum { Value = TIsWeakPointerType<FSoftObjectPtr>::Value } ; } ; template<T> struct TCallTraits<TSoftClassPtr<T>> : public TCallTraitsBase<TSoftClassPtr<T>> { using ConstPointerType = TSoftClassPtr<const T> ; } ; template<class T> TSoftClassPtr<std::remove_cv_t<T>>)",
    "insertText": "MakeSoftClassPtr(T* Object)"
  },
  {
    "label": "MakeSoftClassPtr()",
    "kind": "Method",
    "detail": "Function (} template<class T> TSoftClassPtr<std::remove_cv_t<T>>)",
    "insertText": "MakeSoftClassPtr(TObjectPtr<T> Object)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} struct FSoftObjectPtrFastLess : private FSoftObjectPathFastLess { template<SoftObjectPtrType> bool)",
    "insertText": "operator()(const SoftObjectPtrType& Lhs, const SoftObjectPtrType& Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # if ! PLATFORM_COMPILER_HAS_GENERATED_COMPARISON_OPERATORS template<class TClass> bool)",
    "insertText": "operator(const UClass* Lhs, const TSoftClassPtr<TClass>& Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class TClass> FArchive&)",
    "insertText": "operator(FArchive& Ar, TSoftClassPtr<TClass>& Ptr)"
  }
]