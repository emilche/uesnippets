[
  {
    "label": "FQueuedDataChunk",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FQueuedDataChunk"
  },
  {
    "label": "FPendingBatchData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPendingBatchData"
  },
  {
    "label": "FPendingBatches",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPendingBatches"
  },
  {
    "label": "FQueuedDataChunk()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" Iris / ReplicationSystem / NetRefHandle . h \" namespace UE::Net::Private { struct FQueuedDataChunk {)",
    "insertText": "FQueuedDataChunk() : StorageOffset(0U) , NumBits(0U) , bHasBatchOwnerData(0U) , bIsEndReplicationChunk(0U)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (} uint32 StorageOffset ; uint32 NumBits : 3 0 ; uint32 bHasBatchOwnerData : 1 ; uint32 bIsEndReplicationChunk : 1 ; } ; struct FPendingBatchData { TArray<uint32,TInlineAllocator<3 2>> DataChunkStorage ; TArray<FQueuedDataChunk,TInlineAllocator<4>> QueuedDataChunks ; TArray<FNetRefHandle,TInlineAllocator<4>> PendingMustBeMappedReferences ; TArray<FNetRefHandle,TInlineAllocator<4>> ResolvedReferences ; FNetRefHandle Handle ; } ; struct FPendingBatches { FPendingBatchData*)",
    "insertText": "Find(FNetRefHandle NetRefHandle)"
  },
  {
    "label": "GetHasPendingBatches()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "GetHasPendingBatches()"
  }
]