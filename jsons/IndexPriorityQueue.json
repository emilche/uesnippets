[
  {
    "label": "FIndexPriorityQueue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FIndexPriorityQueue"
  },
  {
    "label": "FQueueNode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FQueueNode"
  },
  {
    "label": "FIndexPriorityQueue()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" MathUtil . h \" # include \" Util / DynamicVector . h \" namespace UE { namespace Geometry { class FIndexPriorityQueue { public : bool EnableDebugChecks = false ; struct FQueueNode { int id = - 1 ; float priority ; int index ; } ; TDynamicVector<FQueueNode> nodes ; int num_nodes ; TArray<int> id_to_index ;)",
    "insertText": "FIndexPriorityQueue()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Initialize(0)"
  },
  {
    "label": "FIndexPriorityQueue()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FIndexPriorityQueue(int maxID)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Initialize(maxID)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Initialize(int MaxNodeID)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (nodes .)",
    "insertText": "Clear()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (id_to_index .)",
    "insertText": "Init(-1, MaxNodeID)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (num_nodes = 0 ; } void)",
    "insertText": "Clear(bool bFreeMemory = true)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (id_to_index .)",
    "insertText": "Init(-1, id_to_index.Num())"
  },
  {
    "label": "GetCount()",
    "kind": "Method",
    "detail": "Function (num_nodes = 0 ; } int)",
    "insertText": "GetCount()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int NodeIndex = id_to_index [ NodeID ] ;)",
    "insertText": "if(NodeIndex <= 0 || NodeIndex > num_nodes)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (} FQueueNode node ; node . id = NodeID ; node . priority = priority ; num_nodes + + ; node . index = num_nodes ; id_to_index [ NodeID ] = node . index ; nodes .)",
    "insertText": "InsertAt(node, num_nodes)"
  },
  {
    "label": "move_up()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "move_up(nodes[num_nodes].index)"
  },
  {
    "label": "Dequeue()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "Dequeue()"
  },
  {
    "label": "remove_at_index()",
    "kind": "Method",
    "detail": "Function (} int NodeID = nodes [ 1 ] . id ;)",
    "insertText": "remove_at_index(1)"
  },
  {
    "label": "remove_at_index()",
    "kind": "Method",
    "detail": "Function (} int NodeIndex = id_to_index [ NodeID ] ;)",
    "insertText": "remove_at_index(NodeIndex)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Update(int NodeID, float Priority)"
  },
  {
    "label": "on_node_updated()",
    "kind": "Method",
    "detail": "Function (} int NodeIndex = id_to_index [ NodeID ] ; FQueueNode n = nodes [ NodeIndex ] ; n . priority = Priority ; nodes [ NodeIndex ] = n ;)",
    "insertText": "on_node_updated(NodeIndex)"
  },
  {
    "label": "GetPriority()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GetPriority(int id)"
  },
  {
    "label": "remove_at_index()",
    "kind": "Method",
    "detail": "Function (} int iNode = id_to_index [ id ] ; return nodes [ iNode ] . priority ; } private : void)",
    "insertText": "remove_at_index(int NodeIndex)"
  },
  {
    "label": "FQueueNode()",
    "kind": "Method",
    "detail": "Function (int id = nodes [ num_nodes ] . id ; id_to_index [ id ] = - 1 ; nodes [ num_nodes ] =)",
    "insertText": "FQueueNode()"
  },
  {
    "label": "swap_nodes_at_indices()",
    "kind": "Method",
    "detail": "Function (num_nodes - - ; return ; })",
    "insertText": "swap_nodes_at_indices(NodeIndex, num_nodes)"
  },
  {
    "label": "swap_nodes_at_indices()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "swap_nodes_at_indices(int i1, int i2)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (FQueueNode n1 = nodes [ i1 ] ; n1 . index = i2 ; FQueueNode n2 = nodes [ i2 ] ; n2 . index = i1 ; nodes [ i1 ] = n2 ; nodes [ i2 ] = n1 ; id_to_index [ n2 . id ] = i1 ; id_to_index [ n1 . id ] = i2 ; } void)",
    "insertText": "move(int iFrom, int iTo)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (FQueueNode n = nodes [ iFrom ] ; n . index = iTo ; nodes [ iTo ] = n ; id_to_index [ n . id ] = iTo ; } void)",
    "insertText": "set(int iTo, FQueueNode& n)"
  },
  {
    "label": "move_up()",
    "kind": "Method",
    "detail": "Function (n . index = iTo ; nodes [ iTo ] = n ; id_to_index [ n . id ] = iTo ; } void)",
    "insertText": "move_up(int iNode)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int iStart = iNode ; FQueueNode iStartNode = nodes [ iStart ] ; int iParent = iNode / 2 ;)",
    "insertText": "while(iParent >= 1)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (break ; })",
    "insertText": "move(iParent, iNode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (iNode = iParent ; iParent = nodes [ iNode ] . index / 2 ; })",
    "insertText": "if(iNode != iStart)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set(iNode, iStartNode)"
  },
  {
    "label": "move_down()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "move_down(int iNode)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int iStart = iNode ; FQueueNode iStartNode = nodes [ iStart ] ;)",
    "insertText": "while(true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int iMoveTo = iNode ; int iLeftChild = 2* iNode ;)",
    "insertText": "if(iLeftChild > num_nodes)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } float min_priority = iStartNode . priority ; float left_child_priority = nodes [ iLeftChild ] . priority ;)",
    "insertText": "if(left_child_priority < min_priority)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (iMoveTo = iLeftChild ; min_priority = left_child_priority ; } int iRightChild = iLeftChild + 1 ;)",
    "insertText": "if(iRightChild <= num_nodes)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (iMoveTo = iRightChild ; } })",
    "insertText": "if(iMoveTo != iNode)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "move(iMoveTo, iNode)"
  },
  {
    "label": "on_node_updated()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "on_node_updated(int iNode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int iParent = iNode / 2 ;)",
    "insertText": "if(iParent > 0 && has_higher_priority(iNode, iParent)) move_up(iNode)"
  },
  {
    "label": "has_higher_priority()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "has_higher_priority(int iHigher, int iLower)"
  },
  {
    "label": "IsValidQueue()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "IsValidQueue()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int childLeftIndex = 2* i ;)",
    "insertText": "if(childLeftIndex < num_nodes && has_higher_priority(childLeftIndex, i))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int childRightIndex = childLeftIndex + 1 ;)",
    "insertText": "if(childRightIndex < num_nodes && has_higher_priority(childRightIndex, i))"
  },
  {
    "label": "CheckIds()",
    "kind": "Method",
    "detail": "Function (} return true ; } bool)",
    "insertText": "CheckIds()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bValidNodesInSycn = true ;)",
    "insertText": "for(int i = 1; i < num_nodes + 1; ++i)"
  },
  {
    "label": "bValidNodesInSycn()",
    "kind": "Method",
    "detail": "Function (const FQueueNode& n = nodes [ i ] ; int id = n . id ; int index = n . index ; bValidNodesInSycn =)",
    "insertText": "bValidNodesInSycn(index == id_to_index[id])"
  },
  {
    "label": "bValidNodesInSycn()",
    "kind": "Method",
    "detail": "Function (bValidNodesInSycn =)",
    "insertText": "bValidNodesInSycn(index == i)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} bool bNoOutOfSyncNodes = true ;)",
    "insertText": "for(int id = 0; id < id_to_index.Num(); ++id)"
  },
  {
    "label": "bNoOutOfSyncNodes()",
    "kind": "Method",
    "detail": "Function (int index = id_to_index [ id ] ; const FQueueNode& n = nodes [ index ] ; bNoOutOfSyncNodes =)",
    "insertText": "bNoOutOfSyncNodes(n.id == id)"
  }
]