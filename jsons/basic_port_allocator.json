[
  {
    "label": "RTC_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RTC_EXPORT"
  },
  {
    "label": "PortConfiguration",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PortConfiguration"
  },
  {
    "label": "AllocationSequence",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AllocationSequence"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "PortData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PortData"
  },
  {
    "label": "State",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "State"
  },
  {
    "label": "UDPPort",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UDPPort"
  },
  {
    "label": "TurnPort",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TurnPort"
  },
  {
    "label": "BasicPortAllocator()",
    "kind": "Method",
    "detail": "Function (# ifndef P2P_CLIENT_BASIC_PORT_ALLOCATOR_H_ # define P2P_CLIENT_BASIC_PORT_ALLOCATOR_H_ # include<memory> # include<string> # include<vector> # include \" absl / strings / string_view . h \" # include \" api / field_trials_view . h \" # include \" api / task_queue / pending_task_safety_flag . h \" # include \" api / turn_customizer . h \" # include \" p2p / base / port_allocator . h \" # include \" p2p / client / relay_port_factory_interface . h \" # include \" p2p / client / turn_port_factory . h \" # include \" rtc_base / checks . h \" # include \" rtc_base / memory / always_valid_pointer . h \" # include \" rtc_base / network . h \" # include \" rtc_base / system / rtc_export . h \" # include \" rtc_base / thread . h \" # include \" rtc_base / thread_annotations . h \" namespace cricket { class RTC_EXPORT BasicPortAllocator : public PortAllocator { public :)",
    "insertText": "BasicPortAllocator(rtc::NetworkManager* network_manager, rtc::PacketSocketFactory* socket_factory, webrtc::TurnCustomizer* customizer = nullptr, RelayPortFactoryInterface* relay_port_factory = nullptr, const webrtc::FieldTrialsView* field_trials = nullptr)"
  },
  {
    "label": "BasicPortAllocator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BasicPortAllocator(rtc::NetworkManager* network_manager, std::unique_ptr<rtc::PacketSocketFactory> owned_socket_factory, const webrtc::FieldTrialsView* field_trials = nullptr)"
  },
  {
    "label": "BasicPortAllocator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BasicPortAllocator(rtc::NetworkManager* network_manager, std::unique_ptr<rtc::PacketSocketFactory> owned_socket_factory, const ServerAddresses& stun_servers, const webrtc::FieldTrialsView* field_trials = nullptr)"
  },
  {
    "label": "BasicPortAllocator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BasicPortAllocator(rtc::NetworkManager* network_manager, rtc::PacketSocketFactory* socket_factory, const ServerAddresses& stun_servers, const webrtc::FieldTrialsView* field_trials = nullptr)"
  },
  {
    "label": "BasicPortAllocator()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "BasicPortAllocator()"
  },
  {
    "label": "SetNetworkIgnoreMask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetNetworkIgnoreMask(int network_ignore_mask)"
  },
  {
    "label": "GetNetworkIgnoreMask()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetNetworkIgnoreMask()"
  },
  {
    "label": "network_manager()",
    "kind": "Method",
    "detail": "Function (rtc::NetworkManager*)",
    "insertText": "network_manager()"
  },
  {
    "label": "CreateSessionInternal()",
    "kind": "Method",
    "detail": "Function (} PortAllocatorSession*)",
    "insertText": "CreateSessionInternal(absl::string_view content_name, int component, absl::string_view ice_ufrag, absl::string_view ice_pwd)"
  },
  {
    "label": "AddTurnServerForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTurnServerForTesting(const RelayServerConfig& turn_server)"
  },
  {
    "label": "relay_port_factory()",
    "kind": "Method",
    "detail": "Function (RelayPortFactoryInterface*)",
    "insertText": "relay_port_factory()"
  },
  {
    "label": "field_trials()",
    "kind": "Method",
    "detail": "Function (const webrtc::FieldTrialsView*)",
    "insertText": "field_trials()"
  },
  {
    "label": "OnIceRegathering()",
    "kind": "Method",
    "detail": "Function (} private : void)",
    "insertText": "OnIceRegathering(PortAllocatorSession* session, IceRegatheringReason reason)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(RelayPortFactoryInterface* relay_port_factory)"
  },
  {
    "label": "MdnsObfuscationEnabled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "MdnsObfuscationEnabled()"
  },
  {
    "label": "BasicPortAllocatorSession()",
    "kind": "Method",
    "detail": "Function (webrtc::AlwaysValidPointer<const webrtc::FieldTrialsView,webrtc::FieldTrialBasedConfig> field_trials_ ; rtc::NetworkManager* network_manager_ ; const webrtc::AlwaysValidPointerNoDefault<rtc::PacketSocketFactory> socket_factory_ ; int network_ignore_mask_ = rtc::kDefaultNetworkIgnoreMask ; RelayPortFactoryInterface* relay_port_factory_ ; std::unique_ptr<RelayPortFactoryInterface> default_relay_port_factory_ ; } ; struct PortConfiguration ; class AllocationSequence ; enum class SessionState { GATHERING,CLEARED,STOPPED } ; class RTC_EXPORT BasicPortAllocatorSession : public PortAllocatorSession { public :)",
    "insertText": "BasicPortAllocatorSession(BasicPortAllocator* allocator, absl::string_view content_name, int component, absl::string_view ice_ufrag, absl::string_view ice_pwd)"
  },
  {
    "label": "BasicPortAllocatorSession()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "BasicPortAllocatorSession()"
  },
  {
    "label": "allocator()",
    "kind": "Method",
    "detail": "Function (BasicPortAllocator*)",
    "insertText": "allocator()"
  },
  {
    "label": "network_thread()",
    "kind": "Method",
    "detail": "Function (rtc::Thread*)",
    "insertText": "network_thread()"
  },
  {
    "label": "StartGettingPorts()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StartGettingPorts()"
  },
  {
    "label": "StopGettingPorts()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StopGettingPorts()"
  },
  {
    "label": "ClearGettingPorts()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearGettingPorts()"
  },
  {
    "label": "IsGettingPorts()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsGettingPorts()"
  },
  {
    "label": "IsCleared()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsCleared()"
  },
  {
    "label": "IsStopped()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsStopped()"
  },
  {
    "label": "ReadyPorts()",
    "kind": "Method",
    "detail": "Function (std::vector<PortInterface*>)",
    "insertText": "ReadyPorts()"
  },
  {
    "label": "ReadyCandidates()",
    "kind": "Method",
    "detail": "Function (std::vector<Candidate>)",
    "insertText": "ReadyCandidates()"
  },
  {
    "label": "CandidatesAllocationDone()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CandidatesAllocationDone()"
  },
  {
    "label": "RegatherOnFailedNetworks()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegatherOnFailedNetworks()"
  },
  {
    "label": "GetCandidateStatsFromReadyPorts()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetCandidateStatsFromReadyPorts(CandidateStatsList* candidate_stats_list)"
  },
  {
    "label": "SetStunKeepaliveIntervalForReadyPorts()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetStunKeepaliveIntervalForReadyPorts(const absl::optional<int>& stun_keepalive_interval)"
  },
  {
    "label": "PruneAllPorts()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PruneAllPorts()"
  },
  {
    "label": "SelectIPv6Networks()",
    "kind": "Method",
    "detail": "Function (std::vector<const rtc::Network*>)",
    "insertText": "SelectIPv6Networks(std::vector<const rtc::Network*>& all_ipv6_networks, int max_ipv6_networks)"
  },
  {
    "label": "UpdateIceParametersInternal()",
    "kind": "Method",
    "detail": "Function (protected : void)",
    "insertText": "UpdateIceParametersInternal()"
  },
  {
    "label": "GetPortConfigurations()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPortConfigurations()"
  },
  {
    "label": "ConfigReady()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConfigReady(std::unique_ptr<PortConfiguration> config)"
  },
  {
    "label": "ABSL_DEPRECATED()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_DEPRECATED(\"Use ConfigReady(std::unique_ptr<PortConfiguration>) instead!\") void ConfigReady(PortConfiguration* config)"
  },
  {
    "label": "PortData()",
    "kind": "Method",
    "detail": "Function (private : class PortData { public : enum State { STATE_INPROGRESS,STATE_COMPLETE,STATE_ERROR,STATE_PRUNED } ;)",
    "insertText": "PortData()"
  },
  {
    "label": "PortData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PortData(Port* port, AllocationSequence* seq) : port_(port), sequence_(seq)"
  },
  {
    "label": "port()",
    "kind": "Method",
    "detail": "Function (} Port*)",
    "insertText": "port()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (state_ = STATE_PRUNED ;)",
    "insertText": "if(port())"
  },
  {
    "label": "port()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "port()->Prune()"
  },
  {
    "label": "set_has_pairable_candidate()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "set_has_pairable_candidate(bool has_pairable_candidate)"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK(state_ == STATE_INPROGRESS)"
  },
  {
    "label": "set_state()",
    "kind": "Method",
    "detail": "Function (} has_pairable_candidate_ = has_pairable_candidate ; } void)",
    "insertText": "set_state(State state)"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK(state != STATE_ERROR || state_ == STATE_INPROGRESS)"
  },
  {
    "label": "OnConfigReady()",
    "kind": "Method",
    "detail": "Function (state_ = state ; } private : Port* port_ = nullptr ; AllocationSequence* sequence_ = nullptr ; bool has_pairable_candidate_ = false ; State state_ = STATE_INPROGRESS ; } ; void)",
    "insertText": "OnConfigReady(std::unique_ptr<PortConfiguration> config)"
  },
  {
    "label": "OnConfigStop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnConfigStop()"
  },
  {
    "label": "AllocatePorts()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AllocatePorts()"
  },
  {
    "label": "OnAllocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnAllocate(int allocation_epoch)"
  },
  {
    "label": "DoAllocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DoAllocate(bool disable_equivalent_phases)"
  },
  {
    "label": "OnNetworksChanged()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnNetworksChanged()"
  },
  {
    "label": "OnAllocationSequenceObjectsCreated()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnAllocationSequenceObjectsCreated()"
  },
  {
    "label": "DisableEquivalentPhases()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisableEquivalentPhases(const rtc::Network* network, PortConfiguration* config, uint32_t* flags)"
  },
  {
    "label": "AddAllocatedPort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddAllocatedPort(Port* port, AllocationSequence* seq)"
  },
  {
    "label": "OnCandidateReady()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnCandidateReady(Port* port, const Candidate& c)"
  },
  {
    "label": "OnCandidateError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnCandidateError(Port* port, const IceCandidateErrorEvent& event)"
  },
  {
    "label": "OnPortComplete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnPortComplete(Port* port)"
  },
  {
    "label": "OnPortError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnPortError(Port* port)"
  },
  {
    "label": "OnProtocolEnabled()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnProtocolEnabled(AllocationSequence* seq, ProtocolType proto)"
  },
  {
    "label": "OnPortDestroyed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnPortDestroyed(PortInterface* port)"
  },
  {
    "label": "MaybeSignalCandidatesAllocationDone()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MaybeSignalCandidatesAllocationDone()"
  },
  {
    "label": "OnPortAllocationComplete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnPortAllocationComplete()"
  },
  {
    "label": "FindPort()",
    "kind": "Method",
    "detail": "Function (PortData*)",
    "insertText": "FindPort(Port* port)"
  },
  {
    "label": "GetNetworks()",
    "kind": "Method",
    "detail": "Function (std::vector<const rtc::Network*>)",
    "insertText": "GetNetworks()"
  },
  {
    "label": "GetFailedNetworks()",
    "kind": "Method",
    "detail": "Function (std::vector<const rtc::Network*>)",
    "insertText": "GetFailedNetworks()"
  },
  {
    "label": "Regather()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Regather(const std::vector<const rtc::Network*>& networks, bool disable_equivalent_phases, IceRegatheringReason reason)"
  },
  {
    "label": "CheckCandidateFilter()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CheckCandidateFilter(const Candidate& c)"
  },
  {
    "label": "CandidatePairable()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CandidatePairable(const Candidate& c, const Port* port)"
  },
  {
    "label": "GetUnprunedPorts()",
    "kind": "Method",
    "detail": "Function (std::vector<PortData*>)",
    "insertText": "GetUnprunedPorts(const std::vector<const rtc::Network*>& networks)"
  },
  {
    "label": "PrunePortsAndRemoveCandidates()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrunePortsAndRemoveCandidates(const std::vector<PortData*>& port_data_list)"
  },
  {
    "label": "GetCandidatesFromPort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetCandidatesFromPort(const PortData& data, std::vector<Candidate>* candidates)"
  },
  {
    "label": "GetBestTurnPortForNetwork()",
    "kind": "Method",
    "detail": "Function (Port*)",
    "insertText": "GetBestTurnPortForNetwork(absl::string_view network_name)"
  },
  {
    "label": "PruneTurnPorts()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "PruneTurnPorts(Port* newly_pairable_turn_port)"
  },
  {
    "label": "PruneNewlyPairableTurnPort()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "PruneNewlyPairableTurnPort(PortData* newly_pairable_turn_port)"
  },
  {
    "label": "RTC_GUARDED_BY()",
    "kind": "Method",
    "detail": "Function (BasicPortAllocator* allocator_ ; rtc::Thread* network_thread_ ; rtc::PacketSocketFactory* socket_factory_ ; bool allocation_started_ ; bool network_manager_started_ ; bool allocation_sequences_created_ ; std::vector<std::unique_ptr<PortConfiguration>> configs_ ; std::vector<AllocationSequence*> sequences_ ; std::vector<PortData> ports_ ; std::vector<IceCandidateErrorEvent> candidate_error_events_ ; uint32_t candidate_filter_ = CF_ALL ; webrtc::PortPrunePolicy turn_port_prune_policy_ ; SessionState state_ = SessionState::CLEARED ; int allocation_epoch_)",
    "insertText": "RTC_GUARDED_BY(network_thread_)"
  },
  {
    "label": "PortConfiguration()",
    "kind": "Method",
    "detail": "Function (webrtc::ScopedTaskSafety network_safety_ ; class AllocationSequence ; } ; struct RTC_EXPORT PortConfiguration { rtc::SocketAddress stun_address ; ServerAddresses stun_servers ; std::string username ; std::string password ; bool use_turn_server_as_stun_server_disabled = false ; typedef std::vector<RelayServerConfig> RelayList ; RelayList relays ;)",
    "insertText": "PortConfiguration(const ServerAddresses& stun_servers, absl::string_view username, absl::string_view password, const webrtc::FieldTrialsView* field_trials = nullptr)"
  },
  {
    "label": "StunServers()",
    "kind": "Method",
    "detail": "Function (ServerAddresses)",
    "insertText": "StunServers()"
  },
  {
    "label": "AddRelay()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddRelay(const RelayServerConfig& config)"
  },
  {
    "label": "SupportsProtocol()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SupportsProtocol(const RelayServerConfig& relay, ProtocolType type)"
  },
  {
    "label": "SupportsProtocol()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SupportsProtocol(ProtocolType type)"
  },
  {
    "label": "GetRelayServerAddresses()",
    "kind": "Method",
    "detail": "Function (ServerAddresses)",
    "insertText": "GetRelayServerAddresses(ProtocolType type)"
  },
  {
    "label": "AllocationSequence()",
    "kind": "Method",
    "detail": "Function (} ; class UDPPort ; class TurnPort ; class AllocationSequence : public sigslot::has_slots<> { public : enum State { kInit,kRunning,kStopped,kCompleted,} ;)",
    "insertText": "AllocationSequence(BasicPortAllocatorSession* session, const rtc::Network* network, PortConfiguration* config, uint32_t flags, std::function<void()> port_allocation_complete_callback)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init()"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Clear()"
  },
  {
    "label": "OnNetworkFailed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnNetworkFailed()"
  },
  {
    "label": "state()",
    "kind": "Method",
    "detail": "Function (State)",
    "insertText": "state()"
  },
  {
    "label": "Start()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Start()"
  },
  {
    "label": "Stop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Stop()"
  },
  {
    "label": "CreateTurnPort()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "CreateTurnPort(const RelayServerConfig& config, int relative_priority)"
  },
  {
    "label": "Process()",
    "kind": "Method",
    "detail": "Function (typedef std::vector<ProtocolType> ProtocolList ; void)",
    "insertText": "Process(int epoch)"
  },
  {
    "label": "IsFlagSet()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsFlagSet(uint32_t flag)"
  },
  {
    "label": "CreateUDPPorts()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CreateUDPPorts()"
  },
  {
    "label": "CreateTCPPorts()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateTCPPorts()"
  },
  {
    "label": "CreateStunPorts()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateStunPorts()"
  },
  {
    "label": "CreateRelayPorts()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateRelayPorts()"
  },
  {
    "label": "OnReadPacket()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnReadPacket(rtc::AsyncPacketSocket* socket, const char* data, size_t size, const rtc::SocketAddress& remote_addr, const int64_t& packet_time_us)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (BasicPortAllocatorSession* session_ ; bool network_failed_ = false ; const rtc::Network* network_ ; rtc::IPAddress previous_best_ip_ ; PortConfiguration* config_ ; State state_ ; uint32_t flags_ ; ProtocolList protocols_ ; std::unique_ptr<rtc::AsyncPacketSocket> udp_socket_ ; UDPPort* udp_port_ ; std::vector<Port*> relay_ports_ ; int phase_ ; std::function<)",
    "insertText": "void()"
  }
]