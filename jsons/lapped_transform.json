[
  {
    "label": "AlignedArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AlignedArray"
  },
  {
    "label": "LappedTransform",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LappedTransform"
  },
  {
    "label": "Callback",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Callback"
  },
  {
    "label": "BlockThunk",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BlockThunk"
  },
  {
    "label": "AlignedArray()",
    "kind": "Method",
    "detail": "Function (# ifndef MODULES_AUDIO_CODING_CODECS_OPUS_TEST_LAPPED_TRANSFORM_H_ # define MODULES_AUDIO_CODING_CODECS_OPUS_TEST_LAPPED_TRANSFORM_H_ # include<complex> # include<memory> # include \" common_audio / real_fourier . h \" # include \" modules / audio_coding / codecs / opus / test / blocker . h \" # include \" rtc_base / memory / aligned_malloc . h \" namespace webrtc { template<T> class AlignedArray { public :)",
    "insertText": "AlignedArray(size_t rows, size_t cols, size_t alignment) : rows_(rows), cols_(cols)"
  },
  {
    "label": "RTC_CHECK_GT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_CHECK_GT(alignment, 0)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (head_row_ = static_cast<)",
    "insertText": "T(AlignedMalloc(rows_ * sizeof(*head_row_), alignment))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (head_row_ [ i ] = static_cast<)",
    "insertText": "T(AlignedMalloc(cols_ * sizeof(**head_row_), alignment))"
  },
  {
    "label": "AlignedArray()",
    "kind": "Method",
    "detail": "Function (} } ~)",
    "insertText": "AlignedArray()"
  },
  {
    "label": "AlignedFree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AlignedFree(head_row_[i])"
  },
  {
    "label": "AlignedFree()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "AlignedFree(head_row_)"
  },
  {
    "label": "Array()",
    "kind": "Method",
    "detail": "Function (} T* const*)",
    "insertText": "Array()"
  },
  {
    "label": "RTC_CHECK_LE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_CHECK_LE(row, rows_)"
  },
  {
    "label": "ProcessAudioBlock()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ProcessAudioBlock(const std::complex<float>* const* in_block, size_t num_in_channels, size_t frames, size_t num_out_channels, std::complex<float>* const* out_block)"
  },
  {
    "label": "LappedTransform()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "LappedTransform(size_t num_in_channels, size_t num_out_channels, size_t chunk_length, const float* window, size_t block_length, size_t shift_amount, Callback* callback)"
  },
  {
    "label": "LappedTransform()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "LappedTransform()"
  },
  {
    "label": "ProcessChunk()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ProcessChunk(const float* const* in_chunk, float* const* out_chunk)"
  },
  {
    "label": "chunk_length()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "chunk_length()"
  },
  {
    "label": "BlockThunk()",
    "kind": "Method",
    "detail": "Function (} private : class BlockThunk : public BlockerCallback { public :)",
    "insertText": "BlockThunk(LappedTransform* parent) : parent_(parent)"
  },
  {
    "label": "ProcessBlock()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ProcessBlock(const float* const* input, size_t num_frames, size_t num_input_channels, size_t num_output_channels, float* const* output)"
  }
]