[
  {
    "label": "combinable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "combinable"
  },
  {
    "label": "combinable()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_combinable_H # define __TBB_combinable_H # include \" enumerable_thread_specific . h \" # include \" cache_aligned_allocator . h \" namespace tbb { template<T> class combinable { private : typedef tbb::cache_aligned_allocator<T> my_alloc ; typedef tbb::enumerable_thread_specific<T,my_alloc,ets_no_key> my_ets_type ; my_ets_type my_ets ; public :)",
    "insertText": "combinable()"
  },
  {
    "label": "combinable()",
    "kind": "Method",
    "detail": "Function (} template<finit>)",
    "insertText": "combinable(finit _finit) : my_ets(_finit)"
  },
  {
    "label": "combinable()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "combinable(const combinable& other) : my_ets(other.my_ets)"
  },
  {
    "label": "combinable()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_ETS_USE_CPP11)",
    "insertText": "combinable(combinable&& other) : my_ets( std::move(other.my_ets))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif combinable&)",
    "insertText": "operator(const combinable & other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (my_ets = other . my_ets ; return* this ; } # if __TBB_ETS_USE_CPP11 combinable&)",
    "insertText": "operator(combinable && other)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (my_ets =)",
    "insertText": "move(other.my_ets)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (my_ets .)",
    "insertText": "clear()"
  },
  {
    "label": "local()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "local()"
  },
  {
    "label": "local()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "local(bool & exists)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (} template<combine_func_t> T)",
    "insertText": "combine(combine_func_t f_combine)"
  },
  {
    "label": "combine_each()",
    "kind": "Method",
    "detail": "Function (} template<combine_func_t> void)",
    "insertText": "combine_each(combine_func_t f_combine)"
  },
  {
    "label": "combine_each()",
    "kind": "Method",
    "detail": "Function (my_ets .)",
    "insertText": "combine_each(f_combine)"
  }
]