[
  {
    "label": "FExpressionError",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionError"
  },
  {
    "label": "FExpressionForward",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionForward"
  },
  {
    "label": "FExpressionPreviousFrameSwitch",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionPreviousFrameSwitch"
  },
  {
    "label": "FExpressionConstant",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionConstant"
  },
  {
    "label": "FExpressionDefaultValue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionDefaultValue"
  },
  {
    "label": "FExpressionGetStructField",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionGetStructField"
  },
  {
    "label": "FExpressionSetStructField",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionSetStructField"
  },
  {
    "label": "FExpressionSelect",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionSelect"
  },
  {
    "label": "ENGINE_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ENGINE_API"
  },
  {
    "label": "FExpressionSwizzle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionSwizzle"
  },
  {
    "label": "FExpressionComponentMask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionComponentMask"
  },
  {
    "label": "FExpressionAppend",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionAppend"
  },
  {
    "label": "FExpressionFeatureLevelSwitch",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionFeatureLevelSwitch"
  },
  {
    "label": "FExpressionShadingPathSwitch",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionShadingPathSwitch"
  },
  {
    "label": "FExpressionQualitySwitch",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionQualitySwitch"
  },
  {
    "label": "FExpressionShaderStageSwitch",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionShaderStageSwitch"
  },
  {
    "label": "FExpressionVirtualTextureFeatureSwitch",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionVirtualTextureFeatureSwitch"
  },
  {
    "label": "FExpressionDistanceFieldsRenderingSwitch",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionDistanceFieldsRenderingSwitch"
  },
  {
    "label": "FExpressionInlineCustomHLSL",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionInlineCustomHLSL"
  },
  {
    "label": "FExpressionCustomHLSL",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionCustomHLSL"
  },
  {
    "label": "FStatementError",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FStatementError"
  },
  {
    "label": "FStatementBreak",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FStatementBreak"
  },
  {
    "label": "FStatementIf",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FStatementIf"
  },
  {
    "label": "FStatementLoop",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FStatementLoop"
  },
  {
    "label": "FExpressionError()",
    "kind": "Method",
    "detail": "Function (# pragma once # if WITH_EDITOR # include \" HLSLTree / HLSLTree . h \" # include \" SceneTypes . h \" namespace UE::HLSLTree { class FExpressionError : public FExpression { public :)",
    "insertText": "FExpressionError(FStringView InErrorMessage) : ErrorMessage(InErrorMessage)"
  },
  {
    "label": "PrepareValue()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "PrepareValue(FEmitContext& Context, FEmitScope& Scope, const FRequestedType& RequestedType, FPrepareValueResult& OutResult)"
  },
  {
    "label": "FExpressionForward()",
    "kind": "Method",
    "detail": "Function (FStringView ErrorMessage ; } ; class FExpressionForward : public FExpression { public :)",
    "insertText": "FExpressionForward(const FExpression* InExpression) : Expression(InExpression)"
  },
  {
    "label": "ComputeAnalyticDerivatives()",
    "kind": "Method",
    "detail": "Function (} const FExpression* Expression ; void)",
    "insertText": "ComputeAnalyticDerivatives(FTree& Tree, FExpressionDerivatives& OutResult)"
  },
  {
    "label": "ComputePreviousFrame()",
    "kind": "Method",
    "detail": "Function (const FExpression*)",
    "insertText": "ComputePreviousFrame(FTree& Tree, const FRequestedType& RequestedType)"
  },
  {
    "label": "EmitValueShader()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EmitValueShader(FEmitContext& Context, FEmitScope& Scope, const FRequestedType& RequestedType, FEmitValueShaderResult& OutResult)"
  },
  {
    "label": "EmitValuePreshader()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EmitValuePreshader(FEmitContext& Context, FEmitScope& Scope, const FRequestedType& RequestedType, FEmitValuePreshaderResult& OutResult)"
  },
  {
    "label": "EmitValueObject()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "EmitValueObject(FEmitContext& Context, FEmitScope& Scope, const FName& ObjectTypeName, void* OutObjectBase)"
  },
  {
    "label": "FExpressionPreviousFrameSwitch()",
    "kind": "Method",
    "detail": "Function (} ; class FExpressionPreviousFrameSwitch : public FExpressionForward { public :)",
    "insertText": "FExpressionPreviousFrameSwitch(const FExpression* InCurrentFrameExpression, const FExpression* InPreviousFrameExpression) : FExpressionForward(InCurrentFrameExpression) , PreviousFrameExpression(InPreviousFrameExpression)"
  },
  {
    "label": "PrepareConstant()",
    "kind": "Method",
    "detail": "Function (} ; namespace Private { FPreparedType)",
    "insertText": "PrepareConstant(const Shader::FValue& Value)"
  },
  {
    "label": "FExpressionConstant()",
    "kind": "Method",
    "detail": "Function (} class FExpressionConstant : public FExpression { public :)",
    "insertText": "FExpressionConstant(const Shader::FValue& InValue) : Value(InValue)"
  },
  {
    "label": "FExpressionDefaultValue()",
    "kind": "Method",
    "detail": "Function (} ; class FExpressionDefaultValue : public FExpressionForward { public :)",
    "insertText": "FExpressionDefaultValue(const FExpression* InExpression, const Shader::FValue& InDefaultValue) : FExpressionForward(InExpression) , DefaultValue(InDefaultValue)"
  },
  {
    "label": "FExpressionGetStructField()",
    "kind": "Method",
    "detail": "Function (} ; class FExpressionGetStructField : public FExpression { public :)",
    "insertText": "FExpressionGetStructField(const Shader::FStructType* InStructType, const Shader::FStructField* InField, const FExpression* InStructExpression) : StructType(InStructType) , Field(InField) , StructExpression(InStructExpression)"
  },
  {
    "label": "FExpressionSetStructField()",
    "kind": "Method",
    "detail": "Function (} ; class FExpressionSetStructField : public FExpression { public :)",
    "insertText": "FExpressionSetStructField(const Shader::FStructType* InStructType, const Shader::FStructField* InField, const FExpression* InStructExpression, const FExpression* InFieldExpression, EMaterialProperty InTestMaterialProperty = MP_MAX) : StructType(InStructType) , Field(InField) , StructExpression(InStructExpression) , FieldExpression(InFieldExpression) , TestMaterialProperty(InTestMaterialProperty)"
  },
  {
    "label": "MakeRequestedStructType()",
    "kind": "Method",
    "detail": "Function (private : FRequestedType)",
    "insertText": "MakeRequestedStructType(const FActiveStructFieldStack& ActiveFieldStack, const FRequestedType& RequestedType)"
  },
  {
    "label": "MakeRequestedFieldType()",
    "kind": "Method",
    "detail": "Function (FRequestedType)",
    "insertText": "MakeRequestedFieldType(const FActiveStructFieldStack& ActiveFieldStack, const FRequestedType& RequestedType)"
  },
  {
    "label": "IsStructFieldActive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsStructFieldActive(FEmitContext& Context)"
  },
  {
    "label": "FExpressionSelect()",
    "kind": "Method",
    "detail": "Function (} ; class FExpressionSelect : public FExpression { public :)",
    "insertText": "FExpressionSelect(const FExpression* InCondition, const FExpression* InTrue, const FExpression* InFalse) : ConditionExpression(InCondition) , TrueExpression(InTrue) , FalseExpression(InFalse)"
  },
  {
    "label": "FExpressionDerivative()",
    "kind": "Method",
    "detail": "Function (} ; class FExpressionDerivative : public FExpression { public :)",
    "insertText": "FExpressionDerivative(EDerivativeCoordinate InCoord, const FExpression* InInput) : Input(InInput), Coord(InCoord)"
  },
  {
    "label": "MakeSwizzleMask()",
    "kind": "Method",
    "detail": "Function (} ; FSwizzleParameters)",
    "insertText": "MakeSwizzleMask(bool bInR, bool bInG, bool bInB, bool bInA)"
  },
  {
    "label": "FExpressionSwizzle()",
    "kind": "Method",
    "detail": "Function (class FExpressionSwizzle : public FExpression { public :)",
    "insertText": "FExpressionSwizzle(const FSwizzleParameters& InParams, const FExpression* InInput) : Parameters(InParams) , Input(InInput)"
  },
  {
    "label": "FExpressionComponentMask()",
    "kind": "Method",
    "detail": "Function (} ; class FExpressionComponentMask : public FExpression { public :)",
    "insertText": "FExpressionComponentMask(const FExpression* InInput, const FExpression* InMask) : Input(InInput) , Mask(InMask)"
  },
  {
    "label": "FExpressionAppend()",
    "kind": "Method",
    "detail": "Function (} ; class FExpressionAppend : public FExpression { public :)",
    "insertText": "FExpressionAppend(const FExpression* InLhs, const FExpression* InRhs) : Lhs(InLhs) , Rhs(InRhs)"
  },
  {
    "label": "FExpressionSwitchBase()",
    "kind": "Method",
    "detail": "Function (} ; class FExpressionSwitchBase : public FExpression { public : int8 MaxInputs = 8 ;)",
    "insertText": "FExpressionSwitchBase(TConstArrayView<const FExpression*> InInputs) : NumInputs(static_cast<int8>(InInputs.Num()))"
  },
  {
    "label": "NewSwitch()",
    "kind": "Method",
    "detail": "Function (Input [ i ] = InInputs [ i ] ; } } const FExpression* Input [ MaxInputs ] = { nullptr } ; int8 NumInputs = 0 ; const FExpression*)",
    "insertText": "NewSwitch(FTree& Tree, TConstArrayView<const FExpression*> InInputs)"
  },
  {
    "label": "IsInputActive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsInputActive(const FEmitContext& Context, int32 Index)"
  },
  {
    "label": "FExpressionFeatureLevelSwitch()",
    "kind": "Method",
    "detail": "Function (} ; class FExpressionFeatureLevelSwitch : public FExpressionSwitchBase { public :)",
    "insertText": "FExpressionFeatureLevelSwitch(TConstArrayView<const FExpression*> InInputs)"
  },
  {
    "label": "FExpressionShadingPathSwitch()",
    "kind": "Method",
    "detail": "Function (} ; class FExpressionShadingPathSwitch : public FExpressionSwitchBase { public :)",
    "insertText": "FExpressionShadingPathSwitch(TConstArrayView<const FExpression*> InInputs)"
  },
  {
    "label": "FExpressionQualitySwitch()",
    "kind": "Method",
    "detail": "Function (} ; class FExpressionQualitySwitch : public FExpressionSwitchBase { public :)",
    "insertText": "FExpressionQualitySwitch(TConstArrayView<const FExpression*> InInputs)"
  },
  {
    "label": "FExpressionShaderStageSwitch()",
    "kind": "Method",
    "detail": "Function (} ; class FExpressionShaderStageSwitch : public FExpressionSwitchBase { public :)",
    "insertText": "FExpressionShaderStageSwitch(TConstArrayView<const FExpression*> InInputs)"
  },
  {
    "label": "FExpressionVirtualTextureFeatureSwitch()",
    "kind": "Method",
    "detail": "Function (} ; class FExpressionVirtualTextureFeatureSwitch : public FExpressionSwitchBase { public :)",
    "insertText": "FExpressionVirtualTextureFeatureSwitch(TConstArrayView<const FExpression*> InInputs)"
  },
  {
    "label": "FExpressionDistanceFieldsRenderingSwitch()",
    "kind": "Method",
    "detail": "Function (} ; class FExpressionDistanceFieldsRenderingSwitch : public FExpressionSwitchBase { public :)",
    "insertText": "FExpressionDistanceFieldsRenderingSwitch(TConstArrayView<const FExpression*> InInputs)"
  },
  {
    "label": "FExpressionInlineCustomHLSL()",
    "kind": "Method",
    "detail": "Function (} ; class FExpressionInlineCustomHLSL : public FExpression { public :)",
    "insertText": "FExpressionInlineCustomHLSL(Shader::EValueType InType, FStringView InCode) : Code(InCode), ResultType(InType)"
  },
  {
    "label": "FExpressionCustomHLSL()",
    "kind": "Method",
    "detail": "Function (FStringView Code ; Shader::EValueType ResultType ; } ; class FExpressionCustomHLSL : public FExpression { public :)",
    "insertText": "FExpressionCustomHLSL(FStringView InDeclarationCode, FStringView InFunctionCode, TConstArrayView<FString> InIncludeFilePaths, TArrayView<FCustomHLSLInput> InInputs, const Shader::FStructType* InOutputStructType) : DeclarationCode(InDeclarationCode) , FunctionCode(InFunctionCode) , IncludeFilePaths(InIncludeFilePaths) , Inputs(InInputs) , OutputStructType(InOutputStructType)"
  },
  {
    "label": "FStatementError()",
    "kind": "Method",
    "detail": "Function (FStringView DeclarationCode ; FStringView FunctionCode ; TConstArrayView<FString> IncludeFilePaths ; TArray<FCustomHLSLInput,TInlineAllocator<8>> Inputs ; const Shader::FStructType* OutputStructType = nullptr ; } ; class FStatementError : public FStatement { public :)",
    "insertText": "FStatementError(FStringView InErrorMessage) : ErrorMessage(InErrorMessage)"
  },
  {
    "label": "Prepare()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Prepare(FEmitContext& Context, FEmitScope& Scope)"
  },
  {
    "label": "EmitShader()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EmitShader(FEmitContext& Context, FEmitScope& Scope)"
  },
  {
    "label": "EmitPreshader()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EmitPreshader(FEmitContext& Context, FEmitScope& Scope, const FRequestedType& RequestedType, TArrayView<const FEmitPreshaderScope> Scopes, Shader::FPreshaderData& OutPreshader)"
  },
  {
    "label": "IsLoop()",
    "kind": "Method",
    "detail": "Function (} ; class FStatementLoop : public FStatement { public : FStatement* BreakStatement ; FScope* LoopScope ; FScope* NextScope ; bool)",
    "insertText": "IsLoop()"
  }
]