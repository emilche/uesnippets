[
  {
    "label": "FScenePreUpdateChangeSet",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FScenePreUpdateChangeSet"
  },
  {
    "label": "FScenePostUpdateChangeSet",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FScenePostUpdateChangeSet"
  },
  {
    "label": "FScene",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FScene"
  },
  {
    "label": "FPrimitiveBounds",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPrimitiveBounds"
  },
  {
    "label": "FCullingVolume",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCullingVolume"
  },
  {
    "label": "FSceneCullingBuilder",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSceneCullingBuilder"
  },
  {
    "label": "FSceneCulling",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSceneCulling"
  },
  {
    "label": "FSceneCullingRenderer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSceneCullingRenderer"
  },
  {
    "label": "FUpdater",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FUpdater"
  },
  {
    "label": "alignas",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "alignas"
  },
  {
    "label": "FBlockTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBlockTraits"
  },
  {
    "label": "FCellIndexCacheEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCellIndexCacheEntry"
  },
  {
    "label": "FItem",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FItem"
  },
  {
    "label": "FPrimitiveState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPrimitiveState"
  },
  {
    "label": "EState",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EState"
  },
  {
    "label": "FSceneInstanceCullingQuery",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSceneInstanceCullingQuery"
  },
  {
    "label": "FSphere()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" SpanAllocator . h \" # include \" ConvexVolume . h \" # include \" Rendering / RenderingSpatialHash . h \" # include \" Tasks / Task . h \" # include \" RendererInterface . h \" # include \" RendererPrivateUtils . h \" # include \" PrimitiveSceneInfo . h \" # include \" SceneCullingDefinitions . h \" # include \" HierarchicalSpatialHashGrid . h \" # include \" InstanceDataSceneProxy . h \" class FScenePreUpdateChangeSet ; class FScenePostUpdateChangeSet ; class FScene ; struct FPrimitiveBounds ; struct FCullingVolume { FVector3d WorldToVolumeTranslation ; FConvexVolume ConvexVolume ; FSphere3d Sphere =)",
    "insertText": "FSphere(ForceInit)"
  },
  {
    "label": "FSceneCulling()",
    "kind": "Method",
    "detail": "Function (} ; class FSceneCullingBuilder ; class FSceneCulling { public : uint32 InvalidCellFlag = 1 U<<3 1 ; uint32 TempCellFlag = 1 U<<3 0 ; class FSceneCullingRenderer ;)",
    "insertText": "FSceneCulling(FScene& InScene)"
  },
  {
    "label": "OnPreSceneUpdate()",
    "kind": "Method",
    "detail": "Function (class FUpdater { public : void)",
    "insertText": "OnPreSceneUpdate(FRDGBuilder& GraphBuilder, const FScenePreUpdateChangeSet& ScenePreUpdateData)"
  },
  {
    "label": "OnPostSceneUpdate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnPostSceneUpdate(FRDGBuilder& GraphBuilder, const FScenePostUpdateChangeSet& ScenePostUpdateData)"
  },
  {
    "label": "FinalizeAndClear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FinalizeAndClear(FRDGBuilder& GraphBuilder, FSceneUniformBuffer& SceneUniformBuffer, bool bPublishStats)"
  },
  {
    "label": "FUpdater()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FUpdater()"
  },
  {
    "label": "BeginUpdate()",
    "kind": "Method",
    "detail": "Function (private : class FSceneCulling ; UE::Tasks::FTask PreUpdateTaskHandle ; UE::Tasks::FTask PostUpdateTaskHandle ; FSceneCullingBuilder* Implementation = nullptr ; # if DO_CHECK std::atomic<int32> DebugTaskCounter = 0 ; # endif } ; FUpdater&)",
    "insertText": "BeginUpdate(FRDGBuilder& GraphBuilder, FSceneUniformBuffer& SceneUniformBuffer, bool bAnySceneUpdatesExpected)"
  },
  {
    "label": "EndUpdate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EndUpdate(FRDGBuilder& GraphBuilder, FSceneUniformBuffer& SceneUniformBuffer, bool bPublishStats)"
  },
  {
    "label": "GetUpdateTaskHandle()",
    "kind": "Method",
    "detail": "Function (UE::Tasks::FTask)",
    "insertText": "GetUpdateTaskHandle()"
  },
  {
    "label": "IsEnabled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsEnabled()"
  },
  {
    "label": "TestConvexVolume()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TestConvexVolume(const FConvexVolume& ViewCullVolume, const FVector3d &WorldToVolumeTranslation, TArray<FCellDraw, SceneRenderingAllocator>& OutCellDraws, uint32 ViewGroupId, uint32 MaxNumViews, uint32& OutNumInstanceGroups)"
  },
  {
    "label": "TestSphere()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TestSphere(const FSphere& Sphere, TArray<FCellDraw, SceneRenderingAllocator>& OutCellDraws, uint32 ViewGroupId, uint32 MaxNumViews, uint32& OutNumInstanceGroups)"
  },
  {
    "label": "Test()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Test(const FCullingVolume& CullingVolume, TArray<FCellDraw, SceneRenderingAllocator>& OutCellDraws, uint32 ViewGroupId, uint32 MaxNumViews, uint32& OutNumInstanceGroups)"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (struct)",
    "insertText": "alignas(16)"
  },
  {
    "label": "FBlockLocAligned()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FBlockLocAligned(const RenderingSpatialHash::TLocation<int64> &InLoc) : Data(int32(InLoc.Coord.X), int32(InLoc.Coord.Y), int32(InLoc.Coord.Z), int32(InLoc.Level))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FBlockLocAligned& BlockLocAligned)"
  },
  {
    "label": "GetLevel()",
    "kind": "Method",
    "detail": "Function (Data = BlockLocAligned . Data ; } int32)",
    "insertText": "GetLevel()"
  },
  {
    "label": "GetWorldPosition()",
    "kind": "Method",
    "detail": "Function (} FVector3d)",
    "insertText": "GetWorldPosition()"
  },
  {
    "label": "GetHash()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetHash()"
  },
  {
    "label": "ValidateAllInstanceAllocations()",
    "kind": "Method",
    "detail": "Function (} FIntVector4 Data ; } ; using FBlockLoc = FBlockLocAligned ; struct FBlockTraits { int32 CellBlockDimLog2 = 3 ; using FBlockLoc = FBlockLoc ; int64 MaxCellBlockCoord = MAX_int32 ; int64 MaxCellCoord = MaxCellBlockCoord<<CellBlockDimLog2 ; } ; using FSpatialHash = THierarchicalSpatialHashGrid<FBlockTraits> ; using FLocation64 = FSpatialHash::FLocation64 ; using FLocation32 = FSpatialHash::FLocation32 ; using FLocation8 = FSpatialHash::FLocation8 ; using FFootprint8 = FSpatialHash::FFootprint8 ; using FFootprint32 = FSpatialHash::FFootprint32 ; using FFootprint64 = FSpatialHash::FFootprint64 ; private : void)",
    "insertText": "ValidateAllInstanceAllocations()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty()"
  },
  {
    "label": "CellIndexMask()",
    "kind": "Method",
    "detail": "Function (struct FCellIndexCacheEntry { uint32 SingleInstanceMask = 1 u<<3 1 ; uint32)",
    "insertText": "CellIndexMask(1u << 31)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (uint32 CellIndexMax = 1 u<<3 1 ; struct FItem { int32 NumInstances ; int32 CellIndex ; } ; void)",
    "insertText": "Add(int32 CellIndex, int32 NumInstances)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Items .)",
    "insertText": "Add(CellIndex)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Items .)",
    "insertText": "Add(NumInstances)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} else { Items .)",
    "insertText": "Add(uint32(CellIndex) | SingleInstanceMask)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Set(int32 Index, int32 CellIndex)"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (Items [ Index ] =)",
    "insertText": "uint32(CellIndex)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset()"
  },
  {
    "label": "LoadAndStepItem()",
    "kind": "Method",
    "detail": "Function (} FItem)",
    "insertText": "LoadAndStepItem(int32 &InOutItemIndex)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (FItem Result ; uint32 PackedCellIndex = Items [ InOutItemIndex ] ; Result . CellIndex =)",
    "insertText": "int32(PackedCellIndex & FCellIndexCacheEntry::CellIndexMask)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Result . NumInstances = 1 ;)",
    "insertText": "if((PackedCellIndex & FCellIndexCacheEntry::SingleInstanceMask) == 0u)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (Result . NumInstances =)",
    "insertText": "int32(Items[++InOutItemIndex])"
  },
  {
    "label": "InvalidPayload()",
    "kind": "Method",
    "detail": "Function (} return Result ; } bool bSingleInstanceOnly = false ; TArray<uint32> Items ; } ; struct FPrimitiveState { int32 PayloadBits = 2 8 ; uint32)",
    "insertText": "InvalidPayload(1u << PayloadBits)"
  },
  {
    "label": "FPrimitiveState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPrimitiveState() : InstanceDataOffset(-1) , NumInstances(0) , State(Unknown) , bDynamic(false) , Payload(InvalidPayload)"
  },
  {
    "label": "IsCachedState()",
    "kind": "Method",
    "detail": "Function (} enum EState : uint32 { Unknown,SinglePrim,Precomputed,UnCullable,Dynamic,Cached,} ; bool)",
    "insertText": "IsCachedState()"
  },
  {
    "label": "AllocateChunk()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<FInstanceSceneDataImmutable,ESPMode::ThreadSafe> InstanceSceneDataImmutable ; } ; TArray<FPrimitiveState> PrimitiveStates ; TSparseArray<FCellIndexCacheEntry> CellIndexCache ; int32 TotalCellIndexCacheItems = 0 ; int32 NumDynamicInstances = 0 ; int32 NumStaticInstances = 0 ; class FSceneCullingBuilder ; class FSceneInstanceCullingQuery ; FScene& Scene ; bool bIsEnabled = false ; bool bUseExplictBounds = false ; FSpatialHash SpatialHash ; FUpdater Updater ; TArray<uint32> PackedCellChunkData ; FSpanAllocator CellChunkIdAllocator ; TArray<uint32> PackedCellData ; TArray<uint32> FreeChunks ; TArray<FPackedCellHeader> CellHeaders ; TBitArray<> CellOccupancyMask ; TBitArray<> BlockLevelOccupancyMask ; TArray<FCellBlockData> CellBlockData ; TArray<FPersistentPrimitiveIndex> UnCullablePrimitives ; int32 UncullableItemChunksOffset = INDEX_NONE ; int32 UncullableNumItemChunks = 0 ; int32 SmallFootprintCellSideThreshold = 1 6 ; bool bTestCellVsQueryBounds = true ; bool bUseAsyncUpdate = true ; bool bUseAsyncQuery = true ; bool bPackedCellDataLocked = false ; uint32)",
    "insertText": "AllocateChunk()"
  },
  {
    "label": "FreeChunk()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeChunk(uint32 ChunkId)"
  },
  {
    "label": "LockChunkCellData()",
    "kind": "Method",
    "detail": "Function (uint32*)",
    "insertText": "LockChunkCellData(uint32 ChunkId, int32 NumSlackChunksNeeded)"
  },
  {
    "label": "UnLockChunkCellData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnLockChunkCellData(uint32 ChunkId)"
  },
  {
    "label": "CellIndexToBlockId()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "CellIndexToBlockId(int32 CellIndex)"
  },
  {
    "label": "GetCellLoc()",
    "kind": "Method",
    "detail": "Function (FLocation64)",
    "insertText": "GetCellLoc(int32 CellIndex)"
  },
  {
    "label": "IsUncullable()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsUncullable(const FPrimitiveBounds& Bounds, FPrimitiveSceneInfo* PrimitiveSceneInfo)"
  }
]