[
  {
    "label": "AlignmentArrangeResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AlignmentArrangeResult"
  },
  {
    "label": "GetChildAlignment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GetChildAlignment"
  },
  {
    "label": "FStretchItem",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FStretchItem"
  },
  {
    "label": "AlignmentArrangeResult()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Layout / Children . h \" # include \" Types / SlateStructs . h \" # include \" CoreMinimal . h \" # include \" Margin . h \" # include \" Visibility . h \" # include \" SlateRect . h \" # include \" ArrangedChildren . h \" # include \" FlowDirection . h \" # include \" Templates / UnrealTypeTraits . h \" struct AlignmentArrangeResult {)",
    "insertText": "AlignmentArrangeResult(float InOffset, float InSize ) : Offset(InOffset) , Size(InSize)"
  },
  {
    "label": "AsInt()",
    "kind": "Method",
    "detail": "Function (} float Offset ; float Size ; } ; namespace ArrangeUtils { template<EOrientation Orientation> struct GetChildAlignment { template<SlotType> int32)",
    "insertText": "AsInt(EFlowDirection InFlowDirection, const SlotType& InSlot)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (default : case EFlowDirection::LeftToRight : return static_cast<)",
    "insertText": "int32(InSlot.GetHorizontalAlignment())"
  },
  {
    "label": "AlignFill()",
    "kind": "Method",
    "detail": "Function (} } ; template<EOrientation Orientation> AlignmentArrangeResult)",
    "insertText": "AlignFill(float AllottedSize, const FMargin& SlotPadding, const float ContentScale = 1.0f)"
  },
  {
    "label": "Orientation()",
    "kind": "Method",
    "detail": "Function (const FMargin& Margin = SlotPadding ; const float TotalMargin = Margin . GetTotalSpaceAlong<)",
    "insertText": "Orientation()"
  },
  {
    "label": "MarginPre()",
    "kind": "Method",
    "detail": "Function (const float)",
    "insertText": "MarginPre(Orientation == Orient_Horizontal)"
  },
  {
    "label": "AlignCenter()",
    "kind": "Method",
    "detail": "Function (} template<EOrientation Orientation> AlignmentArrangeResult)",
    "insertText": "AlignCenter(float AllottedSize, float ChildDesiredSize, const FMargin& SlotPadding, const float ContentScale = 1.0f, bool bClampToParent = true)"
  },
  {
    "label": "MarginPost()",
    "kind": "Method",
    "detail": "Function (const float)",
    "insertText": "MarginPost(Orientation == Orient_Horizontal)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (const float ChildSize =)",
    "insertText": "Max((bClampToParent ? FMath::Min(ChildDesiredSize, AllottedSize - TotalMargin) : ChildDesiredSize), 0.f)"
  },
  {
    "label": "AlignChild()",
    "kind": "Method",
    "detail": "Function (} } template<EOrientation Orientation,SlotType> AlignmentArrangeResult)",
    "insertText": "AlignChild(EFlowDirection InLayoutFlow, float AllottedSize, float ChildDesiredSize, const SlotType& ChildToArrange, const FMargin& SlotPadding, const float& ContentScale = 1.0f, bool bClampToParent = true)"
  },
  {
    "label": "AsInt()",
    "kind": "Method",
    "detail": "Function (const int32 Alignment = ArrangeUtils::GetChildAlignment<Orientation)",
    "insertText": "AsInt(InLayoutFlow, ChildToArrange)"
  },
  {
    "label": "AlignmentArrangeResult()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "AlignmentArrangeResult(MarginPre, FMath::Max(( AllottedSize - TotalMargin ) * ContentScale, 0.f))"
  },
  {
    "label": "AlignChild()",
    "kind": "Method",
    "detail": "Function (} template<EOrientation Orientation,SlotType> AlignmentArrangeResult)",
    "insertText": "AlignChild(float AllottedSize, float ChildDesiredSize, const SlotType& ChildToArrange, const FMargin& SlotPadding, const float& ContentScale = 1.0f, bool bClampToParent = true)"
  },
  {
    "label": "AlignChild()",
    "kind": "Method",
    "detail": "Function (} template<EOrientation Orientation,SlotType> AlignmentArrangeResult)",
    "insertText": "AlignChild(EFlowDirection InLayoutFlow, float AllottedSize, const SlotType& ChildToArrange, const FMargin& SlotPadding, const float& ContentScale = 1.0f, bool bClampToParent = true)"
  },
  {
    "label": "ChildDesiredSize()",
    "kind": "Method",
    "detail": "Function (} const float)",
    "insertText": "ChildDesiredSize(Orientation == Orient_Horizontal ) ? ( ChildToArrange.GetWidget()->GetDesiredSize().X * ContentScale ) : ( ChildToArrange.GetWidget()->GetDesiredSize().Y * ContentScale)"
  },
  {
    "label": "AlignmentArrangeResult()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "AlignmentArrangeResult(MarginPre, FMath::Max((AllottedSize - TotalMargin) * ContentScale, 0.f))"
  },
  {
    "label": "AlignChild()",
    "kind": "Method",
    "detail": "Function (} template<EOrientation Orientation,SlotType> AlignmentArrangeResult)",
    "insertText": "AlignChild(float AllottedSize, const SlotType& ChildToArrange, const FMargin& SlotPadding, const float& ContentScale = 1.0f, bool bClampToParent = true)"
  },
  {
    "label": "ArrangeSingleChild()",
    "kind": "Method",
    "detail": "Function (} template<SlotType> void)",
    "insertText": "ArrangeSingleChild(const FGeometry& AllottedGeometry, FArrangedChildren& ArrangedChildren, const SlotType& ChildSlot, const TAttribute<FVector2D>& ContentScale)"
  },
  {
    "label": "SlotType()",
    "kind": "Method",
    "detail": "Function (ArrangeSingleChild<)",
    "insertText": "SlotType(EFlowDirection::LeftToRight, AllottedGeometry, ArrangedChildren, ChildSlot, ContentScale)"
  },
  {
    "label": "ArrangeSingleChild()",
    "kind": "Method",
    "detail": "Function (} template<SlotType> void)",
    "insertText": "ArrangeSingleChild(EFlowDirection InFlowDirection, const FGeometry& AllottedGeometry, FArrangedChildren& ArrangedChildren, const SlotType& ChildSlot, const TAttribute<FVector2D>& ContentScale)"
  },
  {
    "label": "GetWidget()",
    "kind": "Method",
    "detail": "Function (const EVisibility ChildVisibility = ChildSlot .)",
    "insertText": "GetWidget()->GetVisibility()"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (const FVector2D ThisContentScale = ContentScale .)",
    "insertText": "Get()"
  },
  {
    "label": "SlotPadding()",
    "kind": "Method",
    "detail": "Function (const FMargin)",
    "insertText": "SlotPadding(LayoutPaddingWithFlow(InFlowDirection, ChildSlot.GetPadding()))"
  },
  {
    "label": "Orient_Horizontal()",
    "kind": "Method",
    "detail": "Function (const AlignmentArrangeResult XResult = AlignChild<)",
    "insertText": "Orient_Horizontal(InFlowDirection, AllottedGeometry.GetLocalSize().X, ChildSlot, SlotPadding, ThisContentScale.X)"
  },
  {
    "label": "Orient_Vertical()",
    "kind": "Method",
    "detail": "Function (const AlignmentArrangeResult YResult = AlignChild<)",
    "insertText": "Orient_Vertical(AllottedGeometry.GetLocalSize().Y, ChildSlot, SlotPadding, ThisContentScale.Y)"
  },
  {
    "label": "AddWidget()",
    "kind": "Method",
    "detail": "Function (ArrangedChildren .)",
    "insertText": "AddWidget(ChildVisibility, AllottedGeometry.MakeChild( ChildSlot.GetWidget(), FVector2D(XResult.Offset, YResult.Offset), FVector2D(XResult.Size, YResult.Size) ))"
  },
  {
    "label": "ArrangeSingleChild()",
    "kind": "Method",
    "detail": "Function (} } template<SlotType> void)",
    "insertText": "ArrangeSingleChild(const FGeometry& AllottedGeometry, FArrangedChildren& ArrangedChildren, const SlotType& ChildSlot, const FVector2D& ContentScale)"
  },
  {
    "label": "ArrangeSingleChild()",
    "kind": "Method",
    "detail": "Function (} template<SlotType> void)",
    "insertText": "ArrangeSingleChild(EFlowDirection InFlowDirection, const FGeometry& AllottedGeometry, FArrangedChildren& ArrangedChildren, const SlotType& ChildSlot, const FVector2D& ContentScale)"
  },
  {
    "label": "AddWidget()",
    "kind": "Method",
    "detail": "Function (ArrangedChildren .)",
    "insertText": "AddWidget(ChildVisibility, AllottedGeometry.MakeChild( ChildSlot.GetWidget(), FVector2f(XResult.Size, YResult.Size), FSlateLayoutTransform(FVector2f(XResult.Offset, YResult.Offset)) ))"
  },
  {
    "label": "ArrangeChildrenInStack()",
    "kind": "Method",
    "detail": "Function (} } template<EOrientation Orientation,SlotType> void)",
    "insertText": "ArrangeChildrenInStack(EFlowDirection InLayoutFlow, const TPanelChildren<SlotType>& Children, const FGeometry& AllottedGeometry, FArrangedChildren& ArrangedChildren, float InOffset, bool bInAllowShrink)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} ; float GrowStretchCoefficientTotal = 0 . 0 f ; float ShrinkStretchCoefficientTotal = 0 . 0 f ; float FixedSizeTotal = 0 . 0 f ; float StretchSizeTotal = 0 . 0 f ; struct FStretchItem { float Size = 0 . 0 f ; float BasisSize = 0 . 0 f ; float MinSize = 0 . 0 f ; float MaxSize = 0 . 0 f ; float GrowStretchValue = 0 . 0 f ; float ShrinkStretchValue = 0 . 0 f ; bool bFrozen = false ; FSizeParam::ESizeRule SizeRule = FSizeParam::ESizeRule::SizeRule_Auto ; } ; TArray<FStretchItem,TInlineAllocator<1 6>> StretchItems ; StretchItems .)",
    "insertText": "Init({}, Children.Num())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bAnyChildVisible = false ; bool bAnyStretchContentItems = false ; bool bAnyStretchItems = false ;)",
    "insertText": "for(int32 ChildIndex = 0; ChildIndex < Children.Num(); ++ChildIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const SlotType& CurChild = Children [ ChildIndex ] ;)",
    "insertText": "if(CurChild.GetWidget()->GetVisibility() != EVisibility::Collapsed)"
  },
  {
    "label": "GetPadding()",
    "kind": "Method",
    "detail": "Function (bAnyChildVisible = true ; FixedSizeTotal + = CurChild .)",
    "insertText": "GetPadding().template GetTotalSpaceAlong<Orientation>()"
  },
  {
    "label": "GetWidget()",
    "kind": "Method",
    "detail": "Function (FVector2f ChildDesiredSize = CurChild .)",
    "insertText": "GetWidget()->GetDesiredSize()"
  },
  {
    "label": "ChildSize()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "ChildSize(Orientation == Orient_Vertical)"
  },
  {
    "label": "GetMinSize()",
    "kind": "Method",
    "detail": "Function (const float MinSize = CurChild .)",
    "insertText": "GetMinSize()"
  },
  {
    "label": "GetMaxSize()",
    "kind": "Method",
    "detail": "Function (const float MaxSize = CurChild .)",
    "insertText": "GetMaxSize()"
  },
  {
    "label": "GetSizeRule()",
    "kind": "Method",
    "detail": "Function (FStretchItem& Item = StretchItems [ ChildIndex ] ; Item . MinSize = MinSize ; Item . MaxSize = MaxSize ; Item . SizeRule = CurChild .)",
    "insertText": "GetSizeRule()"
  },
  {
    "label": "ClampSize()",
    "kind": "Method",
    "detail": "Function (ChildSize =)",
    "insertText": "ClampSize(ChildSize, MinSize, MaxSize)"
  },
  {
    "label": "GetSizeValue()",
    "kind": "Method",
    "detail": "Function (Item . GrowStretchValue = CurChild .)",
    "insertText": "GetSizeValue()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Item . ShrinkStretchValue = Item . GrowStretchValue ; Item . Size = 0 . 0 f ; Item . BasisSize = 0 . 0 f ; GrowStretchCoefficientTotal + = Item . GrowStretchValue ; ShrinkStretchCoefficientTotal + = Item . ShrinkStretchValue ; StretchSizeTotal + = ChildSize ; bAnyStretchItems = true ; } else)",
    "insertText": "if(CurChild.GetSizeRule() == FSizeParam::SizeRule_StretchContent)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (Item . GrowStretchValue =)",
    "insertText": "Max(0.f, CurChild.GetSizeValue())"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (Item . ShrinkStretchValue =)",
    "insertText": "Max(0.f,CurChild.GetShrinkSizeValue())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Item . Size = ChildSize ; Item . BasisSize = ChildSize ; GrowStretchCoefficientTotal + = Item . GrowStretchValue ; ShrinkStretchCoefficientTotal + = Item . ShrinkStretchValue ; StretchSizeTotal + = ChildSize ; bAnyStretchContentItems = true ; } else { FixedSizeTotal + = ChildSize ; Item . GrowStretchValue = 0 . 0 f ; Item . ShrinkStretchValue = 0 . 0 f ; Item . Size = ChildSize ; Item . BasisSize = ChildSize ; } } })",
    "insertText": "if(!bAnyChildVisible)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (float AvailableSpace =)",
    "insertText": "Max(MinAvailableSpace, AllottedSize - FixedSizeTotal)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (float UsedSpace = 0 . 0 f ;)",
    "insertText": "for(FStretchItem& Item : StretchItems)"
  },
  {
    "label": "ClampSize()",
    "kind": "Method",
    "detail": "Function (const float Size = AvailableSpace* Item . GrowStretchValue / GrowStretchCoefficientTotal ; Item . Size =)",
    "insertText": "ClampSize(Size, Item.MinSize, Item.MaxSize)"
  },
  {
    "label": "bIsGrowing()",
    "kind": "Method",
    "detail": "Function (UsedSpace + = Item . Size ; } } AvailableSpace - = UsedSpace ; } const bool bIsGrowing = AvailableSpace> StretchSizeTotal ; const bool bCanStretch =)",
    "insertText": "bIsGrowing(GrowStretchCoefficientTotal > 0.0f) : (ShrinkStretchCoefficientTotal > 0.0f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (AvailableSpace - = Item . Size ; NumStretchContentItems + + ;)",
    "insertText": "if(bIsGrowing)"
  },
  {
    "label": "IsNearlyZero()",
    "kind": "Method",
    "detail": "Function (Item . bFrozen | =)",
    "insertText": "IsNearlyZero(Item.GrowStretchValue)"
  },
  {
    "label": "IsNearlyZero()",
    "kind": "Method",
    "detail": "Function (} else { Item . bFrozen | =)",
    "insertText": "IsNearlyZero(Item.ShrinkStretchValue)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (} } } const int32 MaxPasses =)",
    "insertText": "Min(NumStretchContentItems, 5)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (break ; } GrowStretchCoefficientTotal = 0 . 0 f ; ShrinkStretchCoefficientTotal = 0 . 0 f ;)",
    "insertText": "for(const FStretchItem& Item : StretchItems)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (GrowStretchCoefficientTotal + = Item . GrowStretchValue ; ShrinkStretchCoefficientTotal + = Item . ShrinkStretchValue* Item . BasisSize ; } } const float StretchCoefficientTotal = bIsGrowing ? GrowStretchCoefficientTotal : ShrinkStretchCoefficientTotal ;)",
    "insertText": "if(StretchCoefficientTotal < UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "bIsGrowing()",
    "kind": "Method",
    "detail": "Function (const float SizeAdjust =)",
    "insertText": "bIsGrowing(AvailableSpace * (Item.GrowStretchValue / GrowStretchCoefficientTotal)) : (AvailableSpace * (Item.ShrinkStretchValue * Item.BasisSize / ShrinkStretchCoefficientTotal))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Item . bFrozen = true ; continue ; } const float MinSize = Item . MinSize ; const float MaxSize = Item . MaxSize ; const bool bHasMaxConstraint = MaxSize> 0 . 0 f ;)",
    "insertText": "if((Item.Size + SizeAdjust) <= MinSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ConsumedSpace + = MinSize - Item . Size ; Item . Size = MinSize ; Item . bFrozen = true ; } else)",
    "insertText": "if(bHasMaxConstraint && (Item.Size + SizeAdjust) >= MaxSize)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (ConsumedSpace + = MaxSize - Item . Size ; Item . Size = MaxSize ; Item . bFrozen = true ; } else { ConsumedSpace + = SizeAdjust ; Item . Size + = SizeAdjust ; } } } AvailableSpace - = ConsumedSpace ; } } float PositionSoFar = 0 . 0 f ;)",
    "insertText": "for(TPanelChildrenConstIterator<SlotType> It(Children, Orientation, InLayoutFlow); It; ++It)"
  },
  {
    "label": "GetIndex()",
    "kind": "Method",
    "detail": "Function (const float ChildSize = StretchItems [ It .)",
    "insertText": "GetIndex()"
  },
  {
    "label": "SlotPadding()",
    "kind": "Method",
    "detail": "Function (const FMargin)",
    "insertText": "SlotPadding(LayoutPaddingWithFlow(InLayoutFlow, CurChild.GetPadding()))"
  },
  {
    "label": "SlotSize()",
    "kind": "Method",
    "detail": "Function (FVector2f)",
    "insertText": "SlotSize(Orientation == Orient_Vertical) ? FVector2f(AllottedGeometry.GetLocalSize().X, ChildSize + SlotPadding.template GetTotalSpaceAlong<Orient_Vertical>()) : FVector2f(ChildSize + SlotPadding.template GetTotalSpaceAlong<Orient_Horizontal>(), AllottedGeometry.GetLocalSize().Y)"
  },
  {
    "label": "Orient_Horizontal()",
    "kind": "Method",
    "detail": "Function (const AlignmentArrangeResult XAlignmentResult = AlignChild<)",
    "insertText": "Orient_Horizontal(InLayoutFlow, SlotSize.X, CurChild, SlotPadding)"
  },
  {
    "label": "Orient_Vertical()",
    "kind": "Method",
    "detail": "Function (const AlignmentArrangeResult YAlignmentResult = AlignChild<)",
    "insertText": "Orient_Vertical(SlotSize.Y, CurChild, SlotPadding)"
  },
  {
    "label": "LocalPosition()",
    "kind": "Method",
    "detail": "Function (const FVector2f)",
    "insertText": "LocalPosition(Orientation == Orient_Vertical) ? FVector2f(XAlignmentResult.Offset, PositionSoFar + YAlignmentResult.Offset + InOffset) : FVector2f(PositionSoFar + XAlignmentResult.Offset + InOffset, YAlignmentResult.Offset)"
  },
  {
    "label": "FVector2f()",
    "kind": "Method",
    "detail": "Function (const FVector2f LocalSize =)",
    "insertText": "FVector2f(XAlignmentResult.Size, YAlignmentResult.Size)"
  },
  {
    "label": "AddWidget()",
    "kind": "Method",
    "detail": "Function (ArrangedChildren .)",
    "insertText": "AddWidget(ChildVisibility, AllottedGeometry.MakeChild( CurChild.GetWidget(), LocalPosition, LocalSize ))"
  },
  {
    "label": "PositionSoFar()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PositionSoFar(Orientation == Orient_Vertical)"
  },
  {
    "label": "LayoutPaddingWithFlow()",
    "kind": "Method",
    "detail": "Function (} } } FMargin)",
    "insertText": "LayoutPaddingWithFlow(EFlowDirection InLayoutFlow, const FMargin& InPadding)"
  },
  {
    "label": "ReturnPadding()",
    "kind": "Method",
    "detail": "Function (FMargin)",
    "insertText": "ReturnPadding(InPadding)"
  },
  {
    "label": "ComputePopupFitInRect()",
    "kind": "Method",
    "detail": "Function (float Temp = ReturnPadding . Left ; ReturnPadding . Left = ReturnPadding . Right ; ReturnPadding . Right = Temp ; } return ReturnPadding ; } UE::Slate::FDeprecateVector2DResult)",
    "insertText": "ComputePopupFitInRect(const FSlateRect& InAnchor, const FSlateRect& PopupRect, const EOrientation& Orientation, const FSlateRect& RectToFit)"
  }
]