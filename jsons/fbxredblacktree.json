[
  {
    "label": "FbxRedBlackConstIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FbxRedBlackConstIterator"
  },
  {
    "label": "FbxRedBlackIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FbxRedBlackIterator"
  },
  {
    "label": "FbxRedBlackTree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FbxRedBlackTree"
  },
  {
    "label": "RecordType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RecordType"
  },
  {
    "label": "ETreeType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ETreeType"
  },
  {
    "label": "FbxRedBlackIterator()",
    "kind": "Method",
    "detail": "Function (# ifndef _FBXSDK_CORE_BASE_REDBLACKTREE_H_ # define _FBXSDK_CORE_BASE_REDBLACKTREE_H_ # include<fbxsdk / fbxsdk_def . h> # include<fbxsdk / core / base / fbxcontainerallocators . h> # include<fbxsdk / core / base / fbxpair . h> # include<fbxsdk / fbxsdk_nsbegin . h> # ifndef DOXYGEN_SHOULD_SKIP_THIS template<RecordType> class FbxRedBlackConstIterator ; template<RecordType> class FbxRedBlackIterator { public :)",
    "insertText": "FbxRedBlackIterator() : mRecord(0)"
  },
  {
    "label": "FbxRedBlackIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FbxRedBlackIterator(RecordType* pRecord) : mRecord(pRecord)"
  },
  {
    "label": "FbxRedBlackIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FbxRedBlackIterator(const FbxRedBlackIterator<RecordType>& pV) : mRecord(pV.mRecord)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FbxRedBlackIterator&)",
    "insertText": "operator()"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(mRecord != NULL)"
  },
  {
    "label": "Successor()",
    "kind": "Method",
    "detail": "Function (mRecord = mRecord ->)",
    "insertText": "Successor()"
  },
  {
    "label": "t()",
    "kind": "Method",
    "detail": "Function (FbxRedBlackIterator)",
    "insertText": "t(*this)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(mRecord)"
  },
  {
    "label": "Predecessor()",
    "kind": "Method",
    "detail": "Function (mRecord = mRecord ->)",
    "insertText": "Predecessor()"
  },
  {
    "label": "FbxRedBlackConstIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FbxRedBlackConstIterator(const RecordType* pRecord) : mRecord(pRecord)"
  },
  {
    "label": "FbxRedBlackConstIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FbxRedBlackConstIterator(const FbxRedBlackIterator<RecordType>& pV) : mRecord(pV.mRecord)"
  },
  {
    "label": "FbxRedBlackConstIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FbxRedBlackConstIterator(const FbxRedBlackConstIterator<RecordType>& pV) : mRecord(pV.mRecord)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (} ConstValueType&)",
    "insertText": "GetValue()"
  },
  {
    "label": "Minimum()",
    "kind": "Method",
    "detail": "Function (} const RecordType*)",
    "insertText": "Minimum()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const RecordType* lParent = 0 ; const RecordType* lNode = this ;)",
    "insertText": "while(lNode != 0)"
  },
  {
    "label": "Maximum()",
    "kind": "Method",
    "detail": "Function (lParent = lNode ; lNode = lNode -> mLeftChild ; } return lParent ; } const RecordType*)",
    "insertText": "Maximum()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} else { const RecordType* lParent = mParent ; const RecordType* lNode = this ;)",
    "insertText": "while(lParent && lParent->mLefttChild == lNode)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} else { RecordType* lParent = mParent ; RecordType* lNode = this ;)",
    "insertText": "while(lParent && lParent->mLeftChild == lNode)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} else { const RecordType* lParent = mParent ; const RecordType* lNode = this ;)",
    "insertText": "while(lParent && lParent->mRightChild == lNode)"
  },
  {
    "label": "GetBlackDepth()",
    "kind": "Method",
    "detail": "Function (lNode = lParent ; lParent = lParent -> mParent ; } return lParent ; } } int)",
    "insertText": "GetBlackDepth()"
  },
  {
    "label": "RecordType()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RecordType(const RecordType& pRecordType) : mData(pRecordType.mData) , mParent(0) , mLeftChild(0) , mRightChild(0) , mColor(pRecordType.mColor) , mBlackDepth(pRecordType.mBlackDepth)"
  },
  {
    "label": "FbxRedBlackTree()",
    "kind": "Method",
    "detail": "Function (} DataType mData ; class FbxRedBlackTree ; RecordType* mParent ; RecordType* mLeftChild ; RecordType* mRightChild ; unsigned int mColor : 2 ; unsigned int mBlackDepth : 3 0 ; } ; public : typedef FbxRedBlackConstIterator<RecordType> ConstIteratorType ; typedef FbxRedBlackIterator<RecordType> IteratorType ;)",
    "insertText": "FbxRedBlackTree() : mRoot(0), mAllocator(sizeof(RecordType)), mSize(0)"
  },
  {
    "label": "FbxRedBlackTree()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FbxRedBlackTree(const FbxRedBlackTree& pTree) : mRoot(0), mAllocator(sizeof(RecordType)), mSize(0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(pTree)"
  },
  {
    "label": "FbxRedBlackTree()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FbxRedBlackTree()"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Clear()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FbxRedBlackTree&)",
    "insertText": "operator(const FbxRedBlackTree& pTree)"
  },
  {
    "label": "AllocateRecords()",
    "kind": "Method",
    "detail": "Function (void* lBuffer = mAllocator .)",
    "insertText": "AllocateRecords()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (mRoot =)",
    "insertText": "new(lBuffer) RecordType(*(pTree.mRoot))"
  },
  {
    "label": "DuplicateSubTree()",
    "kind": "Method",
    "detail": "Function (mRoot -> mLeftChild =)",
    "insertText": "DuplicateSubTree(pTree.mRoot->mLeftChild)"
  },
  {
    "label": "DuplicateSubTree()",
    "kind": "Method",
    "detail": "Function (mRoot -> mRightChild =)",
    "insertText": "DuplicateSubTree(pTree.mRoot->mRightChild)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mRoot -> mLeftChild -> mParent = mRoot ; })",
    "insertText": "if(mRoot->mRightChild)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (mRoot -> mRightChild -> mParent = mRoot ; } } else {)",
    "insertText": "FBX_ASSERT(pTree.mSize == 0)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(mRoot == 0)"
  },
  {
    "label": "Iter1()",
    "kind": "Method",
    "detail": "Function (ConstIteratorType End ; ConstIteratorType)",
    "insertText": "Iter1(Minimum())"
  },
  {
    "label": "Iter2()",
    "kind": "Method",
    "detail": "Function (ConstIteratorType)",
    "insertText": "Iter2(pTree.Minimum())"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (+ + Iter1 ; + + Iter2 ; } return Iter1 = = End&& Iter2 = = End ; } void)",
    "insertText": "Reserve(unsigned int pRecordCount)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (mAllocator .)",
    "insertText": "Reserve(pRecordCount)"
  },
  {
    "label": "GetSize()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "GetSize()"
  },
  {
    "label": "GetKey()",
    "kind": "Method",
    "detail": "Function (const KeyType& lNodeKey = lNode ->)",
    "insertText": "GetKey()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lParent = lNode ; lNode = lNode -> mRightChild ; } else)",
    "insertText": "if(lCompareKeys(lNodeKey, lDataKey) > 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lParent = lNode ; lNode = lNode -> mLeftChild ; } else { break ; } })",
    "insertText": "if(lNode == 0)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (lNode =)",
    "insertText": "new(lBuffer) RecordType(pData)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (mSize + + ;)",
    "insertText": "FBX_ASSERT(lNode == lBuffer)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(lParent->mRightChild == 0)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (lParent -> mRightChild = lNode ; lNode -> mParent = lParent ; } else {)",
    "insertText": "FBX_ASSERT(lParent->mLeftChild == 0)"
  },
  {
    "label": "FixNodesAfterInsertion()",
    "kind": "Method",
    "detail": "Function (lParent -> mLeftChild = lNode ; lNode -> mParent = lParent ; } } else { mRoot = lNode ; })",
    "insertText": "FixNodesAfterInsertion(lNode)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (lResult = true ; } return FbxPair<RecordType*,)",
    "insertText": "bool(lNode, lResult)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Remove(const KeyType& pKey)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lNode = lNode -> mRightChild ; } else)",
    "insertText": "if(lCompareKeys(lNode->GetKey(), pKey) > 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lNode = lNode -> mLeftChild ; } else { break ; } })",
    "insertText": "if(lNode)"
  },
  {
    "label": "RemoveNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveNode(lNode)"
  },
  {
    "label": "RecordType()",
    "kind": "Method",
    "detail": "Function (mSize - - ; lNode -> ~)",
    "insertText": "RecordType()"
  },
  {
    "label": "FreeMemory()",
    "kind": "Method",
    "detail": "Function (mAllocator .)",
    "insertText": "FreeMemory(lNode)"
  },
  {
    "label": "ClearSubTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearSubTree(mRoot->mLeftChild)"
  },
  {
    "label": "ClearSubTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearSubTree(mRoot->mRightChild)"
  },
  {
    "label": "FreeMemory()",
    "kind": "Method",
    "detail": "Function (mAllocator .)",
    "insertText": "FreeMemory(mRoot)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (} else { return 0 ; } } const RecordType*)",
    "insertText": "Find(const KeyType& pKey)"
  },
  {
    "label": "UpperBound()",
    "kind": "Method",
    "detail": "Function (lNode = lNode -> mLeftChild ; } else { break ; } } return lNode ; } const RecordType*)",
    "insertText": "UpperBound(const KeyType& pKey)"
  },
  {
    "label": "DuplicateSubTree()",
    "kind": "Method",
    "detail": "Function (lCandidate = lNode ; lNode = lNode -> mLeftChild ; } } return lCandidate ; } protected : RecordType* mRoot ; AllocatorType mAllocator ; int mSize ; RecordType*)",
    "insertText": "DuplicateSubTree(const RecordType* pNode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (RecordType* lNewSubTree = 0 ;)",
    "insertText": "if(pNode)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (lNewSubTree =)",
    "insertText": "new(lBuffer) RecordType(*pNode)"
  },
  {
    "label": "DuplicateSubTree()",
    "kind": "Method",
    "detail": "Function (lNewSubTree -> mLeftChild =)",
    "insertText": "DuplicateSubTree(pNode->mLeftChild)"
  },
  {
    "label": "DuplicateSubTree()",
    "kind": "Method",
    "detail": "Function (lNewSubTree -> mRightChild =)",
    "insertText": "DuplicateSubTree(pNode->mRightChild)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lNewSubTree -> mLeftChild -> mParent = lNewSubTree ; })",
    "insertText": "if(lNewSubTree->mRightChild)"
  },
  {
    "label": "FixNodesAfterInsertion()",
    "kind": "Method",
    "detail": "Function (lNewSubTree -> mRightChild -> mParent = lNewSubTree ; } } return lNewSubTree ; } void)",
    "insertText": "FixNodesAfterInsertion(RecordType* pNode)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (RecordType* lNode = pNode ; bool lDone = false ;)",
    "insertText": "while(!lDone)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lDone = true ;)",
    "insertText": "if(lNode->mParent == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lNode -> mColor = RecordType::eBlack ; } else)",
    "insertText": "if(lNode->mParent->mColor == RecordType::eRed)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (RecordType* lUncle = 0 ;)",
    "insertText": "if((lNode->mParent != NULL) && (lNode->mParent->mParent != NULL))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lUncle = lNode -> mParent -> mParent -> mRightChild ; } else)",
    "insertText": "if(lNode->mParent == lNode->mParent->mParent->mRightChild)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lNode -> mParent -> mColor = RecordType::eBlack ; lUncle -> mColor = RecordType::eBlack ; lNode -> mParent -> mParent -> mColor = RecordType::eRed ; lNode = lNode -> mParent -> mParent ; lDone = false ; } else {)",
    "insertText": "if((lNode == lNode->mParent->mRightChild) && (lNode->mParent == lNode->mParent->mParent->mLeftChild))"
  },
  {
    "label": "LeftRotate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LeftRotate(lNode->mParent)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lNode = lNode -> mLeftChild ; } else)",
    "insertText": "if((lNode == lNode->mParent->mLeftChild) && (lNode->mParent == lNode->mParent->mParent->mRightChild))"
  },
  {
    "label": "RightRotate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RightRotate(lNode->mParent)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lNode = lNode -> mRightChild ; } lNode -> mParent -> mColor = RecordType::eBlack ; lNode -> mParent -> mParent -> mColor = RecordType::eRed ;)",
    "insertText": "if((lNode == lNode->mParent->mLeftChild) && (lNode->mParent == lNode->mParent->mParent->mLeftChild))"
  },
  {
    "label": "RightRotate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RightRotate(lNode->mParent->mParent)"
  },
  {
    "label": "LeftRotate()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "LeftRotate(lNode->mParent->mParent)"
  },
  {
    "label": "LeftRotate()",
    "kind": "Method",
    "detail": "Function (} } } } } mRoot -> mColor = RecordType::eBlack ; } void)",
    "insertText": "LeftRotate(RecordType* pNode)"
  },
  {
    "label": "FBX_ASSERT_RETURN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT_RETURN(pNode)"
  },
  {
    "label": "FBX_ASSERT_RETURN()",
    "kind": "Method",
    "detail": "Function (RecordType* lNode = pNode -> mRightChild ;)",
    "insertText": "FBX_ASSERT_RETURN(lNode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef _DEBUG RecordType* A = pNode -> mLeftChild ; RecordType* B = lNode -> mLeftChild ; RecordType* C = lNode -> mRightChild ; RecordType* Z = pNode -> mParent ; # endif pNode -> mRightChild = lNode -> mLeftChild ;)",
    "insertText": "if(pNode->mRightChild)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pNode -> mRightChild -> mParent = pNode ; } lNode -> mParent = pNode -> mParent ;)",
    "insertText": "if(pNode->mParent == 0)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(mRoot == pNode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mRoot = lNode ; } else)",
    "insertText": "if(pNode == pNode->mParent->mLeftChild)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (pNode -> mParent -> mLeftChild = lNode ; } else { pNode -> mParent -> mRightChild = lNode ; } pNode -> mParent = lNode ; lNode -> mLeftChild = pNode ;)",
    "insertText": "FBX_ASSERT(pNode->mLeftChild == A)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(pNode->mRightChild == B)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(pNode->mParent == lNode)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(lNode->mLeftChild == pNode)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(lNode->mRightChild == C)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(lNode->mParent == Z)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(A == 0 || A->mParent == pNode)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(B == 0 || B->mParent == pNode)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(C == 0 || C->mParent == lNode)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(Z == 0 || Z->mLeftChild == lNode || Z->mRightChild == lNode)"
  },
  {
    "label": "RightRotate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RightRotate(RecordType* pNode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (RecordType* lNode = pNode -> mLeftChild ; # ifdef _DEBUG RecordType* A = lNode -> mLeftChild ; RecordType* B = lNode -> mRightChild ; RecordType* C = pNode -> mRightChild ; RecordType* Z = pNode -> mParent ; # endif pNode -> mLeftChild = lNode -> mRightChild ;)",
    "insertText": "if(pNode->mLeftChild)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mRoot = lNode ; } else)",
    "insertText": "if(pNode == pNode->mParent->mRightChild)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (pNode -> mParent -> mRightChild = lNode ; } else { pNode -> mParent -> mLeftChild = lNode ; } pNode -> mParent = lNode ; lNode -> mRightChild = pNode ;)",
    "insertText": "FBX_ASSERT(lNode->mLeftChild == A)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(lNode->mRightChild == pNode)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(pNode->mLeftChild == B)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(pNode->mRightChild == C)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(A == 0 || A->mParent == lNode)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(C == 0 || C->mParent == pNode)"
  },
  {
    "label": "RemoveNode()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveNode(RecordType* pNode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pNode -> mParent -> mLeftChild = 0 ; } else)",
    "insertText": "if(pNode->mParent->mRightChild == pNode)"
  },
  {
    "label": "FBX_ASSERT_NOW()",
    "kind": "Method",
    "detail": "Function (pNode -> mParent -> mRightChild = 0 ; } else {)",
    "insertText": "FBX_ASSERT_NOW(\"Node not found in FbxRedBlackTree\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mRoot = 0 ; })",
    "insertText": "if(pNode->mColor == RecordType::eBlack)"
  },
  {
    "label": "FixNodesAfterRemoval()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FixNodesAfterRemoval(pNode->mParent, 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "if(pNode->mParent)"
  },
  {
    "label": "FixNodesAfterRemoval()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FixNodesAfterRemoval(pNode->mRightChild->mParent, pNode->mRightChild)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } else {)",
    "insertText": "if(pNode->mRightChild == 0)"
  },
  {
    "label": "FixNodesAfterRemoval()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FixNodesAfterRemoval(pNode->mLeftChild->mParent, pNode->mLeftChild)"
  },
  {
    "label": "RemoveNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveNode(lMinRightNode)"
  },
  {
    "label": "ReplaceNode()",
    "kind": "Method",
    "detail": "Function (lMinRightNode -> mColor = pNode -> mColor ;)",
    "insertText": "ReplaceNode(pNode, lMinRightNode)"
  },
  {
    "label": "ReplaceNode()",
    "kind": "Method",
    "detail": "Function (} } pNode -> mParent = 0 ; pNode -> mLeftChild = 0 ; pNode -> mRightChild = 0 ; } void)",
    "insertText": "ReplaceNode(RecordType* pNodeToReplace, RecordType* pReplacement)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pReplacement -> mParent = pNodeToReplace -> mParent ;)",
    "insertText": "if(pNodeToReplace->mParent)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pNodeToReplace -> mParent -> mLeftChild = pReplacement ; } else)",
    "insertText": "if(pNodeToReplace->mParent->mRightChild == pNodeToReplace)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (pNodeToReplace -> mParent -> mRightChild = pReplacement ; } } else {)",
    "insertText": "FBX_ASSERT(mRoot == pNodeToReplace)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mRoot = pReplacement ; } pReplacement -> mLeftChild = pNodeToReplace -> mLeftChild ;)",
    "insertText": "if(pReplacement->mLeftChild)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pReplacement -> mLeftChild -> mParent = pReplacement ; } pReplacement -> mRightChild = pNodeToReplace -> mRightChild ;)",
    "insertText": "if(pReplacement->mRightChild)"
  },
  {
    "label": "Sibling()",
    "kind": "Method",
    "detail": "Function (pReplacement -> mRightChild -> mParent = pReplacement ; } } RecordType*)",
    "insertText": "Sibling(const RecordType* pParent, const RecordType* pNode)"
  },
  {
    "label": "FixNodesAfterRemoval()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "FixNodesAfterRemoval(RecordType* pParent, RecordType* pNode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lDone = true ;)",
    "insertText": "if(!IsBlack(lNode))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lNode -> mColor = RecordType::eBlack ; } else)",
    "insertText": "if(lParent != NULL)"
  },
  {
    "label": "Sibling()",
    "kind": "Method",
    "detail": "Function (RecordType* lSibling =)",
    "insertText": "Sibling(lParent, lNode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lParent -> mColor = RecordType::eRed ; lSibling -> mColor = RecordType::eBlack ;)",
    "insertText": "if(lNode == lParent->mLeftChild)"
  },
  {
    "label": "LeftRotate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LeftRotate(lParent)"
  },
  {
    "label": "RightRotate()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "RightRotate(lParent)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(lSibling && IsBlack(lParent) && IsBlack(lSibling) && IsBlack(lSibling->mLeftChild) && IsBlack(lSibling->mRightChild))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lSibling -> mColor = RecordType::eRed ; lNode = lParent ; lParent = lParent -> mParent ; lDone = false ; } else {)",
    "insertText": "if(!IsBlack(lParent) && IsBlack(lSibling) && ((lSibling == 0) || IsBlack(lSibling->mLeftChild)) && ((lSibling == 0) || IsBlack(lSibling->mRightChild)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lSibling -> mColor = RecordType::eRed ; } lParent -> mColor = RecordType::eBlack ; } else)",
    "insertText": "if(lSibling != 0)"
  },
  {
    "label": "RightRotate()",
    "kind": "Method",
    "detail": "Function (lSibling -> mColor = RecordType::eRed ; lSibling -> mLeftChild -> mColor = RecordType::eBlack ;)",
    "insertText": "RightRotate(lSibling)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((lNode == lParent->mRightChild) && IsBlack(lSibling) && IsBlack(lSibling->mLeftChild) && !IsBlack(lSibling->mRightChild))"
  },
  {
    "label": "LeftRotate()",
    "kind": "Method",
    "detail": "Function (lSibling -> mColor = RecordType::eRed ; lSibling -> mRightChild -> mColor = RecordType::eBlack ;)",
    "insertText": "LeftRotate(lSibling)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(lSibling != 0 && lParent != 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(lSibling->mLeftChild)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } } } })",
    "insertText": "if(mRoot)"
  },
  {
    "label": "ClearSubTree()",
    "kind": "Method",
    "detail": "Function (mRoot -> mColor = RecordType::eBlack ; } } void)",
    "insertText": "ClearSubTree(RecordType* pNode)"
  },
  {
    "label": "ClearSubTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearSubTree(pNode->mLeftChild)"
  },
  {
    "label": "ClearSubTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearSubTree(pNode->mRightChild)"
  },
  {
    "label": "FreeMemory()",
    "kind": "Method",
    "detail": "Function (mAllocator .)",
    "insertText": "FreeMemory(pNode)"
  },
  {
    "label": "GetSubTreeSize()",
    "kind": "Method",
    "detail": "Function (} } int)",
    "insertText": "GetSubTreeSize(RecordType* pNode)"
  },
  {
    "label": "IsSane()",
    "kind": "Method",
    "detail": "Function (} else { return 0 ; } } # if 0 void)",
    "insertText": "IsSane()"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT((mRoot == 0) || (mRoot->mColor == RecordType::eBlack))"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(((mRoot == 0) && (mSize == 0)) || (mRoot != 0) && (mSize != 0))"
  },
  {
    "label": "IsSubTreeSane()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IsSubTreeSane(mRoot)"
  },
  {
    "label": "ComputeBlackDepth()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ComputeBlackDepth(mRoot, 0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (RecordType* lNode = mRoot ; unsigned int lLeafBlackDepth = 0 ;)",
    "insertText": "while(lNode)"
  },
  {
    "label": "mBlackDepth()",
    "kind": "Method",
    "detail": "Function (lLeafBlackDepth = lNode ->)",
    "insertText": "mBlackDepth((lNode->mColor == RecordType::eBlack) ? 1 : 0)"
  },
  {
    "label": "CheckLeavesBlackDepth()",
    "kind": "Method",
    "detail": "Function (} lNode = lNode -> mLeftChild ; })",
    "insertText": "CheckLeavesBlackDepth(mRoot, lLeafBlackDepth)"
  },
  {
    "label": "IsSubTreeSane()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "IsSubTreeSane(const RecordType* pNode)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(pNode != pNode->mParent)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(pNode != pNode->mLeftChild)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT(pNode != pNode->mRightChild)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT((pNode->mColor == RecordType::eBlack) || (pNode->mLeftChild == NULL) || (pNode->mLeftChild->mColor == RecordType::eBlack))"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT((pNode->mColor == RecordType::eBlack) || (pNode->mRightChild == NULL) || (pNode->mRightChild->mColor == RecordType::eBlack))"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT((pNode->mLeftChild == 0 || lCompareKeys(pNode->GetKey(), pNode->mLeftChild->GetKey()) > 0))"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT((pNode->mRightChild == 0 || lCompareKeys(pNode->GetKey(), pNode->mRightChild->GetKey()) < 0))"
  },
  {
    "label": "IsSubTreeSane()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IsSubTreeSane(pNode->mLeftChild)"
  },
  {
    "label": "IsSubTreeSane()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IsSubTreeSane(pNode->mRightChild)"
  },
  {
    "label": "ComputeBlackDepth()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "ComputeBlackDepth(RecordType* pNode, unsigned int pDepth)"
  },
  {
    "label": "ComputeBlackDepth()",
    "kind": "Method",
    "detail": "Function (pDepth + + ; })",
    "insertText": "ComputeBlackDepth(pNode->mLeftChild, pDepth)"
  },
  {
    "label": "ComputeBlackDepth()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ComputeBlackDepth(pNode->mRightChild, pDepth)"
  },
  {
    "label": "CheckLeavesBlackDepth()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "CheckLeavesBlackDepth(RecordType* pNode, unsigned int pBlackDepth)"
  },
  {
    "label": "FBX_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBX_ASSERT((pNode->mBlackDepth + ((pNode->mColor == RecordType::eBlack) ? 1 : 0)) == pBlackDepth)"
  },
  {
    "label": "CheckLeavesBlackDepth()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CheckLeavesBlackDepth(pNode->mLeftChild, pBlackDepth)"
  }
]