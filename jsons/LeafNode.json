[
  {
    "label": "TestLeaf",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TestLeaf"
  },
  {
    "label": "TestLeafIO",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TestLeafIO"
  },
  {
    "label": "SameLeafConfig",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SameLeafConfig"
  },
  {
    "label": "LeafNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LeafNode"
  },
  {
    "label": "ValueConverter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValueConverter"
  },
  {
    "label": "SameConfiguration",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SameConfiguration"
  },
  {
    "label": "ValueOn",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValueOn"
  },
  {
    "label": "ValueOff",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValueOff"
  },
  {
    "label": "ValueAll",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValueAll"
  },
  {
    "label": "ChildOn",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ChildOn"
  },
  {
    "label": "ChildOff",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ChildOff"
  },
  {
    "label": "ChildAll",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ChildAll"
  },
  {
    "label": "ValueIter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValueIter"
  },
  {
    "label": "ChildIter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ChildIter"
  },
  {
    "label": "DenseIter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DenseIter"
  },
  {
    "label": "IteratorBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IteratorBase"
  },
  {
    "label": "Local",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Local"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_TREE_LEAFNODE_HAS_BEEN_INCLUDED # define OPENVDB_TREE_LEAFNODE_HAS_BEEN_INCLUDED # include<openvdb / Types . h> # include<openvdb / util / NodeMasks . h> # include<openvdb / io / Compression . h> # include \" Iterator . h \" # include \" LeafBuffer . h \" # include<algorithm> # include<iostream> # include<memory> # include<sstream> # include<string> # include<type_traits> # include<vector> class TestLeaf ; template<> class TestLeafIO ; namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace tree { template<Index,> struct SameLeafConfig ; template<T,Index Log2Dim> class LeafNode { public : using BuildType = T ; using ValueType = T ; using Buffer = LeafBuffer<ValueType,Log2Dim> ; using LeafNodeType = LeafNode<ValueType,Log2Dim> ; using NodeMaskType = util::NodeMask<Log2Dim> ; using Ptr = SharedPtr<LeafNode> ; const Index LOG2DIM = Log2Dim,TOTAL = Log2Dim,DIM = 1<<TOTAL,NUM_VALUES = 1<<3* Log2Dim,NUM_VOXELS = NUM_VALUES,SIZE = NUM_VALUES,LEVEL = 0 ; template<OtherValueType> struct ValueConverter { using Type = LeafNode<OtherValueType,Log2Dim> ; } ; template<OtherNodeType> struct SameConfiguration { const bool value = SameLeafConfig<LOG2DIM,OtherNodeType>::value ; } ;)",
    "insertText": "LeafNode()"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LeafNode(const Coord& coords, const ValueType& value = zeroVal<ValueType>(), bool active = false)"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LeafNode(PartialCreate, const Coord& coords, const ValueType& value = zeroVal<ValueType>(), bool active = false)"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LeafNode(const LeafNode&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (LeafNode&)",
    "insertText": "operator(const LeafNode&)"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (template<OtherValueType>)",
    "insertText": "LeafNode(const LeafNode<OtherValueType, Log2Dim>& other)"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (template<OtherValueType>)",
    "insertText": "LeafNode(const LeafNode<OtherValueType, Log2Dim>& other, const ValueType& offValue, const ValueType& onValue, TopologyCopy)"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (template<OtherValueType>)",
    "insertText": "LeafNode(const LeafNode<OtherValueType, Log2Dim>& other, const ValueType& background, TopologyCopy)"
  },
  {
    "label": "log2dim()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "log2dim()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (dims .)",
    "insertText": "push_back(Log2Dim)"
  },
  {
    "label": "getChildDim()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "getChildDim()"
  },
  {
    "label": "nonLeafCount()",
    "kind": "Method",
    "detail": "Function (} Index32)",
    "insertText": "nonLeafCount()"
  },
  {
    "label": "offVoxelCount()",
    "kind": "Method",
    "detail": "Function (} Index64)",
    "insertText": "offVoxelCount()"
  },
  {
    "label": "onLeafVoxelCount()",
    "kind": "Method",
    "detail": "Function (} Index64)",
    "insertText": "onLeafVoxelCount()"
  },
  {
    "label": "offLeafVoxelCount()",
    "kind": "Method",
    "detail": "Function (} Index64)",
    "insertText": "offLeafVoxelCount()"
  },
  {
    "label": "onTileCount()",
    "kind": "Method",
    "detail": "Function (} Index64)",
    "insertText": "onTileCount()"
  },
  {
    "label": "isDense()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isDense()"
  },
  {
    "label": "isAllocated()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isAllocated()"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "allocate()"
  },
  {
    "label": "memUsage()",
    "kind": "Method",
    "detail": "Function (} Index64)",
    "insertText": "memUsage()"
  },
  {
    "label": "evalActiveBoundingBox()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalActiveBoundingBox(CoordBBox& bbox, bool visitVoxels = true)"
  },
  {
    "label": "getNodeBoundingBox()",
    "kind": "Method",
    "detail": "Function (CoordBBox)",
    "insertText": "getNodeBoundingBox()"
  },
  {
    "label": "setOrigin()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setOrigin(const Coord& origin)"
  },
  {
    "label": "origin()",
    "kind": "Method",
    "detail": "Function (mOrigin = origin ; } const Coord&)",
    "insertText": "origin()"
  },
  {
    "label": "getOrigin()",
    "kind": "Method",
    "detail": "Function (origin = mOrigin ; } void)",
    "insertText": "getOrigin(Int32& x, Int32& y, Int32& z)"
  },
  {
    "label": "asXYZ()",
    "kind": "Method",
    "detail": "Function (mOrigin .)",
    "insertText": "asXYZ(x, y, z)"
  },
  {
    "label": "coordToOffset()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "coordToOffset(const Coord& xyz)"
  },
  {
    "label": "offsetToLocalCoord()",
    "kind": "Method",
    "detail": "Function (Coord)",
    "insertText": "offsetToLocalCoord(Index n)"
  },
  {
    "label": "offsetToGlobalCoord()",
    "kind": "Method",
    "detail": "Function (Coord)",
    "insertText": "offsetToGlobalCoord(Index n)"
  },
  {
    "label": "str()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "str()"
  },
  {
    "label": "hasSameTopology()",
    "kind": "Method",
    "detail": "Function (template<OtherType,Index OtherLog2Dim> bool)",
    "insertText": "hasSameTopology(const LeafNode<OtherType, OtherLog2Dim>* other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(const LeafNode& other)"
  },
  {
    "label": "ValueIter()",
    "kind": "Method",
    "detail": "Function (} protected : using MaskOnIterator = NodeMaskType::OnIterator ; using MaskOffIterator = NodeMaskType::OffIterator ; using MaskDenseIterator = NodeMaskType::DenseIterator ; struct ValueOn { } ; struct ValueOff { } ; struct ValueAll { } ; struct ChildOn { } ; struct ChildOff { } ; struct ChildAll { } ; template<MaskIterT,NodeT,ValueT,TagT> struct ValueIter : public SparseIteratorBase<MaskIterT,ValueIter<MaskIterT,NodeT,ValueT,TagT>,NodeT,ValueT> { using BaseT = SparseIteratorBase<MaskIterT,ValueIter,NodeT,ValueT> ;)",
    "insertText": "ValueIter()"
  },
  {
    "label": "ValueIter()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ValueIter(const MaskIterT& iter, NodeT* parent): BaseT(iter, parent)"
  },
  {
    "label": "getItem()",
    "kind": "Method",
    "detail": "Function (} ValueT&)",
    "insertText": "getItem(Index pos)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (} ValueT&)",
    "insertText": "getValue()"
  },
  {
    "label": "setItem()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setItem(Index pos, const ValueT& value)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "parent().setValueOnly(pos, value)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValue(const ValueT& value)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "parent().setValueOnly(this->pos(), value)"
  },
  {
    "label": "modifyItem()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp> void)",
    "insertText": "modifyItem(Index n, const ModifyOp& op)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "parent().modifyValue(n, op)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp> void)",
    "insertText": "modifyValue(const ModifyOp& op)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "parent().modifyValue(this->pos(), op)"
  },
  {
    "label": "ChildIter()",
    "kind": "Method",
    "detail": "Function (} } ; template<MaskIterT,NodeT,TagT> struct ChildIter : public SparseIteratorBase<MaskIterT,ChildIter<MaskIterT,NodeT,TagT>,NodeT,ValueType> {)",
    "insertText": "ChildIter()"
  },
  {
    "label": "ChildIter()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ChildIter(const MaskIterT& iter, NodeT* parent): SparseIteratorBase< MaskIterT, ChildIter<MaskIterT, NodeT, TagT>, NodeT, ValueType>(iter, parent)"
  },
  {
    "label": "DenseIter()",
    "kind": "Method",
    "detail": "Function (} } ; template<NodeT,ValueT,TagT> struct DenseIter : public DenseIteratorBase<MaskDenseIterator,DenseIter<NodeT,ValueT,TagT>,NodeT,void,ValueT> { using BaseT = DenseIteratorBase<MaskDenseIterator,DenseIter,NodeT,void,ValueT> ; using NonConstValueT = BaseT::NonConstValueType ;)",
    "insertText": "DenseIter()"
  },
  {
    "label": "DenseIter()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "DenseIter(const MaskDenseIterator& iter, NodeT* parent): BaseT(iter, parent)"
  },
  {
    "label": "getItem()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "getItem(Index pos, void*& child, NonConstValueT& value)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (value = this ->)",
    "insertText": "parent().getValue(pos)"
  },
  {
    "label": "unsetItem()",
    "kind": "Method",
    "detail": "Function (child = nullptr ; return false ; } void)",
    "insertText": "unsetItem(Index pos, const ValueT& value)"
  },
  {
    "label": "cbeginValueOn()",
    "kind": "Method",
    "detail": "Function (} } ; public : using ValueOnIter = ValueIter<MaskOnIterator,LeafNode,const ValueType,ValueOn> ; using ValueOnCIter = ValueIter<MaskOnIterator,const LeafNode,const ValueType,ValueOn> ; using ValueOffIter = ValueIter<MaskOffIterator,LeafNode,const ValueType,ValueOff> ; using ValueOffCIter = ValueIter<MaskOffIterator,const LeafNode,const ValueType,ValueOff> ; using ValueAllIter = ValueIter<MaskDenseIterator,LeafNode,const ValueType,ValueAll> ; using ValueAllCIter = ValueIter<MaskDenseIterator,const LeafNode,const ValueType,ValueAll> ; using ChildOnIter = ChildIter<MaskOnIterator,LeafNode,ChildOn> ; using ChildOnCIter = ChildIter<MaskOnIterator,const LeafNode,ChildOn> ; using ChildOffIter = ChildIter<MaskOffIterator,LeafNode,ChildOff> ; using ChildOffCIter = ChildIter<MaskOffIterator,const LeafNode,ChildOff> ; using ChildAllIter = DenseIter<LeafNode,ValueType,ChildAll> ; using ChildAllCIter = DenseIter<const LeafNode,const ValueType,ChildAll> ; ValueOnCIter)",
    "insertText": "cbeginValueOn()"
  },
  {
    "label": "beginValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnCIter)",
    "insertText": "beginValueOn()"
  },
  {
    "label": "cbeginValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "cbeginValueOff()"
  },
  {
    "label": "beginValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "beginValueOff()"
  },
  {
    "label": "cbeginValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "cbeginValueAll()"
  },
  {
    "label": "beginValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "beginValueAll()"
  },
  {
    "label": "cendValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnCIter)",
    "insertText": "cendValueOn()"
  },
  {
    "label": "endValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnCIter)",
    "insertText": "endValueOn()"
  },
  {
    "label": "cendValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "cendValueOff()"
  },
  {
    "label": "endValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "endValueOff()"
  },
  {
    "label": "cendValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "cendValueAll()"
  },
  {
    "label": "endValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "endValueAll()"
  },
  {
    "label": "cbeginChildOn()",
    "kind": "Method",
    "detail": "Function (} ChildOnCIter)",
    "insertText": "cbeginChildOn()"
  },
  {
    "label": "beginChildOn()",
    "kind": "Method",
    "detail": "Function (} ChildOnCIter)",
    "insertText": "beginChildOn()"
  },
  {
    "label": "cbeginChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "cbeginChildOff()"
  },
  {
    "label": "beginChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "beginChildOff()"
  },
  {
    "label": "cbeginChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "cbeginChildAll()"
  },
  {
    "label": "beginChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "beginChildAll()"
  },
  {
    "label": "cendChildOn()",
    "kind": "Method",
    "detail": "Function (} ChildOnCIter)",
    "insertText": "cendChildOn()"
  },
  {
    "label": "endChildOn()",
    "kind": "Method",
    "detail": "Function (} ChildOnCIter)",
    "insertText": "endChildOn()"
  },
  {
    "label": "cendChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "cendChildOff()"
  },
  {
    "label": "endChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "endChildOff()"
  },
  {
    "label": "cendChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "cendChildAll()"
  },
  {
    "label": "endChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "endChildAll()"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "swap(Buffer& other)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (mBuffer .)",
    "insertText": "swap(other)"
  },
  {
    "label": "buffer()",
    "kind": "Method",
    "detail": "Function (} const Buffer&)",
    "insertText": "buffer()"
  },
  {
    "label": "writeTopology()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeTopology(std::ostream& os, bool toHalf = false)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(std::istream& is, bool fromHalf = false)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(std::istream& is, const CoordBBox& bbox, bool fromHalf = false)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeBuffers(std::ostream& os, bool toHalf = false)"
  },
  {
    "label": "streamingSize()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "streamingSize(bool toHalf = false)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const ValueType&)",
    "insertText": "getValue(const Coord& xyz)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const ValueType&)",
    "insertText": "getValue(Index offset)"
  },
  {
    "label": "probeValue()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "probeValue(const Coord& xyz, ValueType& val)"
  },
  {
    "label": "probeValue()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "probeValue(Index offset, ValueType& val)"
  },
  {
    "label": "getValueLevel()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "getValueLevel(const Coord&)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setActiveState(Index offset, bool on)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(offset<SIZE)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(offset, on)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOnly(const Coord& xyz, const ValueType& val)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOnly(Index offset, const ValueType& val)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOff(const Coord& xyz)"
  },
  {
    "label": "setOff()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOff(LeafNode::coordToOffset(xyz))"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOff(Index offset)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(offset < SIZE)"
  },
  {
    "label": "setOff()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOff(offset)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOff(const Coord& xyz, const ValueType& val)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOff(Index offset, const ValueType& val)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOn(const Coord& xyz)"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOn(LeafNode::coordToOffset(xyz))"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOn(Index offset)"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOn(offset)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOn(const Coord& xyz, const ValueType& val)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueOn(LeafNode::coordToOffset(xyz), val)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValue(const Coord& xyz, const ValueType& val)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueOn(xyz, val)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOn(Index offset, const ValueType& val)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (mBuffer .)",
    "insertText": "setValue(offset, val)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp> void)",
    "insertText": "modifyValue(Index offset, const ModifyOp& op)"
  },
  {
    "label": "loadValues()",
    "kind": "Method",
    "detail": "Function (mBuffer .)",
    "insertText": "loadValues()"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (ValueType& val = const_cast<)",
    "insertText": "ValueType(mBuffer[offset])"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(val)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (} } template<ModifyOp> void)",
    "insertText": "modifyValue(const Coord& xyz, const ModifyOp& op)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "modifyValue(this->coordToOffset(xyz), op)"
  },
  {
    "label": "modifyValueAndActiveState()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp> void)",
    "insertText": "modifyValueAndActiveState(const Coord& xyz, const ModifyOp& op)"
  },
  {
    "label": "coordToOffset()",
    "kind": "Method",
    "detail": "Function (const Index offset = this ->)",
    "insertText": "coordToOffset(xyz)"
  },
  {
    "label": "isOn()",
    "kind": "Method",
    "detail": "Function (bool state = mValueMask .)",
    "insertText": "isOn(offset)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(val, state)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(offset, state)"
  },
  {
    "label": "setValuesOn()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "setValuesOn()"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOn()"
  },
  {
    "label": "setValuesOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValuesOff()"
  },
  {
    "label": "setOff()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOff()"
  },
  {
    "label": "isValueOn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueOn(const Coord& xyz)"
  },
  {
    "label": "isValueOn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueOn(Index offset)"
  },
  {
    "label": "hasActiveTiles()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasActiveTiles()"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(const CoordBBox& bbox, const ValueType&, bool active = true)"
  },
  {
    "label": "denseFill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "denseFill(const CoordBBox& bbox, const ValueType& value, bool active = true)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "fill(bbox, value, active)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "fill(const ValueType& value)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(const ValueType& value, bool active)"
  },
  {
    "label": "copyToDense()",
    "kind": "Method",
    "detail": "Function (template<DenseT> void)",
    "insertText": "copyToDense(const CoordBBox& bbox, DenseT& dense)"
  },
  {
    "label": "copyFromDense()",
    "kind": "Method",
    "detail": "Function (template<DenseT> void)",
    "insertText": "copyFromDense(const CoordBBox& bbox, const DenseT& dense, const ValueType& background, const ValueType& tolerance)"
  },
  {
    "label": "getValueAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> const ValueType&)",
    "insertText": "getValueAndCache(const Coord& xyz, AccessorT&)"
  },
  {
    "label": "isValueOnAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> bool)",
    "insertText": "isValueOnAndCache(const Coord& xyz, AccessorT&)"
  },
  {
    "label": "setValueAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> void)",
    "insertText": "setValueAndCache(const Coord& xyz, const ValueType& val, AccessorT&)"
  },
  {
    "label": "setValueOnlyAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> void)",
    "insertText": "setValueOnlyAndCache(const Coord& xyz, const ValueType& val, AccessorT&)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueOnly(xyz, val)"
  },
  {
    "label": "modifyValueAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp,AccessorT> void)",
    "insertText": "modifyValueAndCache(const Coord& xyz, const ModifyOp& op, AccessorT&)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "modifyValue(xyz, op)"
  },
  {
    "label": "modifyValueAndActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp,AccessorT> void)",
    "insertText": "modifyValueAndActiveStateAndCache(const Coord& xyz, const ModifyOp& op, AccessorT&)"
  },
  {
    "label": "modifyValueAndActiveState()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "modifyValueAndActiveState(xyz, op)"
  },
  {
    "label": "setValueOffAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> void)",
    "insertText": "setValueOffAndCache(const Coord& xyz, const ValueType& value, AccessorT&)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueOff(xyz, value)"
  },
  {
    "label": "setActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> void)",
    "insertText": "setActiveStateAndCache(const Coord& xyz, bool on, AccessorT&)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setActiveState(xyz, on)"
  },
  {
    "label": "probeValueAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> bool)",
    "insertText": "probeValueAndCache(const Coord& xyz, ValueType& val, AccessorT&)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> const ValueType&)",
    "insertText": "getValue(const Coord& xyz, bool& state, int& level, AccessorT&)"
  },
  {
    "label": "getValueLevelAndCache()",
    "kind": "Method",
    "detail": "Function (level = LEVEL ; return mBuffer [ offset ] ; } template<AccessorT> Index)",
    "insertText": "getValueLevelAndCache(const Coord&, AccessorT&)"
  },
  {
    "label": "negate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "negate()"
  },
  {
    "label": "voxelizeActiveTiles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "voxelizeActiveTiles(bool = true)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (} template<MergePolicy Policy> void)",
    "insertText": "merge(const LeafNode&)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (template<MergePolicy Policy> void)",
    "insertText": "merge(const ValueType& tileValue, bool tileActive)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (template<MergePolicy Policy> void)",
    "insertText": "merge(const LeafNode& other, const ValueType& , const ValueType&)"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (template<OtherType> void)",
    "insertText": "topologyUnion(const LeafNode<OtherType, Log2Dim>& other, const bool preserveTiles = false)"
  },
  {
    "label": "topologyIntersection()",
    "kind": "Method",
    "detail": "Function (template<OtherType> void)",
    "insertText": "topologyIntersection(const LeafNode<OtherType, Log2Dim>& other, const ValueType&)"
  },
  {
    "label": "topologyDifference()",
    "kind": "Method",
    "detail": "Function (template<OtherType> void)",
    "insertText": "topologyDifference(const LeafNode<OtherType, Log2Dim>& other, const ValueType&)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (template<CombineOp> void)",
    "insertText": "combine(const LeafNode& other, CombineOp& op)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (template<CombineOp> void)",
    "insertText": "combine(const ValueType& value, bool valueIsActive, CombineOp& op)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (template<CombineOp,OtherType> void)",
    "insertText": "combine2(const LeafNode& other, const OtherType&, bool valueIsActive, CombineOp&)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (template<CombineOp,OtherNodeT> void)",
    "insertText": "combine2(const ValueType&, const OtherNodeT& other, bool valueIsActive, CombineOp&)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (template<CombineOp,OtherNodeT> void)",
    "insertText": "combine2(const LeafNode& b0, const OtherNodeT& b1, CombineOp&)"
  },
  {
    "label": "visitActiveBBox()",
    "kind": "Method",
    "detail": "Function (template<BBoxOp> void)",
    "insertText": "visitActiveBBox(BBoxOp&)"
  },
  {
    "label": "visit()",
    "kind": "Method",
    "detail": "Function (template<VisitorOp> void)",
    "insertText": "visit(VisitorOp&)"
  },
  {
    "label": "visit2Node()",
    "kind": "Method",
    "detail": "Function (template<OtherLeafNodeType,VisitorOp> void)",
    "insertText": "visit2Node(OtherLeafNodeType& other, VisitorOp&)"
  },
  {
    "label": "visit2()",
    "kind": "Method",
    "detail": "Function (template<IterT,VisitorOp> void)",
    "insertText": "visit2(IterT& otherIter, VisitorOp&, bool otherIsLHS = false)"
  },
  {
    "label": "prune()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "prune(const ValueType& = zeroVal<ValueType>())"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addLeaf(LeafNode*)"
  },
  {
    "label": "addLeafAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> void)",
    "insertText": "addLeafAndCache(LeafNode*, AccessorT&)"
  },
  {
    "label": "stealNode()",
    "kind": "Method",
    "detail": "Function (} template<NodeT> NodeT*)",
    "insertText": "stealNode(const Coord&, const ValueType&, bool)"
  },
  {
    "label": "stealNodes()",
    "kind": "Method",
    "detail": "Function (} template<ArrayT> void)",
    "insertText": "stealNodes(ArrayT&, const ValueType&, bool)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addTile(Index level, const Coord&, const ValueType&, bool)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addTile(Index offset, const ValueType&, bool)"
  },
  {
    "label": "addTileAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> void)",
    "insertText": "addTileAndCache(Index, const Coord&, const ValueType&, bool, AccessorT&)"
  },
  {
    "label": "touchLeaf()",
    "kind": "Method",
    "detail": "Function (LeafNode*)",
    "insertText": "touchLeaf(const Coord&)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN)",
    "insertText": "if(!(std::is_same<NodeT, LeafNode>::value))"
  },
  {
    "label": "probeLeaf()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_END } LeafNode*)",
    "insertText": "probeLeaf(const Coord&)"
  },
  {
    "label": "isConstant()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_END } bool)",
    "insertText": "isConstant(ValueType& firstValue, bool& state, const ValueType& tolerance = zeroVal<ValueType>())"
  },
  {
    "label": "isConstant()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isConstant(ValueType& minValue, ValueType& maxValue, bool& state, const ValueType& tolerance = zeroVal<ValueType>())"
  },
  {
    "label": "medianAll()",
    "kind": "Method",
    "detail": "Function (ValueType)",
    "insertText": "medianAll(ValueType *tmp = nullptr)"
  },
  {
    "label": "medianOn()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "medianOn(ValueType &value, ValueType *tmp = nullptr)"
  },
  {
    "label": "medianOff()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "medianOff(ValueType &value, ValueType *tmp = nullptr)"
  },
  {
    "label": "isInactive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isInactive()"
  },
  {
    "label": "isValueMaskOn()",
    "kind": "Method",
    "detail": "Function (} protected : class::TestLeaf ; template<> class::TestLeafIO ; template<,Index> class LeafNode ; struct ValueIter<MaskOnIterator,LeafNode,ValueType,ValueOn> ; struct ValueIter<MaskOffIterator,LeafNode,ValueType,ValueOff> ; struct ValueIter<MaskDenseIterator,LeafNode,ValueType,ValueAll> ; struct ValueIter<MaskOnIterator,const LeafNode,ValueType,ValueOn> ; struct ValueIter<MaskOffIterator,const LeafNode,ValueType,ValueOff> ; struct ValueIter<MaskDenseIterator,const LeafNode,ValueType,ValueAll> ; class IteratorBase<MaskOnIterator,LeafNode> ; class IteratorBase<MaskOffIterator,LeafNode> ; class IteratorBase<MaskDenseIterator,LeafNode> ; public : bool)",
    "insertText": "isValueMaskOn(Index n)"
  },
  {
    "label": "isValueMaskOn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueMaskOn()"
  },
  {
    "label": "isValueMaskOff()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueMaskOff(Index n)"
  },
  {
    "label": "isValueMaskOff()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueMaskOff()"
  },
  {
    "label": "getValueMask()",
    "kind": "Method",
    "detail": "Function (} const NodeMaskType&)",
    "insertText": "getValueMask()"
  },
  {
    "label": "isChildMaskOn()",
    "kind": "Method",
    "detail": "Function (mValueMask = mask ; } bool)",
    "insertText": "isChildMaskOn(Index)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(n, on)"
  },
  {
    "label": "setValueMaskOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueMaskOn(Index n)"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOn(n)"
  },
  {
    "label": "setValueMaskOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueMaskOff(Index n)"
  },
  {
    "label": "setOff()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOff(n)"
  },
  {
    "label": "skipCompressedValues()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "skipCompressedValues(bool seekable, std::istream&, bool fromHalf)"
  },
  {
    "label": "evalNodeOrigin()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalNodeOrigin(Coord& xyz)"
  },
  {
    "label": "xyz()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "xyz(DIM - 1)"
  },
  {
    "label": "doVisit()",
    "kind": "Method",
    "detail": "Function (} template<NodeT,VisitorOp,ChildAllIterT> void)",
    "insertText": "doVisit(NodeT&, VisitorOp&)"
  },
  {
    "label": "doVisit2Node()",
    "kind": "Method",
    "detail": "Function (template<NodeT,OtherNodeT,VisitorOp,ChildAllIterT,OtherChildAllIterT> void)",
    "insertText": "doVisit2Node(NodeT& self, OtherNodeT& other, VisitorOp&)"
  },
  {
    "label": "doVisit2()",
    "kind": "Method",
    "detail": "Function (template<NodeT,VisitorOp,ChildAllIterT,OtherChildAllIterT> void)",
    "insertText": "doVisit2(NodeT& self, OtherChildAllIterT&, VisitorOp&, bool otherIsLHS)"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (private : Buffer mBuffer ; NodeMaskType mValueMask ; Coord mOrigin ; } ; template<Index Dim1,NodeT2> struct SameLeafConfig { const bool value = false ; } ; template<Index Dim1,T2> struct SameLeafConfig<Dim1,LeafNode<T2,Dim1>> { const bool value = true ; } ; template<T,Index Log2Dim> LeafNode<T,Log2Dim)",
    "insertText": "LeafNode(): mValueMask(), mOrigin(0, 0, 0)"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> LeafNode<T,Log2Dim)",
    "insertText": "LeafNode(const Coord& xyz, const ValueType& val, bool active): mBuffer(val), mValueMask(active), mOrigin(xyz & (~(DIM - 1)))"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> LeafNode<T,Log2Dim)",
    "insertText": "LeafNode(PartialCreate, const Coord& xyz, const ValueType& val, bool active): mBuffer(PartialCreate(), val), mValueMask(active), mOrigin(xyz & (~(DIM - 1)))"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> LeafNode<T,Log2Dim)",
    "insertText": "LeafNode(const LeafNode& other): mBuffer(other.mBuffer), mValueMask(other.valueMask()), mOrigin(other.mOrigin)"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> template<OtherValueType> LeafNode<T,Log2Dim)",
    "insertText": "LeafNode(const LeafNode<OtherValueType, Log2Dim>& other): mValueMask(other.valueMask()), mOrigin(other.mOrigin)"
  },
  {
    "label": "convertValue()",
    "kind": "Method",
    "detail": "Function (struct Local { ValueType)",
    "insertText": "convertValue(const OtherValueType& val)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "for(Index i = 0; i < SIZE; ++i)"
  },
  {
    "label": "convertValue()",
    "kind": "Method",
    "detail": "Function (mBuffer [ i ] =)",
    "insertText": "convertValue(other.mBuffer[i])"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (} } template<T,Index Log2Dim> template<OtherValueType> LeafNode<T,Log2Dim)",
    "insertText": "LeafNode(const LeafNode<OtherValueType, Log2Dim>& other, const ValueType& background, TopologyCopy): mBuffer(background), mValueMask(other.valueMask()), mOrigin(other.mOrigin)"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> template<OtherValueType> LeafNode<T,Log2Dim)",
    "insertText": "LeafNode(const LeafNode<OtherValueType, Log2Dim>& other, const ValueType& offValue, const ValueType& onValue, TopologyCopy): mValueMask(other.valueMask()), mOrigin(other.mOrigin)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (mBuffer [)",
    "insertText": "i(mValueMask.isOn(i) ? onValue : offValue)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((xyz[0] & (DIM-1u)) < DIM && (xyz[1] & (DIM-1u)) < DIM && (xyz[2] & (DIM-1u)) < DIM)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(n<(1<< 3*Log2Dim))"
  },
  {
    "label": "setX()",
    "kind": "Method",
    "detail": "Function (Coord xyz ; xyz .)",
    "insertText": "setX(n >> 2*Log2Dim)"
  },
  {
    "label": "n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "n((1<<2*Log2Dim)-1)"
  },
  {
    "label": "setY()",
    "kind": "Method",
    "detail": "Function (xyz .)",
    "insertText": "setY(n >> Log2Dim)"
  },
  {
    "label": "setZ()",
    "kind": "Method",
    "detail": "Function (xyz .)",
    "insertText": "setZ(n & ((1<<Log2Dim)-1))"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueOff(LeafNode::coordToOffset(xyz), val)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> void LeafNode<T,Log2Dim)",
    "insertText": "setActiveState(const Coord& xyz, bool on)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(this->coordToOffset(xyz), on)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueOnly(LeafNode::coordToOffset(xyz), val)"
  },
  {
    "label": "clip()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> void LeafNode<T,Log2Dim)",
    "insertText": "clip(const CoordBBox& clipBBox, const T& background)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "fill(background, false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(clipBBox.isInside(nodeBBox))"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (Coord xyz ; int& x = xyz .)",
    "insertText": "x(), &y = xyz.y(), &z = xyz.z()"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (mask .)",
    "insertText": "setOn(static_cast<Index32>(this->coordToOffset(xyz)))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "for(MaskOffIterator maskIter = mask.beginOff(); maskIter; ++maskIter)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueOff(maskIter.pos(), background)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (} } template<T,Index Log2Dim> void LeafNode<T,Log2Dim)",
    "insertText": "fill(const CoordBBox& bbox, const ValueType& value, bool active)"
  },
  {
    "label": "intersect()",
    "kind": "Method",
    "detail": "Function (clippedBBox .)",
    "insertText": "intersect(bbox)"
  },
  {
    "label": "offsetX()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "offsetX(x & (DIM-1u))"
  },
  {
    "label": "offsetX()",
    "kind": "Method",
    "detail": "Function (const Index offsetXY =)",
    "insertText": "offsetX((y & (DIM-1u)) << Log2Dim)"
  },
  {
    "label": "offsetXY()",
    "kind": "Method",
    "detail": "Function (const Index offset =)",
    "insertText": "offsetXY(z & (DIM-1u))"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mBuffer [ offset ] = value ; mValueMask .)",
    "insertText": "set(offset, active)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (mBuffer .)",
    "insertText": "fill(value)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(active)"
  },
  {
    "label": "xStride()",
    "kind": "Method",
    "detail": "Function (using DenseValueType = DenseT::ValueType ; const size_t xStride = dense .)",
    "insertText": "xStride(), yStride = dense.yStride(), zStride = dense.zStride()"
  },
  {
    "label": "bbox()",
    "kind": "Method",
    "detail": "Function (const Coord& min = dense .)",
    "insertText": "bbox().min()"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (DenseValueType* t0 = dense .)",
    "insertText": "data() + zStride * (bbox.min()[2] - min[2])"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (const T* s0 =& mBuffer [ bbox .)",
    "insertText": "min()[2] & (DIM-1u)"
  },
  {
    "label": "xStride()",
    "kind": "Method",
    "detail": "Function (DenseValueType* t1 = t0 +)",
    "insertText": "xStride(x - min[0])"
  },
  {
    "label": "s0()",
    "kind": "Method",
    "detail": "Function (const T* s1 =)",
    "insertText": "s0((x & (DIM-1u)) << 2*Log2Dim)"
  },
  {
    "label": "yStride()",
    "kind": "Method",
    "detail": "Function (DenseValueType* t2 = t1 +)",
    "insertText": "yStride(y - min[1])"
  },
  {
    "label": "s1()",
    "kind": "Method",
    "detail": "Function (const T* s2 =)",
    "insertText": "s1((y & (DIM-1u)) << Log2Dim)"
  },
  {
    "label": "DenseValueType()",
    "kind": "Method",
    "detail": "Function (* t2 =)",
    "insertText": "DenseValueType(*s2++)"
  },
  {
    "label": "n0()",
    "kind": "Method",
    "detail": "Function (const Int32 n1 =)",
    "insertText": "n0((x & (DIM-1u)) << 2*LOG2DIM)"
  },
  {
    "label": "n1()",
    "kind": "Method",
    "detail": "Function (Int32 n2 =)",
    "insertText": "n1((y & (DIM-1u)) << LOG2DIM)"
  },
  {
    "label": "setOff()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOff(n2)"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (mBuffer [ n2 ] = background ; } else { mValueMask .)",
    "insertText": "setOn(n2)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (mBuffer [ n2 ] =)",
    "insertText": "ValueType(*s2)"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (} } } } } template<T,Index Log2Dim> void LeafNode<T,Log2Dim)",
    "insertText": "readTopology(std::istream& is, bool)"
  },
  {
    "label": "load()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "load(is)"
  },
  {
    "label": "writeTopology()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> void LeafNode<T,Log2Dim)",
    "insertText": "writeTopology(std::ostream& os, bool)"
  },
  {
    "label": "save()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "save(os)"
  },
  {
    "label": "skipCompressedValues()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> void LeafNode<T,Log2Dim)",
    "insertText": "skipCompressedValues(bool seekable, std::istream& is, bool fromHalf)"
  },
  {
    "label": "NodeMaskType()",
    "kind": "Method",
    "detail": "Function (io::readCompressedValues<ValueType,)",
    "insertText": "NodeMaskType(is, nullptr, SIZE, mValueMask, fromHalf)"
  },
  {
    "label": "readCompressedValues()",
    "kind": "Method",
    "detail": "Function (} else { Buffer temp ;)",
    "insertText": "readCompressedValues(is, temp.mData, SIZE, mValueMask, fromHalf)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (} } template<T,Index Log2Dim> void LeafNode<T,Log2Dim)",
    "insertText": "readBuffers(std::istream& is, bool fromHalf)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "readBuffers(is, CoordBBox::inf(), fromHalf)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> void LeafNode<T,Log2Dim)",
    "insertText": "readBuffers(std::istream& is, const CoordBBox& clipBBox, bool fromHalf)"
  },
  {
    "label": "getStreamMetadataPtr()",
    "kind": "Method",
    "detail": "Function (SharedPtr<io::StreamMetadata> meta =)",
    "insertText": "getStreamMetadataPtr(is)"
  },
  {
    "label": "seekable()",
    "kind": "Method",
    "detail": "Function (const bool seekable = meta&& meta ->)",
    "insertText": "seekable()"
  },
  {
    "label": "tellg()",
    "kind": "Method",
    "detail": "Function (std::streamoff maskpos = is .)",
    "insertText": "tellg()"
  },
  {
    "label": "seek()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "seek(is)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} int8_t numBuffers = 1 ;)",
    "insertText": "if(io::getFormatVersion(is) < OPENVDB_FILE_VERSION_NODE_MASK_COMPRESSION)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(&mOrigin), sizeof(Coord::ValueType) * 3)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(&numBuffers), sizeof(int8_t))"
  },
  {
    "label": "skipCompressedValues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "skipCompressedValues(seekable, is, fromHalf)"
  },
  {
    "label": "setOutOfCore()",
    "kind": "Method",
    "detail": "Function (mBuffer .)",
    "insertText": "setOutOfCore(false)"
  },
  {
    "label": "getMappedFilePtr()",
    "kind": "Method",
    "detail": "Function (} else { io::MappedFile::Ptr mappedFile =)",
    "insertText": "getMappedFilePtr(is)"
  },
  {
    "label": "delayLoad()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "delayLoad((mappedFile.get() != nullptr) && clipBBox.isInside(nodeBBox))"
  },
  {
    "label": "setOutOfCore()",
    "kind": "Method",
    "detail": "Function (mBuffer .)",
    "insertText": "setOutOfCore(true)"
  },
  {
    "label": "readCompressedValues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readCompressedValues(is, mBuffer.mData, SIZE, mValueMask, fromHalf)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T background = zeroVal<)",
    "insertText": "T()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (background =* static_cast<const)",
    "insertText": "T(bgPtr)"
  },
  {
    "label": "clip()",
    "kind": "Method",
    "detail": "Function (} this ->)",
    "insertText": "clip(clipBBox, background)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(numBuffers > 1)"
  },
  {
    "label": "getDataCompression()",
    "kind": "Method",
    "detail": "Function (const bool zipped =)",
    "insertText": "getDataCompression(is)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Buffer temp ;)",
    "insertText": "for(int i = 1; i < numBuffers; ++i)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (io::HalfReader<io::RealToHalf<T>::isReal,T)",
    "insertText": "read(is, temp.mData, SIZE, zipped)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} else { io::readData<)",
    "insertText": "T(is, temp.mData, SIZE, zipped)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "if(meta) meta->setLeaf(meta->leaf() + 1)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> void LeafNode<T,Log2Dim)",
    "insertText": "writeBuffers(std::ostream& os, bool toHalf)"
  },
  {
    "label": "writeCompressedValues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeCompressedValues(os, mBuffer.mData, SIZE, mValueMask, NodeMaskType(), toHalf)"
  },
  {
    "label": "evalActiveBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> void LeafNode<T,Log2Dim)",
    "insertText": "evalActiveBoundingBox(CoordBBox& bbox, bool visitVoxels)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (this_bbox .)",
    "insertText": "reset()"
  },
  {
    "label": "translate()",
    "kind": "Method",
    "detail": "Function (this_bbox .)",
    "insertText": "translate(this->origin())"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (} bbox .)",
    "insertText": "expand(this_bbox)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(other)"
  },
  {
    "label": "isConstant()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> bool LeafNode<T,Log2Dim)",
    "insertText": "isConstant(ValueType& firstValue, bool& state, const ValueType& tolerance)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (firstValue = mBuffer [ 0 ] ;)",
    "insertText": "for(Index i = 1; i < SIZE; ++i)"
  },
  {
    "label": "isConstant()",
    "kind": "Method",
    "detail": "Function (} return true ; } template<T,Index Log2Dim> bool LeafNode<T,Log2Dim)",
    "insertText": "isConstant(ValueType& minValue, ValueType& maxValue, bool& state, const ValueType& tolerance)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const T& v = mBuffer [ i ] ;)",
    "insertText": "if(v < minValue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (minValue = v ; } else)",
    "insertText": "if(v > maxValue)"
  },
  {
    "label": "medianAll()",
    "kind": "Method",
    "detail": "Function (maxValue = v ; } } return true ; } template<T,Index Log2Dim> T LeafNode<T,Log2Dim)",
    "insertText": "medianAll(T *tmp)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<T [ ]>)",
    "insertText": "data(nullptr)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "reset(new T[NUM_VALUES])"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (tmp = data .)",
    "insertText": "get()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(tmp != mBuffer.data())"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (const T* src = mBuffer .)",
    "insertText": "data()"
  },
  {
    "label": "midpoint()",
    "kind": "Method",
    "detail": "Function (} const size_t)",
    "insertText": "midpoint(NUM_VALUES - 1)"
  },
  {
    "label": "nth_element()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nth_element(tmp, tmp + midpoint, tmp + NUM_VALUES)"
  },
  {
    "label": "countOn()",
    "kind": "Method",
    "detail": "Function (const Index count = mValueMask .)",
    "insertText": "countOn()"
  },
  {
    "label": "medianAll()",
    "kind": "Method",
    "detail": "Function (value = this ->)",
    "insertText": "medianAll(tmp)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "reset(new T[count])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(auto iter=this->cbeginValueOn(); iter; ++iter)"
  },
  {
    "label": "midpoint()",
    "kind": "Method",
    "detail": "Function (T* begin = tmp - count ; const size_t)",
    "insertText": "midpoint(count - 1)"
  },
  {
    "label": "nth_element()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nth_element(begin, begin + midpoint, tmp)"
  },
  {
    "label": "medianOff()",
    "kind": "Method",
    "detail": "Function (value = begin [ midpoint ] ; return count ; } template<T,Index Log2Dim> Index LeafNode<T,Log2Dim)",
    "insertText": "medianOff(T &value, T *tmp)"
  },
  {
    "label": "countOff()",
    "kind": "Method",
    "detail": "Function (const Index count = mValueMask .)",
    "insertText": "countOff()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(auto iter=this->cbeginValueOff(); iter; ++iter)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (value = begin [ midpoint ] ; return count ; } template<T,Index Log2Dim> void LeafNode<T,Log2Dim)",
    "insertText": "addTile(Index , const Coord& xyz, const ValueType& val, bool active)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "addTile(this->coordToOffset(xyz), val, active)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> void LeafNode<T,Log2Dim)",
    "insertText": "addTile(Index offset, const ValueType& val, bool active)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOnly(offset, val)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setActiveState(offset, active)"
  },
  {
    "label": "addTileAndCache()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> template<AccessorT> void LeafNode<T,Log2Dim)",
    "insertText": "addTileAndCache(Index level, const Coord& xyz, const ValueType& val, bool active, AccessorT&)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "addTile(level, xyz, val, active)"
  },
  {
    "label": "resetBackground()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> void LeafNode<T,Log2Dim)",
    "insertText": "resetBackground(const ValueType& oldBackground, const ValueType& newBackground)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (NodeMaskType::OffIterator iter ;)",
    "insertText": "for(iter = this->mValueMask.beginOff(); iter; ++iter)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (ValueType& inactiveValue = mBuffer [ iter .)",
    "insertText": "pos()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (inactiveValue = newBackground ; } else)",
    "insertText": "if(math::isApproxEqual(inactiveValue, math::negative(oldBackground)))"
  },
  {
    "label": "negative()",
    "kind": "Method",
    "detail": "Function (inactiveValue =)",
    "insertText": "negative(newBackground)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (} } } template<T,Index Log2Dim> template<MergePolicy Policy> void LeafNode<T,Log2Dim)",
    "insertText": "merge(const LeafNode& other)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN)",
    "insertText": "if(Policy == MERGE_NODES)"
  },
  {
    "label": "valueMask()",
    "kind": "Method",
    "detail": "Function (NodeMaskType::OnIterator iter = other .)",
    "insertText": "valueMask().beginOn()"
  },
  {
    "label": "Policy()",
    "kind": "Method",
    "detail": "Function (this -> template merge<)",
    "insertText": "Policy(other)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN)",
    "insertText": "if(Policy != MERGE_ACTIVE_STATES_AND_NODES)"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (} OPENVDB_NO_UNREACHABLE_CODE_WARNING_END } template<T,Index Log2Dim> template<OtherType> void LeafNode<T,Log2Dim)",
    "insertText": "topologyUnion(const LeafNode<OtherType, Log2Dim>& other, bool)"
  },
  {
    "label": "valueMask()",
    "kind": "Method",
    "detail": "Function (mValueMask | = other .)",
    "insertText": "valueMask()"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(args.setARef(mBuffer[i]) .setAIsActive(mValueMask.isOn(i)) .setBRef(other.mBuffer[i]) .setBIsActive(other.valueMask().isOn(i)) .setResultRef(mBuffer[i]))"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(i, args.resultIsActive())"
  },
  {
    "label": "setBRef()",
    "kind": "Method",
    "detail": "Function (CombineArgs<T> args ; args .)",
    "insertText": "setBRef(value).setBIsActive(valueIsActive)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(args.setARef(mBuffer[i]) .setAIsActive(mValueMask.isOn(i)) .setResultRef(mBuffer[i]))"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (} } template<T,Index Log2Dim> template<CombineOp,OtherType> void LeafNode<T,Log2Dim)",
    "insertText": "combine2(const LeafNode& other, const OtherType& value, bool valueIsActive, CombineOp& op)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(args.setARef(other.mBuffer[i]) .setAIsActive(other.valueMask().isOn(i)) .setResultRef(mBuffer[i]))"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (} } template<T,Index Log2Dim> template<CombineOp,OtherNodeT> void LeafNode<T,Log2Dim)",
    "insertText": "combine2(const ValueType& value, const OtherNodeT& other, bool valueIsActive, CombineOp& op)"
  },
  {
    "label": "setARef()",
    "kind": "Method",
    "detail": "Function (CombineArgs<T,OtherNodeT::ValueType> args ; args .)",
    "insertText": "setARef(value).setAIsActive(valueIsActive)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(args.setBRef(other.mBuffer[i]) .setBIsActive(other.valueMask().isOn(i)) .setResultRef(mBuffer[i]))"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (} } template<T,Index Log2Dim> template<CombineOp,OtherNodeT> void LeafNode<T,Log2Dim)",
    "insertText": "combine2(const LeafNode& b0, const OtherNodeT& b1, CombineOp& op)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(i, b0.valueMask().isOn(i) || b1.valueMask().isOn(i))"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(args.setARef(b0.mBuffer[i]) .setAIsActive(b0.valueMask().isOn(i)) .setBRef(b1.mBuffer[i]) .setBIsActive(b1.valueMask().isOn(i)) .setResultRef(mBuffer[i]))"
  },
  {
    "label": "visitActiveBBox()",
    "kind": "Method",
    "detail": "Function (} } template<T,Index Log2Dim> template<BBoxOp> void LeafNode<T,Log2Dim)",
    "insertText": "visitActiveBBox(BBoxOp& op)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (op . template)",
    "insertText": "operator()<LEVEL>(CoordBBox::createCube(i.getCoord(), 1))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } else { op . template)",
    "insertText": "operator()<LEVEL>(this->getNodeBoundingBox())"
  },
  {
    "label": "visit()",
    "kind": "Method",
    "detail": "Function (} } template<T,Index Log2Dim> template<VisitorOp> void LeafNode<T,Log2Dim)",
    "insertText": "visit(VisitorOp& op)"
  },
  {
    "label": "doVisit()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> template<NodeT,VisitorOp,ChildAllIterT> void LeafNode<T,Log2Dim)",
    "insertText": "doVisit(NodeT& self, VisitorOp& op)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(iter)"
  },
  {
    "label": "visit2Node()",
    "kind": "Method",
    "detail": "Function (} } template<T,Index Log2Dim> template<OtherLeafNodeType,VisitorOp> void LeafNode<T,Log2Dim)",
    "insertText": "visit2Node(OtherLeafNodeType& other, VisitorOp& op)"
  },
  {
    "label": "doVisit2Node()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> template<NodeT,OtherNodeT,VisitorOp,ChildAllIterT,OtherChildAllIterT> void LeafNode<T,Log2Dim)",
    "insertText": "doVisit2Node(NodeT& self, OtherNodeT& other, VisitorOp& op)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(iter, otherIter)"
  },
  {
    "label": "visit2()",
    "kind": "Method",
    "detail": "Function (} } template<T,Index Log2Dim> template<IterT,VisitorOp> void LeafNode<T,Log2Dim)",
    "insertText": "visit2(IterT& otherIter, VisitorOp& op, bool otherIsLHS)"
  },
  {
    "label": "doVisit2()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> template<NodeT,VisitorOp,ChildAllIterT,OtherChildAllIterT> void LeafNode<T,Log2Dim)",
    "insertText": "doVisit2(NodeT& self, OtherChildAllIterT& otherIter, VisitorOp& op, bool otherIsLHS)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(otherIter, iter)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "for(ChildAllIterT iter = self.beginChildAll(); iter; ++iter)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } } template<T,Index Log2Dim> std::ostream&)",
    "insertText": "operator(std::ostream& os, const typename LeafNode<T, Log2Dim>::Buffer& buf)"
  }
]