[
  {
    "label": "scheduler",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "scheduler"
  },
  {
    "label": "task_scheduler_init",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "task_scheduler_init"
  },
  {
    "label": "ExceptionPropagationMode",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ExceptionPropagationMode"
  },
  {
    "label": "internal_terminate()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_task_scheduler_init_H # define __TBB_task_scheduler_init_H # include \" tbb_stddef . h \" # include \" limits . h \" # if __TBB_SUPPORTS_WORKERS_WAITING_IN_TERMINATE # include<new> # endif namespace tbb { typedef std::size_t stack_size_type ; namespace internal { class scheduler ; } class task_scheduler_init : internal::no_copy { enum ExceptionPropagationMode { propagation_mode_exact = 1 u,propagation_mode_captured = 2 u,propagation_mode_mask = propagation_mode_exact | propagation_mode_captured } ; internal::scheduler* my_scheduler ; bool)",
    "insertText": "internal_terminate(bool blocking)"
  },
  {
    "label": "internal_blocking_terminate()",
    "kind": "Method",
    "detail": "Function (# if __TBB_SUPPORTS_WORKERS_WAITING_IN_TERMINATE bool __TBB_EXPORTED_METHOD)",
    "insertText": "internal_blocking_terminate(bool throwing)"
  },
  {
    "label": "initialize()",
    "kind": "Method",
    "detail": "Function (# endif public : const int automatic = - 1 ; const int deferred = - 2 ; void __TBB_EXPORTED_METHOD)",
    "insertText": "initialize(int number_of_threads=automatic)"
  },
  {
    "label": "initialize()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_METHOD)",
    "insertText": "initialize(int number_of_threads, stack_size_type thread_stack_size)"
  },
  {
    "label": "terminate()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_METHOD)",
    "insertText": "terminate()"
  },
  {
    "label": "blocking_terminate()",
    "kind": "Method",
    "detail": "Function (# if __TBB_SUPPORTS_WORKERS_WAITING_IN_TERMINATE # if TBB_USE_EXCEPTIONS void)",
    "insertText": "blocking_terminate()"
  },
  {
    "label": "internal_blocking_terminate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_blocking_terminate(true)"
  },
  {
    "label": "blocking_terminate()",
    "kind": "Method",
    "detail": "Function (} # endif bool)",
    "insertText": "blocking_terminate(const std::nothrow_t&) __TBB_NOEXCEPT(true)"
  },
  {
    "label": "task_scheduler_init()",
    "kind": "Method",
    "detail": "Function (} # endif)",
    "insertText": "task_scheduler_init(int number_of_threads=automatic, stack_size_type thread_stack_size=0 ) : my_scheduler(NULL)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(!(thread_stack_size & propagation_mode_mask), \"Requested stack size is not aligned\")"
  },
  {
    "label": "initialize()",
    "kind": "Method",
    "detail": "Function (# if TBB_USE_EXCEPTIONS thread_stack_size | = TBB_USE_CAPTURED_EXCEPTION ? propagation_mode_captured : propagation_mode_exact ; # endif)",
    "insertText": "initialize(number_of_threads, thread_stack_size)"
  },
  {
    "label": "task_scheduler_init()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "task_scheduler_init()"
  },
  {
    "label": "poison_pointer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "poison_pointer(my_scheduler)"
  },
  {
    "label": "default_num_threads()",
    "kind": "Method",
    "detail": "Function (} int __TBB_EXPORTED_FUNC)",
    "insertText": "default_num_threads()"
  },
  {
    "label": "is_active()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "is_active()"
  }
]