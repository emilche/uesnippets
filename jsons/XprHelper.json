[
  {
    "label": "is_valid_index_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_valid_index_type"
  },
  {
    "label": "valid_indexed_view_overload",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "valid_indexed_view_overload"
  },
  {
    "label": "promote_scalar_arg",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "promote_scalar_arg"
  },
  {
    "label": "promote_scalar_arg_unsupported",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "promote_scalar_arg_unsupported"
  },
  {
    "label": "no_assignment_operator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "no_assignment_operator"
  },
  {
    "label": "promote_index_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "promote_index_type"
  },
  {
    "label": "variable_if_dynamic",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "variable_if_dynamic"
  },
  {
    "label": "variable_if_dynamicindex",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "variable_if_dynamicindex"
  },
  {
    "label": "functor_traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "functor_traits"
  },
  {
    "label": "packet_traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "packet_traits"
  },
  {
    "label": "unpacket_traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "unpacket_traits"
  },
  {
    "label": "find_best_packet_helper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "find_best_packet_helper"
  },
  {
    "label": "find_best_packet",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "find_best_packet"
  },
  {
    "label": "compute_default_alignment_helper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "compute_default_alignment_helper"
  },
  {
    "label": "compute_default_alignment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "compute_default_alignment"
  },
  {
    "label": "make_proper_matrix_type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "make_proper_matrix_type"
  },
  {
    "label": "compute_matrix_flags",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "compute_matrix_flags"
  },
  {
    "label": "size_at_compile_time",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "size_at_compile_time"
  },
  {
    "label": "size_of_xpr_at_compile_time",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "size_of_xpr_at_compile_time"
  },
  {
    "label": "plain_matrix_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "plain_matrix_type"
  },
  {
    "label": "plain_matrix_type_dense",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "plain_matrix_type_dense"
  },
  {
    "label": "eval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "eval"
  },
  {
    "label": "plain_object_eval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "plain_object_eval"
  },
  {
    "label": "plain_matrix_type_column_major",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "plain_matrix_type_column_major"
  },
  {
    "label": "plain_matrix_type_row_major",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "plain_matrix_type_row_major"
  },
  {
    "label": "ref_selector",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ref_selector"
  },
  {
    "label": "transfer_constness",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "transfer_constness"
  },
  {
    "label": "nested_eval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "nested_eval"
  },
  {
    "label": "dense_xpr_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "dense_xpr_base"
  },
  {
    "label": "generic_xpr_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "generic_xpr_base"
  },
  {
    "label": "cast_return_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cast_return_type"
  },
  {
    "label": "promote_storage_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "promote_storage_type"
  },
  {
    "label": "cwise_promote_storage_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cwise_promote_storage_type"
  },
  {
    "label": "cwise_promote_storage_order",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cwise_promote_storage_order"
  },
  {
    "label": "product_promote_storage_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "product_promote_storage_type"
  },
  {
    "label": "plain_row_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "plain_row_type"
  },
  {
    "label": "plain_col_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "plain_col_type"
  },
  {
    "label": "plain_diag_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "plain_diag_type"
  },
  {
    "label": "plain_constant_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "plain_constant_type"
  },
  {
    "label": "is_lvalue",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_lvalue"
  },
  {
    "label": "is_diagonal",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_diagonal"
  },
  {
    "label": "is_identity",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_identity"
  },
  {
    "label": "glue_shapes",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "glue_shapes"
  },
  {
    "label": "possibly_same_dense",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "possibly_same_dense"
  },
  {
    "label": "scalar_div_cost",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_div_cost"
  },
  {
    "label": "ScalarBinaryOpTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ScalarBinaryOpTraits"
  },
  {
    "label": "EIGEN_GNUC_AT()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_XPRHELPER_H # define EIGEN_XPRHELPER_H # if EIGEN_COMP_GNUC&& !)",
    "insertText": "EIGEN_GNUC_AT(4,3) #define EIGEN_EMPTY_STRUCT_CTOR(X) \\ EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE X()"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (} \\ EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "X(const X&)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} # else # define)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(X)"
  },
  {
    "label": "convert_index()",
    "kind": "Method",
    "detail": "Function (namespace internal { template<IndexDest,IndexSrc> EIGEN_DEVICE_FUNC IndexDest)",
    "insertText": "convert_index(const IndexSrc& idx)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(idx <= NumTraits<IndexDest>::highest() && \"Index value to big for target type\")"
  },
  {
    "label": "__is_enum()",
    "kind": "Method",
    "detail": "Function (} template<T> struct is_valid_index_type { enum { value = # if EIGEN_HAS_TYPE_TRAITS internal::is_integral<T>::value | | std::is_enum<T>::value # elif EIGEN_COMP_MSVC internal::is_integral<T>::value | |)",
    "insertText": "__is_enum(T)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} ; template<RowIndices,ColIndices> struct valid_indexed_view_overload { enum {)",
    "insertText": "value(internal::is_valid_index_type<RowIndices>::value && internal::is_valid_index_type<ColIndices>::value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<ExprScalar,T,bool IsSupported> struct promote_scalar_arg ; template<S,T> struct promote_scalar_arg<S,T,true> { typedef T type ; } ; template<ExprScalar,T,PromotedType,bool ConvertibleToLiteral = internal::is_convertible<T,PromotedType>::value,bool IsSafe = NumTraits<T>::IsInteger | | ! NumTraits<PromotedType>::IsInteger> struct promote_scalar_arg_unsupported ; template<S,T> struct promote_scalar_arg<S,T,false> : promote_scalar_arg_unsupported<S,T,NumTraits<S>::Literal> { } ; template<S,T,PromotedType> struct promote_scalar_arg_unsupported<S,T,PromotedType,true,true> { typedef PromotedType type ; } ; template<ExprScalar,T,PromotedType> struct promote_scalar_arg_unsupported<ExprScalar,T,PromotedType,false,true> : promote_scalar_arg_unsupported<ExprScalar,T,ExprScalar> { } ; template<S,T,PromotedType,bool ConvertibleToLiteral> struct promote_scalar_arg_unsupported<S,T,PromotedType,ConvertibleToLiteral,false> { } ; template<S,T> struct promote_scalar_arg_unsupported<S,T,S,false,true> { } ; class no_assignment_operator { private : no_assignment_operator&)",
    "insertText": "operator(const no_assignment_operator&)"
  },
  {
    "label": "EIGEN_DEFAULT_COPY_CONSTRUCTOR()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "EIGEN_DEFAULT_COPY_CONSTRUCTOR(no_assignment_operator) EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(no_assignment_operator)"
  },
  {
    "label": "conditional()",
    "kind": "Method",
    "detail": "Function (template<I1,I2> struct promote_index_type { typedef)",
    "insertText": "conditional(sizeof(I1)<sizeof(I2))"
  },
  {
    "label": "EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR()",
    "kind": "Method",
    "detail": "Function (} ; template<T,int Value> class variable_if_dynamic { public :)",
    "insertText": "EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(variable_if_dynamic) EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit variable_if_dynamic(T v)"
  },
  {
    "label": "EIGEN_ONLY_USED_FOR_DEBUG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_ONLY_USED_FOR_DEBUG(v)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(v == T(Value))"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR T)",
    "insertText": "value()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR operator)",
    "insertText": "T()"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "setValue(T v)"
  },
  {
    "label": "variable_if_dynamic()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> class variable_if_dynamic<T,Dynamic> { T m_value ; public : EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "variable_if_dynamic(T value = 0) EIGEN_NO_THROW : m_value(value)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (m_value = value ; } } ; template<T,int Value> class variable_if_dynamicindex { public :)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(variable_if_dynamicindex) EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit variable_if_dynamicindex(T v)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "setValue(T)"
  },
  {
    "label": "variable_if_dynamicindex()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> class variable_if_dynamicindex<T,DynamicIndex> { T m_value ; EIGEN_DEVICE_FUNC)",
    "insertText": "variable_if_dynamicindex()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(false)"
  },
  {
    "label": "variable_if_dynamicindex()",
    "kind": "Method",
    "detail": "Function (} public : EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "variable_if_dynamicindex(T value) : m_value(value)"
  },
  {
    "label": "Dynamic()",
    "kind": "Method",
    "detail": "Function (m_value = value ; } } ; template<T> struct functor_traits { enum { Cost = 1 0,PacketAccess = false,IsRepeatable = false } ; } ; template<T> struct packet_traits ; template<T> struct unpacket_traits ; template<int Size,PacketType,bool Stop = Size = =)",
    "insertText": "Dynamic(Size%unpacket_traits<PacketType>::size)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (template<int Size,PacketType> struct find_best_packet_helper<Size,PacketType,true> { typedef PacketType type ; } ; template<int Size,PacketType> struct find_best_packet_helper<Size,PacketType,false> { typedef find_best_packet_helper<Size,unpacket_traits<PacketType>::half>::type type ; } ; template<T,int Size> struct find_best_packet { typedef find_best_packet_helper<Size,packet_traits<T>::type>::type type ; } ; # if EIGEN_MAX_STATIC_ALIGN_BYTES> 0 template<int ArrayBytes,int AlignmentBytes,bool Match =)",
    "insertText": "bool((ArrayBytes%AlignmentBytes)==0), bool TryHalf = bool(EIGEN_MIN_ALIGN_BYTES<AlignmentBytes)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (enum { value = 0 } ; } ; template<int ArrayBytes,int AlignmentBytes,bool TryHalf> struct compute_default_alignment_helper<ArrayBytes,AlignmentBytes,true,TryHalf> { enum { value = AlignmentBytes } ; } ; template<int ArrayBytes,int AlignmentBytes> struct compute_default_alignment_helper<ArrayBytes,AlignmentBytes,false,true> { enum { value = compute_default_alignment_helper<ArrayBytes,AlignmentBytes / 2>::value } ; } ; # else template<int ArrayBytes,int AlignmentBytes> struct compute_default_alignment_helper { enum { value = 0 } ; } ; # endif template<T,int Size> struct compute_default_alignment { enum { value = compute_default_alignment_helper<Size*)",
    "insertText": "sizeof(T)"
  },
  {
    "label": "AutoAlign()",
    "kind": "Method",
    "detail": "Function (} ; template<T> struct compute_default_alignment<T,Dynamic> { enum { value = EIGEN_MAX_ALIGN_BYTES } ; } ; template<_Scalar,int _Rows,int _Cols,int _Options =)",
    "insertText": "AutoAlign((_Rows==1 && _Cols!=1) ? RowMajor : (_Cols==1 && _Rows!=1) ? ColMajor : EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION)"
  },
  {
    "label": "IsColVector()",
    "kind": "Method",
    "detail": "Function (enum { IsColVector = _Cols = = 1&& _Rows ! = 1,IsRowVector = _Rows = = 1&& _Cols ! = 1,Options =)",
    "insertText": "IsColVector(_Options | ColMajor) & ~RowMajor : IsRowVector ? (_Options | RowMajor)"
  },
  {
    "label": "ret()",
    "kind": "Method",
    "detail": "Function (public : typedef Matrix<_Scalar,_Rows,_Cols,Options,_MaxRows,_MaxCols> type ; } ; template<Scalar,int Rows,int Cols,int Options,int MaxRows,int MaxCols> class compute_matrix_flags { enum { row_major_bit = Options& RowMajor ? RowMajorBit : 0 } ; public : enum { ret = DirectAccessBit | LvalueBit | NestByRefBit | row_major_bit } ; } ; template<int _Rows,int _Cols> struct size_at_compile_time { enum {)",
    "insertText": "ret(_Rows==Dynamic || _Cols==Dynamic)"
  },
  {
    "label": "AutoAlign()",
    "kind": "Method",
    "detail": "Function (} ; template<XprType> struct size_of_xpr_at_compile_time { enum { ret = size_at_compile_time<traits<XprType>::RowsAtCompileTime,traits<XprType>::ColsAtCompileTime>::ret } ; } ; template<T,StorageKind = traits<T>::StorageKind> struct plain_matrix_type ; template<T,BaseClassType,int Flags> struct plain_matrix_type_dense ; template<T> struct plain_matrix_type<T,Dense> { typedef plain_matrix_type_dense<T,traits<T>::XprKind,traits<T>::Flags>::type type ; } ; template<T> struct plain_matrix_type<T,DiagonalShape> { typedef T::PlainObject type ; } ; template<T,int Flags> struct plain_matrix_type_dense<T,MatrixXpr,Flags> { typedef Matrix<traits<T>::Scalar,traits<T>::RowsAtCompileTime,traits<T>::ColsAtCompileTime,)",
    "insertText": "AutoAlign(Flags&RowMajorBit ? RowMajor : ColMajor)"
  },
  {
    "label": "Cols()",
    "kind": "Method",
    "detail": "Function (} ; template<T,StorageKind = traits<T>::StorageKind> struct eval ; template<T> struct eval<T,Dense> { typedef plain_matrix_type<T>::type type ; } ; template<T> struct eval<T,DiagonalShape> { typedef plain_matrix_type<T>::type type ; } ; template<_Scalar,int _Rows,int _Cols,int _Options,int _MaxRows,int _MaxCols> struct eval<Matrix<_Scalar,_Rows,_Cols,_Options,_MaxRows,_MaxCols>,Dense> { typedef const Matrix<_Scalar,_Rows,_Cols,_Options,_MaxRows,_MaxCols>& type ; } ; template<_Scalar,int _Rows,int _Cols,int _Options,int _MaxRows,int _MaxCols> struct eval<Array<_Scalar,_Rows,_Cols,_Options,_MaxRows,_MaxCols>,Dense> { typedef const Array<_Scalar,_Rows,_Cols,_Options,_MaxRows,_MaxCols>& type ; } ; template<T,StorageKind = traits<T>::StorageKind> struct plain_object_eval ; template<T> struct plain_object_eval<T,Dense> { typedef plain_matrix_type_dense<T,traits<T>::XprKind,evaluator<T>::Flags>::type type ; } ; template<T> struct plain_matrix_type_column_major { enum { Rows = traits<T>::RowsAtCompileTime,Cols = traits<T>::ColsAtCompileTime,MaxRows = traits<T>::MaxRowsAtCompileTime,MaxCols = traits<T>::MaxColsAtCompileTime } ; typedef Matrix<traits<T>::Scalar,Rows,)",
    "insertText": "Cols(MaxRows==1&&MaxCols!=1)"
  },
  {
    "label": "Cols()",
    "kind": "Method",
    "detail": "Function (} ; template<T> struct plain_matrix_type_row_major { enum { Rows = traits<T>::RowsAtCompileTime,Cols = traits<T>::ColsAtCompileTime,MaxRows = traits<T>::MaxRowsAtCompileTime,MaxCols = traits<T>::MaxColsAtCompileTime } ; typedef Matrix<traits<T>::Scalar,Rows,)",
    "insertText": "Cols(MaxCols==1&&MaxRows!=1)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} ; template<T> struct ref_selector { typedef conditional<)",
    "insertText": "bool(traits<T>::Flags & NestByRefBit)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} ; template<T1,T2> struct transfer_constness { typedef conditional<)",
    "insertText": "bool(internal::is_const<T1>::value)"
  },
  {
    "label": "CostEval()",
    "kind": "Method",
    "detail": "Function (} ; template<T,int n,PlainObject = plain_object_eval<T>::type> struct nested_eval { enum { ScalarReadCost = NumTraits<traits<T>::Scalar>::ReadCost,CoeffReadCost = evaluator<T>::CoeffReadCost,NAsInteger = n = = Dynamic ? HugeCost : n,)",
    "insertText": "CostEval(NAsInteger+1) * ScalarReadCost + CoeffReadCost, CostNoEval = NAsInteger * CoeffReadCost, Evaluate = (int(evaluator<T>::Flags) & EvalBeforeNestingBit) || (int(CostEval) < int(CostNoEval))"
  },
  {
    "label": "const_cast_ptr()",
    "kind": "Method",
    "detail": "Function (typedef conditional<Evaluate,PlainObject,ref_selector<T>::type>::type type ; } ; template<T> EIGEN_DEVICE_FUNC T*)",
    "insertText": "const_cast_ptr(const T* ptr)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} template<Derived,XprKind = traits<Derived>::XprKind> struct dense_xpr_base { } ; template<Derived> struct dense_xpr_base<Derived,MatrixXpr> { typedef MatrixBase<Derived> type ; } ; template<Derived> struct dense_xpr_base<Derived,ArrayXpr> { typedef ArrayBase<Derived> type ; } ; template<Derived,XprKind = traits<Derived>::XprKind,StorageKind = traits<Derived>::StorageKind> struct generic_xpr_base ; template<Derived,XprKind> struct generic_xpr_base<Derived,XprKind,Dense> { typedef dense_xpr_base<Derived,XprKind>::type type ; } ; template<XprType,CastType> struct cast_return_type { typedef XprType::Scalar CurrentScalarType ; typedef remove_all<CastType>::type _CastType ; typedef _CastType::Scalar NewScalarType ; typedef conditional<is_same<CurrentScalarType,NewScalarType>::value,const XprType&,CastType>::type type ; } ; template<A,B> struct promote_storage_type ; template<A> struct promote_storage_type<A,A> { typedef A ret ; } ; template<A> struct promote_storage_type<A,const A> { typedef A ret ; } ; template<A> struct promote_storage_type<const A,A> { typedef A ret ; } ; template<A,B,Functor> struct cwise_promote_storage_type ; template<A,Functor> struct cwise_promote_storage_type<A,A,Functor> { typedef A ret ; } ; template<Functor> struct cwise_promote_storage_type<Dense,Dense,Functor> { typedef Dense ret ; } ; template<A,Functor> struct cwise_promote_storage_type<A,Dense,Functor> { typedef Dense ret ; } ; template<B,Functor> struct cwise_promote_storage_type<Dense,B,Functor> { typedef Dense ret ; } ; template<Functor> struct cwise_promote_storage_type<Sparse,Dense,Functor> { typedef Sparse ret ; } ; template<Functor> struct cwise_promote_storage_type<Dense,Sparse,Functor> { typedef Sparse ret ; } ; template<LhsKind,RhsKind,int LhsOrder,int RhsOrder> struct cwise_promote_storage_order { enum { value = LhsOrder } ; } ; template<LhsKind,int LhsOrder,int RhsOrder> struct cwise_promote_storage_order<LhsKind,Sparse,LhsOrder,RhsOrder> { enum { value = RhsOrder } ; } ; template<RhsKind,int LhsOrder,int RhsOrder> struct cwise_promote_storage_order<Sparse,RhsKind,LhsOrder,RhsOrder> { enum { value = LhsOrder } ; } ; template<int Order> struct cwise_promote_storage_order<Sparse,Sparse,Order,Order> { enum { value = Order } ; } ; template<A,B,int ProductTag> struct product_promote_storage_type ; template<A,int ProductTag> struct product_promote_storage_type<A,A,ProductTag> { typedef A ret ; } ; template<int ProductTag> struct product_promote_storage_type<Dense,Dense,ProductTag> { typedef Dense ret ; } ; template<A,int ProductTag> struct product_promote_storage_type<A,Dense,ProductTag> { typedef Dense ret ; } ; template<B,int ProductTag> struct product_promote_storage_type<Dense,B,ProductTag> { typedef Dense ret ; } ; template<A,int ProductTag> struct product_promote_storage_type<A,DiagonalShape,ProductTag> { typedef A ret ; } ; template<B,int ProductTag> struct product_promote_storage_type<DiagonalShape,B,ProductTag> { typedef B ret ; } ; template<int ProductTag> struct product_promote_storage_type<Dense,DiagonalShape,ProductTag> { typedef Dense ret ; } ; template<int ProductTag> struct product_promote_storage_type<DiagonalShape,Dense,ProductTag> { typedef Dense ret ; } ; template<A,int ProductTag> struct product_promote_storage_type<A,PermutationStorage,ProductTag> { typedef A ret ; } ; template<B,int ProductTag> struct product_promote_storage_type<PermutationStorage,B,ProductTag> { typedef B ret ; } ; template<int ProductTag> struct product_promote_storage_type<Dense,PermutationStorage,ProductTag> { typedef Dense ret ; } ; template<int ProductTag> struct product_promote_storage_type<PermutationStorage,Dense,ProductTag> { typedef Dense ret ; } ; template<ExpressionType,Scalar = ExpressionType::Scalar> struct plain_row_type { typedef Matrix<Scalar,1,ExpressionType::ColsAtCompileTime,)",
    "insertText": "int(ExpressionType::PlainObject::Options) | int(RowMajor)"
  },
  {
    "label": "EIGEN_SIZE_MIN_PREFER_DYNAMIC()",
    "kind": "Method",
    "detail": "Function (typedef conditional<is_same<traits<ExpressionType>::XprKind,MatrixXpr>::value,MatrixRowType,ArrayRowType>::type type ; } ; template<ExpressionType,Scalar = ExpressionType::Scalar> struct plain_col_type { typedef Matrix<Scalar,ExpressionType::RowsAtCompileTime,1,ExpressionType::PlainObject::Options& ~ RowMajor,ExpressionType::MaxRowsAtCompileTime,1> MatrixColType ; typedef Array<Scalar,ExpressionType::RowsAtCompileTime,1,ExpressionType::PlainObject::Options& ~ RowMajor,ExpressionType::MaxRowsAtCompileTime,1> ArrayColType ; typedef conditional<is_same<traits<ExpressionType>::XprKind,MatrixXpr>::value,MatrixColType,ArrayColType>::type type ; } ; template<ExpressionType,Scalar = ExpressionType::Scalar> struct plain_diag_type { enum { diag_size =)",
    "insertText": "EIGEN_SIZE_MIN_PREFER_DYNAMIC(ExpressionType::RowsAtCompileTime, ExpressionType::ColsAtCompileTime), max_diag_size = EIGEN_SIZE_MIN_PREFER_FIXED(ExpressionType::MaxRowsAtCompileTime, ExpressionType::MaxColsAtCompileTime)"
  },
  {
    "label": "Options()",
    "kind": "Method",
    "detail": "Function (typedef Matrix<Scalar,diag_size,1,ExpressionType::PlainObject::Options& ~ RowMajor,max_diag_size,1> MatrixDiagType ; typedef Array<Scalar,diag_size,1,ExpressionType::PlainObject::Options& ~ RowMajor,max_diag_size,1> ArrayDiagType ; typedef conditional<is_same<traits<ExpressionType>::XprKind,MatrixXpr>::value,MatrixDiagType,ArrayDiagType>::type type ; } ; template<Expr,Scalar = Expr::Scalar> struct plain_constant_type { enum {)",
    "insertText": "Options(traits<Expr>::Flags&RowMajorBit)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (typedef Array<Scalar,traits<Expr>::RowsAtCompileTime,traits<Expr>::ColsAtCompileTime,Options,traits<Expr>::MaxRowsAtCompileTime,traits<Expr>::MaxColsAtCompileTime> array_type ; typedef Matrix<Scalar,traits<Expr>::RowsAtCompileTime,traits<Expr>::ColsAtCompileTime,Options,traits<Expr>::MaxRowsAtCompileTime,traits<Expr>::MaxColsAtCompileTime> matrix_type ; typedef CwiseNullaryOp<scalar_constant_op<Scalar>,const conditional<is_same<traits<Expr>::XprKind,MatrixXpr>::value,matrix_type,array_type>::type> type ; } ; template<ExpressionType> struct is_lvalue { enum {)",
    "insertText": "value(!bool(is_const<ExpressionType>::value)) && bool(traits<ExpressionType>::Flags & LvalueBit)"
  },
  {
    "label": "is_same_dense()",
    "kind": "Method",
    "detail": "Function (} ; template<T> struct is_diagonal { enum { ret = false } ; } ; template<T> struct is_diagonal<DiagonalBase<T>> { enum { ret = true } ; } ; template<T> struct is_diagonal<DiagonalWrapper<T>> { enum { ret = true } ; } ; template<T,int S> struct is_diagonal<DiagonalMatrix<T,S>> { enum { ret = true } ; } ; template<T> struct is_identity { enum { value = false } ; } ; template<T> struct is_identity<CwiseNullaryOp<internal::scalar_identity_op<T::Scalar>,T>> { enum { value = true } ; } ; template<S1,S2> struct glue_shapes ; template<> struct glue_shapes<DenseShape,TriangularShape> { typedef TriangularShape type ; } ; template<T1,T2> struct possibly_same_dense { enum { value = has_direct_access<T1>::ret&& has_direct_access<T2>::ret&& is_same<T1::Scalar,T2::Scalar>::value } ; } ; template<T1,T2> EIGEN_DEVICE_FUNC bool)",
    "insertText": "is_same_dense(const T1 &mat1, const T2 &mat2, typename enable_if<possibly_same_dense<T1,T2>::value>::type * = 0)"
  },
  {
    "label": "is_same_dense()",
    "kind": "Method",
    "detail": "Function (} template<T1,T2> EIGEN_DEVICE_FUNC bool)",
    "insertText": "is_same_dense(const T1 &, const T2 &, typename enable_if<!possibly_same_dense<T1,T2>::value>::type * = 0)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (enum { value = 2 4 } ; } ; template<bool Vectorized> struct scalar_div_cost<unsigned long,Vectorized,conditional<)",
    "insertText": "sizeof(long)"
  },
  {
    "label": "demangle_traversal()",
    "kind": "Method",
    "detail": "Function (enum { value = 2 1 } ; } ; # ifdef EIGEN_DEBUG_ASSIGN std::string)",
    "insertText": "demangle_traversal(int t)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (std::string res ;)",
    "insertText": "if(f&RowMajorBit)"
  }
]