[
  {
    "label": "FMeshRegionBoundaryLoops",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMeshRegionBoundaryLoops"
  },
  {
    "label": "FMeshRegionBoundaryLoops()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" DynamicMesh / DynamicMesh3 . h \" # include \" DynamicMesh / DynamicMeshOverlay . h \" # include \" EdgeLoop . h \" # include \" Util / SparseIndexCollectionTypes . h \" namespace UE { namespace Geometry { class FMeshRegionBoundaryLoops { public : const FDynamicMesh3* Mesh = nullptr ; TArray<FEdgeLoop> Loops ; bool bFailed = false ; public :)",
    "insertText": "FMeshRegionBoundaryLoops()"
  },
  {
    "label": "FMeshRegionBoundaryLoops()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FMeshRegionBoundaryLoops(const FDynamicMesh3* MeshIn, const TArray<int>& RegionTris, bool bAutoCompute = true)"
  },
  {
    "label": "SetMesh()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMesh(const FDynamicMesh3* MeshIn, const TArray<int>& RegionTris)"
  },
  {
    "label": "Compute()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Compute()"
  },
  {
    "label": "GetLoopCount()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetLoopCount()"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Num()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const FEdgeLoop&)",
    "insertText": "operator(int Index)"
  },
  {
    "label": "GetLoopOverlayMap()",
    "kind": "Method",
    "detail": "Function (template<ElementType> using ElementIDAndValue = TPair<int32,ElementType> ; template<ElementType> using VidOverlayMap = TMap<int32,ElementIDAndValue<ElementType>> ; template<StorageType,int ElementSize,ElementType> bool)",
    "insertText": "GetLoopOverlayMap(const FEdgeLoop& LoopIn, const TDynamicMeshOverlay<StorageType, ElementSize>& Overlay, VidOverlayMap<ElementType>& LoopVidsToOverlayElementsOut)"
  },
  {
    "label": "UpdateLoopOverlayMapValidity()",
    "kind": "Method",
    "detail": "Function (template<StorageType,int ElementSize,ElementType> void)",
    "insertText": "UpdateLoopOverlayMapValidity(VidOverlayMap<ElementType>& LoopVidsToOverlayElements, const TDynamicMeshOverlay<StorageType, ElementSize>& Overlay)"
  },
  {
    "label": "GetTriangleSetBoundaryLoop()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetTriangleSetBoundaryLoop(const FDynamicMesh3& Mesh, const TArray<int32>& Tris, FEdgeLoop& Loop)"
  },
  {
    "label": "IsEdgeOnBoundary()",
    "kind": "Method",
    "detail": "Function (protected : FIndexFlagSet Triangles ; FIndexFlagSet Edges ; TArray<int> edges_roi ; bool)",
    "insertText": "IsEdgeOnBoundary(int eid)"
  },
  {
    "label": "IsEdgeOnBoundary()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEdgeOnBoundary(int eid, int& tid_in, int& tid_out)"
  },
  {
    "label": "GetOrientedEdgeVerts()",
    "kind": "Method",
    "detail": "Function (FIndex2i)",
    "insertText": "GetOrientedEdgeVerts(int eID, int tid_in)"
  },
  {
    "label": "GetVertexBoundaryEdges()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetVertexBoundaryEdges(int vID, int& e0, int& e1)"
  },
  {
    "label": "GetAllVertexBoundaryEdges()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetAllVertexBoundaryEdges(int vID, TArray<int>& e)"
  },
  {
    "label": "GetVertexNormal()",
    "kind": "Method",
    "detail": "Function (FVector3d)",
    "insertText": "GetVertexNormal(int vid)"
  },
  {
    "label": "FindLeftTurnEdge()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "FindLeftTurnEdge(int incoming_e, int bowtie_v, TArray<int>& bdry_edges, int bdry_edges_count, const FIndexFlagSet& used_edges)"
  },
  {
    "label": "TryExtractSubloops()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TryExtractSubloops(TArray<int>& loopV, const TArray<int>& loopE, const TArray<int>& bowties, TArray<FEdgeLoop>& SubLoopsOut)"
  }
]