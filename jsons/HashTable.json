[
  {
    "label": "KeyType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "KeyType"
  },
  {
    "label": "ValueType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueType"
  },
  {
    "label": "TKeyValuePair",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TKeyValuePair"
  },
  {
    "label": "KeyValueType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "KeyValueType"
  },
  {
    "label": "HashTraits",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HashTraits"
  },
  {
    "label": "AllocatorType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AllocatorType"
  },
  {
    "label": "THashTable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "THashTable"
  },
  {
    "label": "SEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SEntry"
  },
  {
    "label": "Iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Iterator"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" uLang / Common / Misc / MathUtils . h \" # include \" uLang / Common / Templates / References . h \" # include \" uLang / Common / Templates / Storage . h \" # include \" uLang / Common / Containers / HashTraits . h \" # include<iterator> # include<algorithm> namespace uLang { template<class KeyType,class ValueType> struct TKeyValuePair { KeyType _Key ; ValueType _Value ; bool)",
    "insertText": "operator(const KeyType& Key)"
  },
  {
    "label": "THashTable()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "THashTable(const THashTable& Other)"
  },
  {
    "label": "THashTable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "THashTable(THashTable&& Other)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} THashTable&)",
    "insertText": "operator(THashTable Other)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(_Entries, Other._Entries)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(_NumEntries, Other._NumEntries)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(_NumOccupied, Other._NumOccupied)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(_Allocator, Other._Allocator)"
  },
  {
    "label": "THashTable()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "THashTable()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty()"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (_Allocator .)",
    "insertText": "Deallocate(_Entries)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} } ULANG_FORCEINLINE uint32_t)",
    "insertText": "Num()"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE KeyValueType*)",
    "insertText": "Find(const KeyType& Key)"
  },
  {
    "label": "Lookup()",
    "kind": "Method",
    "detail": "Function (uint32_t Pos =)",
    "insertText": "Lookup(Key)"
  },
  {
    "label": "FindByPredicate()",
    "kind": "Method",
    "detail": "Function (} template<Predicate> const KeyValueType*)",
    "insertText": "FindByPredicate(Predicate Pred)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (} KeyValueType&)",
    "insertText": "Insert(KeyValueType&& KeyValue)"
  },
  {
    "label": "FindOrInsert()",
    "kind": "Method",
    "detail": "Function (} KeyValueType&)",
    "insertText": "FindOrInsert(KeyValueType&& KeyValue)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "Remove(const KeyType& Key)"
  },
  {
    "label": "MoveAndDestruct()",
    "kind": "Method",
    "detail": "Function (auto)",
    "insertText": "MoveAndDestruct(SEntry& Dest, SEntry& Source)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&Dest) SEntry(Move(Source))"
  },
  {
    "label": "SEntry()",
    "kind": "Method",
    "detail": "Function (Source . ~)",
    "insertText": "SEntry()"
  },
  {
    "label": "StopPos()",
    "kind": "Method",
    "detail": "Function (uint32_t)",
    "insertText": "StopPos(Pos + 1) & (_NumEntries - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (SEntry& Entry = _Entries [ StopPos ] ;)",
    "insertText": "if(Entry._Hash == 0 || ProbeDistance(Entry._Hash, StopPos) == 0)"
  },
  {
    "label": "StopPos()",
    "kind": "Method",
    "detail": "Function (break ; })",
    "insertText": "StopPos(StopPos + 1) & (_NumEntries - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Pos < StopPos)"
  },
  {
    "label": "MoveAndDestruct()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MoveAndDestruct(_Entries[Index], _Entries[Index + 1])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "for(uint32_t Index = Pos; Index + 1 < _NumEntries; ++Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(StopPos > 0)"
  },
  {
    "label": "MoveAndDestruct()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MoveAndDestruct(_Entries[_NumEntries - 1], _Entries[0])"
  },
  {
    "label": "_Entries()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "_Entries(StopPos + _NumEntries - 1) & (_NumEntries - 1)"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (- - _NumOccupied ; return true ; } bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (SEntry& Entry = _Entries [ Pos ] ;)",
    "insertText": "if(Entry._Hash)"
  },
  {
    "label": "KeyValueType()",
    "kind": "Method",
    "detail": "Function (Entry . _KeyValue . ~)",
    "insertText": "KeyValueType()"
  },
  {
    "label": "Iterator()",
    "kind": "Method",
    "detail": "Function (} } } _NumOccupied = 0 ; _NumEntries = 0 ; } protected : struct SEntry ; public : template<bool bConst> class Iterator { public : using iterator_category = std::forward_iterator_tag ; using value_type = KeyValueType ; using pointer = std::conditional_t<bConst,const KeyValueType*,KeyValueType*> ; using reference = std::conditional_t<bConst,const KeyValueType&,KeyValueType&> ; private :)",
    "insertText": "Iterator(SEntry* InEntry, SEntry* InEnd) : _CurrentEntry(InEntry), _End(InEnd)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} public : ULANG_FORCEINLINE Iterator&)",
    "insertText": "operator()"
  },
  {
    "label": "EnsureOccupiedOrEnd()",
    "kind": "Method",
    "detail": "Function (+ + _CurrentEntry ;)",
    "insertText": "EnsureOccupiedOrEnd()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return* this ; } ULANG_FORCEINLINE Iterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "this()",
    "kind": "Method",
    "detail": "Function (Iterator tmp =*)",
    "insertText": "this(*this)"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(_End == Other._End, \"Iterator ends were mismatched!\")"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (+ + _CurrentEntry ; } } SEntry* _CurrentEntry ; SEntry* _End ; class THashTable ; } ; ULANG_FORCEINLINE Iterator<false>)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE Iterator<false>)",
    "insertText": "end()"
  },
  {
    "label": "cbegin()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE Iterator<true>)",
    "insertText": "cbegin()"
  },
  {
    "label": "cend()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE Iterator<true>)",
    "insertText": "cend()"
  },
  {
    "label": "GetKeyHash()",
    "kind": "Method",
    "detail": "Function (uint32_t Hash =)",
    "insertText": "GetKeyHash(Key)"
  },
  {
    "label": "DesiredPos()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE uint32_t)",
    "insertText": "DesiredPos(uint32_t Hash)"
  },
  {
    "label": "ProbeDistance()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE uint32_t)",
    "insertText": "ProbeDistance(uint32_t Hash, uint32_t Pos)"
  },
  {
    "label": "InsertInternal()",
    "kind": "Method",
    "detail": "Function (} KeyValueType&)",
    "insertText": "InsertInternal(KeyValueType&& KeyValue)"
  },
  {
    "label": "Grow()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Grow()"
  },
  {
    "label": "InsertInternal()",
    "kind": "Method",
    "detail": "Function (} bool bAlreadyExists { } ; const uint32_t NewPos =)",
    "insertText": "InsertInternal(ComputeNonZeroHash(KeyValue), Move(KeyValue), &bAlreadyExists)"
  },
  {
    "label": "InsertInternal()",
    "kind": "Method",
    "detail": "Function (+ + _NumOccupied ; } return _Entries [ NewPos ] . _KeyValue ; } uint32_t)",
    "insertText": "InsertInternal(uint32_t Hash, KeyValueType&& Value, bool* bAlreadyExists)"
  },
  {
    "label": "DesiredPos()",
    "kind": "Method",
    "detail": "Function (uint32_t Pos =)",
    "insertText": "DesiredPos(Hash)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (uint32_t Distance = 0 ;)",
    "insertText": "for(;;)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (SEntry& Entry = _Entries [ Pos ] ;)",
    "insertText": "if(Entry._Hash == Hash)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const KeyType& Key = Value ;)",
    "insertText": "if(Entry._KeyValue == Key)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* bAlreadyExists = true ; })",
    "insertText": "if(!TAreTypesEqual<KeyType, KeyValueType>::Value)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (Entry . _KeyValue =)",
    "insertText": "Move(Value)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} return Pos ; } })",
    "insertText": "if(Entry._Hash == 0)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (Entry . _Hash = Hash ;)",
    "insertText": "new(&Entry._KeyValue) KeyValueType(Move(Value))"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(Entry._Hash, Hash)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(Entry._KeyValue, Value)"
  },
  {
    "label": "DesiredPos()",
    "kind": "Method",
    "detail": "Function (Distance = ExistingDistance ; } Pos =)",
    "insertText": "DesiredPos(Pos + 1)"
  },
  {
    "label": "Lookup()",
    "kind": "Method",
    "detail": "Function (+ + Distance ; } } ULANG_FORCEINLINE uint32_t)",
    "insertText": "Lookup(const KeyType& Key)"
  },
  {
    "label": "ComputeNonZeroHash()",
    "kind": "Method",
    "detail": "Function (} uint32_t Hash =)",
    "insertText": "ComputeNonZeroHash(Key)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const SEntry& Entry = _Entries [ Pos ] ;)",
    "insertText": "if(Entry._Hash == 0 || Distance > ProbeDistance(Entry._Hash, Pos))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Entry._Hash == Hash && Entry._KeyValue == Key)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (+ + Distance ; } } void)",
    "insertText": "Allocate()"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(CMath::IsPowerOf2(_NumEntries), \"_NumEntries must be a power of 2.\")"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (size_t BytesToAllocate = _NumEntries*)",
    "insertText": "sizeof(SEntry)"
  },
  {
    "label": "_Entries()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_Entries(SEntry*)_Allocator.Allocate(BytesToAllocate)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (SEntry& PrevEntry = PrevEntries [ Pos ] ; uint32_t Hash = PrevEntry . _Hash ;)",
    "insertText": "if(Hash)"
  },
  {
    "label": "InsertInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InsertInternal(Hash, Move(PrevEntry._KeyValue), nullptr)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (} } _Allocator .)",
    "insertText": "Deallocate(PrevEntries)"
  }
]