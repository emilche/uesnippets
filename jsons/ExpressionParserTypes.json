[
  {
    "label": "FExpressionNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionNode"
  },
  {
    "label": "FExpressionError",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FExpressionError"
  },
  {
    "label": "IExpressionNodeStorage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IExpressionNodeStorage"
  },
  {
    "label": "FExpressionError",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FExpressionError"
  },
  {
    "label": "that",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "that"
  },
  {
    "label": "FStringToken",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FStringToken"
  },
  {
    "label": "FTokenStream",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTokenStream"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FTokenStream",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTokenStream"
  },
  {
    "label": "TGetExpressionNodeTypeId",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TGetExpressionNodeTypeId"
  },
  {
    "label": "TGetExpressionNodeTypeId",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TGetExpressionNodeTypeId"
  },
  {
    "label": "FExpressionNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionNode"
  },
  {
    "label": "FExpressionToken",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionToken"
  },
  {
    "label": "FCompiledToken",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCompiledToken"
  },
  {
    "label": "EType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EType"
  },
  {
    "label": "FOperatorFunctionID",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOperatorFunctionID"
  },
  {
    "label": "TOperatorJumpTable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TOperatorJumpTable"
  },
  {
    "label": "manages",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "manages"
  },
  {
    "label": "IOperatorEvaluationEnvironment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IOperatorEvaluationEnvironment"
  },
  {
    "label": "TOperatorEvaluationEnvironment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TOperatorEvaluationEnvironment"
  },
  {
    "label": "FExpressionTokenConsumer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionTokenConsumer"
  },
  {
    "label": "FTokenDefinitions",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTokenDefinitions"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FOpParameters",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOpParameters"
  },
  {
    "label": "FExpressionGrammar",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExpressionGrammar"
  },
  {
    "label": "FTokenStream()",
    "kind": "Method",
    "detail": "Function (CORE_API)",
    "insertText": "FTokenStream(const TCHAR* In)"
  },
  {
    "label": "SetReadPos()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetReadPos(const FStringToken& Token)"
  },
  {
    "label": "Global()",
    "kind": "Method",
    "detail": "Function (FGuid)",
    "insertText": "Global(__VA_ARGS__)"
  },
  {
    "label": "FExpressionNode()",
    "kind": "Method",
    "detail": "Function (T>)",
    "insertText": "FExpressionNode(T In,\n\t\t/** @todo: make this a default function template parameter when VS2012 support goes */\n\t\ttypename TEnableIf<!TPointerIsConvertibleFromTo<T, FExpressionNode>::Value>::Type* = nullptr\n\t\t)"
  },
  {
    "label": "FExpressionNode()",
    "kind": "Method",
    "detail": "Function (CORE_API)",
    "insertText": "FExpressionNode(FExpressionNode&& In)"
  },
  {
    "label": "MakeValue()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "MakeValue(!A)"
  },
  {
    "label": "MapPreUnary()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MapPreUnary(FuncType InFunc)"
  },
  {
    "label": "MapPostUnary()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MapPostUnary(FuncType InFunc)"
  },
  {
    "label": "MakeValue()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "MakeValue(!A)"
  },
  {
    "label": "MapBinary()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MapBinary(FuncType InFunc)"
  },
  {
    "label": "MapShortCircuit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MapShortCircuit(FuncType InFunc)"
  },
  {
    "label": "FExpressionTokenConsumer()",
    "kind": "Method",
    "detail": "Function (CORE_API)",
    "insertText": "FExpressionTokenConsumer(const TCHAR* InExpression)"
  },
  {
    "label": "Extract()",
    "kind": "Method",
    "detail": "Function (TArray<FExpressionToken>)",
    "insertText": "Extract()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(const FStringToken& SourceToken, FExpressionNode&& Node)"
  },
  {
    "label": "FExpressionTokenConsumer()",
    "kind": "Method",
    "detail": "Function (CORE_API)",
    "insertText": "FExpressionTokenConsumer(const FExpressionTokenConsumer&)"
  },
  {
    "label": "DefineToken()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DefineToken(TFunction<FExpressionDefinition>&& Definition)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (DO_CHECK)",
    "insertText": "for(TMap<FGuid, FOpParameters>::TConstIterator It(BinaryOperators)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (associativity)",
    "insertText": "check(CurValue.Associativity == InAssociativity)"
  }
]