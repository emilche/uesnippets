[
  {
    "label": "MappedIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MappedIterator"
  },
  {
    "label": "FilteredIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FilteredIterator"
  },
  {
    "label": "ExpandIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ExpandIterator"
  },
  {
    "label": "ExpandEnumerable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ExpandEnumerable"
  },
  {
    "label": "TPairExpandIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPairExpandIterator"
  },
  {
    "label": "TPairExpandEnumerable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPairExpandEnumerable"
  },
  {
    "label": "FModuloIteration",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FModuloIteration"
  },
  {
    "label": "ToType()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" IndexTypes . h \" # include \" Templates / Function . h \" namespace UE { namespace Geometry { template<FromType,ToType,IteratorT> class MappedIterator { using MapFunctionT = TFunction<)",
    "insertText": "ToType(FromType)"
  },
  {
    "label": "MappedIterator()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "MappedIterator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const MappedIterator& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const MappedIterator&)",
    "insertText": "operator()"
  },
  {
    "label": "MappedIterator()",
    "kind": "Method",
    "detail": "Function (Cur + + ; return* this ; })",
    "insertText": "MappedIterator(const IteratorT& CurItr, const MapFunctionT& MapFunctionIn)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (Cur = CurItr ; MapFunction = MapFunctionIn ; } IteratorT Cur ; MapFunctionT MapFunction ; } ; template<ValueType,IteratorT> class FilteredIterator { using FilterFunctionT = TFunction<)",
    "insertText": "bool(ValueType)"
  },
  {
    "label": "FilteredIterator()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "FilteredIterator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FilteredIterator& Other)"
  },
  {
    "label": "FilteredIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FilteredIterator(const IteratorT& CurItr, const IteratorT& EndItr, const FilterFunctionT& FilterFuncIn)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Cur = CurItr ; End = EndItr ; this -> FilterFunc = FilterFuncIn ;)",
    "insertText": "if(Cur != End && FilterFunc(*Cur) == false)"
  },
  {
    "label": "OutputType()",
    "kind": "Method",
    "detail": "Function (} } IteratorT Cur ; IteratorT End ; FilterFunctionT FilterFunc ; } ; template<OutputType,InputType,InputIteratorT> class ExpandIterator { using ExpandFunctionT = TFunction<)",
    "insertText": "OutputType(InputType, int&)"
  },
  {
    "label": "ExpandIterator()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "ExpandIterator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const ExpandIterator& Other)"
  },
  {
    "label": "ExpandFunc()",
    "kind": "Method",
    "detail": "Function (CurValue =)",
    "insertText": "ExpandFunc(*Cur, CurExpandI)"
  },
  {
    "label": "ExpandIterator()",
    "kind": "Method",
    "detail": "Function (+ + Cur ; } else { break ; } } })",
    "insertText": "ExpandIterator(const InputIteratorT& CurItr, const InputIteratorT& EndItr, const ExpandFunctionT& ExpandFuncIn)"
  },
  {
    "label": "goto_next()",
    "kind": "Method",
    "detail": "Function (Cur = CurItr ; End = EndItr ; ExpandFunc = ExpandFuncIn ; CurExpandI = - 1 ;)",
    "insertText": "goto_next()"
  },
  {
    "label": "ExpandEnumerable()",
    "kind": "Method",
    "detail": "Function (using ExpandIteratorT = ExpandIterator<OutputType,InputType,InputIteratorT> ; public : ExpandFunctionT ExpandFunc ; InputIteratorT BeginItr,EndItr ;)",
    "insertText": "ExpandEnumerable(const InputIteratorT& BeginIn, const InputIteratorT& EndIn, ExpandFunctionT ExpandFuncIn)"
  },
  {
    "label": "ExpandEnumerable()",
    "kind": "Method",
    "detail": "Function (this -> BeginItr = BeginIn ; this -> EndItr = EndIn ; this -> ExpandFunc = ExpandFuncIn ; } template<IteratorSource>)",
    "insertText": "ExpandEnumerable(const IteratorSource& Source, ExpandFunctionT ExpandFuncIn)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (this -> BeginItr = Source .)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (this -> EndItr = Source .)",
    "insertText": "end()"
  },
  {
    "label": "FIndex2i()",
    "kind": "Method",
    "detail": "Function (} } ; template<InputIteratorT> class TPairExpandIterator { using PairExpandFunctionT = TFunction<)",
    "insertText": "FIndex2i(int)"
  },
  {
    "label": "TPairExpandIterator()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "TPairExpandIterator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TPairExpandIterator& Other)"
  },
  {
    "label": "PairFunc()",
    "kind": "Method",
    "detail": "Function (CurPair =)",
    "insertText": "PairFunc(*Cur)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CurValue = CurPair . A ; CurPairI = 1 ; return ; } else { CurPairI = 0 ; + + Cur ; } } else)",
    "insertText": "if(CurPairI == 1)"
  },
  {
    "label": "TPairExpandIterator()",
    "kind": "Method",
    "detail": "Function (CurValue = CurPair . B ; CurPairI = 2 ; return ; } else { CurPairI = 0 ; + + Cur ; } } else { CurPairI = 0 ; + + Cur ; } } })",
    "insertText": "TPairExpandIterator(const InputIteratorT& CurItr, const InputIteratorT& EndItr, const PairExpandFunctionT& PairFuncIn)"
  },
  {
    "label": "TPairExpandEnumerable()",
    "kind": "Method",
    "detail": "Function (using ExpandIteratorT = TPairExpandIterator<InputIteratorT> ; public : ExpandFunctionT ExpandFunc ; InputIteratorT BeginItr,EndItr ;)",
    "insertText": "TPairExpandEnumerable(const InputIteratorT& BeginIn, const InputIteratorT& EndIn, ExpandFunctionT ExpandFuncIn)"
  },
  {
    "label": "TPairExpandEnumerable()",
    "kind": "Method",
    "detail": "Function (this -> BeginItr = BeginIn ; this -> EndItr = EndIn ; this -> ExpandFunc = ExpandFuncIn ; } template<IteratorSource>)",
    "insertText": "TPairExpandEnumerable(const IteratorSource& Source, ExpandFunctionT ExpandFuncIn)"
  },
  {
    "label": "FModuloIteration()",
    "kind": "Method",
    "detail": "Function (} } ; struct FModuloIteration { uint64 MaxIndex = 0 ; uint64 ModuloPrime = 4 2 9 4 9 6 7 3 1 1 ull ; uint64 CurIndex = 0 ; uint64 StartIndex = 0 ; uint64 Count = 0 ; uint64 ModuloNum = 1 ;)",
    "insertText": "FModuloIteration(uint32 MaxIndexIn, uint32 StartIndexIn = 0, uint64 ModuloPrimeIn = 3208642561)"
  },
  {
    "label": "MaxIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MaxIndex(uint64)FMath::Max((uint32)0, MaxIndexIn)"
  },
  {
    "label": "StartIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StartIndex(uint64)FMath::Max((uint32)0, StartIndexIn)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (CurIndex = 0 ; Count = 0 ; ModuloNum =)",
    "insertText": "Max((uint64)1, MaxIndex)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (ModuloPrime = ModuloPrimeIn ;)",
    "insertText": "check(ModuloPrime > MaxIndex)"
  },
  {
    "label": "GetNextIndex()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "GetNextIndex(uint32& NextIndexOut)"
  },
  {
    "label": "NextIndexOut()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NextIndexOut(uint32)"
  },
  {
    "label": "CurIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CurIndex(CurIndex + ModuloPrime)"
  },
  {
    "label": "GetNextIndex()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "GetNextIndex(int32& NextIndexOut)"
  },
  {
    "label": "NextIndexOut()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NextIndexOut(int32)"
  }
]