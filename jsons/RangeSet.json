[
  {
    "label": "TRangeSet",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRangeSet"
  },
  {
    "label": "FArchive",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FArchive"
  },
  {
    "label": "TRangeSet()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Containers / Array . h \" # include \" Math / Range . h \" # include \" Serialization / Archive . h \" template<ElementType> class TRangeSet { typedef TRangeBound<ElementType> BoundsType ; typedef TRange<ElementType> RangeType ; typedef TCallTraits<ElementType>::ParamType ElementValueOrConstRef ; public :)",
    "insertText": "TRangeSet()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} public : void)",
    "insertText": "Add(RangeType Range)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const RangeType& Current = Ranges [ Index ] ;)",
    "insertText": "if(Current.Adjoins(Range) || Current.Overlaps(Range))"
  },
  {
    "label": "RangeType()",
    "kind": "Method",
    "detail": "Function (Range =)",
    "insertText": "RangeType(BoundsType::MinLower(Current.GetLowerBound(), Range.GetLowerBound()), BoundsType::MaxUpper(Current.GetUpperBound(), Range.GetUpperBound()))"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (Ranges .)",
    "insertText": "RemoveAtSwap(Index--)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} } Ranges .)",
    "insertText": "Add(Range)"
  },
  {
    "label": "Merge()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Merge(const TRangeSet& Other)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(*It)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Empty()"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "Contains(ElementValueOrConstRef Element)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (BoundsType Result ;)",
    "insertText": "if(Ranges.Num())"
  },
  {
    "label": "GetLowerBound()",
    "kind": "Method",
    "detail": "Function (Result = Ranges [ 0 ] .)",
    "insertText": "GetLowerBound()"
  },
  {
    "label": "MinLower()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "MinLower(Result, Ranges[i].GetLowerBound())"
  },
  {
    "label": "GetMinBoundValue()",
    "kind": "Method",
    "detail": "Function (} } return Result ; } ElementType)",
    "insertText": "GetMinBoundValue()"
  },
  {
    "label": "GetMaxBound()",
    "kind": "Method",
    "detail": "Function (} BoundsType)",
    "insertText": "GetMaxBound()"
  },
  {
    "label": "GetUpperBound()",
    "kind": "Method",
    "detail": "Function (Result = Ranges [ 0 ] .)",
    "insertText": "GetUpperBound()"
  },
  {
    "label": "MaxUpper()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "MaxUpper(Result, Ranges[i].GetUpperBound())"
  },
  {
    "label": "GetMaxBoundValue()",
    "kind": "Method",
    "detail": "Function (} } return Result ; } ElementType)",
    "insertText": "GetMaxBoundValue()"
  },
  {
    "label": "GetRanges()",
    "kind": "Method",
    "detail": "Function (} template<Allocator> const void)",
    "insertText": "GetRanges(TArray<RangeType, Allocator>& OutRanges)"
  },
  {
    "label": "HasMinBound()",
    "kind": "Method",
    "detail": "Function (OutRanges = Ranges ; } bool)",
    "insertText": "HasMinBound()"
  },
  {
    "label": "HasMaxBound()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasMaxBound()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "Overlaps()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Overlaps(const RangeType& Range)"
  }
]