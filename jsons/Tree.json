[
  {
    "label": "OPENVDB_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OPENVDB_API"
  },
  {
    "label": "Tree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Tree"
  },
  {
    "label": "ValueConverter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValueConverter"
  },
  {
    "label": "DeallocateNodes",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DeallocateNodes"
  },
  {
    "label": "Tree3",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Tree3"
  },
  {
    "label": "Tree4",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Tree4"
  },
  {
    "label": "Tree5",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Tree5"
  },
  {
    "label": "TreeIterTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TreeIterTraits"
  },
  {
    "label": "CombineOpAdapter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CombineOpAdapter"
  },
  {
    "label": "OnExit",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OnExit"
  },
  {
    "label": "TreeBase()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_TREE_TREE_HAS_BEEN_INCLUDED # define OPENVDB_TREE_TREE_HAS_BEEN_INCLUDED # include<openvdb / Types . h> # include<openvdb / Metadata . h> # include<openvdb / math / Math . h> # include<openvdb / math / BBox . h> # include<openvdb / tools / Count . h> # include<openvdb / util / Formats . h> # include<openvdb / util / logging . h> # include<openvdb / Platform . h> # include \" RootNode . h \" # include \" InternalNode . h \" # include \" LeafNode . h \" # include \" TreeIterator . h \" # include \" ValueAccessor . h \" # include<tbb / concurrent_hash_map . h> # include<cstdint> # include<iostream> # include<mutex> # include<sstream> # include<vector> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace tree { class TreeBase { public : using Ptr = SharedPtr<TreeBase> ; using ConstPtr = SharedPtr<const TreeBase> ;)",
    "insertText": "TreeBase()"
  },
  {
    "label": "TreeBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TreeBase(const TreeBase&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TreeBase&)",
    "insertText": "operator(const TreeBase&)"
  },
  {
    "label": "type()",
    "kind": "Method",
    "detail": "Function (const Name&)",
    "insertText": "type()"
  },
  {
    "label": "valueType()",
    "kind": "Method",
    "detail": "Function (Name)",
    "insertText": "valueType()"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (TreeBase::Ptr)",
    "insertText": "copy()"
  },
  {
    "label": "getBackgroundValue()",
    "kind": "Method",
    "detail": "Function (Metadata::Ptr)",
    "insertText": "getBackgroundValue()"
  },
  {
    "label": "evalLeafBoundingBox()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "evalLeafBoundingBox(CoordBBox& bbox)"
  },
  {
    "label": "evalLeafDim()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "evalLeafDim(Coord& dim)"
  },
  {
    "label": "evalActiveVoxelBoundingBox()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "evalActiveVoxelBoundingBox(CoordBBox& bbox)"
  },
  {
    "label": "evalActiveVoxelDim()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "evalActiveVoxelDim(Coord& dim)"
  },
  {
    "label": "getIndexRange()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getIndexRange(CoordBBox& bbox)"
  },
  {
    "label": "clipUnallocatedNodes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clipUnallocatedNodes()"
  },
  {
    "label": "unallocatedLeafCount()",
    "kind": "Method",
    "detail": "Function (Index32)",
    "insertText": "unallocatedLeafCount()"
  },
  {
    "label": "treeDepth()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "treeDepth()"
  },
  {
    "label": "leafCount()",
    "kind": "Method",
    "detail": "Function (Index32)",
    "insertText": "leafCount()"
  },
  {
    "label": "nodeCount()",
    "kind": "Method",
    "detail": "Function (# if OPENVDB_ABI_VERSION_NUMBER> = 7 std::vector<Index32>)",
    "insertText": "nodeCount()"
  },
  {
    "label": "nonLeafCount()",
    "kind": "Method",
    "detail": "Function (# endif Index32)",
    "insertText": "nonLeafCount()"
  },
  {
    "label": "activeLeafVoxelCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "activeLeafVoxelCount()"
  },
  {
    "label": "inactiveLeafVoxelCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "inactiveLeafVoxelCount()"
  },
  {
    "label": "activeVoxelCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "activeVoxelCount()"
  },
  {
    "label": "inactiveVoxelCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "inactiveVoxelCount()"
  },
  {
    "label": "activeTileCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "activeTileCount()"
  },
  {
    "label": "memUsage()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "memUsage()"
  },
  {
    "label": "writeTopology()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeTopology(std::ostream&, bool saveFloatAsHalf = false)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(std::istream&, bool saveFloatAsHalf = false)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(std::istream&, const CoordBBox&, bool saveFloatAsHalf = false)"
  },
  {
    "label": "readNonresidentBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readNonresidentBuffers()"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeBuffers(std::ostream&, bool saveFloatAsHalf = false)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print(std::ostream& os = std::cout, int verboseLevel = 1)"
  },
  {
    "label": "Tree()",
    "kind": "Method",
    "detail": "Function (} ; template<_RootNodeType> class Tree : public TreeBase { public : using Ptr = SharedPtr<Tree> ; using ConstPtr = SharedPtr<const Tree> ; using RootNodeType = _RootNodeType ; using ValueType = RootNodeType::ValueType ; using BuildType = RootNodeType::BuildType ; using LeafNodeType = RootNodeType::LeafNodeType ; const Index DEPTH = RootNodeType::LEVEL + 1 ; template<OtherValueType> struct ValueConverter { using Type = Tree<RootNodeType::template ValueConverter<OtherValueType>::Type> ; } ;)",
    "insertText": "Tree()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Tree&)",
    "insertText": "operator(const Tree&)"
  },
  {
    "label": "Tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Tree(const Tree& other): TreeBase(other), mRoot(other.mRoot)"
  },
  {
    "label": "Tree()",
    "kind": "Method",
    "detail": "Function (} template<OtherRootType>)",
    "insertText": "Tree(const Tree<OtherRootType>& other): TreeBase(other), mRoot(other.root())"
  },
  {
    "label": "Tree()",
    "kind": "Method",
    "detail": "Function (} template<OtherTreeType>)",
    "insertText": "Tree(const OtherTreeType& other, const ValueType& inactiveValue, const ValueType& activeValue, TopologyCopy): TreeBase(other), mRoot(other.root(), inactiveValue, activeValue, TopologyCopy())"
  },
  {
    "label": "Tree()",
    "kind": "Method",
    "detail": "Function (} template<OtherTreeType>)",
    "insertText": "Tree(const OtherTreeType& other, const ValueType& background, TopologyCopy): TreeBase(other), mRoot(other.root(), background, TopologyCopy())"
  },
  {
    "label": "Tree()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Tree(const ValueType& background): mRoot(background)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "clear()"
  },
  {
    "label": "releaseAllAccessors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "releaseAllAccessors()"
  },
  {
    "label": "treeType()",
    "kind": "Method",
    "detail": "Function (} const Name&)",
    "insertText": "treeType()"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(NotImplementedError, \"\")"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (} RootNodeType&)",
    "insertText": "root()"
  },
  {
    "label": "getNodeLog2Dims()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getNodeLog2Dims(std::vector<Index>& dims)"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readTopology(std::istream&, bool saveFloatAsHalf = false)"
  },
  {
    "label": "vec()",
    "kind": "Method",
    "detail": "Function (std::vector<Index32>)",
    "insertText": "vec(DEPTH, 0)"
  },
  {
    "label": "nodeCount()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "nodeCount(vec)"
  },
  {
    "label": "evalMinMax()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "evalMinMax(ValueType &min, ValueType &max)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (} const ValueType&)",
    "insertText": "getValue(const Coord& xyz)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (template<AccessT> const ValueType&)",
    "insertText": "getValue(const Coord& xyz, AccessT&)"
  },
  {
    "label": "getValueDepth()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "getValueDepth(const Coord& xyz)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setActiveState(const Coord& xyz, bool on)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOnly(const Coord& xyz, const ValueType& value)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOn(const Coord& xyz)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOn(const Coord& xyz, const ValueType& value)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValue(const Coord& xyz, const ValueType& value)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (template<AccessT> void)",
    "insertText": "setValue(const Coord& xyz, const ValueType& value, AccessT&)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOff(const Coord& xyz)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOff(const Coord& xyz, const ValueType& value)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (template<ModifyOp> void)",
    "insertText": "modifyValue(const Coord& xyz, const ModifyOp& op)"
  },
  {
    "label": "modifyValueAndActiveState()",
    "kind": "Method",
    "detail": "Function (template<ModifyOp> void)",
    "insertText": "modifyValueAndActiveState(const Coord& xyz, const ModifyOp& op)"
  },
  {
    "label": "probeValue()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "probeValue(const Coord& xyz, ValueType& value)"
  },
  {
    "label": "isValueOn()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isValueOn(const Coord& xyz)"
  },
  {
    "label": "isValueOff()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueOff(const Coord& xyz)"
  },
  {
    "label": "hasActiveTiles()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasActiveTiles()"
  },
  {
    "label": "clip()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "clip(const CoordBBox&)"
  },
  {
    "label": "sparseFill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sparseFill(const CoordBBox& bbox, const ValueType& value, bool active = true)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(const CoordBBox& bbox, const ValueType& value, bool active = true)"
  },
  {
    "label": "sparseFill()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "sparseFill(bbox, value, active)"
  },
  {
    "label": "denseFill()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "denseFill(const CoordBBox& bbox, const ValueType& value, bool active = true)"
  },
  {
    "label": "voxelizeActiveTiles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "voxelizeActiveTiles(bool threaded = true)"
  },
  {
    "label": "prune()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "prune(const ValueType& tolerance = zeroVal<ValueType>())"
  },
  {
    "label": "clearAllAccessors()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "clearAllAccessors()"
  },
  {
    "label": "prune()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "prune(tolerance)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addLeaf(LeafNodeType* leaf)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(leaf)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "addLeaf(leaf)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addTile(Index level, const Coord& xyz, const ValueType& value, bool active)"
  },
  {
    "label": "stealNode()",
    "kind": "Method",
    "detail": "Function (template<NodeT> NodeT*)",
    "insertText": "stealNode(const Coord& xyz, const ValueType& value, bool active)"
  },
  {
    "label": "touchLeaf()",
    "kind": "Method",
    "detail": "Function (LeafNodeType*)",
    "insertText": "touchLeaf(const Coord& xyz)"
  },
  {
    "label": "probeNode()",
    "kind": "Method",
    "detail": "Function (template<NodeType> NodeType*)",
    "insertText": "probeNode(const Coord& xyz)"
  },
  {
    "label": "probeConstNode()",
    "kind": "Method",
    "detail": "Function (template<NodeType> const NodeType*)",
    "insertText": "probeConstNode(const Coord& xyz)"
  },
  {
    "label": "probeLeaf()",
    "kind": "Method",
    "detail": "Function (LeafNodeType*)",
    "insertText": "probeLeaf(const Coord& xyz)"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (const LeafNodeType*)",
    "insertText": "probeConstLeaf(const Coord& xyz)"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (} template<ArrayT> void)",
    "insertText": "getNodes(ArrayT& array)"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "getNodes(array)"
  },
  {
    "label": "stealNodes()",
    "kind": "Method",
    "detail": "Function (} template<ArrayT> void)",
    "insertText": "stealNodes(ArrayT& array)"
  },
  {
    "label": "stealNodes()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "stealNodes(array)"
  },
  {
    "label": "stealNodes()",
    "kind": "Method",
    "detail": "Function (} template<ArrayT> void)",
    "insertText": "stealNodes(ArrayT& array, const ValueType& value, bool state)"
  },
  {
    "label": "stealNodes()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "stealNodes(array, value, state)"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "attachAccessor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "attachAccessor(ValueAccessorBase<Tree, true>&)"
  },
  {
    "label": "attachAccessor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "attachAccessor(ValueAccessorBase<const Tree, true>&)"
  },
  {
    "label": "attachAccessor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "attachAccessor(ValueAccessorBase<Tree, false>&)"
  },
  {
    "label": "attachAccessor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "attachAccessor(ValueAccessorBase<const Tree, false>&)"
  },
  {
    "label": "releaseAccessor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "releaseAccessor(ValueAccessorBase<Tree, true>&)"
  },
  {
    "label": "releaseAccessor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "releaseAccessor(ValueAccessorBase<const Tree, true>&)"
  },
  {
    "label": "releaseAccessor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "releaseAccessor(ValueAccessorBase<Tree, false>&)"
  },
  {
    "label": "releaseAccessor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "releaseAccessor(ValueAccessorBase<const Tree, false>&)"
  },
  {
    "label": "background()",
    "kind": "Method",
    "detail": "Function (const ValueType&)",
    "insertText": "background()"
  },
  {
    "label": "getIndexRange()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "getIndexRange(bbox)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "merge(Tree& other, MergePolicy = MERGE_ACTIVE_STATES)"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (template<OtherRootNodeType> void)",
    "insertText": "topologyUnion(const Tree<OtherRootNodeType>& other, const bool preserveTiles = false)"
  },
  {
    "label": "topologyIntersection()",
    "kind": "Method",
    "detail": "Function (template<OtherRootNodeType> void)",
    "insertText": "topologyIntersection(const Tree<OtherRootNodeType>& other)"
  },
  {
    "label": "topologyDifference()",
    "kind": "Method",
    "detail": "Function (template<OtherRootNodeType> void)",
    "insertText": "topologyDifference(const Tree<OtherRootNodeType>& other)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (template<CombineOp> void)",
    "insertText": "combine(Tree& other, CombineOp& op, bool prune = false)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (# ifndef _MSC_VER template<CombineOp> void)",
    "insertText": "combine(Tree& other, const CombineOp& op, bool prune = false)"
  },
  {
    "label": "combineExtended()",
    "kind": "Method",
    "detail": "Function (# endif template<ExtendedCombineOp> void)",
    "insertText": "combineExtended(Tree& other, ExtendedCombineOp& op, bool prune = false)"
  },
  {
    "label": "combineExtended()",
    "kind": "Method",
    "detail": "Function (# ifndef _MSC_VER template<ExtendedCombineOp> void)",
    "insertText": "combineExtended(Tree& other, const ExtendedCombineOp& op, bool prune = false)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (# endif template<CombineOp,OtherTreeType> void)",
    "insertText": "combine2(const Tree& a, const OtherTreeType& b, CombineOp& op, bool prune = false)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (# ifndef _MSC_VER template<CombineOp,OtherTreeType> void)",
    "insertText": "combine2(const Tree& a, const OtherTreeType& b, const CombineOp& op, bool prune = false)"
  },
  {
    "label": "combine2Extended()",
    "kind": "Method",
    "detail": "Function (# endif template<ExtendedCombineOp,OtherTreeType> void)",
    "insertText": "combine2Extended(const Tree& a, const OtherTreeType& b, ExtendedCombineOp& op, bool prune = false)"
  },
  {
    "label": "combine2Extended()",
    "kind": "Method",
    "detail": "Function (# ifndef _MSC_VER template<ExtendedCombineOp,OtherTreeType> void)",
    "insertText": "combine2Extended(const Tree& a, const OtherTreeType& b, const ExtendedCombineOp&, bool prune = false)"
  },
  {
    "label": "OPENVDB_DEPRECATED_MESSAGE()",
    "kind": "Method",
    "detail": "Function (# endif template<BBoxOp>)",
    "insertText": "OPENVDB_DEPRECATED_MESSAGE(\"Use tools::visitNodesDepthFirst or DynamicNodeManager instead\") void visitActiveBBox(BBoxOp& op)"
  },
  {
    "label": "visitActiveBBox()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "visitActiveBBox(op)"
  },
  {
    "label": "OPENVDB_DEPRECATED_MESSAGE()",
    "kind": "Method",
    "detail": "Function (} template<VisitorOp>)",
    "insertText": "OPENVDB_DEPRECATED_MESSAGE(\"Use tools::visitNodesDepthFirst or DynamicNodeManager instead\") void visit(VisitorOp& op)"
  },
  {
    "label": "OPENVDB_DEPRECATED_MESSAGE()",
    "kind": "Method",
    "detail": "Function (template<VisitorOp>)",
    "insertText": "OPENVDB_DEPRECATED_MESSAGE(\"Use tools::visitNodesDepthFirst or DynamicNodeManager instead\") void visit(const VisitorOp& op)"
  },
  {
    "label": "OPENVDB_DEPRECATED_MESSAGE()",
    "kind": "Method",
    "detail": "Function (template<OtherTreeType,VisitorOp>)",
    "insertText": "OPENVDB_DEPRECATED_MESSAGE(\"Use tools::visitNodesDepthFirst or DynamicNodeManager instead\") void visit2(OtherTreeType& other, VisitorOp& op)"
  },
  {
    "label": "OPENVDB_DEPRECATED_MESSAGE()",
    "kind": "Method",
    "detail": "Function (template<OtherTreeType,VisitorOp>)",
    "insertText": "OPENVDB_DEPRECATED_MESSAGE(\"Use tools::visitNodesDepthFirst or DynamicNodeManager instead\") void visit2(OtherTreeType& other, const VisitorOp& op)"
  },
  {
    "label": "beginRootChildren()",
    "kind": "Method",
    "detail": "Function (RootNodeType::ChildOnCIter)",
    "insertText": "beginRootChildren()"
  },
  {
    "label": "cbeginRootChildren()",
    "kind": "Method",
    "detail": "Function (} RootNodeType::ChildOnCIter)",
    "insertText": "cbeginRootChildren()"
  },
  {
    "label": "beginRootTiles()",
    "kind": "Method",
    "detail": "Function (} RootNodeType::ChildOffCIter)",
    "insertText": "beginRootTiles()"
  },
  {
    "label": "cbeginRootTiles()",
    "kind": "Method",
    "detail": "Function (} RootNodeType::ChildOffCIter)",
    "insertText": "cbeginRootTiles()"
  },
  {
    "label": "beginRootDense()",
    "kind": "Method",
    "detail": "Function (} RootNodeType::ChildAllCIter)",
    "insertText": "beginRootDense()"
  },
  {
    "label": "cbeginRootDense()",
    "kind": "Method",
    "detail": "Function (} RootNodeType::ChildAllCIter)",
    "insertText": "cbeginRootDense()"
  },
  {
    "label": "beginNode()",
    "kind": "Method",
    "detail": "Function (} using NodeIter = NodeIteratorBase<Tree,RootNodeType::ChildOnIter> ; using NodeCIter = NodeIteratorBase<const Tree,RootNodeType::ChildOnCIter> ; using LeafIter = LeafIteratorBase<Tree,RootNodeType::ChildOnIter> ; using LeafCIter = LeafIteratorBase<const Tree,RootNodeType::ChildOnCIter> ; NodeIter)",
    "insertText": "beginNode()"
  },
  {
    "label": "cbeginNode()",
    "kind": "Method",
    "detail": "Function (} NodeCIter)",
    "insertText": "cbeginNode()"
  },
  {
    "label": "beginLeaf()",
    "kind": "Method",
    "detail": "Function (} LeafIter)",
    "insertText": "beginLeaf()"
  },
  {
    "label": "cbeginLeaf()",
    "kind": "Method",
    "detail": "Function (} LeafCIter)",
    "insertText": "cbeginLeaf()"
  },
  {
    "label": "beginValueAll()",
    "kind": "Method",
    "detail": "Function (} using ValueAllIter = TreeValueIteratorBase<Tree,RootNodeType::ValueAllIter> ; using ValueAllCIter = TreeValueIteratorBase<const Tree,RootNodeType::ValueAllCIter> ; using ValueOnIter = TreeValueIteratorBase<Tree,RootNodeType::ValueOnIter> ; using ValueOnCIter = TreeValueIteratorBase<const Tree,RootNodeType::ValueOnCIter> ; using ValueOffIter = TreeValueIteratorBase<Tree,RootNodeType::ValueOffIter> ; using ValueOffCIter = TreeValueIteratorBase<const Tree,RootNodeType::ValueOffCIter> ; ValueAllIter)",
    "insertText": "beginValueAll()"
  },
  {
    "label": "cbeginValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "cbeginValueAll()"
  },
  {
    "label": "beginValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnIter)",
    "insertText": "beginValueOn()"
  },
  {
    "label": "cbeginValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnCIter)",
    "insertText": "cbeginValueOn()"
  },
  {
    "label": "beginValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffIter)",
    "insertText": "beginValueOff()"
  },
  {
    "label": "cbeginValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "cbeginValueOff()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} template<IterT> IterT)",
    "insertText": "begin()"
  },
  {
    "label": "cbegin()",
    "kind": "Method",
    "detail": "Function (template<CIterT> CIterT)",
    "insertText": "cbegin()"
  },
  {
    "label": "DeallocateNodes()",
    "kind": "Method",
    "detail": "Function (template<NodeType> struct DeallocateNodes {)",
    "insertText": "DeallocateNodes(std::vector<NodeType*>& nodes) : mNodes(nodes.empty() ? nullptr : &nodes.front())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()(const tbb::blocked_range<size_t>& range)"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (delete mNodes [ n ] ; mNodes [ n ] = nullptr ; } } NodeType** const mNodes ; } ; RootNodeType mRoot ; AccessorRegistry mAccessorRegistry ; ConstAccessorRegistry mConstAccessorRegistry ; std::unique_ptr<const Name> sTreeTypeName ; } ; template<_RootNodeType> std::unique_ptr<const Name> Tree<_RootNodeType>::sTreeTypeName ; template<T,Index N1 = 4,Index N2 = 3> struct Tree3 { using Type = Tree<RootNode<InternalNode<LeafNode<T,N2>,N1>>> ; } ; template<T,Index N1 = 5,Index N2 = 4,Index N3 = 3> struct Tree4 { using Type = Tree<RootNode<InternalNode<InternalNode<LeafNode<T,N3>,N2>,N1>>> ; } ; template<T,Index N1 = 6,Index N2 = 5,Index N3 = 4,Index N4 = 3> struct Tree5 { using Type = Tree<RootNode<InternalNode<InternalNode<InternalNode<LeafNode<T,N4>,N3>,N2>,N1>>> ; } ; void)",
    "insertText": "readTopology(std::istream& is, bool)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (int32_t bufferCount ; is .)",
    "insertText": "read(reinterpret_cast<char*>(&bufferCount), sizeof(int32_t))"
  },
  {
    "label": "writeTopology()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "writeTopology(std::ostream& os, bool)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (int32_t bufferCount = 1 ; os .)",
    "insertText": "write(reinterpret_cast<char*>(&bufferCount), sizeof(int32_t))"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "print(std::ostream& os, int)"
  },
  {
    "label": "type()",
    "kind": "Method",
    "detail": "Function (os<<\" Tree Type : \"<<)",
    "insertText": "type() << \" Active Voxel Count: \" << activeVoxelCount() << std::endl << \" Active tile Count: \" << activeTileCount() << std::endl << \" Inactive Voxel Count: \" << inactiveVoxelCount() << std::endl << \" Leaf Node Count: \" << leafCount() << std::endl << \" Non-leaf Node Count: \" << nonLeafCount()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} template<TreeT,IterT> struct TreeIterTraits ; template<TreeT> struct TreeIterTraits<TreeT,TreeT::RootNodeType::ChildOnIter> { TreeT::RootNodeType::ChildOnIter)",
    "insertText": "begin(TreeT& tree)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} } ; template<TreeT> struct TreeIterTraits<TreeT,TreeT::RootNodeType::ChildOnCIter> { TreeT::RootNodeType::ChildOnCIter)",
    "insertText": "begin(const TreeT& tree)"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (} template<RootNodeType> void Tree<RootNodeType)",
    "insertText": "readTopology(std::istream& is, bool saveFloatAsHalf)"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readTopology(is, saveFloatAsHalf)"
  },
  {
    "label": "writeTopology()",
    "kind": "Method",
    "detail": "Function (} template<RootNodeType> void Tree<RootNodeType)",
    "insertText": "writeTopology(std::ostream& os, bool saveFloatAsHalf)"
  },
  {
    "label": "writeTopology()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeTopology(os, saveFloatAsHalf)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (} template<RootNodeType> void Tree<RootNodeType)",
    "insertText": "readBuffers(std::istream &is, bool saveFloatAsHalf)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "readBuffers(is, saveFloatAsHalf)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (} template<RootNodeType> void Tree<RootNodeType)",
    "insertText": "readBuffers(std::istream &is, const CoordBBox& bbox, bool saveFloatAsHalf)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "readBuffers(is, bbox, saveFloatAsHalf)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (it ->)",
    "insertText": "getValue(Index(0))"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (} } template<RootNodeType> void Tree<RootNodeType)",
    "insertText": "writeBuffers(std::ostream &os, bool saveFloatAsHalf)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "writeBuffers(os, saveFloatAsHalf)"
  },
  {
    "label": "stealNodes()",
    "kind": "Method",
    "detail": "Function (std::vector<LeafNodeType*> leafnodes ; this ->)",
    "insertText": "stealNodes(leafnodes)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, leafnodes.size()), DeallocateNodes<LeafNodeType>(leafnodes))"
  },
  {
    "label": "stealNodes()",
    "kind": "Method",
    "detail": "Function (std::vector<RootNodeType::ChildNodeType*> internalNodes ; this ->)",
    "insertText": "stealNodes(internalNodes)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, internalNodes.size()), DeallocateNodes<typename RootNodeType::ChildNodeType>(internalNodes))"
  },
  {
    "label": "attachAccessor()",
    "kind": "Method",
    "detail": "Function (} template<RootNodeType> void Tree<RootNodeType)",
    "insertText": "attachAccessor(ValueAccessorBase<Tree, true>& accessor)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (AccessorRegistry::accessor a ; mAccessorRegistry .)",
    "insertText": "insert(a, &accessor)"
  },
  {
    "label": "attachAccessor()",
    "kind": "Method",
    "detail": "Function (} template<RootNodeType> void Tree<RootNodeType)",
    "insertText": "attachAccessor(ValueAccessorBase<const Tree, true>& accessor)"
  },
  {
    "label": "releaseAccessor()",
    "kind": "Method",
    "detail": "Function (} template<RootNodeType> void Tree<RootNodeType)",
    "insertText": "releaseAccessor(ValueAccessorBase<Tree, true>& accessor)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (mAccessorRegistry .)",
    "insertText": "erase(&accessor)"
  },
  {
    "label": "releaseAccessor()",
    "kind": "Method",
    "detail": "Function (} template<RootNodeType> void Tree<RootNodeType)",
    "insertText": "releaseAccessor(ValueAccessorBase<const Tree, true>& accessor)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(typename ConstAccessorRegistry::iterator it = mConstAccessorRegistry.begin(); it != mConstAccessorRegistry.end(); ++it)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (mAccessorRegistry .)",
    "insertText": "erase(nullptr)"
  },
  {
    "label": "release()",
    "kind": "Method",
    "detail": "Function (it -> first ->)",
    "insertText": "release()"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (} template<RootNodeType> template<AccessT> const RootNodeType::ValueType& Tree<RootNodeType)",
    "insertText": "getValue(const Coord& xyz, AccessT& accessor)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "setValueOff(xyz)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "setValueOff(xyz, value)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "setActiveState(xyz, on)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "setValueOn(xyz, value)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "setValueOnly(xyz, value)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} template<RootNodeType> template<AccessT> void Tree<RootNodeType)",
    "insertText": "setValue(const Coord& xyz, const ValueType& value, AccessT& accessor)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (accessor .)",
    "insertText": "setValue(xyz, value)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "setActiveState(xyz, true)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "modifyValue(xyz, op)"
  },
  {
    "label": "modifyValueAndActiveState()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "modifyValueAndActiveState(xyz, op)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "addTile(level, xyz, value, active)"
  },
  {
    "label": "clip()",
    "kind": "Method",
    "detail": "Function (} template<RootNodeType> void Tree<RootNodeType)",
    "insertText": "clip(const CoordBBox& bbox)"
  },
  {
    "label": "getLeaf()",
    "kind": "Method",
    "detail": "Function (const LeafNodeType* leaf = it .)",
    "insertText": "getLeaf()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + it ;)",
    "insertText": "if(!leaf->isAllocated())"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "addTile(0, leaf->origin(), this->background(), false)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index32 sum = 0 ;)",
    "insertText": "for(auto it = this->cbeginLeaf(); it; ++it) if (!it->isAllocated())"
  },
  {
    "label": "denseFill()",
    "kind": "Method",
    "detail": "Function (} template<RootNodeType> void Tree<RootNodeType)",
    "insertText": "denseFill(const CoordBBox& bbox, const ValueType& value, bool active)"
  },
  {
    "label": "voxelizeActiveTiles()",
    "kind": "Method",
    "detail": "Function (} template<RootNodeType> void Tree<RootNodeType)",
    "insertText": "voxelizeActiveTiles(bool threaded)"
  },
  {
    "label": "voxelizeActiveTiles()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "voxelizeActiveTiles(threaded)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Metadata::Ptr result ;)",
    "insertText": "if(Metadata::isRegisteredType(valueType()))"
  },
  {
    "label": "createMetadata()",
    "kind": "Method",
    "detail": "Function (using MetadataT = TypedMetadata<ValueType> ; result =)",
    "insertText": "createMetadata(valueType())"
  },
  {
    "label": "MetadataT()",
    "kind": "Method",
    "detail": "Function (MetadataT* m = static_cast<)",
    "insertText": "MetadataT(result.get())"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (m ->)",
    "insertText": "value() = mRoot.background()"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (} } return result ; } template<RootNodeType> void Tree<RootNodeType)",
    "insertText": "merge(Tree& other, MergePolicy policy)"
  },
  {
    "label": "MERGE_NODES()",
    "kind": "Method",
    "detail": "Function (break ; case MERGE_NODES : mRoot . template merge<)",
    "insertText": "MERGE_NODES(other.mRoot)"
  },
  {
    "label": "MERGE_ACTIVE_STATES_AND_NODES()",
    "kind": "Method",
    "detail": "Function (break ; case MERGE_ACTIVE_STATES_AND_NODES : mRoot . template merge<)",
    "insertText": "MERGE_ACTIVE_STATES_AND_NODES(other.mRoot)"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (break ; } } template<RootNodeType> template<OtherRootNodeType> void Tree<RootNodeType)",
    "insertText": "topologyUnion(const Tree<OtherRootNodeType>& other, const bool preserveTiles)"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "topologyUnion(other.root(), preserveTiles)"
  },
  {
    "label": "topologyIntersection()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "topologyIntersection(other.root())"
  },
  {
    "label": "topologyDifference()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "topologyDifference(other.root())"
  },
  {
    "label": "CombineOpAdapter()",
    "kind": "Method",
    "detail": "Function (} template<AValueT,CombineOp,BValueT = AValueT> struct CombineOpAdapter {)",
    "insertText": "CombineOpAdapter(CombineOp& _op): op(_op)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()(CombineArgs<AValueT, BValueT>& args)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(args.a(), args.b(), args.result())"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (} CombineOp& op ; } ; template<RootNodeType> template<CombineOp> void Tree<RootNodeType)",
    "insertText": "combine(Tree& other, CombineOp& op, bool prune)"
  },
  {
    "label": "extendedOp()",
    "kind": "Method",
    "detail": "Function (CombineOpAdapter<ValueType,CombineOp>)",
    "insertText": "extendedOp(op)"
  },
  {
    "label": "combineExtended()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "combineExtended(other, extendedOp, prune)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (} # ifndef _MSC_VER template<RootNodeType> template<CombineOp> void Tree<RootNodeType)",
    "insertText": "combine(Tree& other, const CombineOp& op, bool prune)"
  },
  {
    "label": "combineExtended()",
    "kind": "Method",
    "detail": "Function (} # endif template<RootNodeType> template<ExtendedCombineOp> void Tree<RootNodeType)",
    "insertText": "combineExtended(Tree& other, ExtendedCombineOp& op, bool prune)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "combine(other.root(), op, prune)"
  },
  {
    "label": "combineExtended()",
    "kind": "Method",
    "detail": "Function (} # ifndef _MSC_VER template<RootNodeType> template<ExtendedCombineOp> void Tree<RootNodeType)",
    "insertText": "combineExtended(Tree& other, const ExtendedCombineOp& op, bool prune)"
  },
  {
    "label": "ExtendedCombineOp()",
    "kind": "Method",
    "detail": "Function (mRoot . template combine<const)",
    "insertText": "ExtendedCombineOp(other.mRoot, op, prune)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (} # endif template<RootNodeType> template<CombineOp,OtherTreeType> void Tree<RootNodeType)",
    "insertText": "combine2(const Tree& a, const OtherTreeType& b, CombineOp& op, bool prune)"
  },
  {
    "label": "combine2Extended()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "combine2Extended(a, b, extendedOp, prune)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (} # ifndef _MSC_VER template<RootNodeType> template<CombineOp,OtherTreeType> void Tree<RootNodeType)",
    "insertText": "combine2(const Tree& a, const OtherTreeType& b, const CombineOp& op, bool prune)"
  },
  {
    "label": "combine2Extended()",
    "kind": "Method",
    "detail": "Function (} # endif template<RootNodeType> template<ExtendedCombineOp,OtherTreeType> void Tree<RootNodeType)",
    "insertText": "combine2Extended(const Tree& a, const OtherTreeType& b, ExtendedCombineOp& op, bool prune)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "combine2(a.root(), b.root(), op, prune)"
  },
  {
    "label": "combine2Extended()",
    "kind": "Method",
    "detail": "Function (} # ifndef _MSC_VER template<RootNodeType> template<ExtendedCombineOp,OtherTreeType> void Tree<RootNodeType)",
    "insertText": "combine2Extended(const Tree& a, const OtherTreeType& b, const ExtendedCombineOp& op, bool prune)"
  },
  {
    "label": "ExtendedCombineOp()",
    "kind": "Method",
    "detail": "Function (mRoot . template combine2<const)",
    "insertText": "ExtendedCombineOp(a.root(), b.root(), op, prune)"
  },
  {
    "label": "visit()",
    "kind": "Method",
    "detail": "Function (} # endif template<RootNodeType> template<VisitorOp> void Tree<RootNodeType)",
    "insertText": "visit(VisitorOp& op)"
  },
  {
    "label": "VisitorOp()",
    "kind": "Method",
    "detail": "Function (mRoot . template visit<)",
    "insertText": "VisitorOp(op)"
  },
  {
    "label": "visit()",
    "kind": "Method",
    "detail": "Function (} template<RootNodeType> template<VisitorOp> void Tree<RootNodeType)",
    "insertText": "visit(const VisitorOp& op)"
  },
  {
    "label": "visit2()",
    "kind": "Method",
    "detail": "Function (} template<RootNodeType> template<OtherTreeType,VisitorOp> void Tree<RootNodeType)",
    "insertText": "visit2(OtherTreeType& other, VisitorOp& op)"
  },
  {
    "label": "VisitorOp()",
    "kind": "Method",
    "detail": "Function (using OtherRootNodeType = OtherTreeType::RootNodeType ; mRoot . template visit2<OtherRootNodeType,)",
    "insertText": "VisitorOp(other.root(), op)"
  },
  {
    "label": "visit2()",
    "kind": "Method",
    "detail": "Function (} template<RootNodeType> template<OtherTreeType,VisitorOp> void Tree<RootNodeType)",
    "insertText": "visit2(OtherTreeType& other, const VisitorOp& op)"
  },
  {
    "label": "call_once()",
    "kind": "Method",
    "detail": "Function (std::once_flag once ;)",
    "insertText": "call_once(once, []() { std::vector<Index> dims; Tree::getNodeLog2Dims(dims); std::ostringstream ostr; ostr << \"Tree_\" << typeNameAsString<BuildType>(); for (size_t i = 1, N = dims.size(); i < N; ++i) { ostr << \"_\" << dims[i]; } sTreeTypeName.reset(new Name(ostr.str())); })"
  },
  {
    "label": "dim()",
    "kind": "Method",
    "detail": "Function (Coord)",
    "insertText": "dim(0, 0, 0)"
  },
  {
    "label": "evalActiveVoxelDim()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "evalActiveVoxelDim(dim)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (const Index64 totalVoxels = dim .)",
    "insertText": "x() * dim.y() * dim.z(), activeVoxels = this->activeVoxelCount()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(totalVoxels >= activeVoxels)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "reset()"
  },
  {
    "label": "evalActiveBoundingBox()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "evalActiveBoundingBox(bbox, false)"
  },
  {
    "label": "evalActiveBoundingBox()",
    "kind": "Method",
    "detail": "Function (mRoot .)",
    "insertText": "evalActiveBoundingBox(bbox, true)"
  },
  {
    "label": "evalActiveVoxelBoundingBox()",
    "kind": "Method",
    "detail": "Function (CoordBBox bbox ; bool notEmpty = this ->)",
    "insertText": "evalActiveVoxelBoundingBox(bbox)"
  },
  {
    "label": "extents()",
    "kind": "Method",
    "detail": "Function (dim = bbox .)",
    "insertText": "extents()"
  },
  {
    "label": "evalLeafBoundingBox()",
    "kind": "Method",
    "detail": "Function (CoordBBox bbox ; bool notEmpty = this ->)",
    "insertText": "evalLeafBoundingBox(bbox)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (minVal = maxVal = zeroVal<)",
    "insertText": "ValueType()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (minVal = maxVal =* iter ;)",
    "insertText": "for(++iter; iter; ++iter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const ValueType& val =* iter ;)",
    "insertText": "if(math::cwiseLessThan(val, minVal))"
  },
  {
    "label": "getNodeLog2Dims()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getNodeLog2Dims(dims)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (} template<RootNodeType> void Tree<RootNodeType)",
    "insertText": "print(std::ostream& os, int verboseLevel)"
  },
  {
    "label": "OnExit()",
    "kind": "Method",
    "detail": "Function (struct OnExit { std::ostream& os ; std::streamsize savedPrecision ;)",
    "insertText": "OnExit(std::ostream& _os): os(_os), savedPrecision(os.precision())"
  },
  {
    "label": "OnExit()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "OnExit()"
  },
  {
    "label": "precision()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "precision(savedPrecision)"
  },
  {
    "label": "restorePrecision()",
    "kind": "Method",
    "detail": "Function (} } ; OnExit)",
    "insertText": "restorePrecision(os)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (os<<\" Configuration : \\ n \" ;)",
    "insertText": "if(verboseLevel <= 1)"
  },
  {
    "label": "Root()",
    "kind": "Method",
    "detail": "Function (os<<\")",
    "insertText": "Root(\" << mRoot.getTableSize() << \")"
  },
  {
    "label": "Internal()",
    "kind": "Method",
    "detail": "Function (os<<\",)",
    "insertText": "Internal(\" << (1 << dims[i]) << \"^3)"
  },
  {
    "label": "Leaf()",
    "kind": "Method",
    "detail": "Function (} os<<\",)",
    "insertText": "Leaf(\" << (1 << dims.back()) << \"^3)"
  },
  {
    "label": "evalMinMax()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "evalMinMax(minVal, maxVal)"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (const Index32 leafCount = nodeCount .)",
    "insertText": "front()"
  },
  {
    "label": "nodeCount()",
    "kind": "Method",
    "detail": "Function (# else std::vector<Index64>)",
    "insertText": "nodeCount(dims.size())"
  },
  {
    "label": "rbegin()",
    "kind": "Method",
    "detail": "Function (const Index64 leafCount =* nodeCount .)",
    "insertText": "rbegin()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "assert(dims.size() == nodeCount.size())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index64 totalNodeCount = 0 ;)",
    "insertText": "for(size_t i = 0; i < nodeCount.size(); ++i)"
  },
  {
    "label": "Root()",
    "kind": "Method",
    "detail": "Function (os<<\")",
    "insertText": "Root(1 x \" << mRoot.getTableSize() << \")"
  }
]