[
  {
    "label": "FRDGAsyncTask",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRDGAsyncTask"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "TRDGHandle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRDGHandle"
  },
  {
    "label": "TRDGHandleRegistry",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRDGHandleRegistry"
  },
  {
    "label": "TRDGHandleBitArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRDGHandleBitArray"
  },
  {
    "label": "TRDGHandleUniqueFilter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRDGHandleUniqueFilter"
  },
  {
    "label": "FRDGTextureDesc",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRDGTextureDesc"
  },
  {
    "label": "FRDGBlackboard",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGBlackboard"
  },
  {
    "label": "FRDGAsyncComputeBudgetScopeGuard",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGAsyncComputeBudgetScopeGuard"
  },
  {
    "label": "FRDGScopedCsvStatExclusive",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGScopedCsvStatExclusive"
  },
  {
    "label": "FRDGScopedCsvStatExclusiveConditional",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGScopedCsvStatExclusiveConditional"
  },
  {
    "label": "FRDGBarrierBatch",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGBarrierBatch"
  },
  {
    "label": "FRDGBarrierBatchBegin",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGBarrierBatchBegin"
  },
  {
    "label": "FRDGBarrierBatchEnd",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGBarrierBatchEnd"
  },
  {
    "label": "FRDGBarrierValidation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGBarrierValidation"
  },
  {
    "label": "FRDGEventName",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGEventName"
  },
  {
    "label": "FRDGUserValidation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGUserValidation"
  },
  {
    "label": "FRDGViewableResource",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGViewableResource"
  },
  {
    "label": "FRDGBufferPool",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGBufferPool"
  },
  {
    "label": "FRDGTransientRenderTarget",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGTransientRenderTarget"
  },
  {
    "label": "FRDGTrace",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGTrace"
  },
  {
    "label": "FRDGResourceDumpContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGResourceDumpContext"
  },
  {
    "label": "RDG_ENABLE_DEBUG()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" ProfilingDebugging / RealtimeGPUProfiler . h \" # include \" RenderGraphAllocator . h \" # include \" RenderGraphFwd . h \" # include \" RHIBreadcrumbs . h \" # define)",
    "insertText": "RDG_ENABLE_DEBUG(!UE_BUILD_SHIPPING && !UE_BUILD_TEST) #if RDG_ENABLE_DEBUG #define IF_RDG_ENABLE_DEBUG(Op) Op #else #define IF_RDG_ENABLE_DEBUG(Op) #endif #define RDG_ENABLE_DEBUG_WITH_ENGINE (RDG_ENABLE_DEBUG && WITH_ENGINE) #define RDG_ENABLE_TRACE UE_TRACE_ENABLED && !IS_PROGRAM && !UE_BUILD_SHIPPING #if RDG_ENABLE_TRACE #define IF_RDG_ENABLE_TRACE(Op) Op #else #define IF_RDG_ENABLE_TRACE(Op) #endif #define RDG_DUMP_RESOURCES (WITH_DUMPGPU) #define RDG_EVENTS_NONE 0 #define RDG_EVENTS_STRING_REF 1 #define RDG_EVENTS_STRING_COPY 2 #if WITH_PROFILEGPU #if UE_BUILD_TEST || UE_BUILD_SHIPPING #define RDG_EVENTS RDG_EVENTS_STRING_REF #else #define RDG_EVENTS RDG_EVENTS_STRING_COPY #endif #elif WITH_RHI_BREADCRUMBS #define RDG_EVENTS RDG_EVENTS_STRING_REF #else #define RDG_EVENTS RDG_EVENTS_NONE #endif #define SUPPORTS_VISUALIZE_TEXTURE (WITH_ENGINE && (!UE_BUILD_SHIPPING || WITH_EDITOR))"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ENUM_CLASS_FLAGS(ERDGBuilderFlags)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (enum class ERDGPassFlags : uint16 { None = 0,Raster = 1<<0,Compute = 1<<1,AsyncCompute = 1<<2,Copy = 1<<3,NeverCull = 1<<4,SkipRenderPass = 1<<5,NeverMerge = 1<<6,NeverParallel = 1<<7,Readback = Copy | NeverCull } ;)",
    "insertText": "ENUM_CLASS_FLAGS(ERDGPassFlags)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (enum class ERDGBufferFlags : uint8 { None = 0,MultiFrame = 1<<0,SkipTracking = 1<<1,ForceImmediateFirstBarrier = 1<<2,} ;)",
    "insertText": "ENUM_CLASS_FLAGS(ERDGBufferFlags)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (enum class ERDGTextureFlags : uint8 { None = 0,MultiFrame = 1<<0,SkipTracking = 1<<1,ForceImmediateFirstBarrier = 1<<2,MaintainCompression = 1<<3,} ;)",
    "insertText": "ENUM_CLASS_FLAGS(ERDGTextureFlags)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (enum class ERDGSetupTaskWaitPoint : uint8 { Compile = 0,Execute = 1,MAX } ; enum class ERDGUnorderedAccessViewFlags : uint8 { None = 0,SkipBarrier = 1<<0 } ;)",
    "insertText": "ENUM_CLASS_FLAGS(ERDGUnorderedAccessViewFlags)"
  },
  {
    "label": "GetParentType()",
    "kind": "Method",
    "detail": "Function (enum class ERDGViewableResourceType : uint8 { Texture,Buffer,MAX } ; enum class ERDGViewType : uint8 { TextureUAV,TextureSRV,BufferUAV,BufferSRV,MAX } ; ERDGViewableResourceType)",
    "insertText": "GetParentType(ERDGViewType ViewType)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (enum class ERDGInitialDataFlags : uint8 { None = 0,NoCopy = 1<<0 } ;)",
    "insertText": "ENUM_CLASS_FLAGS(ERDGInitialDataFlags)"
  },
  {
    "label": "GetViewableResourceType()",
    "kind": "Method",
    "detail": "Function (None,Page,PowerOfTwo } ; ERDGViewableResourceType)",
    "insertText": "GetViewableResourceType(ERDGViewType ViewType)"
  },
  {
    "label": "TRDGHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRDGHandle(uint32 InIndex)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Index(IndexType)"
  },
  {
    "label": "GetIndex()",
    "kind": "Method",
    "detail": "Function (} IndexType)",
    "insertText": "GetIndex()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TRDGHandle Handle =* this ; Handle - = Subtract ; return Handle ; } TRDGHandle)",
    "insertText": "operator(int32 Add)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TRDGHandle Handle =* this ; Handle + = Add ; return Handle ; } TRDGHandle&)",
    "insertText": "operator()"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (- - Index ; return* this ; } TRDGHandle)",
    "insertText": "Min(TRDGHandle A, TRDGHandle B)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (} private : const IndexType kNullIndex = TNumericLimits<IndexType)",
    "insertText": "Max()"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (IndexType Index = kNullIndex ; uint32)",
    "insertText": "GetTypeHash(TRDGHandle Handle)"
  },
  {
    "label": "TRDGHandleRegistry()",
    "kind": "Method",
    "detail": "Function (} } ; PRAGMA_ENABLE_BUFFER_OVERRUN_WARNING enum class ERDGHandleRegistryDestructPolicy { Registry,Allocator,Never } ; template<LocalHandleType,ERDGHandleRegistryDestructPolicy DestructPolicy = ERDGHandleRegistryDestructPolicy::Registry> class TRDGHandleRegistry { public : using HandleType = LocalHandleType ; using ObjectType = HandleType::ObjectType ; using IndexType = HandleType::IndexType ;)",
    "insertText": "TRDGHandleRegistry()"
  },
  {
    "label": "TRDGHandleRegistry()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRDGHandleRegistry(const TRDGHandleRegistry&)"
  },
  {
    "label": "TRDGHandleRegistry()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRDGHandleRegistry(TRDGHandleRegistry&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TRDGHandleRegistry&)",
    "insertText": "operator(TRDGHandleRegistry&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TRDGHandleRegistry&)",
    "insertText": "operator(const TRDGHandleRegistry&)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Clear()"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Insert(ObjectType* Object)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (Array .)",
    "insertText": "Emplace(Object)"
  },
  {
    "label": "Last()",
    "kind": "Method",
    "detail": "Function (Object -> Handle =)",
    "insertText": "Last()"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (} template<DerivedType = ObjectType,class . . . TArgs> DerivedType*)",
    "insertText": "Allocate(FRDGAllocator& Allocator, TArgs&&... Args)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (DerivedType* Object ;)",
    "insertText": "if(DestructPolicy == ERDGHandleRegistryDestructPolicy::Allocator)"
  },
  {
    "label": "DerivedType()",
    "kind": "Method",
    "detail": "Function (Object = Allocator . Alloc<)",
    "insertText": "DerivedType(Forward<TArgs>(Args)...)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Insert(Object)"
  },
  {
    "label": "ObjectType()",
    "kind": "Method",
    "detail": "Function (Array [ Index ] -> ~)",
    "insertText": "ObjectType()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (} } Array .)",
    "insertText": "Empty()"
  },
  {
    "label": "Enumerate()",
    "kind": "Method",
    "detail": "Function (} template<FunctionType> void)",
    "insertText": "Enumerate(FunctionType Function)"
  },
  {
    "label": "Function()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Function(Object)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} } const ObjectType*)",
    "insertText": "Get(HandleType Handle)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const ObjectType*)",
    "insertText": "operator(HandleType Handle)"
  },
  {
    "label": "Begin()",
    "kind": "Method",
    "detail": "Function (} HandleType)",
    "insertText": "Begin()"
  },
  {
    "label": "End()",
    "kind": "Method",
    "detail": "Function (} HandleType)",
    "insertText": "End()"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Num()"
  },
  {
    "label": "TRDGHandleUniqueFilter()",
    "kind": "Method",
    "detail": "Function (} } ; template<HandleType> class TRDGHandleUniqueFilter { public :)",
    "insertText": "TRDGHandleUniqueFilter()"
  },
  {
    "label": "TRDGHandleUniqueFilter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRDGHandleUniqueFilter(HandleType InHandle)"
  },
  {
    "label": "AddHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddHandle(InHandle)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset()"
  },
  {
    "label": "AddHandle()",
    "kind": "Method",
    "detail": "Function (Handle = HandleType::Null ; } void)",
    "insertText": "AddHandle(HandleType InHandle)"
  },
  {
    "label": "IsNull()",
    "kind": "Method",
    "detail": "Function (Handle = Handle .)",
    "insertText": "IsNull()"
  },
  {
    "label": "GetUniqueHandle()",
    "kind": "Method",
    "detail": "Function (} } HandleType)",
    "insertText": "GetUniqueHandle()"
  },
  {
    "label": "Create2D()",
    "kind": "Method",
    "detail": "Function (struct FRDGTextureDesc : public FRHITextureDesc { FRDGTextureDesc)",
    "insertText": "Create2D(FIntPoint Size , EPixelFormat Format , FClearValueBinding ClearValue , ETextureCreateFlags Flags , uint8 NumMips = 1 , uint8 NumSamples = 1 , uint32 ExtData = 0)"
  },
  {
    "label": "FRDGTextureDesc()",
    "kind": "Method",
    "detail": "Function (const uint16 Depth = 1 ; const uint16 ArraySize = 1 ; return)",
    "insertText": "FRDGTextureDesc(ETextureDimension::Texture2D, Flags, Format, ClearValue, { Size.X, Size.Y }, Depth, ArraySize, NumMips, NumSamples, ExtData)"
  },
  {
    "label": "Create2DArray()",
    "kind": "Method",
    "detail": "Function (} FRDGTextureDesc)",
    "insertText": "Create2DArray(FIntPoint Size , EPixelFormat Format , FClearValueBinding ClearValue , ETextureCreateFlags Flags , uint16 ArraySize , uint8 NumMips = 1 , uint8 NumSamples = 1 , uint32 ExtData = 0)"
  },
  {
    "label": "FRDGTextureDesc()",
    "kind": "Method",
    "detail": "Function (const uint16 Depth = 1 ; return)",
    "insertText": "FRDGTextureDesc(ETextureDimension::Texture2DArray, Flags, Format, ClearValue, { Size.X, Size.Y }, Depth, ArraySize, NumMips, NumSamples, ExtData)"
  },
  {
    "label": "Create3D()",
    "kind": "Method",
    "detail": "Function (} FRDGTextureDesc)",
    "insertText": "Create3D(FIntVector Size , EPixelFormat Format , FClearValueBinding ClearValue , ETextureCreateFlags Flags , uint8 NumMips = 1 , uint32 ExtData = 0)"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (const uint16 ArraySize = 1 ; const uint8 LocalNumSamples = 1 ;)",
    "insertText": "checkf(Size.Z <= TNumericLimits<decltype(FRDGTextureDesc::Depth)>::Max(), TEXT(\"Depth parameter (Size.Z) exceeds valid range\"))"
  },
  {
    "label": "CreateCube()",
    "kind": "Method",
    "detail": "Function (} FRDGTextureDesc)",
    "insertText": "CreateCube(uint32 Size , EPixelFormat Format , FClearValueBinding ClearValue , ETextureCreateFlags Flags , uint8 NumMips = 1 , uint8 NumSamples = 1 , uint32 ExtData = 0)"
  },
  {
    "label": "FRDGTextureDesc()",
    "kind": "Method",
    "detail": "Function (const uint16 Depth = 1 ; const uint16 ArraySize = 1 ; return)",
    "insertText": "FRDGTextureDesc(ETextureDimension::TextureCube, Flags, Format, ClearValue, { (int32)Size, (int32)Size }, Depth, ArraySize, NumMips, NumSamples, ExtData)"
  },
  {
    "label": "CreateCubeArray()",
    "kind": "Method",
    "detail": "Function (} FRDGTextureDesc)",
    "insertText": "CreateCubeArray(uint32 Size , EPixelFormat Format , FClearValueBinding ClearValue , ETextureCreateFlags Flags , uint16 ArraySize , uint8 NumMips = 1 , uint8 NumSamples = 1 , uint32 ExtData = 0)"
  },
  {
    "label": "FRDGTextureDesc()",
    "kind": "Method",
    "detail": "Function (const uint16 Depth = 1 ; return)",
    "insertText": "FRDGTextureDesc(ETextureDimension::TextureCubeArray, Flags, Format, ClearValue, { (int32)Size, (int32)Size }, Depth, ArraySize, NumMips, NumSamples, ExtData)"
  },
  {
    "label": "FRDGTextureDesc()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FRDGTextureDesc()"
  },
  {
    "label": "FRDGTextureDesc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRDGTextureDesc(ETextureDimension InDimension , ETextureCreateFlags InFlags , EPixelFormat InFormat , FClearValueBinding InClearValue , FIntPoint InExtent , uint16 InDepth , uint16 InArraySize , uint8 InNumMips , uint8 InNumSamples , uint32 InExtData ) : FRHITextureDesc(InDimension, InFlags, InFormat, InClearValue, InExtent, InDepth, InArraySize, InNumMips, InNumSamples, InExtData)"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (} } ; class FRDGBlackboard ; class FRDGAsyncComputeBudgetScopeGuard ; class FRDGScopedCsvStatExclusive ; class FRDGScopedCsvStatExclusiveConditional ; class FRDGBarrierBatch ; class FRDGBarrierBatchBegin ; class FRDGBarrierBatchEnd ; class FRDGBarrierValidation ; class FRDGEventName ; class FRDGUserValidation ; class FRDGViewableResource ; using FRDGPassHandle = TRDGHandle<FRDGPass,uint32> ; using FRDGPassRegistry = TRDGHandleRegistry<FRDGPassHandle> ; using FRDGPassHandleArray = TArray<FRDGPassHandle,TInlineAllocator<4,FRDGArrayAllocator>> ; using FRDGPassBitArray = TRDGHandleBitArray<FRDGPassHandle> ; using FRDGUniformBufferHandle = TRDGHandle<FRDGUniformBuffer,uint32> ; using FRDGUniformBufferRegistry = TRDGHandleRegistry<FRDGUniformBufferHandle> ; using FRDGUniformBufferBitArray = TRDGHandleBitArray<FRDGUniformBufferHandle> ; using FRDGViewHandle = TRDGHandle<FRDGView,uint32> ; using FRDGViewRegistry = TRDGHandleRegistry<FRDGViewHandle,ERDGHandleRegistryDestructPolicy::Never> ; using FRDGViewUniqueFilter = TRDGHandleUniqueFilter<FRDGViewHandle> ; using FRDGViewBitArray = TRDGHandleBitArray<FRDGViewHandle> ; using FRDGTextureHandle = TRDGHandle<FRDGTexture,uint32> ; using FRDGTextureRegistry = TRDGHandleRegistry<FRDGTextureHandle,ERDGHandleRegistryDestructPolicy::Never> ; using FRDGTextureBitArray = TRDGHandleBitArray<FRDGTextureHandle> ; using FRDGBufferHandle = TRDGHandle<FRDGBuffer,uint32> ; using FRDGBufferReservedCommitHandle = TRDGHandle<FRDGBuffer,uint16> ; using FRDGBufferRegistry = TRDGHandleRegistry<FRDGBufferHandle,ERDGHandleRegistryDestructPolicy::Registry> ; using FRDGBufferBitArray = TRDGHandleBitArray<FRDGBufferHandle> ; class FRDGBufferPool ; class FRDGTransientRenderTarget ; using FRDGPassHandlesByPipeline = TRHIPipelineArray<FRDGPassHandle> ; using FRDGPassesByPipeline = TRHIPipelineArray<FRDGPass*> ; class FRDGTrace ; class FRDGResourceDumpContext ; using FRDGBufferNumElementsCallback = TFunction<)",
    "insertText": "uint32()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (using FRDGBufferInitialDataCallback = TFunction<const)",
    "insertText": "void()"
  },
  {
    "label": "uint64()",
    "kind": "Method",
    "detail": "Function (using FRDGBufferInitialDataSizeCallback = TFunction<)",
    "insertText": "uint64()"
  },
  {
    "label": "ArrayType()",
    "kind": "Method",
    "detail": "Function (template<ArrayType,ArrayTypeNoRef = std::remove_reference_t<ArrayType>,= TEnableIf<TIsTArray_V<ArrayTypeNoRef>>::Type> using TRDGBufferArrayCallback = TFunction<const)",
    "insertText": "ArrayType()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (using FRDGBufferInitialDataFreeCallback = TFunction<)",
    "insertText": "void(const void* InData)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (using FRDGBufferInitialDataFillCallback = TFunction<)",
    "insertText": "void(void* InData, uint32 InDataSize)"
  },
  {
    "label": "FIntVector()",
    "kind": "Method",
    "detail": "Function (using FRDGDispatchGroupCountCallback = TFunction<)",
    "insertText": "FIntVector()"
  }
]