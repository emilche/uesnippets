[
  {
    "label": "FDynamicGraph",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDynamicGraph"
  },
  {
    "label": "FEdge",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEdge"
  },
  {
    "label": "FEdgeSplitInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEdgeSplitInfo"
  },
  {
    "label": "FEdgeCollapseInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEdgeCollapseInfo"
  },
  {
    "label": "FDynamicGraphN",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDynamicGraphN"
  },
  {
    "label": "InvalidEdgeV()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" VectorTypes . h \" # include \" IndexTypes . h \" # include \" BoxTypes . h \" # include \" GeometryTypes . h \" # include \" Util / DynamicVector . h \" # include \" Util / IndexUtil . h \" # include \" Util / IteratorUtil . h \" # include \" Util / RefCountVector . h \" # include \" Util / SmallListSet . h \" # include \" VectorUtil . h \" namespace UE { namespace Geometry { class FDynamicGraph { public : int InvalidID = IndexConstants::InvalidID ; int DuplicateEdgeID = - 2 ; struct FEdge { int A,B,Group ; } ; FIndex2i)",
    "insertText": "InvalidEdgeV()"
  },
  {
    "label": "InvalidEdge3()",
    "kind": "Method",
    "detail": "Function (} FEdge)",
    "insertText": "InvalidEdge3()"
  },
  {
    "label": "FDynamicGraph()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FDynamicGraph()"
  },
  {
    "label": "updateTimeStamp()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "updateTimeStamp(bool bShapeChange)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (timestamp + + ;)",
    "insertText": "if(bShapeChange)"
  },
  {
    "label": "Timestamp()",
    "kind": "Method",
    "detail": "Function (shape_timestamp + + ; } } public : int)",
    "insertText": "Timestamp()"
  },
  {
    "label": "EdgeCount()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "EdgeCount()"
  },
  {
    "label": "MaxVertexID()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "MaxVertexID()"
  },
  {
    "label": "MaxEdgeID()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "MaxEdgeID()"
  },
  {
    "label": "MaxGroupID()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "MaxGroupID()"
  },
  {
    "label": "IsEdge()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEdge(int EID)"
  },
  {
    "label": "VtxVerticesItr()",
    "kind": "Method",
    "detail": "Function (} FSmallListSet::MappedValueEnumerable)",
    "insertText": "VtxVerticesItr(int VID)"
  },
  {
    "label": "VtxEdgesItr()",
    "kind": "Method",
    "detail": "Function (} FSmallListSet::ValueEnumerable)",
    "insertText": "VtxEdgesItr(int VID)"
  },
  {
    "label": "GetVtxEdgeCount()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "GetVtxEdgeCount(int VID)"
  },
  {
    "label": "GetMaxVtxEdgeCount()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "GetMaxVtxEdgeCount()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int max = 0 ;)",
    "insertText": "for(int VID : vertices_refcount.Indices())"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (max =)",
    "insertText": "Max(max, vertex_edges.GetCount(VID))"
  },
  {
    "label": "GetEdgeV()",
    "kind": "Method",
    "detail": "Function (} return max ; } FIndex2i)",
    "insertText": "GetEdgeV(int EID)"
  },
  {
    "label": "GetEdgeGroup()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "GetEdgeGroup(int EID)"
  },
  {
    "label": "SetEdgeGroup()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetEdgeGroup(int EID, int GroupID)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (edges [ EID ] . Group = GroupID ; max_group_id =)",
    "insertText": "Max(max_group_id, GroupID + 1)"
  },
  {
    "label": "updateTimeStamp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "updateTimeStamp(false)"
  },
  {
    "label": "AllocateEdgeGroup()",
    "kind": "Method",
    "detail": "Function (} } int)",
    "insertText": "AllocateEdgeGroup()"
  },
  {
    "label": "append_vertex_internal()",
    "kind": "Method",
    "detail": "Function (} protected : int)",
    "insertText": "append_vertex_internal()"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (int VID = vertices_refcount .)",
    "insertText": "Allocate()"
  },
  {
    "label": "allocate_edges_list()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "allocate_edges_list(VID)"
  },
  {
    "label": "updateTimeStamp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "updateTimeStamp(true)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (vertex_edges .)",
    "insertText": "Clear(VID)"
  },
  {
    "label": "AllocateAt()",
    "kind": "Method",
    "detail": "Function (} vertex_edges .)",
    "insertText": "AllocateAt(VID)"
  },
  {
    "label": "AppendEdge()",
    "kind": "Method",
    "detail": "Function (} public : int)",
    "insertText": "AppendEdge(const FEdge& E)"
  },
  {
    "label": "AppendEdge()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "AppendEdge(const FIndex2i& ev, int GID = -1)"
  },
  {
    "label": "AppendEdge()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "AppendEdge(int v0, int v1, int GID = -1)"
  },
  {
    "label": "Increment()",
    "kind": "Method",
    "detail": "Function (vertices_refcount .)",
    "insertText": "Increment(v0)"
  },
  {
    "label": "Increment()",
    "kind": "Method",
    "detail": "Function (vertices_refcount .)",
    "insertText": "Increment(v1)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (max_group_id =)",
    "insertText": "Max(max_group_id, GID + 1)"
  },
  {
    "label": "add_edge()",
    "kind": "Method",
    "detail": "Function (int EID =)",
    "insertText": "add_edge(v0, v1, GID)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (edges .)",
    "insertText": "InsertAt(FEdge{A, B, GID}, EID)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (vertex_edges .)",
    "insertText": "Insert(A, EID)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (vertex_edges .)",
    "insertText": "Insert(B, EID)"
  },
  {
    "label": "EdgeIndices()",
    "kind": "Method",
    "detail": "Function (} typedef FRefCountVector::IndexEnumerable edge_iterator ; edge_iterator)",
    "insertText": "EdgeIndices()"
  },
  {
    "label": "Edges()",
    "kind": "Method",
    "detail": "Function (} template<T> using value_iteration = FRefCountVector::MappedEnumerable<T> ; value_iteration<FEdge>)",
    "insertText": "Edges()"
  },
  {
    "label": "FindEdge()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "FindEdge(int VA, int VB)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (int vMax =)",
    "insertText": "Max(VA, VB)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (vertex_edges .)",
    "insertText": "Remove(ev.A, EID)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (vertex_edges .)",
    "insertText": "Remove(ev.B, EID)"
  },
  {
    "label": "Decrement()",
    "kind": "Method",
    "detail": "Function (edges_refcount .)",
    "insertText": "Decrement(EID)"
  },
  {
    "label": "Decrement()",
    "kind": "Method",
    "detail": "Function (int VID = ev [ j ] ; vertices_refcount .)",
    "insertText": "Decrement(VID)"
  },
  {
    "label": "RemoveEdge()",
    "kind": "Method",
    "detail": "Function (EMeshResult result =)",
    "insertText": "RemoveEdge(EID, bRemoveIsolatedVertices)"
  },
  {
    "label": "SplitEdge()",
    "kind": "Method",
    "detail": "Function (} return EMeshResult::Ok ; } struct FEdgeSplitInfo { int VNew ; int ENewBN ; } ; EMeshResult)",
    "insertText": "SplitEdge(int VA, int VB, FEdgeSplitInfo& Split)"
  },
  {
    "label": "FindEdge()",
    "kind": "Method",
    "detail": "Function (int EID =)",
    "insertText": "FindEdge(VA, VB)"
  },
  {
    "label": "SplitEdge()",
    "kind": "Method",
    "detail": "Function (} EMeshResult)",
    "insertText": "SplitEdge(int EAB, FEdgeSplitInfo& Split)"
  },
  {
    "label": "replace_edge_vertex()",
    "kind": "Method",
    "detail": "Function (int eaf = EAB ;)",
    "insertText": "replace_edge_vertex(eaf, B, f)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (vertex_edges .)",
    "insertText": "Remove(B, EAB)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (vertex_edges .)",
    "insertText": "Insert(f, eaf)"
  },
  {
    "label": "add_edge()",
    "kind": "Method",
    "detail": "Function (int efb =)",
    "insertText": "add_edge(f, B, GID)"
  },
  {
    "label": "Increment()",
    "kind": "Method",
    "detail": "Function (vertices_refcount .)",
    "insertText": "Increment(f, 2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int FIncr = 0 ; int BIncr = 0 ;)",
    "insertText": "if(EAf != InvalidID)"
  },
  {
    "label": "RemoveEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveEdge(EAB, false)"
  },
  {
    "label": "replace_edge_vertex()",
    "kind": "Method",
    "detail": "Function (edges [ EAf ] . Group = GID ; } else { EAf = EAB ;)",
    "insertText": "replace_edge_vertex(EAf, B, f)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (vertex_edges .)",
    "insertText": "Insert(f, EAf)"
  },
  {
    "label": "FindEdge()",
    "kind": "Method",
    "detail": "Function (FIncr + + ; BIncr - - ; } int EfB =)",
    "insertText": "FindEdge(f, B)"
  },
  {
    "label": "Increment()",
    "kind": "Method",
    "detail": "Function (FIncr + + ; BIncr + + ; } else { edges [ EfB ] . Group = GID ; } vertices_refcount .)",
    "insertText": "Increment(f, (unsigned short) FIncr)"
  },
  {
    "label": "Increment()",
    "kind": "Method",
    "detail": "Function (vertices_refcount .)",
    "insertText": "Increment(B, (unsigned short) BIncr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(BIncr < 0)"
  },
  {
    "label": "BDecr()",
    "kind": "Method",
    "detail": "Function (unsigned short)",
    "insertText": "BDecr(unsigned short) (-BIncr)"
  },
  {
    "label": "Decrement()",
    "kind": "Method",
    "detail": "Function (vertices_refcount .)",
    "insertText": "Decrement(B, BDecr)"
  },
  {
    "label": "unimplemented()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "unimplemented()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool DiscardIsolatedVertices = true ;)",
    "insertText": "if(IsVertex(VKeep) == false || IsVertex(VRemove) == false)"
  },
  {
    "label": "edge_other_v()",
    "kind": "Method",
    "detail": "Function (int o =)",
    "insertText": "edge_other_v(eax, A)"
  },
  {
    "label": "RemoveEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveEdge(eax, DiscardIsolatedVertices)"
  },
  {
    "label": "replace_edge_vertex()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "replace_edge_vertex(eax, A, B)"
  },
  {
    "label": "Decrement()",
    "kind": "Method",
    "detail": "Function (vertices_refcount .)",
    "insertText": "Decrement(A)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (vertex_edges .)",
    "insertText": "Insert(B, eax)"
  },
  {
    "label": "Increment()",
    "kind": "Method",
    "detail": "Function (vertices_refcount .)",
    "insertText": "Increment(B)"
  },
  {
    "label": "Decrement()",
    "kind": "Method",
    "detail": "Function (} edges_refcount .)",
    "insertText": "Decrement(EAB)"
  },
  {
    "label": "Decrement()",
    "kind": "Method",
    "detail": "Function (vertices_refcount .)",
    "insertText": "Decrement(B)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (} vertex_edges .)",
    "insertText": "Clear(A)"
  },
  {
    "label": "edge_other_v()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "edge_other_v(int EID, int VID)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (int ev0 = edges [ EID ] . A,ev1 = edges [ EID ] . B ;)",
    "insertText": "return(ev0 == VID) ? ev1 : ((ev1 == VID) ? ev0 : InvalidID)"
  },
  {
    "label": "replace_edge_vertex()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "replace_edge_vertex(int EID, int VOld, int VNew)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int A = edges [ EID ] . A,B = edges [ EID ] . B ;)",
    "insertText": "if(A == VOld)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (edges [ EID ] . A =)",
    "insertText": "Min(B, VNew)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (edges [ EID ] . B =)",
    "insertText": "Max(B, VNew)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (edges [ EID ] . A =)",
    "insertText": "Min(A, VNew)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (edges [ EID ] . B =)",
    "insertText": "Max(A, VNew)"
  },
  {
    "label": "IsCompactV()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsCompactV()"
  },
  {
    "label": "IsBoundaryVertex()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsBoundaryVertex(int VID)"
  },
  {
    "label": "IsJunctionVertex()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsJunctionVertex(int VID)"
  },
  {
    "label": "IsRegularVertex()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsRegularVertex(int VID)"
  },
  {
    "label": "CheckValidity()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "CheckValidity(EValidityCheckFailMode FailMode = EValidityCheckFailMode::Check)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (bool is_ok = true ; TFunction<)",
    "insertText": "void(bool)> CheckOrFailF = [&](bool b)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (is_ok = is_ok&& b ; } ;)",
    "insertText": "if(FailMode == EValidityCheckFailMode::Check)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (is_ok = is_ok&& b ; } ; } else)",
    "insertText": "if(FailMode == EValidityCheckFailMode::Ensure)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (is_ok = is_ok&& b ; } ; })",
    "insertText": "for(int EID : EdgeIndices())"
  },
  {
    "label": "GetEdgeV()",
    "kind": "Method",
    "detail": "Function (FIndex2i ev =)",
    "insertText": "GetEdgeV(EID)"
  },
  {
    "label": "IsDense()",
    "kind": "Method",
    "detail": "Function (} bool is_compact = vertices_refcount .)",
    "insertText": "IsDense()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(int VID : VertexIndices())"
  },
  {
    "label": "edge_other_v()",
    "kind": "Method",
    "detail": "Function (int otherV =)",
    "insertText": "edge_other_v(edgeid, VID)"
  },
  {
    "label": "FindEdge()",
    "kind": "Method",
    "detail": "Function (int e2 =)",
    "insertText": "FindEdge(VID, otherV)"
  },
  {
    "label": "FindEdge()",
    "kind": "Method",
    "detail": "Function (e2 =)",
    "insertText": "FindEdge(otherV, VID)"
  },
  {
    "label": "CheckOrFailF()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CheckOrFailF(vertices_refcount.GetRefCount(VID) == vertex_edges.GetCount(VID) + 1)"
  },
  {
    "label": "subclass_validity_checks()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "subclass_validity_checks(CheckOrFailF)"
  },
  {
    "label": "debug_check_is_vertex()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "debug_check_is_vertex(int V)"
  },
  {
    "label": "debug_check_is_edge()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "debug_check_is_edge(int E)"
  },
  {
    "label": "AppendVertex()",
    "kind": "Method",
    "detail": "Function (} } ; class FDynamicGraphN : public FDynamicGraph { public : int)",
    "insertText": "AppendVertex()"
  },
  {
    "label": "append_new_split_vertex()",
    "kind": "Method",
    "detail": "Function (} protected : int)",
    "insertText": "append_new_split_vertex(int A, int B)"
  }
]