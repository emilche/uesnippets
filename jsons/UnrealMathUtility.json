[
  {
    "label": "FTwoVectors",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTwoVectors"
  },
  {
    "label": "FLinearColor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FLinearColor"
  },
  {
    "label": "TRange",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRange"
  },
  {
    "label": "TCustomLerp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TCustomLerp"
  },
  {
    "label": "FMath",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMath"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "U",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "U"
  },
  {
    "label": "UE_PRIVATE_MATH_DEPRECATION()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Misc / AssertionMacros . h \" # include \" HAL / PlatformMath . h \" # include \" Math / MathFwd . h \" # include \" Templates / Identity . h \" # include \" Templates / Requires . h \" # ifndef ENABLE_NAN_DIAGNOSTIC # if UE_BUILD_DEBUG # define ENABLE_NAN_DIAGNOSTIC 1 # else # define ENABLE_NAN_DIAGNOSTIC 0 # endif # endif struct FTwoVectors ; struct FLinearColor ; template<ElementType> class TRange ; # define UE_INCLUDETOOL_IGNORE_INCONSISTENT_STATE # ifndef UE_DEPRECATE_LEGACY_MATH_CONSTANT_MACRO_NAMES # define UE_DEPRECATE_LEGACY_MATH_CONSTANT_MACRO_NAMES 0 # endif # ifndef UE_DEFINE_LEGACY_MATH_CONSTANT_MACRO_NAMES # define UE_DEFINE_LEGACY_MATH_CONSTANT_MACRO_NAMES 1 # endif # if UE_DEFINE_LEGACY_MATH_CONSTANT_MACRO_NAMES # if UE_DEPRECATE_LEGACY_MATH_CONSTANT_MACRO_NAMES # define)",
    "insertText": "UE_PRIVATE_MATH_DEPRECATION(Before, After) UE_DEPRECATED_MACRO(5.1, \"The \" #Before \" macro has been deprecated in favor of \" #After \".\") #else #define UE_PRIVATE_MATH_DEPRECATION(Before, After) #endif #undef PI #define PI UE_PRIVATE_MATH_DEPRECATION(PI , UE_PI ) UE_PI #define SMALL_NUMBER UE_PRIVATE_MATH_DEPRECATION(SMALL_NUMBER , UE_SMALL_NUMBER ) UE_SMALL_NUMBER #define KINDA_SMALL_NUMBER UE_PRIVATE_MATH_DEPRECATION(KINDA_SMALL_NUMBER , UE_KINDA_SMALL_NUMBER ) UE_KINDA_SMALL_NUMBER #define BIG_NUMBER UE_PRIVATE_MATH_DEPRECATION(BIG_NUMBER , UE_BIG_NUMBER ) UE_BIG_NUMBER #define EULERS_NUMBER UE_PRIVATE_MATH_DEPRECATION(EULERS_NUMBER , UE_EULERS_NUMBER ) UE_EULERS_NUMBER #define FLOAT_NON_FRACTIONAL UE_PRIVATE_MATH_DEPRECATION(FLOAT_NON_FRACTIONAL , UE_FLOAT_NON_FRACTIONAL ) UE_FLOAT_NON_FRACTIONAL #define DOUBLE_PI UE_PRIVATE_MATH_DEPRECATION(DOUBLE_PI , UE_DOUBLE_PI ) UE_DOUBLE_PI #define DOUBLE_SMALL_NUMBER UE_PRIVATE_MATH_DEPRECATION(DOUBLE_SMALL_NUMBER , UE_DOUBLE_SMALL_NUMBER ) UE_DOUBLE_SMALL_NUMBER #define DOUBLE_KINDA_SMALL_NUMBER UE_PRIVATE_MATH_DEPRECATION(DOUBLE_KINDA_SMALL_NUMBER , UE_DOUBLE_KINDA_SMALL_NUMBER ) UE_DOUBLE_KINDA_SMALL_NUMBER #define DOUBLE_BIG_NUMBER UE_PRIVATE_MATH_DEPRECATION(DOUBLE_BIG_NUMBER , UE_DOUBLE_BIG_NUMBER ) UE_DOUBLE_BIG_NUMBER #define DOUBLE_EULERS_NUMBER UE_PRIVATE_MATH_DEPRECATION(DOUBLE_EULERS_NUMBER , UE_DOUBLE_EULERS_NUMBER ) UE_DOUBLE_EULERS_NUMBER #define DOUBLE_UE_GOLDEN_RATIO UE_PRIVATE_MATH_DEPRECATION(DOUBLE_UE_GOLDEN_RATIO , UE_DOUBLE_GOLDEN_RATIO ) UE_DOUBLE_GOLDEN_RATIO #define DOUBLE_NON_FRACTIONAL UE_PRIVATE_MATH_DEPRECATION(DOUBLE_NON_FRACTIONAL , UE_DOUBLE_NON_FRACTIONAL ) UE_DOUBLE_NON_FRACTIONAL #define MAX_FLT UE_PRIVATE_MATH_DEPRECATION(MAX_FLT , UE_MAX_FLT ) UE_MAX_FLT #define INV_PI UE_PRIVATE_MATH_DEPRECATION(INV_PI , UE_INV_PI ) UE_INV_PI #define HALF_PI UE_PRIVATE_MATH_DEPRECATION(HALF_PI , UE_HALF_PI ) UE_HALF_PI #define TWO_PI UE_PRIVATE_MATH_DEPRECATION(TWO_PI , UE_TWO_PI ) UE_TWO_PI #define PI_SQUARED UE_PRIVATE_MATH_DEPRECATION(PI_SQUARED , UE_PI_SQUARED ) UE_PI_SQUARED #define DOUBLE_INV_PI UE_PRIVATE_MATH_DEPRECATION(DOUBLE_INV_PI , UE_DOUBLE_INV_PI ) UE_DOUBLE_INV_PI #define DOUBLE_HALF_PI UE_PRIVATE_MATH_DEPRECATION(DOUBLE_HALF_PI , UE_DOUBLE_HALF_PI ) UE_DOUBLE_HALF_PI #define DOUBLE_TWO_PI UE_PRIVATE_MATH_DEPRECATION(DOUBLE_TWO_PI , UE_DOUBLE_TWO_PI ) UE_DOUBLE_TWO_PI #define DOUBLE_PI_SQUARED UE_PRIVATE_MATH_DEPRECATION(DOUBLE_PI_SQUARED , UE_DOUBLE_PI_SQUARED ) UE_DOUBLE_PI_SQUARED #define DOUBLE_UE_SQRT_2 UE_PRIVATE_MATH_DEPRECATION(DOUBLE_UE_SQRT_2 , UE_DOUBLE_SQRT_2 ) UE_DOUBLE_SQRT_2 #define DOUBLE_UE_SQRT_3 UE_PRIVATE_MATH_DEPRECATION(DOUBLE_UE_SQRT_3 , UE_DOUBLE_SQRT_3 ) UE_DOUBLE_SQRT_3 #define DOUBLE_UE_INV_SQRT_2 UE_PRIVATE_MATH_DEPRECATION(DOUBLE_UE_INV_SQRT_2 , UE_DOUBLE_INV_SQRT_2 ) UE_DOUBLE_INV_SQRT_2 #define DOUBLE_UE_INV_SQRT_3 UE_PRIVATE_MATH_DEPRECATION(DOUBLE_UE_INV_SQRT_3 , UE_DOUBLE_INV_SQRT_3 ) UE_DOUBLE_INV_SQRT_3 #define DOUBLE_UE_HALF_SQRT_2 UE_PRIVATE_MATH_DEPRECATION(DOUBLE_UE_HALF_SQRT_2 , UE_DOUBLE_HALF_SQRT_2 ) UE_DOUBLE_HALF_SQRT_2 #define DOUBLE_UE_HALF_SQRT_3 UE_PRIVATE_MATH_DEPRECATION(DOUBLE_UE_HALF_SQRT_3 , UE_DOUBLE_HALF_SQRT_3 ) UE_DOUBLE_HALF_SQRT_3 #define DELTA UE_PRIVATE_MATH_DEPRECATION(DELTA , UE_DELTA ) UE_DELTA #define DOUBLE_DELTA UE_PRIVATE_MATH_DEPRECATION(DOUBLE_DELTA , UE_DOUBLE_DELTA ) UE_DOUBLE_DELTA #define FLOAT_NORMAL_THRESH UE_PRIVATE_MATH_DEPRECATION(FLOAT_NORMAL_THRESH , UE_FLOAT_NORMAL_THRESH ) UE_FLOAT_NORMAL_THRESH #define DOUBLE_NORMAL_THRESH UE_PRIVATE_MATH_DEPRECATION(DOUBLE_NORMAL_THRESH , UE_DOUBLE_NORMAL_THRESH ) UE_DOUBLE_NORMAL_THRESH #define THRESH_POINT_ON_PLANE UE_PRIVATE_MATH_DEPRECATION(THRESH_POINT_ON_PLANE , UE_THRESH_POINT_ON_PLANE ) UE_THRESH_POINT_ON_PLANE #define THRESH_POINT_ON_SIDE UE_PRIVATE_MATH_DEPRECATION(THRESH_POINT_ON_SIDE , UE_THRESH_POINT_ON_SIDE ) UE_THRESH_POINT_ON_SIDE #define THRESH_POINTS_ARE_SAME UE_PRIVATE_MATH_DEPRECATION(THRESH_POINTS_ARE_SAME , UE_THRESH_POINTS_ARE_SAME ) UE_THRESH_POINTS_ARE_SAME #define THRESH_POINTS_ARE_NEAR UE_PRIVATE_MATH_DEPRECATION(THRESH_POINTS_ARE_NEAR , UE_THRESH_POINTS_ARE_NEAR ) UE_THRESH_POINTS_ARE_NEAR #define THRESH_NORMALS_ARE_SAME UE_PRIVATE_MATH_DEPRECATION(THRESH_NORMALS_ARE_SAME , UE_THRESH_NORMALS_ARE_SAME ) UE_THRESH_NORMALS_ARE_SAME #define THRESH_UVS_ARE_SAME UE_PRIVATE_MATH_DEPRECATION(THRESH_UVS_ARE_SAME , UE_THRESH_UVS_ARE_SAME ) UE_THRESH_UVS_ARE_SAME #define THRESH_VECTORS_ARE_NEAR UE_PRIVATE_MATH_DEPRECATION(THRESH_VECTORS_ARE_NEAR , UE_THRESH_VECTORS_ARE_NEAR ) UE_THRESH_VECTORS_ARE_NEAR #define THRESH_SPLIT_POLY_WITH_PLANE UE_PRIVATE_MATH_DEPRECATION(THRESH_SPLIT_POLY_WITH_PLANE , UE_THRESH_SPLIT_POLY_WITH_PLANE ) UE_THRESH_SPLIT_POLY_WITH_PLANE #define THRESH_SPLIT_POLY_PRECISELY UE_PRIVATE_MATH_DEPRECATION(THRESH_SPLIT_POLY_PRECISELY , UE_THRESH_SPLIT_POLY_PRECISELY ) UE_THRESH_SPLIT_POLY_PRECISELY #define THRESH_ZERO_NORM_SQUARED UE_PRIVATE_MATH_DEPRECATION(THRESH_ZERO_NORM_SQUARED , UE_THRESH_ZERO_NORM_SQUARED ) UE_THRESH_ZERO_NORM_SQUARED #define THRESH_NORMALS_ARE_PARALLEL UE_PRIVATE_MATH_DEPRECATION(THRESH_NORMALS_ARE_PARALLEL , UE_THRESH_NORMALS_ARE_PARALLEL ) UE_THRESH_NORMALS_ARE_PARALLEL #define THRESH_NORMALS_ARE_ORTHOGONAL UE_PRIVATE_MATH_DEPRECATION(THRESH_NORMALS_ARE_ORTHOGONAL , UE_THRESH_NORMALS_ARE_ORTHOGONAL ) UE_THRESH_NORMALS_ARE_ORTHOGONAL #define THRESH_VECTOR_NORMALIZED UE_PRIVATE_MATH_DEPRECATION(THRESH_VECTOR_NORMALIZED , UE_THRESH_VECTOR_NORMALIZED ) UE_THRESH_VECTOR_NORMALIZED #define THRESH_QUAT_NORMALIZED UE_PRIVATE_MATH_DEPRECATION(THRESH_QUAT_NORMALIZED , UE_THRESH_QUAT_NORMALIZED ) UE_THRESH_QUAT_NORMALIZED #define DOUBLE_THRESH_POINT_ON_PLANE UE_PRIVATE_MATH_DEPRECATION(DOUBLE_THRESH_POINT_ON_PLANE , UE_DOUBLE_THRESH_POINT_ON_PLANE ) UE_DOUBLE_THRESH_POINT_ON_PLANE #define DOUBLE_THRESH_POINT_ON_SIDE UE_PRIVATE_MATH_DEPRECATION(DOUBLE_THRESH_POINT_ON_SIDE , UE_DOUBLE_THRESH_POINT_ON_SIDE ) UE_DOUBLE_THRESH_POINT_ON_SIDE #define DOUBLE_THRESH_POINTS_ARE_SAME UE_PRIVATE_MATH_DEPRECATION(DOUBLE_THRESH_POINTS_ARE_SAME , UE_DOUBLE_THRESH_POINTS_ARE_SAME ) UE_DOUBLE_THRESH_POINTS_ARE_SAME #define DOUBLE_THRESH_POINTS_ARE_NEAR UE_PRIVATE_MATH_DEPRECATION(DOUBLE_THRESH_POINTS_ARE_NEAR , UE_DOUBLE_THRESH_POINTS_ARE_NEAR ) UE_DOUBLE_THRESH_POINTS_ARE_NEAR #define DOUBLE_THRESH_NORMALS_ARE_SAME UE_PRIVATE_MATH_DEPRECATION(DOUBLE_THRESH_NORMALS_ARE_SAME , UE_DOUBLE_THRESH_NORMALS_ARE_SAME ) UE_DOUBLE_THRESH_NORMALS_ARE_SAME #define DOUBLE_THRESH_UVS_ARE_SAME UE_PRIVATE_MATH_DEPRECATION(DOUBLE_THRESH_UVS_ARE_SAME , UE_DOUBLE_THRESH_UVS_ARE_SAME ) UE_DOUBLE_THRESH_UVS_ARE_SAME #define DOUBLE_THRESH_VECTORS_ARE_NEAR UE_PRIVATE_MATH_DEPRECATION(DOUBLE_THRESH_VECTORS_ARE_NEAR , UE_DOUBLE_THRESH_VECTORS_ARE_NEAR ) UE_DOUBLE_THRESH_VECTORS_ARE_NEAR #define DOUBLE_THRESH_SPLIT_POLY_WITH_PLANE UE_PRIVATE_MATH_DEPRECATION(DOUBLE_THRESH_SPLIT_POLY_WITH_PLANE , UE_DOUBLE_THRESH_SPLIT_POLY_WITH_PLANE ) UE_DOUBLE_THRESH_SPLIT_POLY_WITH_PLANE #define DOUBLE_THRESH_SPLIT_POLY_PRECISELY UE_PRIVATE_MATH_DEPRECATION(DOUBLE_THRESH_SPLIT_POLY_PRECISELY , UE_DOUBLE_THRESH_SPLIT_POLY_PRECISELY ) UE_DOUBLE_THRESH_SPLIT_POLY_PRECISELY #define DOUBLE_THRESH_ZERO_NORM_SQUARED UE_PRIVATE_MATH_DEPRECATION(DOUBLE_THRESH_ZERO_NORM_SQUARED , UE_DOUBLE_THRESH_ZERO_NORM_SQUARED ) UE_DOUBLE_THRESH_ZERO_NORM_SQUARED #define DOUBLE_THRESH_NORMALS_ARE_PARALLEL UE_PRIVATE_MATH_DEPRECATION(DOUBLE_THRESH_NORMALS_ARE_PARALLEL , UE_DOUBLE_THRESH_NORMALS_ARE_PARALLEL ) UE_DOUBLE_THRESH_NORMALS_ARE_PARALLEL #define DOUBLE_THRESH_NORMALS_ARE_ORTHOGONAL UE_PRIVATE_MATH_DEPRECATION(DOUBLE_THRESH_NORMALS_ARE_ORTHOGONAL , UE_DOUBLE_THRESH_NORMALS_ARE_ORTHOGONAL ) UE_DOUBLE_THRESH_NORMALS_ARE_ORTHOGONAL #define DOUBLE_THRESH_VECTOR_NORMALIZED UE_PRIVATE_MATH_DEPRECATION(DOUBLE_THRESH_VECTOR_NORMALIZED , UE_DOUBLE_THRESH_VECTOR_NORMALIZED ) UE_DOUBLE_THRESH_VECTOR_NORMALIZED #define DOUBLE_THRESH_QUAT_NORMALIZED UE_PRIVATE_MATH_DEPRECATION(DOUBLE_THRESH_QUAT_NORMALIZED , UE_DOUBLE_THRESH_QUAT_NORMALIZED ) UE_DOUBLE_THRESH_QUAT_NORMALIZED #endif #undef UE_INCLUDETOOL_IGNORE_INCONSISTENT_STATE #define UE_PI (3.1415926535897932f) #define UE_SMALL_NUMBER (1.e-8f) #define UE_KINDA_SMALL_NUMBER (1.e-4f) #define UE_BIG_NUMBER (3.4e+38f) #define UE_EULERS_NUMBER (2.71828182845904523536f) #define UE_GOLDEN_RATIO (1.6180339887498948482045868343656381f) #define UE_FLOAT_NON_FRACTIONAL (8388608.f) #define UE_DOUBLE_PI (3.141592653589793238462643383279502884197169399) #define UE_DOUBLE_SMALL_NUMBER (1.e-8) #define UE_DOUBLE_KINDA_SMALL_NUMBER (1.e-4) #define UE_DOUBLE_BIG_NUMBER (3.4e+38) #define UE_DOUBLE_EULERS_NUMBER (2.7182818284590452353602874713526624977572) #define UE_DOUBLE_GOLDEN_RATIO (1.6180339887498948482045868343656381) #define UE_DOUBLE_NON_FRACTIONAL (4503599627370496.0) #define UE_MAX_FLT 3.402823466e+38F #define UE_INV_PI (0.31830988618f) #define UE_HALF_PI (1.57079632679f) #define UE_TWO_PI (6.28318530717f) #define UE_PI_SQUARED (9.86960440108f) #define UE_DOUBLE_INV_PI (0.31830988618379067154) #define UE_DOUBLE_HALF_PI (1.57079632679489661923) #define UE_DOUBLE_TWO_PI (6.28318530717958647692) #define UE_DOUBLE_PI_SQUARED (9.86960440108935861883) #define UE_SQRT_2 (1.4142135623730950488016887242097f) #define UE_SQRT_3 (1.7320508075688772935274463415059f) #define UE_INV_SQRT_2 (0.70710678118654752440084436210485f) #define UE_INV_SQRT_3 (0.57735026918962576450914878050196f) #define UE_HALF_SQRT_2 (0.70710678118654752440084436210485f) #define UE_HALF_SQRT_3 (0.86602540378443864676372317075294f) #define UE_DOUBLE_SQRT_2 (1.4142135623730950488016887242097) #define UE_DOUBLE_SQRT_3 (1.7320508075688772935274463415059) #define UE_DOUBLE_INV_SQRT_2 (0.70710678118654752440084436210485) #define UE_DOUBLE_INV_SQRT_3 (0.57735026918962576450914878050196) #define UE_DOUBLE_HALF_SQRT_2 (0.70710678118654752440084436210485) #define UE_DOUBLE_HALF_SQRT_3 (0.86602540378443864676372317075294) #define UE_KM_TO_M (1000.f) #define UE_M_TO_KM (0.001f) #define UE_CM_TO_M (0.01f) #define UE_M_TO_CM (100.f) #define UE_CM2_TO_M2 (0.0001f) #define UE_M2_TO_CM2 (10000.f) #define UE_DELTA (0.00001f) #define UE_DOUBLE_DELTA (0.00001 ) #define UE_FLOAT_NORMAL_THRESH (0.0001f) #define UE_DOUBLE_NORMAL_THRESH (0.0001) #define UE_THRESH_POINT_ON_PLANE (0.10f) #define UE_THRESH_POINT_ON_SIDE (0.20f) #define UE_THRESH_POINTS_ARE_SAME (0.00002f) #define UE_THRESH_POINTS_ARE_NEAR (0.015f) #define UE_THRESH_NORMALS_ARE_SAME (0.00002f) #define UE_THRESH_UVS_ARE_SAME (0.0009765625f) #define UE_THRESH_VECTORS_ARE_NEAR (0.0004f) #define UE_THRESH_SPLIT_POLY_WITH_PLANE (0.25f) #define UE_THRESH_SPLIT_POLY_PRECISELY (0.01f) #define UE_THRESH_ZERO_NORM_SQUARED (0.0001f) #define UE_THRESH_NORMALS_ARE_PARALLEL (0.999845f) #define UE_THRESH_NORMALS_ARE_ORTHOGONAL (0.017455f) #define UE_THRESH_VECTOR_NORMALIZED (0.01f) #define UE_THRESH_QUAT_NORMALIZED (0.01f) #define UE_DOUBLE_THRESH_POINT_ON_PLANE (0.10) #define UE_DOUBLE_THRESH_POINT_ON_SIDE (0.20) #define UE_DOUBLE_THRESH_POINTS_ARE_SAME (0.00002) #define UE_DOUBLE_THRESH_POINTS_ARE_NEAR (0.015) #define UE_DOUBLE_THRESH_NORMALS_ARE_SAME (0.00002) #define UE_DOUBLE_THRESH_UVS_ARE_SAME (0.0009765625) #define UE_DOUBLE_THRESH_VECTORS_ARE_NEAR (0.0004) #define UE_DOUBLE_THRESH_SPLIT_POLY_WITH_PLANE (0.25) #define UE_DOUBLE_THRESH_SPLIT_POLY_PRECISELY (0.01) #define UE_DOUBLE_THRESH_ZERO_NORM_SQUARED (0.0001) #define UE_DOUBLE_THRESH_NORMALS_ARE_PARALLEL (0.999845) #define UE_DOUBLE_THRESH_NORMALS_ARE_ORTHOGONAL (0.017455) #define UE_DOUBLE_THRESH_VECTOR_NORMALIZED (0.01) #define UE_DOUBLE_THRESH_QUAT_NORMALIZED (0.01)"
  },
  {
    "label": "RandHelper()",
    "kind": "Method",
    "detail": "Function (bool Value = false ; } ; struct FMath : public FPlatformMath { [ [ nodiscard ] ] int32)",
    "insertText": "RandHelper(int32 A)"
  },
  {
    "label": "RandHelper64()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] int64)",
    "insertText": "RandHelper64(int64 A)"
  },
  {
    "label": "RandRange()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] int32)",
    "insertText": "RandRange(int32 Min, int32 Max)"
  },
  {
    "label": "Range()",
    "kind": "Method",
    "detail": "Function (const int32)",
    "insertText": "Range(Max - Min)"
  },
  {
    "label": "RandRange()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] int64)",
    "insertText": "RandRange(int64 Min, int64 Max)"
  },
  {
    "label": "RandRange()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] float)",
    "insertText": "RandRange(float InMin, float InMax)"
  },
  {
    "label": "RandRange()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] double)",
    "insertText": "RandRange(double InMin, double InMax)"
  },
  {
    "label": "FRandRange()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] float)",
    "insertText": "FRandRange(float InMin, float InMax)"
  },
  {
    "label": "FRandRange()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] double)",
    "insertText": "FRandRange(double InMin, double InMax)"
  },
  {
    "label": "RESOLVE_FLOAT_AMBIGUITY_2_ARGS()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RESOLVE_FLOAT_AMBIGUITY_2_ARGS(FRandRange)"
  },
  {
    "label": "RandBool()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] bool)",
    "insertText": "RandBool()"
  },
  {
    "label": "VRand()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] FVector)",
    "insertText": "VRand()"
  },
  {
    "label": "VRandCone()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector)",
    "insertText": "VRandCone(FVector const& Dir, float ConeHalfAngleRad)"
  },
  {
    "label": "VRandCone()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector)",
    "insertText": "VRandCone(FVector const& Dir, float HorizontalConeHalfAngleRad, float VerticalConeHalfAngleRad)"
  },
  {
    "label": "RandPointInCircle()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector2D)",
    "insertText": "RandPointInCircle(float CircleRadius)"
  },
  {
    "label": "RandPointInBox()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector)",
    "insertText": "RandPointInBox(const FBox& Box)"
  },
  {
    "label": "GetReflectionVector()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector)",
    "insertText": "GetReflectionVector(const FVector& Direction, const FVector& SurfaceNormal)"
  },
  {
    "label": "IsWithin()",
    "kind": "Method",
    "detail": "Function (template<class T,class U> [ [ nodiscard ] ] bool)",
    "insertText": "IsWithin(const T& TestValue, const U& MinValue, const U& MaxValue)"
  },
  {
    "label": "IsWithinInclusive()",
    "kind": "Method",
    "detail": "Function (} template<class T,class U> [ [ nodiscard ] ] bool)",
    "insertText": "IsWithinInclusive(const T& TestValue, const U& MinValue, const U& MaxValue)"
  },
  {
    "label": "IsNearlyEqual()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] bool)",
    "insertText": "IsNearlyEqual(float A, float B, float ErrorTolerance = UE_SMALL_NUMBER)"
  },
  {
    "label": "IsNearlyEqual()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] bool)",
    "insertText": "IsNearlyEqual(double A, double B, double ErrorTolerance = UE_DOUBLE_SMALL_NUMBER)"
  },
  {
    "label": "RESOLVE_FLOAT_PREDICATE_AMBIGUITY_2_ARGS()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RESOLVE_FLOAT_PREDICATE_AMBIGUITY_2_ARGS(IsNearlyEqual)"
  },
  {
    "label": "RESOLVE_FLOAT_PREDICATE_AMBIGUITY_3_ARGS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RESOLVE_FLOAT_PREDICATE_AMBIGUITY_3_ARGS(IsNearlyEqual)"
  },
  {
    "label": "IsNearlyZero()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] bool)",
    "insertText": "IsNearlyZero(float Value, float ErrorTolerance = UE_SMALL_NUMBER)"
  },
  {
    "label": "IsNearlyZero()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] bool)",
    "insertText": "IsNearlyZero(double Value, double ErrorTolerance = UE_DOUBLE_SMALL_NUMBER)"
  },
  {
    "label": "RESOLVE_FLOAT_PREDICATE_AMBIGUITY_2_ARGS()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RESOLVE_FLOAT_PREDICATE_AMBIGUITY_2_ARGS(IsNearlyZero)"
  },
  {
    "label": "TIsNearlyEqualByULP()",
    "kind": "Method",
    "detail": "Function (private : template<FloatType,IntegralType,IntegralType SignedBit> bool)",
    "insertText": "TIsNearlyEqualByULP(FloatType A, FloatType B, int32 MaxUlps)"
  },
  {
    "label": "FloatToSignedNumber()",
    "kind": "Method",
    "detail": "Function (IntegralType SNB =)",
    "insertText": "FloatToSignedNumber(FMath::AsUInt(B))"
  },
  {
    "label": "Distance()",
    "kind": "Method",
    "detail": "Function (IntegralType)",
    "insertText": "Distance(SNA >= SNB) ? (SNA - SNB) : (SNB - SNA)"
  },
  {
    "label": "IsNearlyEqualByULP()",
    "kind": "Method",
    "detail": "Function (} public : [ [ nodiscard ] ] bool)",
    "insertText": "IsNearlyEqualByULP(float A, float B, int32 MaxUlps = 4)"
  },
  {
    "label": "IsNearlyEqualByULP()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] bool)",
    "insertText": "IsNearlyEqualByULP(double A, double B, int32 MaxUlps = 4)"
  },
  {
    "label": "IsPowerOfTwo()",
    "kind": "Method",
    "detail": "Function (} template<T> [ [ nodiscard ] ] bool)",
    "insertText": "IsPowerOfTwo(T Value)"
  },
  {
    "label": "Floor()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] float)",
    "insertText": "Floor(float F)"
  },
  {
    "label": "Floor()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] double)",
    "insertText": "Floor(double F)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<IntegralType)",
    "insertText": "UE_REQUIRES(std::is_integral_v<IntegralType>) > [[nodiscard]] static constexpr FORCEINLINE IntegralType Floor(IntegralType I)"
  },
  {
    "label": "Min3()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "Min3(const T A, const T B, const T C)"
  },
  {
    "label": "Max3Index()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] int32)",
    "insertText": "Max3Index(const T A, const T B, const T C)"
  },
  {
    "label": "Min3Index()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] int32)",
    "insertText": "Min3Index(const T A, const T B, const T C)"
  },
  {
    "label": "Square()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "Square(const T A)"
  },
  {
    "label": "MIX_FLOATS_3_ARGS()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MIX_FLOATS_3_ARGS(Clamp)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] float)",
    "insertText": "Clamp(const float X, const float Min, const float Max)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] double)",
    "insertText": "Clamp(const double X, const double Min, const double Max)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] int64)",
    "insertText": "Clamp(const int64 X, const int32 Min, const int32 Max)"
  },
  {
    "label": "WrapImpl()",
    "kind": "Method",
    "detail": "Function (} private : template<class T> [ [ nodiscard ] ] T)",
    "insertText": "WrapImpl(const T X, const T Min, const T Max)"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (using SizeType = std::conditional_t<std::is_integral_v<T>,std::make_unsigned<T>,TIdentity<T>>::type ; SizeType)",
    "insertText": "Size(SizeType)Max - (SizeType)"
  },
  {
    "label": "Modulo()",
    "kind": "Method",
    "detail": "Function (SizeType Mod =)",
    "insertText": "Modulo((SizeType)((SizeType)Min - (SizeType)EndVal), Size)"
  },
  {
    "label": "EndVal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EndVal(Mod != (T)0) ? (T)((SizeType)Max - Mod)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(EndVal > Max)"
  },
  {
    "label": "Modulo()",
    "kind": "Method",
    "detail": "Function (SizeType Mod =)",
    "insertText": "Modulo((SizeType)((SizeType)EndVal - (SizeType)Max), Size)"
  },
  {
    "label": "EndVal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EndVal(Mod != (T)0) ? (T)((SizeType)Min + Mod)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} return EndVal ; } public : template<T)",
    "insertText": "UE_REQUIRES(std::is_floating_point_v<T>) > [[nodiscard]] static constexpr FORCEINLINE T Wrap(const T X, const T Min, const T Max)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T)",
    "insertText": "UE_REQUIRES(!std::is_floating_point_v<T>) > UE_DEPRECATED(5.5, \"Use of FMath::Wrap with non-floating point arguments is deprecated - consider FMath::WrapExclusive instead.\") [[nodiscard]] static constexpr FORCEINLINE T Wrap(const T X, const T Min, const T Max)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T)",
    "insertText": "UE_REQUIRES(std::is_integral_v<T>) > [[nodiscard]] static constexpr FORCEINLINE T WrapExclusive(const T X, const T Min, const T Max)"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (using SizeType = std::make_unsigned_t<T> ; SizeType)",
    "insertText": "Size(SizeType)((SizeType)Max - (SizeType)Min)"
  },
  {
    "label": "Mod()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Mod(SizeType)FMath::Modulo((SizeType)((SizeType)Min - (SizeType)X), Size)"
  },
  {
    "label": "Mod()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Mod(SizeType)(Size - Mod)"
  },
  {
    "label": "Mod()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "Mod(SizeType)FMath::Modulo((SizeType)((SizeType)X - (SizeType)Min), Size)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "return(T)(Min + Mod)"
  },
  {
    "label": "Modulo()",
    "kind": "Method",
    "detail": "Function (} template<ValueType,BaseType> [ [ nodiscard ] ] auto)",
    "insertText": "Modulo(ValueType Value, BaseType Base)"
  },
  {
    "label": "GridSnap()",
    "kind": "Method",
    "detail": "Function (} else { return Value % Base ; } } template<class T> [ [ nodiscard ] ] T)",
    "insertText": "GridSnap(T Location, T Grid)"
  },
  {
    "label": "MIX_FLOATS_2_ARGS()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MIX_FLOATS_2_ARGS(GridSnap)"
  },
  {
    "label": "DivideAndRoundUp()",
    "kind": "Method",
    "detail": "Function (template<class T> [ [ nodiscard ] ] T)",
    "insertText": "DivideAndRoundUp(T Dividend, T Divisor)"
  },
  {
    "label": "DivideAndRoundDown()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "DivideAndRoundDown(T Dividend, T Divisor)"
  },
  {
    "label": "Log2()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] float)",
    "insertText": "Log2(float Value)"
  },
  {
    "label": "Loge()",
    "kind": "Method",
    "detail": "Function (float LogToLog2 = 1 . 4 4 2 6 9 5 0 2 f ; return)",
    "insertText": "Loge(Value)"
  },
  {
    "label": "Log2()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] double)",
    "insertText": "Log2(double Value)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T)",
    "insertText": "UE_REQUIRES(std::is_floating_point_v<T>) > static constexpr FORCEINLINE void SinCos(std::decay_t<T>* ScalarSin, std::decay_t<T>* ScalarCos, T Value)"
  },
  {
    "label": "quotient()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "quotient(UE_INV_PI*0.5f)"
  },
  {
    "label": "quotient()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "quotient(T)((int64)(quotient + 0.5f))"
  },
  {
    "label": "quotient()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "quotient(T)((int64)(quotient - 0.5f))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} T y = Value - UE_TWO_PI* quotient ; T sign ;)",
    "insertText": "if(y > UE_HALF_PI)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (y = UE_PI - y ; sign = - 1 . 0 f ; } else)",
    "insertText": "if(y < -UE_HALF_PI)"
  },
  {
    "label": "ScalarSin()",
    "kind": "Method",
    "detail": "Function (y = - UE_PI - y ; sign = - 1 . 0 f ; } else { sign = + 1 . 0 f ; } T y2 = y* y ;*)",
    "insertText": "ScalarSin(( ( ( (-2.3889859e-08f * y2 + 2.7525562e-06f) * y2 - 0.00019840874f ) * y2 + 0.0083333310f ) * y2 - 0.16666667f ) * y2 + 1.0f)"
  },
  {
    "label": "p()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "p(( ( ( -2.6051615e-07f * y2 + 2.4760495e-05f ) * y2 - 0.0013888378f ) * y2 + 0.041666638f ) * y2 - 0.5f)"
  },
  {
    "label": "SinCos()",
    "kind": "Method",
    "detail": "Function (* ScalarCos = sign* p ; } void)",
    "insertText": "SinCos(double* ScalarSin, double* ScalarCos, double Value)"
  },
  {
    "label": "Sin()",
    "kind": "Method",
    "detail": "Function (* ScalarSin =)",
    "insertText": "Sin(Value)"
  },
  {
    "label": "Cos()",
    "kind": "Method",
    "detail": "Function (* ScalarCos =)",
    "insertText": "Cos(Value)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T,U)",
    "insertText": "UE_REQUIRES(!std::is_same_v<T, U>) > static FORCEINLINE void SinCos(T* ScalarSin, T* ScalarCos, U Value)"
  },
  {
    "label": "SinCos()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SinCos(ScalarSin, ScalarCos, T(Value))"
  },
  {
    "label": "FASTASIN_HALF_PI()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "FASTASIN_HALF_PI(1.5707963050f) [[nodiscard]] static FORCEINLINE float FastAsin(float Value)"
  },
  {
    "label": "nonnegative()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "nonnegative(Value >= 0.0f)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (const float x =)",
    "insertText": "Abs(Value)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (float omx = 1 . 0 f - x ;)",
    "insertText": "if(omx < 0.0f)"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (omx = 0 . 0 f ; } const float root =)",
    "insertText": "Sqrt(omx)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "result((((((-0.0012624911f * x + 0.0066700901f) * x - 0.0170881256f) * x + 0.0308918810f) * x - 0.0501743046f) * x + 0.0889789874f) * x - 0.2145988016f)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (result* = root ;)",
    "insertText": "return(nonnegative ? FASTASIN_HALF_PI - result : result - FASTASIN_HALF_PI)"
  },
  {
    "label": "FastAsin()",
    "kind": "Method",
    "detail": "Function (} # undef FASTASIN_HALF_PI [ [ nodiscard ] ] double)",
    "insertText": "FastAsin(double Value)"
  },
  {
    "label": "RadiansToDegrees()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] auto)",
    "insertText": "RadiansToDegrees(T const& RadVal) -> decltype(RadVal * (180.f / UE_PI))"
  },
  {
    "label": "RadiansToDegrees()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "RadiansToDegrees(float const& RadVal)"
  },
  {
    "label": "RadiansToDegrees()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "RadiansToDegrees(double const& RadVal)"
  },
  {
    "label": "DegreesToRadians()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] auto)",
    "insertText": "DegreesToRadians(T const& DegVal) -> decltype(DegVal * (UE_PI / 180.f))"
  },
  {
    "label": "DegreesToRadians()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "DegreesToRadians(float const& DegVal)"
  },
  {
    "label": "DegreesToRadians()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "DegreesToRadians(double const& DegVal)"
  },
  {
    "label": "ClampAngle()",
    "kind": "Method",
    "detail": "Function (} template<T> [ [ nodiscard ] ] T)",
    "insertText": "ClampAngle(T AngleDegrees, T MinAngleDegrees, T MaxAngleDegrees)"
  },
  {
    "label": "RESOLVE_FLOAT_AMBIGUITY_3_ARGS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RESOLVE_FLOAT_AMBIGUITY_3_ARGS(ClampAngle)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (template<T,T2)",
    "insertText": "UE_REQUIRES(std::is_floating_point_v<T> || std::is_floating_point_v<T2>) > [[nodiscard]] static constexpr auto FindDeltaAngleDegrees(T A1, T2 A2) -> decltype(A1 * A2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (auto Delta = A2 - A1 ;)",
    "insertText": "if(Delta > 180.0f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Delta = Delta - 3 6 0 . 0 f ; } else)",
    "insertText": "if(Delta < -180.0f)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (Delta = Delta + 3 6 0 . 0 f ; } return Delta ; } template<T,T2)",
    "insertText": "UE_REQUIRES(std::is_floating_point_v<T> || std::is_floating_point_v<T2>) > [[nodiscard]] static constexpr auto FindDeltaAngleRadians(T A1, T2 A2) -> decltype(A1 * A2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (auto Delta = A2 - A1 ;)",
    "insertText": "if(Delta > UE_PI)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Delta = Delta - UE_TWO_PI ; } else)",
    "insertText": "if(Delta < -UE_PI)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (Delta = Delta + UE_TWO_PI ; } return Delta ; } template<T)",
    "insertText": "UE_REQUIRES(std::is_floating_point_v<T>) > [[nodiscard]] static constexpr T UnwindRadians(T A)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (A - = UE_TWO_PI ; })",
    "insertText": "while(A < -UE_PI)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (A + = UE_TWO_PI ; } return A ; } template<T)",
    "insertText": "UE_REQUIRES(std::is_floating_point_v<T>) > [[nodiscard]] static constexpr T UnwindDegrees(T A)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (A - = 3 6 0 . f ; })",
    "insertText": "while(A < -180.f)"
  },
  {
    "label": "WindRelativeAnglesDegrees()",
    "kind": "Method",
    "detail": "Function (A + = 3 6 0 . f ; } return A ; } void)",
    "insertText": "WindRelativeAnglesDegrees(float InAngle0, float& InOutAngle1)"
  },
  {
    "label": "WindRelativeAnglesDegrees()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WindRelativeAnglesDegrees(double InAngle0, double& InOutAngle1)"
  },
  {
    "label": "FixedTurn()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] float)",
    "insertText": "FixedTurn(float InCurrent, float InDesired, float InDeltaRate)"
  },
  {
    "label": "CartesianToPolar()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "CartesianToPolar(const T X, const T Y, T& OutRad, T& OutAng)"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (OutRad =)",
    "insertText": "Sqrt(Square(X) + Square(Y))"
  },
  {
    "label": "Atan2()",
    "kind": "Method",
    "detail": "Function (OutAng =)",
    "insertText": "Atan2(Y, X)"
  },
  {
    "label": "CartesianToPolar()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "CartesianToPolar(const UE::Math::TVector2<T> InCart, UE::Math::TVector2<T>& OutPolar)"
  },
  {
    "label": "CartesianToPolar()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CartesianToPolar(InCart.X, InCart.Y, OutPolar.X, OutPolar.Y)"
  },
  {
    "label": "PolarToCartesian()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "PolarToCartesian(const T Rad, const T Ang, T& OutX, T& OutY)"
  },
  {
    "label": "Cos()",
    "kind": "Method",
    "detail": "Function (OutX = Rad*)",
    "insertText": "Cos(Ang)"
  },
  {
    "label": "Sin()",
    "kind": "Method",
    "detail": "Function (OutY = Rad*)",
    "insertText": "Sin(Ang)"
  },
  {
    "label": "PolarToCartesian()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "PolarToCartesian(const UE::Math::TVector2<T> InPolar, UE::Math::TVector2<T>& OutCart)"
  },
  {
    "label": "PolarToCartesian()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PolarToCartesian(InPolar.X, InPolar.Y, OutCart.X, OutCart.Y)"
  },
  {
    "label": "GetDotDistance()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "GetDotDistance(FVector2D &OutDotDist, const FVector &Direction, const FVector &AxisX, const FVector &AxisY, const FVector &AxisZ)"
  },
  {
    "label": "GetAzimuthAndElevation()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector2D)",
    "insertText": "GetAzimuthAndElevation(const FVector &Direction, const FVector &AxisX, const FVector &AxisY, const FVector &AxisZ)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (template<T,T2)",
    "insertText": "UE_REQUIRES(std::is_floating_point_v<T>) > [[nodiscard]] static constexpr FORCEINLINE auto GetRangePct(T MinValue, T MaxValue, T2 Value)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const T Divisor = MaxValue - MinValue ;)",
    "insertText": "if(FMath::IsNearlyZero(Divisor))"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (using RetType =)",
    "insertText": "decltype(T() / T2())"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "return(Value - MinValue)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T,T2)",
    "insertText": "UE_REQUIRES(std::is_floating_point_v<T>) > [[nodiscard]] static auto GetRangePct(UE::Math::TVector2<T> const& Range, T2 Value)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T,T2)",
    "insertText": "UE_REQUIRES(std::is_floating_point_v<T>) > [[nodiscard]] static auto GetRangeValue(UE::Math::TVector2<T> const& Range, T2 Pct)"
  },
  {
    "label": "GetMappedRangeValueClamped()",
    "kind": "Method",
    "detail": "Function (} template<T,T2> [ [ nodiscard ] ] auto)",
    "insertText": "GetMappedRangeValueClamped(const UE::Math::TVector2<T>& InputRange, const UE::Math::TVector2<T>& OutputRange, const T2 Value)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (using RangePctType =)",
    "insertText": "decltype(T() * T2())"
  },
  {
    "label": "RangePctType()",
    "kind": "Method",
    "detail": "Function (const RangePctType ClampedPct = Clamp<)",
    "insertText": "RangePctType(GetRangePct(InputRange, Value), 0.f, 1.f)"
  },
  {
    "label": "GetMappedRangeValueUnclamped()",
    "kind": "Method",
    "detail": "Function (} template<T,T2> [ [ nodiscard ] ] auto)",
    "insertText": "GetMappedRangeValueUnclamped(const UE::Math::TVector2<T>& InputRange, const UE::Math::TVector2<T>& OutputRange, const T2 Value)"
  },
  {
    "label": "GetRangePct()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] double)",
    "insertText": "GetRangePct(TRange<T> const& Range, T Value)"
  },
  {
    "label": "GetRangeValue()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "GetRangeValue(TRange<T> const& Range, T Pct)"
  },
  {
    "label": "GetMappedRangeValueClamped()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "GetMappedRangeValueClamped(const TRange<T>& InputRange, const TRange<T>& OutputRange, const T Value)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T ClampedPct = FMath::Clamp<)",
    "insertText": "T(GetRangePct(InputRange, Value), 0, 1)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T,U)",
    "insertText": "UE_REQUIRES(!TCustomLerp<T>::Value && (std::is_floating_point_v<U> || std::is_same_v<T, U>) && !std::is_same_v<T, bool>) > [[nodiscard]] static constexpr FORCEINLINE_DEBUGGABLE T Lerp( const T& A, const T& B, const U& Alpha)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T,U)",
    "insertText": "UE_REQUIRES(TCustomLerp<T>::Value) > [[nodiscard]] static FORCEINLINE_DEBUGGABLE T Lerp(const T& A, const T& B, const U& Alpha)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T1,T2,T3)",
    "insertText": "UE_REQUIRES(!std::is_same_v<T1, T2> && !TCustomLerp<T1>::Value && !TCustomLerp<T2>::Value) > [[nodiscard]] static auto Lerp( const T1& A, const T2& B, const T3& Alpha ) -> decltype(A * B)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (using ABType =)",
    "insertText": "decltype(A * B)"
  },
  {
    "label": "LerpStable()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "LerpStable(const T& A, const T& B, double Alpha)"
  },
  {
    "label": "LerpStable()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "LerpStable(const T& A, const T& B, float Alpha)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T1,T2,T3)",
    "insertText": "UE_REQUIRES(!std::is_same_v<T1, T2>) > [[nodiscard]] static auto LerpStable( const T1& A, const T2& B, const T3& Alpha ) -> decltype(A * B)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T,U)",
    "insertText": "UE_REQUIRES(!TCustomLerp<T>::Value && (std::is_floating_point_v<U> || std::is_same_v<T, U>)) > [[nodiscard]] static constexpr FORCEINLINE_DEBUGGABLE T BiLerp(const T& P00,const T& P10,const T& P01,const T& P11, const U& FracX, const U& FracY)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T,U)",
    "insertText": "UE_REQUIRES(TCustomLerp<T>::Value) > [[nodiscard]] static FORCEINLINE_DEBUGGABLE T BiLerp(const T& P00, const T& P10, const T& P01, const T& P11, const U& FracX, const U& FracY)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T,U)",
    "insertText": "UE_REQUIRES(!TCustomLerp<T>::Value && (std::is_floating_point_v<U> || std::is_same_v<T, U>)) > [[nodiscard]] static constexpr FORCEINLINE_DEBUGGABLE T CubicInterp( const T& P0, const T& T0, const T& P1, const T& T1, const U& A)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const U A2 = A* A ; const U A3 = A2* A ; return)",
    "insertText": "T((((2*A3)-(3*A2)+1) * P0) + ((A3-(2*A2)+A) * T0) + ((A3-A2) * T1) + (((-2*A3)+(3*A2)) * P1))"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T,U)",
    "insertText": "UE_REQUIRES(TCustomLerp<T>::Value) > [[nodiscard]] static FORCEINLINE_DEBUGGABLE T CubicInterp(const T& P0, const T& T0, const T& P1, const T& T1, const U& A)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T,U)",
    "insertText": "UE_REQUIRES(std::is_floating_point_v<U>) > [[nodiscard]] static constexpr FORCEINLINE_DEBUGGABLE T CubicInterpDerivative( const T& P0, const T& T0, const T& P1, const T& T1, const U& A)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T a = 6 . f* P0 + 3 . f* T0 + 3 . f* T1 - 6 . f* P1 ; T b = - 6 . f* P0 - 4 . f* T0 - 2 . f* T1 + 6 . f* P1 ; T c = T0 ; const U A2 = A* A ; return)",
    "insertText": "T((a * A2) + (b * A) + c)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T,U)",
    "insertText": "UE_REQUIRES(std::is_floating_point_v<U>) > [[nodiscard]] static constexpr FORCEINLINE_DEBUGGABLE T CubicInterpSecondDerivative( const T& P0, const T& T0, const T& P1, const T& T1, const U& A)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (T a = 1 2 . f* P0 + 6 . f* T0 + 6 . f* T1 - 1 2 . f* P1 ; T b = - 6 . f* P0 - 4 . f* T0 - 2 . f* T1 + 6 . f* P1 ;)",
    "insertText": "return(a * A)"
  },
  {
    "label": "InterpEaseIn()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "InterpEaseIn(const T& A, const T& B, float Alpha, float Exp)"
  },
  {
    "label": "Pow()",
    "kind": "Method",
    "detail": "Function (float const ModifiedAlpha =)",
    "insertText": "Pow(Alpha, Exp)"
  },
  {
    "label": "InterpEaseOut()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "InterpEaseOut(const T& A, const T& B, float Alpha, float Exp)"
  },
  {
    "label": "Pow()",
    "kind": "Method",
    "detail": "Function (float const ModifiedAlpha = 1 . f -)",
    "insertText": "Pow(1.f - Alpha, Exp)"
  },
  {
    "label": "InterpEaseInOut()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "InterpEaseInOut(const T& A, const T& B, float Alpha, float Exp)"
  },
  {
    "label": "InterpStep()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "InterpStep(const T& A, const T& B, float Alpha, int32 Steps)"
  },
  {
    "label": "FloorToFloat()",
    "kind": "Method",
    "detail": "Function (const float NumIntervals = StepsAsFloat - 1 . f ; float const ModifiedAlpha =)",
    "insertText": "FloorToFloat(Alpha * StepsAsFloat)"
  },
  {
    "label": "InterpSinIn()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "InterpSinIn(const T& A, const T& B, float Alpha)"
  },
  {
    "label": "Cos()",
    "kind": "Method",
    "detail": "Function (float const ModifiedAlpha = - 1 . f*)",
    "insertText": "Cos(Alpha * UE_HALF_PI)"
  },
  {
    "label": "InterpSinOut()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "InterpSinOut(const T& A, const T& B, float Alpha)"
  },
  {
    "label": "Sin()",
    "kind": "Method",
    "detail": "Function (float const ModifiedAlpha =)",
    "insertText": "Sin(Alpha * UE_HALF_PI)"
  },
  {
    "label": "InterpSinInOut()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "InterpSinInOut(const T& A, const T& B, float Alpha)"
  },
  {
    "label": "InterpExpoIn()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "InterpExpoIn(const T& A, const T& B, float Alpha)"
  },
  {
    "label": "ModifiedAlpha()",
    "kind": "Method",
    "detail": "Function (float const)",
    "insertText": "ModifiedAlpha(Alpha == 0.f) ? 0.f : Pow(2.f, 10.f * (Alpha - 1.f))"
  },
  {
    "label": "InterpExpoOut()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "InterpExpoOut(const T& A, const T& B, float Alpha)"
  },
  {
    "label": "ModifiedAlpha()",
    "kind": "Method",
    "detail": "Function (float const)",
    "insertText": "ModifiedAlpha(Alpha == 1.f) ? 1.f : -Pow(2.f, -10.f * Alpha)"
  },
  {
    "label": "InterpExpoInOut()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "InterpExpoInOut(const T& A, const T& B, float Alpha)"
  },
  {
    "label": "InterpCircularIn()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "InterpCircularIn(const T& A, const T& B, float Alpha)"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (float const ModifiedAlpha = - 1 .)",
    "insertText": "f(Sqrt(1.f - Alpha * Alpha) - 1.f)"
  },
  {
    "label": "InterpCircularOut()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "InterpCircularOut(const T& A, const T& B, float Alpha)"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (Alpha - = 1 . f ; float const ModifiedAlpha =)",
    "insertText": "Sqrt(1.f - Alpha * Alpha)"
  },
  {
    "label": "InterpCircularInOut()",
    "kind": "Method",
    "detail": "Function (} template<class T> [ [ nodiscard ] ] T)",
    "insertText": "InterpCircularInOut(const T& A, const T& B, float Alpha)"
  },
  {
    "label": "LerpRange()",
    "kind": "Method",
    "detail": "Function (} template<T,U> [ [ nodiscard ] ] UE::Math::TRotator<T>)",
    "insertText": "LerpRange(const UE::Math::TRotator<T>& A, const UE::Math::TRotator<T>& B, U Alpha)"
  },
  {
    "label": "CubicCRSplineInterp()",
    "kind": "Method",
    "detail": "Function (template<class U> [ [ nodiscard ] ] U)",
    "insertText": "CubicCRSplineInterp(const U& P0, const U& P1, const U& P2, const U& P3, const float T0, const float T1, const float T2, const float T3, const float T)"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (float InvT1MinusT0 = 1 . 0)",
    "insertText": "f(T1 - T0)"
  },
  {
    "label": "L01()",
    "kind": "Method",
    "detail": "Function (U)",
    "insertText": "L01(P0 * ((T1 - T) * InvT1MinusT0) ) + ( P1 * ((T - T0) * InvT1MinusT0))"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (float InvT2MinusT1 = 1 . 0)",
    "insertText": "f(T2 - T1)"
  },
  {
    "label": "L12()",
    "kind": "Method",
    "detail": "Function (U)",
    "insertText": "L12(P1 * ((T2 - T) * InvT2MinusT1) ) + ( P2 * ((T - T1) * InvT2MinusT1))"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (float InvT3MinusT2 = 1 . 0)",
    "insertText": "f(T3 - T2)"
  },
  {
    "label": "L23()",
    "kind": "Method",
    "detail": "Function (U)",
    "insertText": "L23(P2 * ((T3 - T) * InvT3MinusT2) ) + ( P3 * ((T - T2) * InvT3MinusT2))"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (float InvT2MinusT0 = 1 . 0)",
    "insertText": "f(T2 - T0)"
  },
  {
    "label": "L012()",
    "kind": "Method",
    "detail": "Function (U)",
    "insertText": "L012(L01 * ((T2 - T) * InvT2MinusT0) ) + ( L12 * ((T - T0) * InvT2MinusT0))"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (float InvT3MinusT1 = 1 . 0)",
    "insertText": "f(T3 - T1)"
  },
  {
    "label": "L123()",
    "kind": "Method",
    "detail": "Function (U)",
    "insertText": "L123(L12 * ((T3 - T) * InvT3MinusT1) ) + ( L23 * ((T - T1) * InvT3MinusT1))"
  },
  {
    "label": "CubicCRSplineInterpSafe()",
    "kind": "Method",
    "detail": "Function (} template<class U> [ [ nodiscard ] ] U)",
    "insertText": "CubicCRSplineInterpSafe(const U& P0, const U& P1, const U& P2, const U& P3, const float T0, const float T1, const float T2, const float T3, const float T)"
  },
  {
    "label": "T1MinusT0()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "T1MinusT0(T1 - T0)"
  },
  {
    "label": "T2MinusT1()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "T2MinusT1(T2 - T1)"
  },
  {
    "label": "T3MinusT2()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "T3MinusT2(T3 - T2)"
  },
  {
    "label": "T2MinusT0()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "T2MinusT0(T2 - T0)"
  },
  {
    "label": "T3MinusT1()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "T3MinusT1(T3 - T1)"
  },
  {
    "label": "L12()",
    "kind": "Method",
    "detail": "Function (float InvT2MinusT1 = 1 . 0 f / T2MinusT1 ; U)",
    "insertText": "L12(P1 * ((T2 - T) * InvT2MinusT1)) + (P2 * ((T - T1) * InvT2MinusT1))"
  },
  {
    "label": "L23()",
    "kind": "Method",
    "detail": "Function (float InvT3MinusT2 = 1 . 0 f / T3MinusT2 ; U)",
    "insertText": "L23(P2 * ((T3 - T) * InvT3MinusT2)) + (P3 * ((T - T2) * InvT3MinusT2))"
  },
  {
    "label": "L012()",
    "kind": "Method",
    "detail": "Function (float InvT2MinusT0 = 1 . 0 f / T2MinusT0 ; U)",
    "insertText": "L012(L01 * ((T2 - T) * InvT2MinusT0)) + (L12 * ((T - T0) * InvT2MinusT0))"
  },
  {
    "label": "L123()",
    "kind": "Method",
    "detail": "Function (float InvT3MinusT1 = 1 . 0 f / T3MinusT1 ; U)",
    "insertText": "L123(L12 * ((T3 - T) * InvT3MinusT1)) + (L23 * ((T - T1) * InvT3MinusT1))"
  },
  {
    "label": "VInterpNormalRotationTo()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] FVector)",
    "insertText": "VInterpNormalRotationTo(const FVector& Current, const FVector& Target, float DeltaTime, float RotationSpeedDegrees)"
  },
  {
    "label": "VInterpConstantTo()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector)",
    "insertText": "VInterpConstantTo(const FVector& Current, const FVector& Target, float DeltaTime, float InterpSpeed)"
  },
  {
    "label": "VInterpTo()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector)",
    "insertText": "VInterpTo(const FVector& Current, const FVector& Target, float DeltaTime, float InterpSpeed)"
  },
  {
    "label": "Vector2DInterpConstantTo()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector2D)",
    "insertText": "Vector2DInterpConstantTo(const FVector2D& Current, const FVector2D& Target, float DeltaTime, float InterpSpeed)"
  },
  {
    "label": "Vector2DInterpTo()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector2D)",
    "insertText": "Vector2DInterpTo(const FVector2D& Current, const FVector2D& Target, float DeltaTime, float InterpSpeed)"
  },
  {
    "label": "RInterpConstantTo()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FRotator)",
    "insertText": "RInterpConstantTo(const FRotator& Current, const FRotator& Target, float DeltaTime, float InterpSpeed)"
  },
  {
    "label": "RInterpTo()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FRotator)",
    "insertText": "RInterpTo(const FRotator& Current, const FRotator& Target, float DeltaTime, float InterpSpeed)"
  },
  {
    "label": "FInterpConstantTo()",
    "kind": "Method",
    "detail": "Function (template<T1,T2 = T1,T3 = T2,T4 = T3> [ [ nodiscard ] ] auto)",
    "insertText": "FInterpConstantTo(T1 Current, T2 Target, T3 DeltaTime, T4 InterpSpeed)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (using RetType =)",
    "insertText": "decltype(T1() * T2() * T3() * T4())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const RetType Dist = Target - Current ;)",
    "insertText": "if(FMath::Square(Dist) < UE_SMALL_NUMBER)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (} const RetType Step = InterpSpeed* DeltaTime ; return Current +)",
    "insertText": "Clamp(Dist, -Step, Step)"
  },
  {
    "label": "FInterpTo()",
    "kind": "Method",
    "detail": "Function (} template<T1,T2 = T1,T3 = T2,T4 = T3> [ [ nodiscard ] ] auto)",
    "insertText": "FInterpTo(T1 Current, T2 Target, T3 DeltaTime, T4 InterpSpeed)"
  },
  {
    "label": "RetType()",
    "kind": "Method",
    "detail": "Function (} const RetType DeltaMove = Dist* FMath::Clamp<)",
    "insertText": "RetType(DeltaTime * InterpSpeed, 0.f, 1.f)"
  },
  {
    "label": "QInterpConstantTo()",
    "kind": "Method",
    "detail": "Function (template<class T> [ [ nodiscard ] ] UE::Math::TQuat<T>)",
    "insertText": "QInterpConstantTo(const UE::Math::TQuat<T>& Current, const UE::Math::TQuat<T>& Target, float DeltaTime, float InterpSpeed)"
  },
  {
    "label": "QInterpTo()",
    "kind": "Method",
    "detail": "Function (template<class T> [ [ nodiscard ] ] UE::Math::TQuat<T>)",
    "insertText": "QInterpTo(const UE::Math::TQuat<T>& Current, const UE::Math::TQuat<T>& Target, float DeltaTime, float InterpSpeed)"
  },
  {
    "label": "InvExpApprox()",
    "kind": "Method",
    "detail": "Function (template<class T> [ [ nodiscard ] ] T)",
    "insertText": "InvExpApprox(T X)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "A(1.00746054f)"
  },
  {
    "label": "B()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "B(0.45053901f)"
  },
  {
    "label": "C()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "C(0.25724632f)"
  },
  {
    "label": "ExponentialSmoothingApprox()",
    "kind": "Method",
    "detail": "Function (} template<class T> void)",
    "insertText": "ExponentialSmoothingApprox(T& InOutValue, const T& InTargetValue, const float InDeltaTime, const float InSmoothingTime)"
  },
  {
    "label": "InvExpApprox()",
    "kind": "Method",
    "detail": "Function (const float A = InDeltaTime / InSmoothingTime ; float Exp =)",
    "insertText": "InvExpApprox(A)"
  },
  {
    "label": "InTargetValue()",
    "kind": "Method",
    "detail": "Function (InOutValue =)",
    "insertText": "InTargetValue(InOutValue - InTargetValue)"
  },
  {
    "label": "CriticallyDampedSmoothing()",
    "kind": "Method",
    "detail": "Function (} else { InOutValue = InTargetValue ; } } template<class T> void)",
    "insertText": "CriticallyDampedSmoothing(T& InOutValue, T& InOutValueRate, const T& InTargetValue, const T& InTargetValueRate, const float InDeltaTime, const float InSmoothingTime)"
  },
  {
    "label": "B()",
    "kind": "Method",
    "detail": "Function (T X0 = InOutValue - AdjustedTarget ; X0 - = InTargetValueRate* InSmoothingTime ; const T)",
    "insertText": "B(InOutValueRate + X0 * W)"
  },
  {
    "label": "AdjustedTarget()",
    "kind": "Method",
    "detail": "Function (InOutValue =)",
    "insertText": "AdjustedTarget(X0 + B)"
  },
  {
    "label": "InOutValueRate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InOutValueRate(InOutValueRate - B * W)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(InDeltaTime > 0.0f)"
  },
  {
    "label": "InOutValueRate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InOutValueRate(InTargetValue - InOutValue)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (InOutValue = InTargetValue ; } else { InOutValue = InTargetValue ; InOutValueRate =)",
    "insertText": "T(0)"
  },
  {
    "label": "SpringDamper()",
    "kind": "Method",
    "detail": "Function (} } template<class T> void)",
    "insertText": "SpringDamper(T& InOutValue, T& InOutValueRate, const T& InTargetValue, const T& InTargetValueRate, const float InDeltaTime, const float InUndampedFrequency, const float InDampingRatio)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (InOutValue + = InOutValueRate* InDeltaTime ; return ; } else)",
    "insertText": "if(InDampingRatio < UE_SMALL_NUMBER)"
  },
  {
    "label": "SinCos()",
    "kind": "Method",
    "detail": "Function (T Err = InOutValue - InTargetValue ; const T B = InOutValueRate / W ; float S,C ;)",
    "insertText": "SinCos(&S, &C, W * InDeltaTime)"
  },
  {
    "label": "Err()",
    "kind": "Method",
    "detail": "Function (InOutValue = InTargetValue + Err* C + B* S ; InOutValueRate = InOutValueRate* C -)",
    "insertText": "Err(W * S)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T Err = InOutValue - AdjustedTarget ;)",
    "insertText": "if(InDampingRatio > 1.0f)"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (const float WD = W*)",
    "insertText": "Sqrt(FMath::Square(InDampingRatio) - 1.0f)"
  },
  {
    "label": "C2()",
    "kind": "Method",
    "detail": "Function (const T)",
    "insertText": "C2(InOutValueRate + (W * InDampingRatio - WD) * Err) / (2.0f * WD)"
  },
  {
    "label": "A1()",
    "kind": "Method",
    "detail": "Function (const T C1 = Err - C2 ; const float)",
    "insertText": "A1(WD - InDampingRatio * W)"
  },
  {
    "label": "A2()",
    "kind": "Method",
    "detail": "Function (const float)",
    "insertText": "A2(WD + InDampingRatio * W)"
  },
  {
    "label": "InvExpApprox()",
    "kind": "Method",
    "detail": "Function (const float A1_DT = - A1* InDeltaTime ; const float A2_DT = - A2* InDeltaTime ; const float E1 =)",
    "insertText": "InvExpApprox(A1_DT)"
  },
  {
    "label": "InvExpApprox()",
    "kind": "Method",
    "detail": "Function (const float E2 =)",
    "insertText": "InvExpApprox(A2_DT)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (InOutValue = AdjustedTarget + E1* C1 + E2* C2 ; InOutValueRate = E1* C1* A1 + E2* C2* A2 ; } else)",
    "insertText": "if(InDampingRatio < 1.0f)"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (const float WD = W*)",
    "insertText": "Sqrt(1.0f - FMath::Square(InDampingRatio))"
  },
  {
    "label": "B()",
    "kind": "Method",
    "detail": "Function (const T A = Err ; const T)",
    "insertText": "B(InOutValueRate + Err * (InDampingRatio * W))"
  },
  {
    "label": "SinCos()",
    "kind": "Method",
    "detail": "Function (float S,C ;)",
    "insertText": "SinCos(&S, &C, WD * InDeltaTime)"
  },
  {
    "label": "InvExpApprox()",
    "kind": "Method",
    "detail": "Function (const float E0 = InDampingRatio* W* InDeltaTime ; const float E =)",
    "insertText": "InvExpApprox(E0)"
  },
  {
    "label": "E()",
    "kind": "Method",
    "detail": "Function (InOutValue =)",
    "insertText": "E(A * C + B * S)"
  },
  {
    "label": "E()",
    "kind": "Method",
    "detail": "Function (InOutValueRate = - InOutValue* InDampingRatio* W ; InOutValueRate + =)",
    "insertText": "E(B * (WD * C) - A * (WD * S))"
  },
  {
    "label": "AdjustedTarget()",
    "kind": "Method",
    "detail": "Function (InOutValue =)",
    "insertText": "AdjustedTarget(C1 + C2 * InDeltaTime)"
  },
  {
    "label": "InOutValueRate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InOutValueRate(C2 - C1 * W - C2 * (W * InDeltaTime))"
  },
  {
    "label": "SpringDamperSmoothing()",
    "kind": "Method",
    "detail": "Function (} } template<class T> void)",
    "insertText": "SpringDamperSmoothing(T& InOutValue, T& InOutValueRate, const T& InTargetValue, const T& InTargetValueRate, const float InDeltaTime, const float InSmoothingTime, const float InDampingRatio)"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (InOutValue = InTargetValue ; return ; } float UndampedFrequency = 1 . 0)",
    "insertText": "f(UE_PI * InSmoothingTime)"
  },
  {
    "label": "SpringDamper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SpringDamper(InOutValue, InOutValueRate, InTargetValue, InTargetValueRate, InDeltaTime, UndampedFrequency, InDampingRatio)"
  },
  {
    "label": "MakePulsatingValue()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] float)",
    "insertText": "MakePulsatingValue(const double InCurrentTime, const float InPulsesPerSecond, const float InPhase = 0.0f)"
  },
  {
    "label": "RayPlaneIntersection()",
    "kind": "Method",
    "detail": "Function (} template<FReal> [ [ nodiscard ] ] UE::Math::TVector<FReal>)",
    "insertText": "RayPlaneIntersection(const UE::Math::TVector<FReal>& RayOrigin, const UE::Math::TVector<FReal>& RayDirection, const UE::Math::TPlane<FReal>& Plane)"
  },
  {
    "label": "RayPlaneIntersectionParam()",
    "kind": "Method",
    "detail": "Function (template<FReal> [ [ nodiscard ] ] FReal)",
    "insertText": "RayPlaneIntersectionParam(const UE::Math::TVector<FReal>& RayOrigin, const UE::Math::TVector<FReal>& RayDirection, const UE::Math::TPlane<FReal>& Plane)"
  },
  {
    "label": "LinePlaneIntersection()",
    "kind": "Method",
    "detail": "Function (template<FReal> [ [ nodiscard ] ] UE::Math::TVector<FReal>)",
    "insertText": "LinePlaneIntersection(const UE::Math::TVector<FReal>& Point1, const UE::Math::TVector<FReal>& Point2, const UE::Math::TVector<FReal>& PlaneOrigin, const UE::Math::TVector<FReal>& PlaneNormal)"
  },
  {
    "label": "LinePlaneIntersection()",
    "kind": "Method",
    "detail": "Function (template<FReal> [ [ nodiscard ] ] UE::Math::TVector<FReal>)",
    "insertText": "LinePlaneIntersection(const UE::Math::TVector<FReal>& Point1, const UE::Math::TVector<FReal>& Point2, const UE::Math::TPlane<FReal>& Plane)"
  },
  {
    "label": "ComputeProjectedSphereScissorRect()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] uint32)",
    "insertText": "ComputeProjectedSphereScissorRect(FIntRect& InOutScissorRect, FVector SphereOrigin, float Radius, FVector ViewOrigin, const FMatrix& ViewMatrix, const FMatrix& ProjMatrix)"
  },
  {
    "label": "ComputeBoundingSphereForCone()",
    "kind": "Method",
    "detail": "Function (template<FReal> [ [ nodiscard ] ] UE::Math::TSphere<FReal>)",
    "insertText": "ComputeBoundingSphereForCone(UE::Math::TVector<FReal> const& ConeOrigin, UE::Math::TVector<FReal> const& ConeDirection, FReal ConeRadius, FReal CosConeAngle, FReal SinConeAngle)"
  },
  {
    "label": "PlaneAABBIntersection()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] bool)",
    "insertText": "PlaneAABBIntersection(const FPlane& P, const FBox& AABB)"
  },
  {
    "label": "PlaneAABBRelativePosition()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] int32)",
    "insertText": "PlaneAABBRelativePosition(const FPlane& P, const FBox& AABB)"
  },
  {
    "label": "SphereAABBIntersection()",
    "kind": "Method",
    "detail": "Function (template<FReal> [ [ nodiscard ] ] bool)",
    "insertText": "SphereAABBIntersection(const UE::Math::TVector<FReal>& SphereCenter,const FReal RadiusSquared,const UE::Math::TBox<FReal>& AABB)"
  },
  {
    "label": "SphereAABBIntersection()",
    "kind": "Method",
    "detail": "Function (template<FReal> [ [ nodiscard ] ] bool)",
    "insertText": "SphereAABBIntersection(const UE::Math::TSphere<FReal>& Sphere, const UE::Math::TBox<FReal>& AABB)"
  },
  {
    "label": "PointBoxIntersection()",
    "kind": "Method",
    "detail": "Function (template<FReal> [ [ nodiscard ] ] bool)",
    "insertText": "PointBoxIntersection(const UE::Math::TVector<FReal>& Point, const UE::Math::TBox<FReal>& Box)"
  },
  {
    "label": "LineBoxIntersection()",
    "kind": "Method",
    "detail": "Function (template<FReal> [ [ nodiscard ] ] bool)",
    "insertText": "LineBoxIntersection(const UE::Math::TBox<FReal>& Box, const UE::Math::TVector<FReal>& Start, const UE::Math::TVector<FReal>& End, const UE::Math::TVector<FReal>& Direction)"
  },
  {
    "label": "LineBoxIntersection()",
    "kind": "Method",
    "detail": "Function (template<FReal> [ [ nodiscard ] ] bool)",
    "insertText": "LineBoxIntersection(const UE::Math::TBox<FReal>& Box, const UE::Math::TVector<FReal>& Start, const UE::Math::TVector<FReal>& End, const UE::Math::TVector<FReal>& Direction, const UE::Math::TVector<FReal>& OneOverDirection)"
  },
  {
    "label": "LineExtentBoxIntersection()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "LineExtentBoxIntersection(const FBox& inBox, const FVector& Start, const FVector& End, const FVector& Extent, FVector& HitLocation, FVector& HitNormal, float& HitTime)"
  },
  {
    "label": "LineSphereIntersection()",
    "kind": "Method",
    "detail": "Function (template<FReal> [ [ nodiscard ] ] bool)",
    "insertText": "LineSphereIntersection(const UE::Math::TVector<FReal>& Start,const UE::Math::TVector<FReal>& Dir, FReal Length,const UE::Math::TVector<FReal>& Origin, FReal Radius)"
  },
  {
    "label": "SphereConeIntersection()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] bool)",
    "insertText": "SphereConeIntersection(const FVector& SphereCenter, float SphereRadius, const FVector& ConeAxis, float ConeAngleSin, float ConeAngleCos)"
  },
  {
    "label": "ClosestPointOnLine()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector)",
    "insertText": "ClosestPointOnLine(const FVector& LineStart, const FVector& LineEnd, const FVector& Point)"
  },
  {
    "label": "ClosestPointOnInfiniteLine()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector)",
    "insertText": "ClosestPointOnInfiniteLine(const FVector& LineStart, const FVector& LineEnd, const FVector& Point)"
  },
  {
    "label": "IntersectPlanes3()",
    "kind": "Method",
    "detail": "Function (template<FReal> [ [ nodiscard ] ] bool)",
    "insertText": "IntersectPlanes3(UE::Math::TVector<FReal>& I, const UE::Math::TPlane<FReal>& P1, const UE::Math::TPlane<FReal>& P2, const UE::Math::TPlane<FReal>& P3)"
  },
  {
    "label": "IntersectPlanes2()",
    "kind": "Method",
    "detail": "Function (template<FReal> [ [ nodiscard ] ] bool)",
    "insertText": "IntersectPlanes2(UE::Math::TVector<FReal>& I, UE::Math::TVector<FReal>& D, const UE::Math::TPlane<FReal>& P1, const UE::Math::TPlane<FReal>& P2)"
  },
  {
    "label": "PointDistToLine()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "PointDistToLine(const FVector &Point, const FVector &Direction, const FVector &Origin, FVector &OutClosestPoint)"
  },
  {
    "label": "PointDistToLine()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] float)",
    "insertText": "PointDistToLine(const FVector &Point, const FVector &Direction, const FVector &Origin)"
  },
  {
    "label": "ClosestPointOnSegment()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector)",
    "insertText": "ClosestPointOnSegment(const FVector &Point, const FVector &StartPoint, const FVector &EndPoint)"
  },
  {
    "label": "ClosestPointOnSegment2D()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector2D)",
    "insertText": "ClosestPointOnSegment2D(const FVector2D &Point, const FVector2D &StartPoint, const FVector2D &EndPoint)"
  },
  {
    "label": "PointDistToSegment()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] float)",
    "insertText": "PointDistToSegment(const FVector &Point, const FVector &StartPoint, const FVector &EndPoint)"
  },
  {
    "label": "PointDistToSegmentSquared()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] float)",
    "insertText": "PointDistToSegmentSquared(const FVector &Point, const FVector &StartPoint, const FVector &EndPoint)"
  },
  {
    "label": "SegmentDistToSegment()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SegmentDistToSegment(FVector A1, FVector B1, FVector A2, FVector B2, FVector& OutP1, FVector& OutP2)"
  },
  {
    "label": "SegmentDistToSegmentSafe()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SegmentDistToSegmentSafe(FVector A1, FVector B1, FVector A2, FVector B2, FVector& OutP1, FVector& OutP2)"
  },
  {
    "label": "GetTForSegmentPlaneIntersect()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] float)",
    "insertText": "GetTForSegmentPlaneIntersect(const FVector& StartPoint, const FVector& EndPoint, const FPlane& Plane)"
  },
  {
    "label": "SegmentPlaneIntersection()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SegmentPlaneIntersection(const FVector& StartPoint, const FVector& EndPoint, const FPlane& Plane, FVector& out_IntersectionPoint)"
  },
  {
    "label": "SegmentTriangleIntersection()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SegmentTriangleIntersection(const FVector& StartPoint, const FVector& EndPoint, const FVector& A, const FVector& B, const FVector& C, FVector& OutIntersectPoint, FVector& OutTriangleNormal)"
  },
  {
    "label": "SegmentIntersection2D()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SegmentIntersection2D(const FVector& SegmentStartA, const FVector& SegmentEndA, const FVector& SegmentStartB, const FVector& SegmentEndB, FVector& out_IntersectionPoint)"
  },
  {
    "label": "ClosestPointOnTriangleToPoint()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector)",
    "insertText": "ClosestPointOnTriangleToPoint(const FVector& Point, const FVector& A, const FVector& B, const FVector& C)"
  },
  {
    "label": "ClosestPointOnTetrahedronToPoint()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector)",
    "insertText": "ClosestPointOnTetrahedronToPoint(const FVector& Point, const FVector& A, const FVector& B, const FVector& C, const FVector& D)"
  },
  {
    "label": "SphereDistToLine()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SphereDistToLine(FVector SphereOrigin, float SphereRadius, FVector LineOrigin, FVector LineDir, FVector& OutClosestPoint)"
  },
  {
    "label": "GetDistanceWithinConeSegment()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] bool)",
    "insertText": "GetDistanceWithinConeSegment(FVector Point, FVector ConeStartPoint, FVector ConeLine, float RadiusAtStart, float RadiusAtEnd, float &PercentageOut)"
  },
  {
    "label": "PointsAreCoplanar()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] bool)",
    "insertText": "PointsAreCoplanar(const TArray<FVector>& Points, const float Tolerance = 0.1f)"
  },
  {
    "label": "TruncateToHalfIfClose()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] float)",
    "insertText": "TruncateToHalfIfClose(float F, float Tolerance = UE_SMALL_NUMBER)"
  },
  {
    "label": "TruncateToHalfIfClose()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] double)",
    "insertText": "TruncateToHalfIfClose(double F, double Tolerance = UE_SMALL_NUMBER)"
  },
  {
    "label": "RoundHalfToEven()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] float)",
    "insertText": "RoundHalfToEven(float F)"
  },
  {
    "label": "RoundHalfToEven()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] double)",
    "insertText": "RoundHalfToEven(double F)"
  },
  {
    "label": "RoundHalfFromZero()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] float)",
    "insertText": "RoundHalfFromZero(float F)"
  },
  {
    "label": "RoundHalfFromZero()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] double)",
    "insertText": "RoundHalfFromZero(double F)"
  },
  {
    "label": "RoundHalfToZero()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] float)",
    "insertText": "RoundHalfToZero(float F)"
  },
  {
    "label": "RoundHalfToZero()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] double)",
    "insertText": "RoundHalfToZero(double F)"
  },
  {
    "label": "RoundFromZero()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] float)",
    "insertText": "RoundFromZero(float F)"
  },
  {
    "label": "RoundFromZero()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] double)",
    "insertText": "RoundFromZero(double F)"
  },
  {
    "label": "RoundToZero()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] float)",
    "insertText": "RoundToZero(float F)"
  },
  {
    "label": "RoundToZero()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] double)",
    "insertText": "RoundToZero(double F)"
  },
  {
    "label": "RoundToNegativeInfinity()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] float)",
    "insertText": "RoundToNegativeInfinity(float F)"
  },
  {
    "label": "RoundToNegativeInfinity()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] double)",
    "insertText": "RoundToNegativeInfinity(double F)"
  },
  {
    "label": "RoundToPositiveInfinity()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] float)",
    "insertText": "RoundToPositiveInfinity(float F)"
  },
  {
    "label": "RoundToPositiveInfinity()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] double)",
    "insertText": "RoundToPositiveInfinity(double F)"
  },
  {
    "label": "FormatIntToHumanReadable()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] FString)",
    "insertText": "FormatIntToHumanReadable(int32 Val)"
  },
  {
    "label": "MemoryTest()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] bool)",
    "insertText": "MemoryTest(void* BaseAddress, uint32 NumBytes)"
  },
  {
    "label": "Eval()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Eval(FString Str, float& OutValue)"
  },
  {
    "label": "GetBaryCentric2D()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector)",
    "insertText": "GetBaryCentric2D(const FVector& Point, const FVector& A, const FVector& B, const FVector& C)"
  },
  {
    "label": "GetBaryCentric2D()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector)",
    "insertText": "GetBaryCentric2D(const FVector2D& Point, const FVector2D& A, const FVector2D& B, const FVector2D& C)"
  },
  {
    "label": "ComputeBaryCentric2D()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector)",
    "insertText": "ComputeBaryCentric2D(const FVector& Point, const FVector& A, const FVector& B, const FVector& C)"
  },
  {
    "label": "ComputeBarycentricTri()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] bool)",
    "insertText": "ComputeBarycentricTri(const FVector& Point, const FVector& A, const FVector& B, const FVector& C, FVector& OutBarycentric, double Tolerance = UE_DOUBLE_SMALL_NUMBER)"
  },
  {
    "label": "ComputeBaryCentric3D()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] FVector4)",
    "insertText": "ComputeBaryCentric3D(const FVector& Point, const FVector& A, const FVector& B, const FVector& C, const FVector& D)"
  },
  {
    "label": "SmoothStep()",
    "kind": "Method",
    "detail": "Function (const uint32 BitFlag [ 3 2 ] ; template<T> [ [ nodiscard ] ] T)",
    "insertText": "SmoothStep(T A, T B, T X)"
  },
  {
    "label": "ExtractBoolFromBitfield()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] bool)",
    "insertText": "ExtractBoolFromBitfield(const uint8* Ptr, uint32 Index)"
  },
  {
    "label": "Mask()",
    "kind": "Method",
    "detail": "Function (const uint8* BytePtr = Ptr + Index / 8 ; uint8)",
    "insertText": "Mask(uint8)(1 << (Index & 0x7))"
  },
  {
    "label": "SetBoolInBitField()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetBoolInBitField(uint8* Ptr, uint32 Index, bool bSet)"
  },
  {
    "label": "ApplyScaleToFloat()",
    "kind": "Method",
    "detail": "Function (* BytePtr | = Mask ; } else {* BytePtr& = ~ Mask ; } } void)",
    "insertText": "ApplyScaleToFloat(float& Dst, const FVector& DeltaScale, float Magnitude = 1.0f)"
  },
  {
    "label": "Quantize8UnsignedByte()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] uint8)",
    "insertText": "Quantize8UnsignedByte(float x)"
  },
  {
    "label": "Ret()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Ret(int32)(x * 255.f + 0.5f)"
  },
  {
    "label": "Quantize8SignedByte()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] uint8)",
    "insertText": "Quantize8SignedByte(float x)"
  },
  {
    "label": "Quantize8UnsignedByte()",
    "kind": "Method",
    "detail": "Function (float y = x* 0 . 5 f + 0 . 5 f ; return)",
    "insertText": "Quantize8UnsignedByte(y)"
  },
  {
    "label": "GreatestCommonDivisor()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] int32)",
    "insertText": "GreatestCommonDivisor(int32 a, int32 b)"
  },
  {
    "label": "LeastCommonMultiplier()",
    "kind": "Method",
    "detail": "Function (int32 t = b ; b = a % b ; a = t ; } return a ; } [ [ nodiscard ] ] int32)",
    "insertText": "LeastCommonMultiplier(int32 a, int32 b)"
  },
  {
    "label": "GreatestCommonDivisor()",
    "kind": "Method",
    "detail": "Function (int32 CurrentGcd =)",
    "insertText": "GreatestCommonDivisor(a, b)"
  },
  {
    "label": "PerlinNoise1D()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] float)",
    "insertText": "PerlinNoise1D(float Value)"
  },
  {
    "label": "PerlinNoise2D()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] float)",
    "insertText": "PerlinNoise2D(const FVector2D& Location)"
  },
  {
    "label": "PerlinNoise3D()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] float)",
    "insertText": "PerlinNoise3D(const FVector& Location)"
  },
  {
    "label": "WeightedMovingAverage()",
    "kind": "Method",
    "detail": "Function (template<T> [ [ nodiscard ] ] T)",
    "insertText": "WeightedMovingAverage(T CurrentSample, T PreviousSample, T Weight)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Weight = Clamp<)",
    "insertText": "T(Weight, 0.f, 1.f)"
  },
  {
    "label": "WAvg()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "WAvg(CurrentSample * Weight) + (PreviousSample * (1.f - Weight))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T Distance = Abs<)",
    "insertText": "T(CurrentSample - PreviousSample)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T Weight = MinWeight ;)",
    "insertText": "if(MaxDistance > 0)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T LerpAlpha = Clamp<)",
    "insertText": "T(Distance / MaxDistance, 0.f, 1.f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Weight = Lerp<)",
    "insertText": "T(MinWeight, MaxWeight, LerpAlpha)"
  },
  {
    "label": "WeightedMovingAverage()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "WeightedMovingAverage(CurrentSample, PreviousSample, Weight)"
  },
  {
    "label": "MatrixInverse()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] bool)",
    "insertText": "MatrixInverse(FMatrix44f* DstMatrix, const FMatrix44f* SrcMatrix)"
  },
  {
    "label": "MatrixInverse()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] bool)",
    "insertText": "MatrixInverse(FMatrix44d* DstMatrix, const FMatrix44d* SrcMatrix)"
  },
  {
    "label": "ConvertArrayType()",
    "kind": "Method",
    "detail": "Function (} ; namespace UE { namespace LWC { template<TDest,TSrc,InAllocatorType> TArray<TDest,InAllocatorType>)",
    "insertText": "ConvertArrayType(const TArray<TSrc, InAllocatorType>& From)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Converted .)",
    "insertText": "Add(static_cast<TDest>(Item))"
  },
  {
    "label": "ConvertArrayTypeClampMax()",
    "kind": "Method",
    "detail": "Function (} return Converted ; } } template<TDest,TSrc,InAllocatorType> TArray<TDest,InAllocatorType>)",
    "insertText": "ConvertArrayTypeClampMax(const TArray<TSrc, InAllocatorType>& From)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Converted .)",
    "insertText": "Add(FMath::Min(TNumericLimits<TDest>::Max(), static_cast<TDest>(Item)))"
  },
  {
    "label": "FloatToIntCastChecked()",
    "kind": "Method",
    "detail": "Function (} return Converted ; } } template<OutIntType,InFloatType> OutIntType)",
    "insertText": "FloatToIntCastChecked(InFloatType FloatValue)"
  },
  {
    "label": "FloatToIntCastChecked()",
    "kind": "Method",
    "detail": "Function (} template<> int32)",
    "insertText": "FloatToIntCastChecked(float FloatValue)"
  },
  {
    "label": "FloatToIntCastChecked()",
    "kind": "Method",
    "detail": "Function (} template<> int32)",
    "insertText": "FloatToIntCastChecked(double FloatValue)"
  }
]