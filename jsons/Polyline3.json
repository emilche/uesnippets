[
  {
    "label": "TPolyline3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPolyline3"
  },
  {
    "label": "SegmentIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SegmentIterator"
  },
  {
    "label": "SegmentEnumerable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SegmentEnumerable"
  },
  {
    "label": "TPolyline3()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" VectorTypes . h \" # include \" SegmentTypes . h \" # include \" LineTypes . h \" # include \" BoxTypes . h \" namespace UE { namespace Geometry { using namespace UE::Math ; template<T> class TPolyline3 { protected : TArray<TVector<T>> Vertices ; public :)",
    "insertText": "TPolyline3()"
  },
  {
    "label": "TPolyline3()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TPolyline3(const TArray<TVector<T>>& VertexList) : Vertices(VertexList)"
  },
  {
    "label": "TPolyline3()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TPolyline3(const TVector<T>& Point0, const TVector<T>& Point1)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "Add(Point0)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "Add(Point1)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const TVector<T>&)",
    "insertText": "operator(int Index)"
  },
  {
    "label": "GetVertices()",
    "kind": "Method",
    "detail": "Function (} const TArray<TVector<T>>&)",
    "insertText": "GetVertices()"
  },
  {
    "label": "SegmentCount()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "SegmentCount()"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Clear()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "Reset()"
  },
  {
    "label": "AppendVertex()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendVertex(const TVector<T>& Position)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "Add(Position)"
  },
  {
    "label": "AppendVertices()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendVertices(const TArray<TVector<T>>& NewVertices)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "Append(NewVertices)"
  },
  {
    "label": "AppendVertices()",
    "kind": "Method",
    "detail": "Function (} template<VectorType> void)",
    "insertText": "AppendVertices(const TArray<VectorType>& NewVertices)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (int32 NumV = NewVertices .)",
    "insertText": "Num()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "Reserve(Vertices.Num() + NumV)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "Append((TVector<T>)NewVertices[k])"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Set(int VertexIndex, const TVector<T>& Position)"
  },
  {
    "label": "RemoveVertex()",
    "kind": "Method",
    "detail": "Function (Vertices [ VertexIndex ] = Position ; } void)",
    "insertText": "RemoveVertex(int VertexIndex)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "RemoveAt(VertexIndex)"
  },
  {
    "label": "SetVertices()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetVertices(const TArray<TVector<T>>& NewVertices)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "SetNum(NumVerts, EAllowShrinking::No)"
  },
  {
    "label": "Reverse()",
    "kind": "Method",
    "detail": "Function (Vertices [ k ] = NewVertices [ k ] ; } } void)",
    "insertText": "Reverse()"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(Vertices[VertexIndex], Vertices[j])"
  },
  {
    "label": "GetTangent()",
    "kind": "Method",
    "detail": "Function (} } TVector<T>)",
    "insertText": "GetTangent(int VertexIndex)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "return(Vertices[VertexIndex+1] - Vertices[VertexIndex-1]).Normalized()"
  },
  {
    "label": "GetSegment()",
    "kind": "Method",
    "detail": "Function (} TSegment3<T>)",
    "insertText": "GetSegment(int SegmentIndex)"
  },
  {
    "label": "GetSegmentPoint()",
    "kind": "Method",
    "detail": "Function (} TVector<T>)",
    "insertText": "GetSegmentPoint(int SegmentIndex, T SegmentParam)"
  },
  {
    "label": "seg()",
    "kind": "Method",
    "detail": "Function (TSegment3<T>)",
    "insertText": "seg(Vertices[SegmentIndex], Vertices[SegmentIndex + 1])"
  },
  {
    "label": "GetSegmentPointUnitParam()",
    "kind": "Method",
    "detail": "Function (} TVector<T>)",
    "insertText": "GetSegmentPointUnitParam(int SegmentIndex, T SegmentParam)"
  },
  {
    "label": "GetBounds()",
    "kind": "Method",
    "detail": "Function (} TAxisAlignedBox3<T>)",
    "insertText": "GetBounds()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (TAxisAlignedBox3<T> box = TAxisAlignedBox3<T)",
    "insertText": "Empty()"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (box .)",
    "insertText": "Contain(Vertices[k])"
  },
  {
    "label": "Length()",
    "kind": "Method",
    "detail": "Function (} return box ; } T)",
    "insertText": "Length()"
  },
  {
    "label": "Distance()",
    "kind": "Method",
    "detail": "Function (length + =)",
    "insertText": "Distance(Vertices[i], Vertices[i+1])"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return length ; } class SegmentIterator { public : bool)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (i + + ; return* this ; } SegmentIterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (SegmentIterator)",
    "insertText": "copy(*this)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (i + + ; return copy ; } bool)",
    "insertText": "operator(const SegmentIterator & i3)"
  },
  {
    "label": "SegmentItr()",
    "kind": "Method",
    "detail": "Function (} class TPolyline3 ; } ; class SegmentIterator ; SegmentIterator)",
    "insertText": "SegmentItr()"
  },
  {
    "label": "SegmentEnumerable()",
    "kind": "Method",
    "detail": "Function (} class SegmentEnumerable { public : const TPolyline3<T>* Polyline ;)",
    "insertText": "SegmentEnumerable() : Polyline(nullptr)"
  },
  {
    "label": "SegmentEnumerable()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SegmentEnumerable(const TPolyline3<T> * p) : Polyline(p)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} SegmentIterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} SegmentIterator)",
    "insertText": "end()"
  },
  {
    "label": "Segments()",
    "kind": "Method",
    "detail": "Function (} } ; SegmentEnumerable)",
    "insertText": "Segments()"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "DistanceSquared(const TVector<T>& QueryPoint, int& NearestSegIndexOut, T& NearestSegParamOut)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (NearestSegIndexOut = - 1 ; NearestSegParamOut = TNumericLimits<T)",
    "insertText": "Max()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (TSegment3<T> seg = TSegment3<)",
    "insertText": "T(Vertices[vi], Vertices[vi+1])"
  },
  {
    "label": "t()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "t(QueryPoint - seg.Center).Dot(seg.Direction)"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (d = UE::)",
    "insertText": "DistanceSquared(seg.EndPoint(), QueryPoint)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(t <= -seg.Extent)"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (d = UE::)",
    "insertText": "DistanceSquared(seg.StartPoint(), QueryPoint)"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (} else { d = UE::)",
    "insertText": "DistanceSquared(seg.PointAt(t), QueryPoint)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(d < dist)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (dist = d ; NearestSegIndexOut = vi ; NearestSegParamOut = TMathUtil<T)",
    "insertText": "Clamp(t, -seg.Extent, seg.Extent)"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (} } return dist ; } T)",
    "insertText": "DistanceSquared(const TVector<T>& QueryPoint)"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (int seg ; T segt ; return)",
    "insertText": "DistanceSquared(QueryPoint, seg, segt)"
  },
  {
    "label": "AverageEdgeLength()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "AverageEdgeLength()"
  },
  {
    "label": "Distance()",
    "kind": "Method",
    "detail": "Function (avg + =)",
    "insertText": "Distance(Vertices[i], Vertices[i - 1])"
  },
  {
    "label": "avg()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "avg(T)(N-1)"
  },
  {
    "label": "SmoothSubdivide()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SmoothSubdivide(TPolyline3<T>& NewPolyline)"
  },
  {
    "label": "Alpha()",
    "kind": "Method",
    "detail": "Function (const T)",
    "insertText": "Alpha(T)1 / (T)"
  },
  {
    "label": "OneMinusAlpha()",
    "kind": "Method",
    "detail": "Function (const T)",
    "insertText": "OneMinusAlpha(T)2 / (T)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (NewPolyline . Vertices .)",
    "insertText": "SetNum(2*N)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (NewPolyline . Vertices [ 0 ] = Vertices [ 0 ] ; int k = 1 ;)",
    "insertText": "for(int i = 1; i < N; ++i)"
  },
  {
    "label": "Simplify()",
    "kind": "Method",
    "detail": "Function (const TVector<T>& Prev = Vertices [ i - 1 ] ; const TVector<T>& Cur = Vertices [ i ] ; const TVector<T>& Next = Vertices [ i + 1 ] ; NewPolyline . Vertices [ k + + ] = Alpha* Prev + OneMinusAlpha* Cur ; NewPolyline . Vertices [ k + + ] = OneMinusAlpha* Cur + Alpha* Next ; } NewPolyline . Vertices [ k ] = Vertices [ N ] ; } void)",
    "insertText": "Simplify(T ClusterTolerance, T LineDeviationTolerance)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (T ClusterToleranceSquared = ClusterTolerance* ClusterTolerance ; NewVertices .)",
    "insertText": "Add(Vertices[0])"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (continue ; } NewVertices .)",
    "insertText": "Add(Vertices[Index])"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} NewVertices .)",
    "insertText": "Add(Vertices.Last())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { NewVertices = Vertices ; } TArray<bool> Marked ;)",
    "insertText": "if(LineDeviationTolerance > 0 && NewVertices.Num() >= 3)"
  },
  {
    "label": "SetNumZeroed()",
    "kind": "Method",
    "detail": "Function (Marked .)",
    "insertText": "SetNumZeroed(NewVertices.Num())"
  },
  {
    "label": "Last()",
    "kind": "Method",
    "detail": "Function (Marked [ 0 ] = true ; Marked .)",
    "insertText": "Last()"
  },
  {
    "label": "SimplifyDouglasPeucker()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SimplifyDouglasPeucker(LineDeviationTolerance, NewVertices, 0, NewVertices.Num()-1, Marked)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Marked.IsEmpty())"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (Vertices =)",
    "insertText": "MoveTemp(NewVertices)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "Add(NewVertices[Index])"
  },
  {
    "label": "SimplifyDouglasPeucker()",
    "kind": "Method",
    "detail": "Function (} } } } private : void)",
    "insertText": "SimplifyDouglasPeucker(T Tolerance, const TArray<TVector<T>>& Vertices, int32 j, int32 k, TArray<bool>& Marked)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (Marked .)",
    "insertText": "SetNum(Vertices.Num())"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (int maxi = j ; T maxd2 = 0 ; T tol2 = Tolerance* Tolerance ; TSegment3<T> S = TSegment3<)",
    "insertText": "T(Vertices[j], Vertices[k])"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (T dv2 = S .)",
    "insertText": "DistanceSquared(Vertices[i])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (maxi = i ; maxd2 = dv2 ; })",
    "insertText": "if(maxd2 > tol2)"
  },
  {
    "label": "SimplifyDouglasPeucker()",
    "kind": "Method",
    "detail": "Function (Marked [ maxi ] = true ;)",
    "insertText": "SimplifyDouglasPeucker(Tolerance, Vertices, j, maxi, Marked)"
  },
  {
    "label": "SimplifyDouglasPeucker()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SimplifyDouglasPeucker(Tolerance, Vertices, maxi, k, Marked)"
  }
]