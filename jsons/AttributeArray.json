[
  {
    "label": "TestAttributeArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TestAttributeArray"
  },
  {
    "label": "for",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "for"
  },
  {
    "label": "OPENVDB_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OPENVDB_API"
  },
  {
    "label": "AccessorBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AccessorBase"
  },
  {
    "label": "Accessor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Accessor"
  },
  {
    "label": "Flag",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Flag"
  },
  {
    "label": "SerializationFlag",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "SerializationFlag"
  },
  {
    "label": "that",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "that"
  },
  {
    "label": "OPENVDB_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OPENVDB_API"
  },
  {
    "label": "ScopedRegistryLock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScopedRegistryLock"
  },
  {
    "label": "AttributeHandle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AttributeHandle"
  },
  {
    "label": "MyIterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MyIterator"
  },
  {
    "label": "AttributeArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AttributeArray"
  },
  {
    "label": "for",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "for"
  },
  {
    "label": "AttributeArray",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AttributeArray"
  },
  {
    "label": "AttributeArray",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AttributeArray"
  },
  {
    "label": "AttributeArray",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AttributeArray"
  },
  {
    "label": "TruncateTrait",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TruncateTrait"
  },
  {
    "label": "TruncateTrait",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TruncateTrait"
  },
  {
    "label": "TruncateTrait",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TruncateTrait"
  },
  {
    "label": "TruncateTrait",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TruncateTrait"
  },
  {
    "label": "UIntTypeTrait",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UIntTypeTrait"
  },
  {
    "label": "UIntTypeTrait",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UIntTypeTrait"
  },
  {
    "label": "UIntTypeTrait",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UIntTypeTrait"
  },
  {
    "label": "UIntTypeTrait",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UIntTypeTrait"
  },
  {
    "label": "UIntTypeTrait",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UIntTypeTrait"
  },
  {
    "label": "UnknownCodec",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UnknownCodec"
  },
  {
    "label": "NullCodec",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NullCodec"
  },
  {
    "label": "Storage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Storage"
  },
  {
    "label": "TruncateCodec",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TruncateCodec"
  },
  {
    "label": "Storage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Storage"
  },
  {
    "label": "PositionRange",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PositionRange"
  },
  {
    "label": "UnitRange",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UnitRange"
  },
  {
    "label": "FixedPointCodec",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FixedPointCodec"
  },
  {
    "label": "Storage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Storage"
  },
  {
    "label": "UnitVecCodec",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UnitVecCodec"
  },
  {
    "label": "Storage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Storage"
  },
  {
    "label": "for",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "for"
  },
  {
    "label": "TypedAttributeArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TypedAttributeArray"
  },
  {
    "label": "comparison",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "comparison"
  },
  {
    "label": "cast",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "cast"
  },
  {
    "label": "TypedAttributeArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TypedAttributeArray"
  },
  {
    "label": "AttributeHandle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AttributeHandle"
  },
  {
    "label": "AttributeHandle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AttributeHandle"
  },
  {
    "label": "AttributeWriteHandle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AttributeWriteHandle"
  },
  {
    "label": "AttributeWriteHandle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AttributeWriteHandle"
  },
  {
    "label": "type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "type"
  },
  {
    "label": "AccessorEval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AccessorEval"
  },
  {
    "label": "AccessorEval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AccessorEval"
  },
  {
    "label": "ScopedRegistryLock()",
    "kind": "Method",
    "detail": "Function (public:)",
    "insertText": "ScopedRegistryLock()"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (Ptr)",
    "insertText": "create(const NamePair& type, Index length, Index stride = 1,\n        bool constantStride = true,\n        const Metadata* metadata = nullptr,\n        const ScopedRegistryLock* lock = nullptr)"
  },
  {
    "label": "isRegistered()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isRegistered(const NamePair& type, const ScopedRegistryLock* lock = nullptr)"
  },
  {
    "label": "clearRegistry()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clearRegistry(const ScopedRegistryLock* lock = nullptr)"
  },
  {
    "label": "copyValuesUnsafe()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copyValuesUnsafe(const AttributeArray& sourceArray, const IterT& iter)"
  },
  {
    "label": "copyValues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copyValues(const AttributeArray& sourceArray, const IterT& iter, bool compact = true)"
  },
  {
    "label": "setHidden()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setHidden(bool state)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "bool(mFlags & HIDDEN)"
  },
  {
    "label": "setTransient()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setTransient(bool state)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "bool(mFlags & TRANSIENT)"
  },
  {
    "label": "setStreaming()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setStreaming(bool state)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "bool(mFlags & STREAMING)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "bool(mFlags & CONSTANTSTRIDE)"
  },
  {
    "label": "doCopyValues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "doCopyValues(const AttributeArray& sourceArray, const IterT& iter,\n        bool rangeChecking = true)"
  },
  {
    "label": "setConstantStride()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setConstantStride(bool state)"
  },
  {
    "label": "registerType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "registerType(const NamePair& type, FactoryMethod,\n        const ScopedRegistryLock* lock = nullptr)"
  },
  {
    "label": "unregisterType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "unregisterType(const NamePair& type,\n        const ScopedRegistryLock* lock = nullptr)"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "decode(const ValueType&, ValueType&)"
  },
  {
    "label": "encode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "encode(const ValueType&, ValueType&)"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "decode(const StorageType&, ValueType&)"
  },
  {
    "label": "encode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "encode(const ValueType&, StorageType&)"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "decode(const StorageType&, ValueType&)"
  },
  {
    "label": "encode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "encode(const ValueType&, StorageType&)"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "decode(const StorageType&, math::Vec3<T>&)"
  },
  {
    "label": "encode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "encode(const math::Vec3<T>&, StorageType&)"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (Ptr)",
    "insertText": "create(Index n, Index strideOrTotalSize = 1, bool constantStride = true,\n        const Metadata* metadata = nullptr)"
  },
  {
    "label": "attributeType()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "attributeType()"
  },
  {
    "label": "isRegistered()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isRegistered()"
  },
  {
    "label": "registerType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "registerType()"
  },
  {
    "label": "unregisterType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "unregisterType()"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "sizeof(ValueType)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "sizeof(StorageType)"
  },
  {
    "label": "getUnsafe()",
    "kind": "Method",
    "detail": "Function (ValueType)",
    "insertText": "getUnsafe(const AttributeArray* array, const Index n)"
  },
  {
    "label": "setUnsafe()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setUnsafe(Index n, const ValueType& value)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set(Index n, const ValueType& value)"
  },
  {
    "label": "setUnsafe()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setUnsafe(Index n, const T& value)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set(Index n, const T& value)"
  },
  {
    "label": "setUnsafe()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setUnsafe(AttributeArray* array, const Index n, const ValueType& value)"
  },
  {
    "label": "collapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "collapse(const ValueType& uniformValue)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(const ValueType& value)"
  },
  {
    "label": "collapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "collapse(AttributeArray* array, const ValueType& value)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(AttributeArray* array, const ValueType& value)"
  },
  {
    "label": "compressUnsafe()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "compressUnsafe()"
  },
  {
    "label": "setOutOfCore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setOutOfCore(const bool)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "allocate()"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deallocate()"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (Ptr)",
    "insertText": "create(const AttributeArray& array, const bool collapseOnDestruction = true)"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (Ptr)",
    "insertText": "create(AttributeArray& array, const bool expand = true)"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "expand(bool fill = true)"
  },
  {
    "label": "collapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "collapse()"
  },
  {
    "label": "collapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "collapse(const ValueType& uniformValue)"
  },
  {
    "label": "compact()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "compact()"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(const ValueType& value)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set(Index n, const ValueType& value)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set(Index n, Index m, const ValueType& value)"
  },
  {
    "label": "it()",
    "kind": "Method",
    "detail": "Function (IterT)",
    "insertText": "it(iter)"
  },
  {
    "label": "targetOffset()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "targetOffset(targetIndex * bytes)"
  },
  {
    "label": "sourceOffset()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "sourceOffset(sourceIndex * bytes)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (tbb::spin_mutex::scoped_lock)",
    "insertText": "lock(mMutex)"
  },
  {
    "label": "rhsLock()",
    "kind": "Method",
    "detail": "Function (tbb::spin_mutex::scoped_lock)",
    "insertText": "rhsLock(rhs.mMutex)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (tbb::spin_mutex::scoped_lock)",
    "insertText": "lock(mMutex)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (tbb::spin_mutex::scoped_lock)",
    "insertText": "lock(mMutex)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (tbb::spin_mutex::scoped_lock)",
    "insertText": "lock(mMutex)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (tbb::spin_mutex::scoped_lock)",
    "insertText": "lock(mMutex)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (tbb::spin_mutex::scoped_lock)",
    "insertText": "lock(self->mMutex)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (buffers)",
    "insertText": "OPENVDB_THROW(IoError, \"Cannot read paged AttributeArray buffers.\")"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (tbb::spin_mutex::scoped_lock)",
    "insertText": "lock(mMutex)"
  },
  {
    "label": "bloscCompressed()",
    "kind": "Method",
    "detail": "Function (uint8_t)",
    "insertText": "bloscCompressed(0)"
  },
  {
    "label": "compressedBytes()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "compressedBytes(mCompressedBytes)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (completed)",
    "insertText": "assert(!mPageHandle)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (tbb::spin_mutex::scoped_lock)",
    "insertText": "lock(mMutex)"
  },
  {
    "label": "flags()",
    "kind": "Method",
    "detail": "Function (uint8_t)",
    "insertText": "flags(mFlags)"
  },
  {
    "label": "serializationFlags()",
    "kind": "Method",
    "detail": "Function (uint8_t)",
    "insertText": "serializationFlags(0)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "size(mSize)"
  },
  {
    "label": "stride()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "stride(mStrideOrTotalSize)"
  },
  {
    "label": "bloscCompressed()",
    "kind": "Method",
    "detail": "Function (uint8_t)",
    "insertText": "bloscCompressed(1)"
  },
  {
    "label": "bloscCompressed()",
    "kind": "Method",
    "detail": "Function (uint8_t)",
    "insertText": "bloscCompressed(0)"
  },
  {
    "label": "bloscCompressed()",
    "kind": "Method",
    "detail": "Function (uint8_t)",
    "insertText": "bloscCompressed(0)"
  }
]