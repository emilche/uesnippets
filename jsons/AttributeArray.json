[
  {
    "label": "TestAttributeArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TestAttributeArray"
  },
  {
    "label": "OPENVDB_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OPENVDB_API"
  },
  {
    "label": "AccessorBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AccessorBase"
  },
  {
    "label": "Accessor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Accessor"
  },
  {
    "label": "Flag",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Flag"
  },
  {
    "label": "SerializationFlag",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "SerializationFlag"
  },
  {
    "label": "AttributeHandle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AttributeHandle"
  },
  {
    "label": "AttributeArray",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AttributeArray"
  },
  {
    "label": "TruncateTrait",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TruncateTrait"
  },
  {
    "label": "UIntTypeTrait",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UIntTypeTrait"
  },
  {
    "label": "UnknownCodec",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UnknownCodec"
  },
  {
    "label": "NullCodec",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NullCodec"
  },
  {
    "label": "Storage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Storage"
  },
  {
    "label": "TruncateCodec",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TruncateCodec"
  },
  {
    "label": "PositionRange",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PositionRange"
  },
  {
    "label": "UnitRange",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UnitRange"
  },
  {
    "label": "FixedPointCodec",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FixedPointCodec"
  },
  {
    "label": "UnitVecCodec",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UnitVecCodec"
  },
  {
    "label": "TypedAttributeArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TypedAttributeArray"
  },
  {
    "label": "AttributeWriteHandle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AttributeWriteHandle"
  },
  {
    "label": "AccessorEval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AccessorEval"
  },
  {
    "label": "floatingPointToFixedPoint()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_POINTS_ATTRIBUTE_ARRAY_HAS_BEEN_INCLUDED # define OPENVDB_POINTS_ATTRIBUTE_ARRAY_HAS_BEEN_INCLUDED # include<openvdb / Types . h> # include<openvdb / math / QuantizedUnitVec . h> # include<openvdb / util / Name . h> # include<openvdb / util / logging . h> # include<openvdb / io / io . h> # include<openvdb / io / Compression . h> # include \" IndexIterator . h \" # include \" StreamCompression . h \" # include<tbb / spin_mutex . h> # include<atomic> # include<memory> # include<mutex> # include<string> # include<type_traits> class TestAttributeArray ; namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { using NamePair = std::pair<Name,Name> ; namespace points { template<IntegerT,FloatT> IntegerT)",
    "insertText": "floatingPointToFixedPoint(const FloatT s)"
  },
  {
    "label": "fixedPointToFloatingPoint()",
    "kind": "Method",
    "detail": "Function (} template<FloatT,IntegerT> FloatT)",
    "insertText": "fixedPointToFloatingPoint(const IntegerT s)"
  },
  {
    "label": "floatingPointToFixedPoint()",
    "kind": "Method",
    "detail": "Function (} template<IntegerVectorT,FloatT> IntegerVectorT)",
    "insertText": "floatingPointToFixedPoint(const math::Vec3<FloatT>& v)"
  },
  {
    "label": "fixedPointToFloatingPoint()",
    "kind": "Method",
    "detail": "Function (} template<FloatVectorT,IntegerT> FloatVectorT)",
    "insertText": "fixedPointToFloatingPoint(const math::Vec3<IntegerT>& v)"
  },
  {
    "label": "ScopedRegistryLock()",
    "kind": "Method",
    "detail": "Function (} class AttributeArray { protected : struct AccessorBase ; template<T> struct Accessor ; using AccessorBasePtr = std::shared_ptr<AccessorBase> ; public : enum Flag { TRANSIENT = 0 x1,HIDDEN = 0 x2,CONSTANTSTRIDE = 0 x8,STREAMING = 0 x10,PARTIALREAD = 0 x20 } ; enum SerializationFlag { WRITESTRIDED = 0 x1,WRITEUNIFORM = 0 x2,WRITEMEMCOMPRESS = 0 x4,WRITEPAGED = 0 x8 } ; class ScopedRegistryLock { tbb::spin_mutex::scoped_lock lock ; public :)",
    "insertText": "ScopedRegistryLock()"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (} ; using Ptr = std::shared_ptr<AttributeArray> ; using ConstPtr = std::shared_ptr<const AttributeArray> ; using FactoryMethod =)",
    "insertText": "Ptr(*)(Index, Index, bool, const Metadata*)"
  },
  {
    "label": "AttributeArray()",
    "kind": "Method",
    "detail": "Function (template<ValueType,CodecType> class AttributeHandle ;)",
    "insertText": "AttributeArray(): mPageHandle()"
  },
  {
    "label": "AttributeArray()",
    "kind": "Method",
    "detail": "Function (mOutOfCore = 0 ; } ~)",
    "insertText": "AttributeArray()"
  },
  {
    "label": "AttributeArray()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "AttributeArray(const AttributeArray& rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (AttributeArray&)",
    "insertText": "operator(const AttributeArray& rhs)"
  },
  {
    "label": "AttributeArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AttributeArray(AttributeArray&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (AttributeArray&)",
    "insertText": "operator(AttributeArray&&)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (AttributeArray::Ptr)",
    "insertText": "copy()"
  },
  {
    "label": "OPENVDB_DEPRECATED_MESSAGE()",
    "kind": "Method",
    "detail": "Function (# ifndef _MSC_VER)",
    "insertText": "OPENVDB_DEPRECATED_MESSAGE(\"In-memory compression no longer supported, use AttributeArray::copy() instead\") #endif virtual AttributeArray::Ptr copyUncompressed()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "size()"
  },
  {
    "label": "stride()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "stride()"
  },
  {
    "label": "dataSize()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "dataSize()"
  },
  {
    "label": "valueType()",
    "kind": "Method",
    "detail": "Function (Name)",
    "insertText": "valueType()"
  },
  {
    "label": "codecType()",
    "kind": "Method",
    "detail": "Function (Name)",
    "insertText": "codecType()"
  },
  {
    "label": "valueTypeSize()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "valueTypeSize()"
  },
  {
    "label": "storageTypeSize()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "storageTypeSize()"
  },
  {
    "label": "valueTypeIsFloatingPoint()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "valueTypeIsFloatingPoint()"
  },
  {
    "label": "valueTypeIsClass()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "valueTypeIsClass()"
  },
  {
    "label": "valueTypeIsVector()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "valueTypeIsVector()"
  },
  {
    "label": "valueTypeIsQuaternion()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "valueTypeIsQuaternion()"
  },
  {
    "label": "valueTypeIsMatrix()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "valueTypeIsMatrix()"
  },
  {
    "label": "memUsage()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "memUsage()"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (Ptr)",
    "insertText": "create(const NamePair& type, Index length, Index stride = 1, bool constantStride = true, const Metadata* metadata = nullptr, const ScopedRegistryLock* lock = nullptr)"
  },
  {
    "label": "isRegistered()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isRegistered(const NamePair& type, const ScopedRegistryLock* lock = nullptr)"
  },
  {
    "label": "clearRegistry()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clearRegistry(const ScopedRegistryLock* lock = nullptr)"
  },
  {
    "label": "type()",
    "kind": "Method",
    "detail": "Function (const NamePair&)",
    "insertText": "type()"
  },
  {
    "label": "isType()",
    "kind": "Method",
    "detail": "Function (template<AttributeArrayType> bool)",
    "insertText": "isType()"
  },
  {
    "label": "hasValueType()",
    "kind": "Method",
    "detail": "Function (} template<ValueType> bool)",
    "insertText": "hasValueType()"
  },
  {
    "label": "OPENVDB_DEPRECATED_MESSAGE()",
    "kind": "Method",
    "detail": "Function (} # ifndef _MSC_VER)",
    "insertText": "OPENVDB_DEPRECATED_MESSAGE(\"Use copyValues() with source-target index pairs\") #endif virtual void set(const Index n, const AttributeArray& sourceArray, const Index sourceIndex)"
  },
  {
    "label": "copyValuesUnsafe()",
    "kind": "Method",
    "detail": "Function (template<IterT> void)",
    "insertText": "copyValuesUnsafe(const AttributeArray& sourceArray, const IterT& iter)"
  },
  {
    "label": "copyValues()",
    "kind": "Method",
    "detail": "Function (template<IterT> void)",
    "insertText": "copyValues(const AttributeArray& sourceArray, const IterT& iter, bool compact = true)"
  },
  {
    "label": "isUniform()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isUniform()"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "expand(bool fill = true)"
  },
  {
    "label": "collapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "collapse()"
  },
  {
    "label": "compact()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "compact()"
  },
  {
    "label": "OPENVDB_DEPRECATED_MESSAGE()",
    "kind": "Method",
    "detail": "Function (# ifndef _MSC_VER)",
    "insertText": "OPENVDB_DEPRECATED_MESSAGE(\"Previously this compressed the attribute array, now it does nothing\") #endif virtual bool compress()"
  },
  {
    "label": "OPENVDB_DEPRECATED_MESSAGE()",
    "kind": "Method",
    "detail": "Function (# ifndef _MSC_VER)",
    "insertText": "OPENVDB_DEPRECATED_MESSAGE(\"Previously this uncompressed the attribute array, now it does nothing\") #endif virtual bool decompress()"
  },
  {
    "label": "setHidden()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setHidden(bool state)"
  },
  {
    "label": "isHidden()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isHidden()"
  },
  {
    "label": "setTransient()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setTransient(bool state)"
  },
  {
    "label": "isTransient()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isTransient()"
  },
  {
    "label": "setStreaming()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setStreaming(bool state)"
  },
  {
    "label": "isStreaming()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isStreaming()"
  },
  {
    "label": "hasConstantStride()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasConstantStride()"
  },
  {
    "label": "flags()",
    "kind": "Method",
    "detail": "Function (} uint8_t)",
    "insertText": "flags()"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "write(std::ostream&, bool outputTransient)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "write(std::ostream&)"
  },
  {
    "label": "readMetadata()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readMetadata(std::istream&)"
  },
  {
    "label": "writeMetadata()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeMetadata(std::ostream&, bool outputTransient, bool paged)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(std::istream&)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeBuffers(std::ostream&, bool outputTransient)"
  },
  {
    "label": "readPagedBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readPagedBuffers(compression::PagedInputStream&)"
  },
  {
    "label": "writePagedBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writePagedBuffers(compression::PagedOutputStream&, bool outputTransient)"
  },
  {
    "label": "loadData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "loadData()"
  },
  {
    "label": "isDataLoaded()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isDataLoaded()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(const AttributeArray& other)"
  },
  {
    "label": "isEqual()",
    "kind": "Method",
    "detail": "Function (} private : class::TestAttributeArray ; bool)",
    "insertText": "isEqual(const AttributeArray& other)"
  },
  {
    "label": "dataAsByteArray()",
    "kind": "Method",
    "detail": "Function (char*)",
    "insertText": "dataAsByteArray()"
  },
  {
    "label": "doCopyValues()",
    "kind": "Method",
    "detail": "Function (template<IterT> void)",
    "insertText": "doCopyValues(const AttributeArray& sourceArray, const IterT& iter, bool rangeChecking = true)"
  },
  {
    "label": "AttributeArray()",
    "kind": "Method",
    "detail": "Function (protected : # if OPENVDB_ABI_VERSION_NUMBER> = 7)",
    "insertText": "AttributeArray(const AttributeArray& rhs, const tbb::spin_mutex::scoped_lock&)"
  },
  {
    "label": "setConstantStride()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "setConstantStride(bool state)"
  },
  {
    "label": "getAccessor()",
    "kind": "Method",
    "detail": "Function (AccessorBasePtr)",
    "insertText": "getAccessor()"
  },
  {
    "label": "registerType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "registerType(const NamePair& type, FactoryMethod, const ScopedRegistryLock* lock = nullptr)"
  },
  {
    "label": "unregisterType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "unregisterType(const NamePair& type, const ScopedRegistryLock* lock = nullptr)"
  },
  {
    "label": "AccessorBase()",
    "kind": "Method",
    "detail": "Function (bool mIsUniform = true ; tbb::spin_mutex mMutex ; uint8_t mFlags = 0 ; uint8_t mUsePagedRead = 0 ; std::atomic<Index32> mOutOfCore ; union { compression::PageHandle::Ptr mPageHandle ; size_t mCompressedBytes ; } ; } ; struct AttributeArray::AccessorBase { ~)",
    "insertText": "AccessorBase()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} ; template<T> struct AttributeArray::Accessor : public AttributeArray::AccessorBase { using GetterPtr =)",
    "insertText": "T(*)(const AttributeArray* array, const Index n)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (using SetterPtr =)",
    "insertText": "void(*)(AttributeArray* array, const Index n, const T& value)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (using ValuePtr =)",
    "insertText": "void(*)(AttributeArray* array, const T& value)"
  },
  {
    "label": "Accessor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Accessor(GetterPtr getter, SetterPtr setter, ValuePtr collapser, ValuePtr filler) : mGetter(getter), mSetter(setter), mCollapser(collapser), mFiller(filler)"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (} GetterPtr mGetter ; SetterPtr mSetter ; ValuePtr mCollapser ; ValuePtr mFiller ; } ; namespace attribute_traits { template<T> struct TruncateTrait { } ; template<> struct TruncateTrait<float> { using Type = math::half ; } ; template<> struct TruncateTrait<int> { using Type = short ; } ; template<T> struct TruncateTrait<math::Vec3<T>> { using Type = math::Vec3<TruncateTrait<T>::Type> ; } ; template<bool OneByte,T> struct UIntTypeTrait { } ; template<T> struct UIntTypeTrait<true,T> { using Type = uint8_t ; } ; template<T> struct UIntTypeTrait<false,T> { using Type = uint16_t ; } ; template<T> struct UIntTypeTrait<true,math::Vec3<T>> { using Type = math::Vec3<uint8_t> ; } ; template<T> struct UIntTypeTrait<false,math::Vec3<T>> { using Type = math::Vec3<uint16_t> ; } ; } struct UnknownCodec { } ; struct NullCodec { template<T> struct Storage { using Type = T ; } ; template<ValueType> void)",
    "insertText": "decode(const ValueType&, ValueType&)"
  },
  {
    "label": "encode()",
    "kind": "Method",
    "detail": "Function (template<ValueType> void)",
    "insertText": "encode(const ValueType&, ValueType&)"
  },
  {
    "label": "name()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "name()"
  },
  {
    "label": "encode()",
    "kind": "Method",
    "detail": "Function (template<StorageType,ValueType> void)",
    "insertText": "encode(const ValueType&, StorageType&)"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (} template<ValueType> ValueType)",
    "insertText": "decode(const ValueType& value)"
  },
  {
    "label": "string()",
    "kind": "Method",
    "detail": "Function (const std::string Name =)",
    "insertText": "string(Range::name()) + (OneByte ? \"8\" : \"16\")"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (} } ; struct UnitVecCodec { using StorageType = uint16_t ; template<T> struct Storage { using Type = StorageType ; } ; template<T> void)",
    "insertText": "decode(const StorageType&, math::Vec3<T>&)"
  },
  {
    "label": "encode()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "encode(const math::Vec3<T>&, StorageType&)"
  },
  {
    "label": "TypedAttributeArray()",
    "kind": "Method",
    "detail": "Function (# if OPENVDB_ABI_VERSION_NUMBER> = 7)",
    "insertText": "TypedAttributeArray(const TypedAttributeArray&)"
  },
  {
    "label": "OPENVDB_DEPRECATED_MESSAGE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_DEPRECATED_MESSAGE(\"Use copy-constructor without unused bool parameter\") TypedAttributeArray(const TypedAttributeArray&, bool)"
  },
  {
    "label": "TypedAttributeArray()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "TypedAttributeArray(const TypedAttributeArray&, bool uncompress = false)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# endif TypedAttributeArray&)",
    "insertText": "operator(const TypedAttributeArray&)"
  },
  {
    "label": "TypedAttributeArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TypedAttributeArray(TypedAttributeArray&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TypedAttributeArray&)",
    "insertText": "operator(TypedAttributeArray&&)"
  },
  {
    "label": "TypedAttributeArray()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "TypedAttributeArray()"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "deallocate()"
  },
  {
    "label": "OPENVDB_DEPRECATED_MESSAGE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_DEPRECATED_MESSAGE(\"In-memory compression no longer supported, use AttributeArray::copy() instead\") AttributeArray::Ptr copyUncompressed()"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (Ptr)",
    "insertText": "create(Index n, Index strideOrTotalSize = 1, bool constantStride = true, const Metadata* metadata = nullptr)"
  },
  {
    "label": "cast()",
    "kind": "Method",
    "detail": "Function (TypedAttributeArray&)",
    "insertText": "cast(AttributeArray& attributeArray)"
  },
  {
    "label": "cast()",
    "kind": "Method",
    "detail": "Function (const TypedAttributeArray&)",
    "insertText": "cast(const AttributeArray& attributeArray)"
  },
  {
    "label": "attributeType()",
    "kind": "Method",
    "detail": "Function (const NamePair&)",
    "insertText": "attributeType()"
  },
  {
    "label": "isRegistered()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isRegistered()"
  },
  {
    "label": "registerType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "registerType()"
  },
  {
    "label": "unregisterType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "unregisterType()"
  },
  {
    "label": "getUnsafe()",
    "kind": "Method",
    "detail": "Function (ValueType)",
    "insertText": "getUnsafe(Index n)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (ValueType)",
    "insertText": "get(Index n)"
  },
  {
    "label": "getUnsafe()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "getUnsafe(Index n, T& value)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "get(Index n, T& value)"
  },
  {
    "label": "getUnsafe()",
    "kind": "Method",
    "detail": "Function (ValueType)",
    "insertText": "getUnsafe(const AttributeArray* array, const Index n)"
  },
  {
    "label": "setUnsafe()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setUnsafe(Index n, const ValueType& value)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set(Index n, const ValueType& value)"
  },
  {
    "label": "setUnsafe()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "setUnsafe(Index n, const T& value)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "set(Index n, const T& value)"
  },
  {
    "label": "setUnsafe()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setUnsafe(AttributeArray* array, const Index n, const ValueType& value)"
  },
  {
    "label": "OPENVDB_DEPRECATED_MESSAGE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_DEPRECATED_MESSAGE(\"Use copyValues() with source-target index pairs\") void set(const Index n, const AttributeArray& sourceArray, const Index sourceIndex)"
  },
  {
    "label": "collapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "collapse(const ValueType& uniformValue)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(const ValueType& value)"
  },
  {
    "label": "collapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "collapse(AttributeArray* array, const ValueType& value)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(AttributeArray* array, const ValueType& value)"
  },
  {
    "label": "OPENVDB_DEPRECATED_MESSAGE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_DEPRECATED_MESSAGE(\"Previously this compressed the attribute array, now it does nothing\") bool compress()"
  },
  {
    "label": "OPENVDB_DEPRECATED_MESSAGE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_DEPRECATED_MESSAGE(\"Previously this uncompressed the attribute array, now it does nothing\") bool decompress()"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "read(std::istream&)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "write(std::ostream& os, bool outputTransient)"
  },
  {
    "label": "writeMetadata()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeMetadata(std::ostream& os, bool outputTransient, bool paged)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeBuffers(std::ostream& os, bool outputTransient)"
  },
  {
    "label": "writePagedBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writePagedBuffers(compression::PagedOutputStream& os, bool outputTransient)"
  },
  {
    "label": "isOutOfCore()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isOutOfCore()"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (StorageType*)",
    "insertText": "data()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(validData())"
  },
  {
    "label": "validData()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "validData()"
  },
  {
    "label": "TypedAttributeArray()",
    "kind": "Method",
    "detail": "Function (} private : class::TestAttributeArray ; # if OPENVDB_ABI_VERSION_NUMBER> = 7)",
    "insertText": "TypedAttributeArray(const TypedAttributeArray&, const tbb::spin_mutex::scoped_lock&)"
  },
  {
    "label": "doLoad()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "doLoad()"
  },
  {
    "label": "doLoadUnsafe()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "doLoadUnsafe(const bool compression = true)"
  },
  {
    "label": "compressUnsafe()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "compressUnsafe()"
  },
  {
    "label": "setOutOfCore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setOutOfCore(const bool)"
  },
  {
    "label": "arrayMemUsage()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "arrayMemUsage()"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "allocate()"
  },
  {
    "label": "factory()",
    "kind": "Method",
    "detail": "Function (AttributeArray::Ptr)",
    "insertText": "factory(Index n, Index strideOrTotalSize, bool constantStride, const Metadata* metadata)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (} std::unique_ptr<const NamePair> sTypeName ; std::unique_ptr<StorageType [ ]> mData ; Index mSize ; Index mStrideOrTotalSize ; } ; template<ValueType,CodecType = UnknownCodec> class AttributeHandle { public : using Handle = AttributeHandle<ValueType,CodecType> ; using Ptr = std::shared_ptr<Handle> ; using UniquePtr = std::unique_ptr<Handle> ; protected : using GetterPtr =)",
    "insertText": "ValueType(*)(const AttributeArray* array, const Index n)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (using SetterPtr =)",
    "insertText": "void(*)(AttributeArray* array, const Index n, const ValueType& value)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (using ValuePtr =)",
    "insertText": "void(*)(AttributeArray* array, const ValueType& value)"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (public : Ptr)",
    "insertText": "create(const AttributeArray& array, const bool collapseOnDestruction = true)"
  },
  {
    "label": "AttributeHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AttributeHandle(const AttributeArray& array, const bool collapseOnDestruction = true)"
  },
  {
    "label": "AttributeHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AttributeHandle(const AttributeHandle&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (AttributeHandle&)",
    "insertText": "operator(const AttributeHandle&)"
  },
  {
    "label": "AttributeHandle()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "AttributeHandle()"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (ValueType)",
    "insertText": "get(Index n, Index m = 0)"
  },
  {
    "label": "array()",
    "kind": "Method",
    "detail": "Function (const AttributeArray&)",
    "insertText": "array()"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (protected : Index)",
    "insertText": "index(Index n, Index m)"
  },
  {
    "label": "compatibleType()",
    "kind": "Method",
    "detail": "Function (const AttributeArray* mArray ; GetterPtr mGetter ; SetterPtr mSetter ; ValuePtr mCollapser ; ValuePtr mFiller ; private : class::TestAttributeArray ; template<bool IsUnknownCodec> std::enable_if<IsUnknownCodec,bool>::type)",
    "insertText": "compatibleType()"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (template<bool IsUnknownCodec> std::enable_if<IsUnknownCodec,ValueType>::type)",
    "insertText": "get(Index index)"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (AttributeArray::Ptr mLocalArray ; Index mStrideOrTotalSize ; Index mSize ; bool mCollapseOnDestruction ; } ; template<ValueType,CodecType = UnknownCodec> class AttributeWriteHandle : public AttributeHandle<ValueType,CodecType> { public : using Handle = AttributeWriteHandle<ValueType,CodecType> ; using Ptr = std::shared_ptr<Handle> ; using ScopedPtr = std::unique_ptr<Handle> ; Ptr)",
    "insertText": "create(AttributeArray& array, const bool expand = true)"
  },
  {
    "label": "AttributeWriteHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AttributeWriteHandle(AttributeArray& array, const bool expand = true)"
  },
  {
    "label": "AttributeWriteHandle()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "AttributeWriteHandle()"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set(Index n, Index m, const ValueType& value)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (private : class::TestAttributeArray ; template<bool IsUnknownCodec> std::enable_if<IsUnknownCodec,void>::type)",
    "insertText": "set(Index index, const ValueType& value)"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (} ; template<ValueType> void)",
    "insertText": "decode(const ValueType& data, ValueType& val)"
  },
  {
    "label": "encode()",
    "kind": "Method",
    "detail": "Function (val = data ; } template<ValueType> void)",
    "insertText": "encode(const ValueType& val, ValueType& data)"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (data = val ; } template<StorageType,ValueType> void)",
    "insertText": "decode(const StorageType& data, ValueType& val)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (val = static_cast<)",
    "insertText": "ValueType(data)"
  },
  {
    "label": "encode()",
    "kind": "Method",
    "detail": "Function (} template<StorageType,ValueType> void)",
    "insertText": "encode(const ValueType& val, StorageType& data)"
  },
  {
    "label": "StorageType()",
    "kind": "Method",
    "detail": "Function (data = static_cast<)",
    "insertText": "StorageType(val)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (val = Range::template decode<)",
    "insertText": "ValueType(val)"
  },
  {
    "label": "StorageType()",
    "kind": "Method",
    "detail": "Function (data = floatingPointToFixedPoint<)",
    "insertText": "StorageType(newVal)"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "decode(const StorageType& data, math::Vec3<T>& val)"
  },
  {
    "label": "unpack()",
    "kind": "Method",
    "detail": "Function (val = math::)",
    "insertText": "unpack(data)"
  },
  {
    "label": "encode()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "encode(const math::Vec3<T>& val, StorageType& data)"
  },
  {
    "label": "pack()",
    "kind": "Method",
    "detail": "Function (data = math::)",
    "insertText": "pack(val)"
  },
  {
    "label": "doCopyValues()",
    "kind": "Method",
    "detail": "Function (} template<IterT> void)",
    "insertText": "doCopyValues(const AttributeArray& sourceArray, const IterT& iter, bool rangeChecking)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(sourceArray.valueTypeIsFloatingPoint() == this->valueTypeIsFloatingPoint())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(sourceArray.isDataLoaded() && this->isDataLoaded())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(this->storageTypeSize()*this->stride() == sourceArray.storageTypeSize()*sourceArray.stride())"
  },
  {
    "label": "bytes()",
    "kind": "Method",
    "detail": "Function (const size_t)",
    "insertText": "bytes(sourceArray.storageTypeSize()*sourceArray.stride())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(sourceBuffer && targetBuffer)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(IndexError, \"Cannot copy array data as target array is uniform.\")"
  },
  {
    "label": "sourceIndex()",
    "kind": "Method",
    "detail": "Function (const Index sourceIndex = sourceIsUniform ? 0 : it .)",
    "insertText": "sourceIndex()"
  },
  {
    "label": "targetIndex()",
    "kind": "Method",
    "detail": "Function (const Index targetIndex = it .)",
    "insertText": "targetIndex()"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(IndexError, \"Cannot copy array data as source index exceeds size of source array.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(targetIndex >= targetDataSize)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(IndexError, \"Cannot copy array data as target index exceeds size of target array.\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "assert(sourceIndex < sourceArray.dataSize())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(targetIndex < this->dataSize())"
  },
  {
    "label": "targetOffset()",
    "kind": "Method",
    "detail": "Function (} const size_t)",
    "insertText": "targetOffset(targetIndex * bytes)"
  },
  {
    "label": "sourceOffset()",
    "kind": "Method",
    "detail": "Function (const size_t)",
    "insertText": "sourceOffset(sourceIndex * bytes)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(targetBuffer + targetOffset, sourceBuffer + sourceOffset, bytes)"
  },
  {
    "label": "doCopyValues()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "doCopyValues(sourceArray, iter, false)"
  },
  {
    "label": "copyValues()",
    "kind": "Method",
    "detail": "Function (} template<IterT> void)",
    "insertText": "copyValues(const AttributeArray& sourceArray, const IterT& iter, bool compact)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(TypeError, \"Cannot copy array data due to mis-match in storage type sizes.\")"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "expand()"
  },
  {
    "label": "doCopyValues()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "doCopyValues(sourceArray, iter, true)"
  },
  {
    "label": "TypedAttributeArray()",
    "kind": "Method",
    "detail": "Function (} } template<ValueType_,Codec_> std::unique_ptr<const NamePair> TypedAttributeArray<ValueType_,Codec_>::sTypeName ; template<ValueType_,Codec_> TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "TypedAttributeArray(Index n, Index strideOrTotalSize, bool constantStride, const ValueType& uniformValue) : AttributeArray() , mData(new StorageType[1]) , mSize(n) , mStrideOrTotalSize(strideOrTotalSize)"
  },
  {
    "label": "setConstantStride()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setConstantStride(true)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ValueError, \"Creating a TypedAttributeArray with a constant stride requires that \" \\ \"stride to be at least one.\")"
  },
  {
    "label": "setConstantStride()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setConstantStride(false)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ValueError, \"Creating a TypedAttributeArray with a non-constant stride must have \" \\ \"a total size of at least the number of elements in the array.\") } } mSize = std::max(Index(1), mSize)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (mStrideOrTotalSize =)",
    "insertText": "max(Index(1), mStrideOrTotalSize)"
  },
  {
    "label": "encode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "encode(uniformValue, this->data()[0])"
  },
  {
    "label": "TypedAttributeArray()",
    "kind": "Method",
    "detail": "Function (} # if OPENVDB_ABI_VERSION_NUMBER> = 7 template<ValueType_,Codec_> TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "TypedAttributeArray(const TypedAttributeArray& rhs) : TypedAttributeArray(rhs, tbb::spin_mutex::scoped_lock(rhs.mMutex))"
  },
  {
    "label": "TypedAttributeArray()",
    "kind": "Method",
    "detail": "Function (} template<ValueType_,Codec_> TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "TypedAttributeArray(const TypedAttributeArray& rhs, const tbb::spin_mutex::scoped_lock& lock) : AttributeArray(rhs, lock) #else template<typename ValueType_, typename Codec_> TypedAttributeArray<ValueType_, Codec_>::TypedAttributeArray(const TypedAttributeArray& rhs, bool) : AttributeArray(rhs) #endif , mSize(rhs.mSize) , mStrideOrTotalSize(rhs.mStrideOrTotalSize)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(static_cast<void*>(this->data()), rhs.data(), this->arrayMemUsage())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } template<ValueType_,Codec_> TypedAttributeArray<ValueType_,Codec_>& TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "operator(const TypedAttributeArray& rhs)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (tbb::spin_mutex::scoped_lock)",
    "insertText": "lock(mMutex)"
  },
  {
    "label": "rhsLock()",
    "kind": "Method",
    "detail": "Function (tbb::spin_mutex::scoped_lock)",
    "insertText": "rhsLock(rhs.mMutex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mFlags = rhs . mFlags ; mUsePagedRead = rhs . mUsePagedRead ; mSize = rhs . mSize ; mStrideOrTotalSize = rhs . mStrideOrTotalSize ; mIsUniform = rhs . mIsUniform ;)",
    "insertText": "if(this->validData())"
  },
  {
    "label": "call_once()",
    "kind": "Method",
    "detail": "Function (std::once_flag once ;)",
    "insertText": "call_once(once, []() { sTypeName.reset(new NamePair(typeNameAsString<ValueType>(), Codec::name())); })"
  },
  {
    "label": "registerType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "registerType(TypedAttributeArray::attributeType(), TypedAttributeArray::factory)"
  },
  {
    "label": "unregisterType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "unregisterType(TypedAttributeArray::attributeType())"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (} template<ValueType_,Codec_> TypedAttributeArray<ValueType_,Codec_>::Ptr TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "create(Index n, Index stride, bool constantStride, const Metadata* metadata)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (const TypedMetadata<ValueType>* typedMetadata = metadata ? dynamic_cast<const TypedMetadata<)",
    "insertText": "ValueType(metadata)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(TypeError, \"Invalid Attribute Type\")"
  },
  {
    "label": "TypedAttributeArray()",
    "kind": "Method",
    "detail": "Function (} return static_cast<)",
    "insertText": "TypedAttributeArray(attributeArray)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (# endif return)",
    "insertText": "Ptr(new TypedAttributeArray<ValueType, Codec>(*this))"
  },
  {
    "label": "copyUncompressed()",
    "kind": "Method",
    "detail": "Function (} template<ValueType_,Codec_> AttributeArray::Ptr TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "copyUncompressed()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!mData)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (mData .)",
    "insertText": "reset(new StorageType[1])"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} else { const size_t)",
    "insertText": "size(this->dataSize())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(size > 0)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (mData .)",
    "insertText": "reset(new StorageType[size])"
  },
  {
    "label": "setOutOfCore()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setOutOfCore(false)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (this -> mPageHandle .)",
    "insertText": "reset()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(mData) mData.reset()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(n < this->dataSize())"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (ValueType val ;)",
    "insertText": "decode(this->data()[mIsUniform ? 0 : n], val)"
  },
  {
    "label": "getUnsafe()",
    "kind": "Method",
    "detail": "Function (} template<ValueType_,Codec_> template<T> void TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "getUnsafe(Index n, T& val)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (val = static_cast<)",
    "insertText": "T(this->getUnsafe(n))"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} template<ValueType_,Codec_> template<T> void TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "get(Index n, T& val)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (val = static_cast<)",
    "insertText": "T(this->get(n))"
  },
  {
    "label": "setUnsafe()",
    "kind": "Method",
    "detail": "Function (} template<ValueType_,Codec_> void TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "setUnsafe(Index n, const ValueType& val)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!this->isOutOfCore())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!this->isUniform())"
  },
  {
    "label": "encode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "encode(val, this->data()[mIsUniform ? 0 : n])"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} template<ValueType_,Codec_> void TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "set(Index n, const ValueType& val)"
  },
  {
    "label": "setUnsafe()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setUnsafe(n, val)"
  },
  {
    "label": "setUnsafe()",
    "kind": "Method",
    "detail": "Function (} template<ValueType_,Codec_> template<T> void TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "setUnsafe(Index n, const T& val)"
  },
  {
    "label": "setUnsafe()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setUnsafe(n, static_cast<ValueType>(val))"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} template<ValueType_,Codec_> template<T> void TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "set(Index n, const T& val)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "set(n, static_cast<ValueType>(val))"
  },
  {
    "label": "Codec()",
    "kind": "Method",
    "detail": "Function (static_cast<TypedAttributeArray<ValueType,)",
    "insertText": "Codec(array)->setUnsafe(n, value)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} template<ValueType_,Codec_> void TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "set(Index n, const AttributeArray& sourceArray, const Index sourceIndex)"
  },
  {
    "label": "TypedAttributeArray()",
    "kind": "Method",
    "detail": "Function (const TypedAttributeArray& sourceTypedArray = static_cast<const)",
    "insertText": "TypedAttributeArray(sourceArray)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (ValueType sourceValue ; sourceTypedArray .)",
    "insertText": "get(sourceIndex, sourceValue)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "set(n, sourceValue)"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (} template<ValueType_,Codec_> void TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "expand(bool fill)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(fill)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (const ValueType_ val = this ->)",
    "insertText": "get(0)"
  },
  {
    "label": "collapse()",
    "kind": "Method",
    "detail": "Function (} this ->)",
    "insertText": "collapse(this->get(0))"
  },
  {
    "label": "collapse()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "collapse(zeroVal<ValueType>())"
  },
  {
    "label": "Codec()",
    "kind": "Method",
    "detail": "Function (static_cast<TypedAttributeArray<ValueType,)",
    "insertText": "Codec(array)->collapse(value)"
  },
  {
    "label": "encode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "encode(value, this->data()[i])"
  },
  {
    "label": "Codec()",
    "kind": "Method",
    "detail": "Function (static_cast<TypedAttributeArray<ValueType,)",
    "insertText": "Codec(array)->fill(value)"
  },
  {
    "label": "compress()",
    "kind": "Method",
    "detail": "Function (} template<ValueType_,Codec_> bool TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "compress()"
  },
  {
    "label": "Codec_()",
    "kind": "Method",
    "detail": "Function (TypedAttributeArray<ValueType_,Codec_>* self = const_cast<TypedAttributeArray<ValueType_,)",
    "insertText": "Codec_(this)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (tbb::spin_mutex::scoped_lock)",
    "insertText": "lock(self->mMutex)"
  },
  {
    "label": "doLoadUnsafe()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "doLoadUnsafe()"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (} template<ValueType_,Codec_> void TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "read(std::istream& is)"
  },
  {
    "label": "readMetadata()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "readMetadata(is)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "readBuffers(is)"
  },
  {
    "label": "readMetadata()",
    "kind": "Method",
    "detail": "Function (} template<ValueType_,Codec_> void TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "readMetadata(std::istream& is)"
  },
  {
    "label": "Index64()",
    "kind": "Method",
    "detail": "Function (Index64 bytes =)",
    "insertText": "Index64(0)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(&bytes), sizeof(Index64))"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (bytes = bytes -)",
    "insertText": "sizeof(Int16) - sizeof(Index)"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (uint8_t flags =)",
    "insertText": "uint8_t(0)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(&flags), sizeof(uint8_t))"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(&serializationFlags), sizeof(uint8_t))"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (Index size =)",
    "insertText": "Index(0)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(&size), sizeof(Index))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mSize = size ;)",
    "insertText": "if(mFlags >= 0x20)"
  },
  {
    "label": "OPENVDB_LOG_WARN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_LOG_WARN(\"Unknown attribute flags for VDB file format.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(serializationFlags >= 0x10)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(IoError, \"Unknown attribute serialization flags for VDB file format.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} mIsUniform = serializationFlags& WRITEUNIFORM ; mUsePagedRead = serializationFlags& WRITEPAGED ; mCompressedBytes = bytes ; mFlags | = PARTIALREAD ;)",
    "insertText": "if(serializationFlags & WRITESTRIDED)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(&stride), sizeof(Index))"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (mStrideOrTotalSize = stride ; } else { mStrideOrTotalSize = 1 ; } } template<ValueType_,Codec_> void TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "readBuffers(std::istream& is)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(IoError, \"Cannot read paged AttributeArray buffers.\")"
  },
  {
    "label": "bloscCompressed()",
    "kind": "Method",
    "detail": "Function (uint8_t)",
    "insertText": "bloscCompressed(0)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(mFlags & PARTIALREAD)"
  },
  {
    "label": "buffer()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<char [ ]>)",
    "insertText": "buffer(new char[mCompressedBytes])"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(buffer.get(), mCompressedBytes)"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (mCompressedBytes = 0 ; mFlags = static_cast<)",
    "insertText": "uint8_t(mFlags & ~PARTIALREAD)"
  },
  {
    "label": "dataSize()",
    "kind": "Method",
    "detail": "Function (const size_t inBytes = this ->)",
    "insertText": "dataSize() * sizeof(StorageType)"
  },
  {
    "label": "bloscDecompress()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<char [ ]> newBuffer =)",
    "insertText": "bloscDecompress(buffer.get(), inBytes)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (} mData .)",
    "insertText": "reset(reinterpret_cast<StorageType*>(buffer.release()))"
  },
  {
    "label": "readPagedBuffers()",
    "kind": "Method",
    "detail": "Function (} template<ValueType_,Codec_> void TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "readPagedBuffers(compression::PagedInputStream& is)"
  },
  {
    "label": "delayLoad()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "delayLoad(mappedFile.get() != nullptr)"
  },
  {
    "label": "compressedBytes()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "compressedBytes(mCompressedBytes)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!mPageHandle)"
  },
  {
    "label": "createHandle()",
    "kind": "Method",
    "detail": "Function (mPageHandle = is .)",
    "insertText": "createHandle(compressedBytes)"
  },
  {
    "label": "setOutOfCore()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setOutOfCore(delayLoad)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(mPageHandle, std::streamsize(mPageHandle->size()), delayLoad)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<char [ ]> buffer = mPageHandle ->)",
    "insertText": "read()"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (} mUsePagedRead = 0 ; } template<ValueType_,Codec_> void TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "write(std::ostream& os)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "write(os, false)"
  },
  {
    "label": "writeMetadata()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "writeMetadata(os, outputTransient, false)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "writeBuffers(os, outputTransient)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(IoError, \"Cannot write out a partially-read AttributeArray.\")"
  },
  {
    "label": "flags()",
    "kind": "Method",
    "detail": "Function (} uint8_t)",
    "insertText": "flags(mFlags)"
  },
  {
    "label": "serializationFlags()",
    "kind": "Method",
    "detail": "Function (uint8_t)",
    "insertText": "serializationFlags(0)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "size(mSize)"
  },
  {
    "label": "stride()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "stride(mStrideOrTotalSize)"
  },
  {
    "label": "strideOfOne()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "strideOfOne(this->stride() == 1)"
  },
  {
    "label": "getDataCompression()",
    "kind": "Method",
    "detail": "Function (bool bloscCompression =)",
    "insertText": "getDataCompression(os)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t compressedBytes = 0 ;)",
    "insertText": "if(!strideOfOne)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (serializationFlags | = WRITESTRIDED ; })",
    "insertText": "if(mIsUniform)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (serializationFlags | = WRITEUNIFORM ;)",
    "insertText": "if(bloscCompression && paged)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(bloscCompression)"
  },
  {
    "label": "bloscCompressedSize()",
    "kind": "Method",
    "detail": "Function (compressedBytes =)",
    "insertText": "bloscCompressedSize(charBuffer, inBytes)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} } Index64 bytes =)",
    "insertText": "sizeof(Int16) + sizeof(Index)"
  },
  {
    "label": "bytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bytes(compressedBytes > 0) ? compressedBytes : this->arrayMemUsage()"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&bytes), sizeof(Index64))"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&flags), sizeof(uint8_t))"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&serializationFlags), sizeof(uint8_t))"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&size), sizeof(Index))"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(this->data()), sizeof(StorageType))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(io::getDataCompression(os) & io::COMPRESS_BLOSC)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<char [ ]> compressedBuffer ; size_t compressedBytes = 0 ; const char* charBuffer = reinterpret_cast<const)",
    "insertText": "char(this->data())"
  },
  {
    "label": "bloscCompress()",
    "kind": "Method",
    "detail": "Function (compressedBuffer =)",
    "insertText": "bloscCompress(charBuffer, inBytes, compressedBytes)"
  },
  {
    "label": "bloscCompressed()",
    "kind": "Method",
    "detail": "Function (uint8_t)",
    "insertText": "bloscCompressed(1)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&bloscCompressed), sizeof(uint8_t))"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(compressedBuffer.get()), compressedBytes)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(this->data()), inBytes)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(this->data()), this->arrayMemUsage())"
  },
  {
    "label": "getDataCompression()",
    "kind": "Method",
    "detail": "Function (bool bloscCompression =)",
    "insertText": "getDataCompression(os.getOutputStream())"
  },
  {
    "label": "doLoadUnsafe()",
    "kind": "Method",
    "detail": "Function (} template<ValueType_,Codec_> void TypedAttributeArray<ValueType_,Codec_)",
    "insertText": "doLoadUnsafe(const bool)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(self->mPageHandle)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!(self->mFlags & PARTIALREAD))"
  },
  {
    "label": "Codec_()",
    "kind": "Method",
    "detail": "Function (const TypedAttributeArray<ValueType_,Codec_>* const otherT = dynamic_cast<const TypedAttributeArray<ValueType_,)",
    "insertText": "Codec_(&other)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (const StorageType* target = this ->)",
    "insertText": "data(), *source = otherT->data()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (Index n = this -> mIsUniform ? 1 : mSize ;)",
    "insertText": "while(n && math::isExactlyEqual(*target++, *source++))"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (ValueType)",
    "insertText": "get(GetterPtr , const AttributeArray* array, const Index n)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set(SetterPtr , AttributeArray* array, const Index n, const ValueType& value)"
  },
  {
    "label": "setUnsafe()",
    "kind": "Method",
    "detail": "Function (TypedAttributeArray<ValueType,CodecType)",
    "insertText": "setUnsafe(array, n, value)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (ValueType)",
    "insertText": "get(GetterPtr functor, const AttributeArray* array, const Index n)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set(SetterPtr functor, AttributeArray* array, const Index n, const ValueType& value)"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (} } ; template<ValueType,CodecType> AttributeHandle<ValueType,CodecType>::Ptr AttributeHandle<ValueType,CodecType)",
    "insertText": "create(const AttributeArray& array, const bool collapseOnDestruction)"
  },
  {
    "label": "AttributeHandle()",
    "kind": "Method",
    "detail": "Function (} template<ValueType,CodecType> AttributeHandle<ValueType,CodecType)",
    "insertText": "AttributeHandle(const AttributeArray& array, const bool collapseOnDestruction) : mArray(&array) , mStrideOrTotalSize(array.hasConstantStride() ? array.stride() : 1) , mSize(array.hasConstantStride() ? array.size() : array.dataSize()) , mCollapseOnDestruction(collapseOnDestruction && array.isStreaming())"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(TypeError, \"Cannot bind handle due to incompatible type of AttributeArray.\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(accessor)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (AttributeArray::Accessor<ValueType>* typedAccessor = static_cast<AttributeArray::Accessor<)",
    "insertText": "ValueType(accessor.get())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(mArray)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (Index index = n* mStrideOrTotalSize + m ;)",
    "insertText": "assert(index < (mSize * mStrideOrTotalSize))"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (} template<ValueType,CodecType> AttributeWriteHandle<ValueType,CodecType>::Ptr AttributeWriteHandle<ValueType,CodecType)",
    "insertText": "create(AttributeArray& array, const bool expand)"
  },
  {
    "label": "AttributeWriteHandle()",
    "kind": "Method",
    "detail": "Function (} template<ValueType,CodecType> AttributeWriteHandle<ValueType,CodecType)",
    "insertText": "AttributeWriteHandle(AttributeArray& array, const bool expand) : AttributeHandle<ValueType, CodecType>(array, false)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (this -> set<std::is_same<CodecType,UnknownCodec)",
    "insertText": "value(this->index(n, 0), value)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (this -> set<std::is_same<CodecType,UnknownCodec)",
    "insertText": "value(this->index(n, m), value)"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (} template<ValueType,CodecType> void AttributeWriteHandle<ValueType,CodecType)",
    "insertText": "expand(const bool fill)"
  },
  {
    "label": "AttributeArray()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "AttributeArray(this->mArray)->expand(fill)"
  },
  {
    "label": "AttributeArray()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "AttributeArray(this->mArray)->collapse()"
  },
  {
    "label": "mCollapser()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "mCollapser(const_cast<AttributeArray*>(this->mArray), uniformValue)"
  },
  {
    "label": "mFiller()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "mFiller(const_cast<AttributeArray*>(this->mArray), value)"
  },
  {
    "label": "setUnsafe()",
    "kind": "Method",
    "detail": "Function (TypedAttributeArray<ValueType,CodecType)",
    "insertText": "setUnsafe(const_cast<AttributeArray*>(this->mArray), index, value)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(this->mArray)"
  }
]