[
  {
    "label": "TRobinHoodHashTable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRobinHoodHashTable"
  },
  {
    "label": "FHashType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FHashType"
  },
  {
    "label": "RobinHoodHashTable_Private",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RobinHoodHashTable_Private"
  },
  {
    "label": "FHashElementId",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FHashElementId"
  },
  {
    "label": "TFreeList",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TFreeList"
  },
  {
    "label": "FSpan",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSpan"
  },
  {
    "label": "FUnitType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FUnitType"
  },
  {
    "label": "TKeyValue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TKeyValue"
  },
  {
    "label": "FData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FData"
  },
  {
    "label": "FIteratorState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FIteratorState"
  },
  {
    "label": "FIteratorType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FIteratorType"
  },
  {
    "label": "FConstIteratorType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FConstIteratorType"
  },
  {
    "label": "TRobinHoodHashMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRobinHoodHashMap"
  },
  {
    "label": "should",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "should"
  },
  {
    "label": "TRobinHoodHashSet",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRobinHoodHashSet"
  },
  {
    "label": "CHECK_CONCURRENT_ACCESS()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Containers / Map . h \" # include \" Templates / UnrealTemplate . h \" # define RUN_HASHTABLE_CONCURENCY_CHECKS UE_BUILD_DEBUG # if RUN_HASHTABLE_CONCURENCY_CHECKS # define)",
    "insertText": "CHECK_CONCURRENT_ACCESS(x) check(x) #else #define CHECK_CONCURRENT_ACCESS(x)"
  },
  {
    "label": "FHashType()",
    "kind": "Method",
    "detail": "Function (namespace RobinHoodHashTable_Private { template<,,,> class TRobinHoodHashTable ; } class FHashType { public :)",
    "insertText": "FHashType() : Hash(InvalidHash)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(FHashType Other)"
  },
  {
    "label": "IsOccupied()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsOccupied()"
  },
  {
    "label": "FHashElementId()",
    "kind": "Method",
    "detail": "Function (IntType Hash ; } ; class FHashElementId { public :)",
    "insertText": "FHashElementId() : Index(INDEX_NONE)"
  },
  {
    "label": "FHashElementId()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FHashElementId(int32 InIndex) : Index(InIndex)"
  },
  {
    "label": "GetIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetIndex()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty()"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Push(IndexType NodeIndex)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (+ + NumElements ; int Index = 1 ; int Size = FreeList .)",
    "insertText": "Num()"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (const int LeftoverSize = Size % 2 ; Size = Size / 2 ; const int CheckIndex = Index + Size ; const int IndexIfLess = CheckIndex + LeftoverSize ; Index = FreeList [ CheckIndex ] . Start> NodeIndex ? IndexIfLess : Index ; } int ArrayEnd =)",
    "insertText": "Min(Index + Size + 1, FreeList.Num())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } Index + + ; })",
    "insertText": "if(Index < FreeList.Num() && FreeList[Index].End + 1 == NodeIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FreeList [ Index ] . End = NodeIndex ;)",
    "insertText": "if(FreeList[Index - 1].Start - 1 == NodeIndex)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (FreeList [ Index - 1 ] . Start = FreeList [ Index ] . Start ; FreeList .)",
    "insertText": "RemoveAt(Index)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (FreeList [ Index - 1 ] . Start = NodeIndex ; return ; } FreeList .)",
    "insertText": "Insert(FSpan{ NodeIndex , NodeIndex }, Index)"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (} IndexType)",
    "insertText": "Pop()"
  },
  {
    "label": "Last()",
    "kind": "Method",
    "detail": "Function (- - NumElements ; FSpan& Span = FreeList .)",
    "insertText": "Last()"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (IndexType Index = Span . Start ;)",
    "insertText": "checkSlow(Index != INDEX_NONE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const FSpan& Span = FreeList [ i ] ;)",
    "insertText": "if(Index >= Span.Start && Index <= Span.End)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (FreeList .)",
    "insertText": "Reset(1)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (FreeList .)",
    "insertText": "Push(FSpan{ INDEX_NONE, INDEX_NONE })"
  },
  {
    "label": "TKeyValue()",
    "kind": "Method",
    "detail": "Function (} } ; struct FUnitType { } ; template<KeyType,ValueType> class TKeyValue { using FindValueType = ValueType* ; using FindValueTypeConst = const ValueType* ; using ElementType = TPair<const KeyType,ValueType> ; template<,,,> class TRobinHoodHashTable ; template<DeducedKeyType,DeducedValueType>)",
    "insertText": "TKeyValue(DeducedKeyType&& InKey, DeducedValueType&& InVal) : Pair(Forward<DeducedKeyType>(InKey) , Forward<DeducedValueType>(InVal))"
  },
  {
    "label": "FindImpl()",
    "kind": "Method",
    "detail": "Function (} ElementType Pair ; FindValueType)",
    "insertText": "FindImpl()"
  },
  {
    "label": "DeducedValueType()",
    "kind": "Method",
    "detail": "Function (Pair . Value = Forward<)",
    "insertText": "DeducedValueType(InValue)"
  },
  {
    "label": "GetElement()",
    "kind": "Method",
    "detail": "Function (} ElementType&)",
    "insertText": "GetElement()"
  },
  {
    "label": "FData()",
    "kind": "Method",
    "detail": "Function (struct FData {)",
    "insertText": "FData()"
  },
  {
    "label": "FData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FData(const FData&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FData&)",
    "insertText": "operator(const FData&)"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (} SizeType)",
    "insertText": "GetAllocatedSize()"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (} template<DeducedKeyType,DeducedValueType> IndexType)",
    "insertText": "Allocate(DeducedKeyType&& Key, DeducedValueType&& Val, FHashType Hash)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (IndexType Index ;)",
    "insertText": "if(FreeList.Num() > 0)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)&KeyVals[Index])"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (KeyVals .)",
    "insertText": "Push(KeyValueType{ Forward<DeducedKeyType>(Key), Forward<DeducedValueType>(Val) })"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (Hashes .)",
    "insertText": "Push(Hash)"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "checkSlow(Index != InvalidIndex)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (FreeList .)",
    "insertText": "Push(Index)"
  },
  {
    "label": "FHashType()",
    "kind": "Method",
    "detail": "Function (Hashes [ Index ] =)",
    "insertText": "FHashType()"
  },
  {
    "label": "KeyValueType()",
    "kind": "Method",
    "detail": "Function (KeyVals [ Index ] . ~)",
    "insertText": "KeyValueType()"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (# if RUN_HASHTABLE_CONCURENCY_CHECKS)",
    "insertText": "memset(&KeyVals[Index], 0, sizeof(KeyValueType))"
  },
  {
    "label": "CHECK_CONCURRENT_ACCESS()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "CHECK_CONCURRENT_ACCESS(FPlatformAtomics::InterlockedDecrement(&ConcurrentReaders) == 0)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Contains(IndexType Index)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} const KeyValueType&)",
    "insertText": "Get(IndexType Index)"
  },
  {
    "label": "GetMaxIndex()",
    "kind": "Method",
    "detail": "Function (} IndexType)",
    "insertText": "GetMaxIndex()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} struct FIteratorState { IndexType Index ; bool)",
    "insertText": "operator(const FIteratorState& Rhs)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (State .)",
    "insertText": "Index(State.Index + 1)"
  },
  {
    "label": "End()",
    "kind": "Method",
    "detail": "Function (} FIteratorState)",
    "insertText": "End()"
  },
  {
    "label": "Start()",
    "kind": "Method",
    "detail": "Function (FIteratorState Iter =)",
    "insertText": "Start()"
  },
  {
    "label": "Next()",
    "kind": "Method",
    "detail": "Function (Iter =)",
    "insertText": "Next(Iter)"
  },
  {
    "label": "SetNumUnsafeInternal()",
    "kind": "Method",
    "detail": "Function (} KeyVals .)",
    "insertText": "SetNumUnsafeInternal(0)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reserve(SizeType ReserveNum)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (KeyVals .)",
    "insertText": "Reserve(ReserveNum)"
  },
  {
    "label": "ModTableSize()",
    "kind": "Method",
    "detail": "Function (} # if RUN_HASHTABLE_CONCURENCY_CHECKS int ConcurrentReaders = 0 ; int ConcurrentWriters = 0 ; # endif TArray<KeyValueType,HashMapAllocator> KeyVals ; TArray<FHashType,HashMapAllocator> Hashes ; TFreeList<InlineOneAllocatorType> FreeList ; } ; IndexType)",
    "insertText": "ModTableSize(IndexType HashValue)"
  },
  {
    "label": "ModTableSize()",
    "kind": "Method",
    "detail": "Function (IndexType InsertIndex = Index ; FHashType InsertHash = Hash ; IndexType CurrentBucket =)",
    "insertText": "ModTableSize(Hash.AsUInt())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (IndexType InsertDistance = 0 ;)",
    "insertText": "for(;;)"
  },
  {
    "label": "ModTableSize()",
    "kind": "Method",
    "detail": "Function (IndexType OtherDistance =)",
    "insertText": "ModTableSize(CurrentBucket - HashData[CurrentBucket].AsUInt())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (MaximumDistance = InsertDistance ; } IndexData [ CurrentBucket ] = InsertIndex ; HashData [ CurrentBucket ] = InsertHash ; break ; } else)",
    "insertText": "if(OtherDistance < InsertDistance)"
  },
  {
    "label": "ModTableSize()",
    "kind": "Method",
    "detail": "Function (MaximumDistance = InsertDistance ; } IndexType OtherIndex = IndexData [ CurrentBucket ] ; FHashType OtherHash = HashData [ CurrentBucket ] ; IndexData [ CurrentBucket ] = InsertIndex ; HashData [ CurrentBucket ] = InsertHash ; InsertDistance = OtherDistance ; InsertIndex = OtherIndex ; InsertHash = OtherHash ; } InsertDistance + + ; CurrentBucket =)",
    "insertText": "ModTableSize(CurrentBucket + 1)"
  },
  {
    "label": "FindOrUpdateIdByHashInternal()",
    "kind": "Method",
    "detail": "Function (} } private : template<bool UpdateValue,DeducedKeyType,DeducedValueType> FHashElementId)",
    "insertText": "FindOrUpdateIdByHashInternal(FHashType HashValue, DeducedKeyType&& Key, DeducedValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "ModTableSize()",
    "kind": "Method",
    "detail": "Function (IndexType BucketIndex =)",
    "insertText": "ModTableSize(HashValue.AsUInt())"
  },
  {
    "label": "ModTableSize()",
    "kind": "Method",
    "detail": "Function (const IndexType EndBucketIndex =)",
    "insertText": "ModTableSize(HashValue.AsUInt() + MaximumDistance + 1)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (bIsAlreadyInMap = true ; if)",
    "insertText": "constexpr(UpdateValue)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (KeyValueData .)",
    "insertText": "Get(IndexData[BucketIndex]).Update(Forward<DeducedValueType>(Val))"
  },
  {
    "label": "ModTableSize()",
    "kind": "Method",
    "detail": "Function (} return IndexData [ BucketIndex ] ; } } BucketIndex =)",
    "insertText": "ModTableSize(BucketIndex + 1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(BucketIndex != EndBucketIndex)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (TArray<IndexType,InlineOneAllocatorType> IndexDataOld =)",
    "insertText": "MoveTemp(IndexData)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (TArray<FHashType,InlineOneAllocatorType> HashDataOld =)",
    "insertText": "MoveTemp(HashData)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (IndexType OldSizePow2Minus1 = SizePow2Minus1 ; SizePow2Minus1 = SizePow2Minus1* 2 + 1 ; MaximumDistance = 0 ; IndexData .)",
    "insertText": "Reserve(SizePow2Minus1 + 1)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (IndexData .)",
    "insertText": "AddUninitialized(SizePow2Minus1 + 1)"
  },
  {
    "label": "AddDefaulted()",
    "kind": "Method",
    "detail": "Function (HashData .)",
    "insertText": "AddDefaulted(SizePow2Minus1 + 1)"
  },
  {
    "label": "InsertIntoTable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InsertIntoTable(IndexDataOld[Index], HashDataOld[Index])"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (} } } IndexType InsertIndex = KeyValueData .)",
    "insertText": "Allocate(Forward<DeducedKeyType>(Key), Forward<DeducedValueType>(Val), HashValue)"
  },
  {
    "label": "InsertIntoTable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InsertIntoTable(InsertIndex, HashValue)"
  },
  {
    "label": "FHashElementId()",
    "kind": "Method",
    "detail": "Function (bIsAlreadyInMap = false ; return)",
    "insertText": "FHashElementId(InsertIndex)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (} protected : template<DeducedKeyType,DeducedValueType> FHashElementId)",
    "insertText": "FindOrAddIdByHash(FHashType HashValue, DeducedKeyType&& Key, DeducedValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (} template<DeducedKeyType,DeducedValueType> FHashElementId)",
    "insertText": "FindOrAddId(DeducedKeyType&& Key, DeducedValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "ComputeHash()",
    "kind": "Method",
    "detail": "Function (FHashType HashValue =)",
    "insertText": "ComputeHash(Key)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} template<DeducedKeyType,DeducedValueType> FindValueType)",
    "insertText": "FindOrAdd(DeducedKeyType&& Key, DeducedValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (FHashElementId Id =)",
    "insertText": "FindOrAddId(Forward<DeducedKeyType>(Key), Forward<DeducedValueType>(Val), bIsAlreadyInMap)"
  },
  {
    "label": "UpdateIdByHash()",
    "kind": "Method",
    "detail": "Function (} template<DeducedKeyType,DeducedValueType> FHashElementId)",
    "insertText": "UpdateIdByHash(FHashType HashValue, DeducedKeyType&& Key, DeducedValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "UpdateId()",
    "kind": "Method",
    "detail": "Function (} template<DeducedKeyType,DeducedValueType> FHashElementId)",
    "insertText": "UpdateId(DeducedKeyType&& Key, DeducedValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (} template<DeducedKeyType,DeducedValueType> FindValueType)",
    "insertText": "Update(DeducedKeyType&& Key, DeducedValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "UpdateId()",
    "kind": "Method",
    "detail": "Function (FHashElementId Id =)",
    "insertText": "UpdateId(Forward<DeducedKeyType>(Key), Forward<DeducedValueType>(Val), bIsAlreadyInMap)"
  },
  {
    "label": "TRobinHoodHashTable()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TRobinHoodHashTable()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (IndexData .)",
    "insertText": "Reserve(1)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (IndexData .)",
    "insertText": "AddUninitialized()"
  },
  {
    "label": "AddDefaulted()",
    "kind": "Method",
    "detail": "Function (HashData .)",
    "insertText": "AddDefaulted()"
  },
  {
    "label": "TRobinHoodHashTable()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TRobinHoodHashTable(const TRobinHoodHashTable& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IndexData [ Idx ] = Other . IndexData [ Idx ] ; HashData [ Idx ] = Other . HashData [ Idx ] ; } } TRobinHoodHashTable&)",
    "insertText": "operator(const TRobinHoodHashTable& Other)"
  },
  {
    "label": "TRobinHoodHashTable()",
    "kind": "Method",
    "detail": "Function (IndexData [ Idx ] = Other . IndexData [ Idx ] ; HashData [ Idx ] = Other . HashData [ Idx ] ; } } return* this ; })",
    "insertText": "TRobinHoodHashTable(TRobinHoodHashTable&& Other)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (SizePow2Minus1 = Other . SizePow2Minus1 ; MaximumDistance = Other . MaximumDistance ; KeyValueData =)",
    "insertText": "MoveTemp(Other.KeyValueData)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (IndexData =)",
    "insertText": "MoveTemp(Other.IndexData)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (HashData =)",
    "insertText": "MoveTemp(Other.HashData)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TRobinHoodHashTable&)",
    "insertText": "operator(TRobinHoodHashTable&& Other)"
  },
  {
    "label": "ComputeHash()",
    "kind": "Method",
    "detail": "Function (} return* this ; } public : FHashType)",
    "insertText": "ComputeHash(const KeyType& Key)"
  },
  {
    "label": "GetKeyHash()",
    "kind": "Method",
    "detail": "Function (FHashType::IntType HashValue =)",
    "insertText": "GetKeyHash(Key)"
  },
  {
    "label": "HashBits()",
    "kind": "Method",
    "detail": "Function (FHashType::IntType)",
    "insertText": "HashBits(~(1 << (sizeof(typename FHashType::IntType) * 8 - 1)))"
  },
  {
    "label": "FIteratorType()",
    "kind": "Method",
    "detail": "Function (} class FIteratorType { FData::FIteratorState State ; FData& Data ; template<,,,> class TRobinHoodHashTable ;)",
    "insertText": "FIteratorType(FData& InData, bool bIsStartIterator) : Data(InData)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } public : bool)",
    "insertText": "operator(const FIteratorType& Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FIteratorType&)",
    "insertText": "operator()"
  },
  {
    "label": "Next()",
    "kind": "Method",
    "detail": "Function (State = Data .)",
    "insertText": "Next(State)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} } ; FIteratorType)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} FIteratorType)",
    "insertText": "end()"
  },
  {
    "label": "FConstIteratorType()",
    "kind": "Method",
    "detail": "Function (} class FConstIteratorType { FData::FIteratorState State ; const FData& Data ; template<,,,> class TRobinHoodHashTable ;)",
    "insertText": "FConstIteratorType(const FData& InData, bool bIsStartIterator) : Data(InData)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } public : bool)",
    "insertText": "operator(const FConstIteratorType& Rhs)"
  },
  {
    "label": "GetByElementId()",
    "kind": "Method",
    "detail": "Function (} ElementType&)",
    "insertText": "GetByElementId(FHashElementId Id)"
  },
  {
    "label": "ContainsElementId()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ContainsElementId(FHashElementId Id)"
  },
  {
    "label": "FindIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindIdByHash(const FHashType HashValue, const KeyType& ComparableKey)"
  },
  {
    "label": "FindId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindId(const KeyType& Key)"
  },
  {
    "label": "FindByHash()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "FindByHash(const FHashType HashValue, const KeyType& Key)"
  },
  {
    "label": "FindIdByHash()",
    "kind": "Method",
    "detail": "Function (FHashElementId Id =)",
    "insertText": "FindIdByHash(HashValue, Key)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (} return nullptr ; } FindValueType)",
    "insertText": "Find(const KeyType& Key)"
  },
  {
    "label": "FindId()",
    "kind": "Method",
    "detail": "Function (FHashElementId Id =)",
    "insertText": "FindId(Key)"
  },
  {
    "label": "RemoveByHash()",
    "kind": "Method",
    "detail": "Function (} return nullptr ; } bool)",
    "insertText": "RemoveByHash(const FHashType HashValue, const KeyType& ComparableKey)"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (bool bIsFoundInMap = false ;)",
    "insertText": "checkSlow(HashValue == ComputeHash(ComparableKey)) IndexType BucketIndex = ModTableSize(HashValue.AsUInt())"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (KeyValueData .)",
    "insertText": "Deallocate(IndexData[BucketIndex])"
  },
  {
    "label": "RemoveByElementId()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "RemoveByElementId(FHashElementId Id)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (IndexData .)",
    "insertText": "Empty(1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (IndexType NewSizePow2Minus1 = SizePow2Minus1 ;)",
    "insertText": "while((ReserveNum * LoadFactorQuotient) >= (NewSizePow2Minus1 * LoadFactorDivisor))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NewSizePow2Minus1 = NewSizePow2Minus1* 2 + 1 ; })",
    "insertText": "if(NewSizePow2Minus1 > SizePow2Minus1)"
  },
  {
    "label": "TRobinHoodHashMap()",
    "kind": "Method",
    "detail": "Function (} private : FData KeyValueData ; TArray<IndexType,InlineOneAllocatorType> IndexData ; TArray<FHashType,InlineOneAllocatorType> HashData ; IndexType SizePow2Minus1 = 0 ; IndexType MaximumDistance = 0 ; # if RUN_HASHTABLE_CONCURENCY_CHECKS int ConcurrentReaders = 0 ; int ConcurrentWriters = 0 ; # endif } ; } template<KeyType,ValueType,Hasher = TDefaultMapHashableKeyFuncs<KeyType,ValueType,false>,HashMapAllocator = FDefaultAllocator> class TRobinHoodHashMap : public RobinHoodHashTable_Private::TRobinHoodHashTable<KeyType,ValueType,Hasher,HashMapAllocator> { using Base = RobinHoodHashTable_Private::TRobinHoodHashTable<KeyType,ValueType,Hasher,HashMapAllocator> ; using IndexType = Base::IndexType ; using FindValueType = Base::FindValueType ; using FindValueTypeConst = Base::FindValueTypeConst ; public :)",
    "insertText": "TRobinHoodHashMap() : Base()"
  },
  {
    "label": "TRobinHoodHashMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TRobinHoodHashMap(const TRobinHoodHashMap& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TRobinHoodHashMap&)",
    "insertText": "operator(const TRobinHoodHashMap& Other)"
  },
  {
    "label": "TRobinHoodHashMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRobinHoodHashMap(TRobinHoodHashMap&& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TRobinHoodHashMap&)",
    "insertText": "operator(TRobinHoodHashMap&& Other)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (FHashElementId)",
    "insertText": "FindOrAddIdByHash(FHashType HashValue, const KeyType& Key, const ValueType& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddIdByHash(FHashType HashValue, const KeyType& Key, ValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddIdByHash(FHashType HashValue, KeyType&& Key, const ValueType& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddIdByHash(FHashType HashValue, KeyType&& Key, ValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddId(const KeyType& Key, const ValueType& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddId(const KeyType& Key, ValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddId(KeyType&& Key, const ValueType& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddId(KeyType&& Key, ValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "FindOrAdd(const KeyType& Key, const ValueType& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "FindOrAdd(const KeyType& Key, ValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "FindOrAdd(KeyType&& Key, const ValueType& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "FindOrAdd(KeyType&& Key, ValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddIdByHash(FHashType HashValue, const KeyType& Key, const ValueType& Val)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "FindOrAddIdByHash(HashValue, Key, Val, bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddIdByHash(FHashType HashValue, const KeyType& Key, ValueType&& Val)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "FindOrAddIdByHash(HashValue, Key, MoveTemp(Val), bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddIdByHash(FHashType HashValue, KeyType&& Key, const ValueType& Val)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "FindOrAddIdByHash(HashValue, MoveTemp(Key), Val, bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddIdByHash(FHashType HashValue, KeyType&& Key, ValueType&& Val)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "FindOrAddIdByHash(HashValue, MoveTemp(Key), MoveTemp(Val), bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddId(const KeyType& Key, const ValueType& Val)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "FindOrAddId(Key, Val, bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddId(const KeyType& Key, ValueType&& Val)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "FindOrAddId(Key, MoveTemp(Val), bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddId(KeyType&& Key, const ValueType& Val)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "FindOrAddId(MoveTemp(Key), Val)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddId(KeyType&& Key, ValueType&& Val)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "FindOrAddId(MoveTemp(Key), MoveTemp(Val), bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "FindOrAdd(const KeyType& Key, const ValueType& Val)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "FindOrAdd(Key, Val, bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "FindOrAdd(const KeyType& Key, ValueType&& Val)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "FindOrAdd(Key, MoveTemp(Val), bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "FindOrAdd(KeyType&& Key, const ValueType& Val)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "FindOrAdd(MoveTemp(Key), Val, bIsAlreadyInMap)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "FindOrAdd(KeyType&& Key, ValueType&& Val)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "FindOrAdd(MoveTemp(Key), MoveTemp(Val), bIsAlreadyInMap)"
  },
  {
    "label": "UpdateIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "UpdateIdByHash(FHashType HashValue, const KeyType& Key, const ValueType& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "UpdateIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "UpdateIdByHash(FHashType HashValue, const KeyType& Key, ValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "UpdateIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "UpdateIdByHash(FHashType HashValue, KeyType&& Key, const ValueType& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "UpdateIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "UpdateIdByHash(FHashType HashValue, KeyType&& Key, ValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "UpdateId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "UpdateId(const KeyType& Key, const ValueType& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "UpdateId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "UpdateId(const KeyType& Key, ValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "UpdateId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "UpdateId(KeyType&& Key, const ValueType& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "UpdateId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "UpdateId(KeyType&& Key, ValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "Update(const KeyType& Key, const ValueType& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "Update(const KeyType& Key, ValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "Update(KeyType&& Key, const ValueType& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "Update(KeyType&& Key, ValueType&& Val, bool& bIsAlreadyInMap)"
  },
  {
    "label": "UpdateIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "UpdateIdByHash(FHashType HashValue, const KeyType& Key, const ValueType& Val)"
  },
  {
    "label": "UpdateIdByHash()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "UpdateIdByHash(HashValue, Key, Val, bIsAlreadyInMap)"
  },
  {
    "label": "UpdateIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "UpdateIdByHash(FHashType HashValue, const KeyType& Key, ValueType&& Val)"
  },
  {
    "label": "UpdateIdByHash()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "UpdateIdByHash(HashValue, Key, MoveTemp(Val), bIsAlreadyInMap)"
  },
  {
    "label": "UpdateIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "UpdateIdByHash(FHashType HashValue, KeyType&& Key, const ValueType& Val)"
  },
  {
    "label": "UpdateIdByHash()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "UpdateIdByHash(HashValue, MoveTemp(Key), Val, bIsAlreadyInMap)"
  },
  {
    "label": "UpdateIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "UpdateIdByHash(FHashType HashValue, KeyType&& Key, ValueType&& Val)"
  },
  {
    "label": "UpdateIdByHash()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "UpdateIdByHash(HashValue, MoveTemp(Key), MoveTemp(Val), bIsAlreadyInMap)"
  },
  {
    "label": "UpdateId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "UpdateId(const KeyType& Key, const ValueType& Val)"
  },
  {
    "label": "UpdateId()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "UpdateId(Key, Val, bIsAlreadyInMap)"
  },
  {
    "label": "UpdateId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "UpdateId(const KeyType& Key, ValueType&& Val)"
  },
  {
    "label": "UpdateId()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "UpdateId(Key, MoveTemp(Val), bIsAlreadyInMap)"
  },
  {
    "label": "UpdateId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "UpdateId(KeyType&& Key, const ValueType& Val)"
  },
  {
    "label": "UpdateId()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "UpdateId(MoveTemp(Key), Val)"
  },
  {
    "label": "UpdateId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "UpdateId(KeyType&& Key, ValueType&& Val)"
  },
  {
    "label": "UpdateId()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "UpdateId(MoveTemp(Key), MoveTemp(Val), bIsAlreadyInMap)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "Update(const KeyType& Key, const ValueType& Val)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "Update(Key, Val, bIsAlreadyInMap)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "Update(const KeyType& Key, ValueType&& Val)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "Update(Key, MoveTemp(Val), bIsAlreadyInMap)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "Update(KeyType&& Key, const ValueType& Val)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "Update(MoveTemp(Key), Val, bIsAlreadyInMap)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "Update(KeyType&& Key, ValueType&& Val)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInMap ; return)",
    "insertText": "Update(MoveTemp(Key), MoveTemp(Val), bIsAlreadyInMap)"
  },
  {
    "label": "TRobinHoodHashSet()",
    "kind": "Method",
    "detail": "Function (} } ; template<KeyType,Hasher = DefaultKeyFuncs<KeyType,false>,HashMapAllocator = FDefaultAllocator> class TRobinHoodHashSet : public RobinHoodHashTable_Private::TRobinHoodHashTable<KeyType,RobinHoodHashTable_Private::FUnitType,Hasher,HashMapAllocator> { using Unit = RobinHoodHashTable_Private::FUnitType ; using Base = RobinHoodHashTable_Private::TRobinHoodHashTable<KeyType,Unit,Hasher,HashMapAllocator> ; using IndexType = Base::IndexType ; using FindValueType = Base::FindValueType ; using FindValueTypeConst = Base::FindValueTypeConst ; public :)",
    "insertText": "TRobinHoodHashSet() : Base()"
  },
  {
    "label": "TRobinHoodHashSet()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TRobinHoodHashSet(const TRobinHoodHashSet& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TRobinHoodHashSet&)",
    "insertText": "operator(const TRobinHoodHashSet& Other)"
  },
  {
    "label": "TRobinHoodHashSet()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRobinHoodHashSet(TRobinHoodHashSet&& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TRobinHoodHashSet&)",
    "insertText": "operator(TRobinHoodHashSet&& Other)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (FHashElementId)",
    "insertText": "FindOrAddIdByHash(FHashType HashValue, const KeyType& Key, bool& bIsAlreadyInSet)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddIdByHash(FHashType HashValue, KeyType&& Key, bool& bIsAlreadyInSet)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddId(const KeyType& Key, bool& bIsAlreadyInSet)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddId(KeyType&& Key, bool& bIsAlreadyInSet)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "FindOrAdd(const KeyType& Key, bool& bIsAlreadyInSet)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "FindOrAdd(KeyType&& Key, bool& bIsAlreadyInSet)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddIdByHash(FHashType HashValue, const KeyType& Key)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInSet ; return)",
    "insertText": "FindOrAddIdByHash(HashValue, Key, Unit(), bIsAlreadyInSet)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddIdByHash(FHashType HashValue, KeyType&& Key)"
  },
  {
    "label": "FindOrAddIdByHash()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInSet ; return)",
    "insertText": "FindOrAddIdByHash(HashValue, MoveTemp(Key), Unit(), bIsAlreadyInSet)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddId(const KeyType& Key)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInSet ; return)",
    "insertText": "FindOrAddId(Key, Unit(), bIsAlreadyInSet)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (} FHashElementId)",
    "insertText": "FindOrAddId(KeyType&& Key)"
  },
  {
    "label": "FindOrAddId()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInSet ; return)",
    "insertText": "FindOrAddId(MoveTemp(Key), Unit(), bIsAlreadyInSet)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "FindOrAdd(const KeyType& Key)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInSet ; return)",
    "insertText": "FindOrAdd(Key, Unit(), bIsAlreadyInSet)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} FindValueType)",
    "insertText": "FindOrAdd(KeyType&& Key)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (bool bIsAlreadyInSet ; return)",
    "insertText": "FindOrAdd(MoveTemp(Key), Unit(), bIsAlreadyInSet)"
  }
]