[
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "MessagePumpLibevent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MessagePumpLibevent"
  },
  {
    "label": "MessagePumpLibeventTest",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MessagePumpLibeventTest"
  },
  {
    "label": "EpollEventEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "EpollEventEntry"
  },
  {
    "label": "RunState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RunState"
  },
  {
    "label": "MessagePumpEpoll()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_MESSAGE_LOOP_MESSAGE_PUMP_EPOLL_H_ # define BASE_MESSAGE_LOOP_MESSAGE_PUMP_EPOLL_H_ # include<sys / epoll . h> # include<cstdint> # include<map> # include \" base / base_export . h \" # include \" base / containers / stack_container . h \" # include \" base / files / scoped_file . h \" # include \" base / memory / raw_ptr . h \" # include \" base / memory / ref_counted . h \" # include \" base / memory / weak_ptr . h \" # include \" base / message_loop / message_pump . h \" # include \" base / message_loop / message_pump_libevent . h \" # include \" base / message_loop / watchable_io_message_pump_posix . h \" # include \" base / threading / thread_checker . h \" # include \" base / time / time . h \" namespace base { class BASE_EXPORT MessagePumpEpoll : public MessagePump,public WatchableIOMessagePumpPosix { using InterestParams = MessagePumpLibevent::EpollInterestParams ; using Interest = MessagePumpLibevent::EpollInterest ; public : using FdWatchController = MessagePumpLibevent::FdWatchController ;)",
    "insertText": "MessagePumpEpoll()"
  },
  {
    "label": "MessagePumpEpoll()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MessagePumpEpoll(const MessagePumpEpoll&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MessagePumpEpoll&)",
    "insertText": "operator(const MessagePumpEpoll&)"
  },
  {
    "label": "WatchFileDescriptor()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "WatchFileDescriptor(int fd, bool persistent, int mode, FdWatchController* controller, FdWatcher* watcher)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Run(Delegate* delegate)"
  },
  {
    "label": "Quit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Quit()"
  },
  {
    "label": "ScheduleWork()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ScheduleWork()"
  },
  {
    "label": "ScheduleDelayedWork()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ScheduleDelayedWork(const Delegate::NextWorkInfo& next_work_info)"
  },
  {
    "label": "EpollEventEntry()",
    "kind": "Method",
    "detail": "Function (private : class MessagePumpLibevent ; class MessagePumpLibeventTest ; struct EpollEventEntry {)",
    "insertText": "EpollEventEntry(int fd)"
  },
  {
    "label": "EpollEventEntry()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EpollEventEntry(const EpollEventEntry&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (EpollEventEntry&)",
    "insertText": "operator(const EpollEventEntry&)"
  },
  {
    "label": "EpollEventEntry()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "EpollEventEntry()"
  },
  {
    "label": "ComputeActiveEvents()",
    "kind": "Method",
    "detail": "Function (uint32_t)",
    "insertText": "ComputeActiveEvents()"
  },
  {
    "label": "RunState()",
    "kind": "Method",
    "detail": "Function (const int fd ; uint32_t registered_events = 0 ; StackVector<scoped_refptr<Interest>,2> interests ; } ; struct RunState {)",
    "insertText": "RunState(Delegate* delegate) : delegate(delegate)"
  },
  {
    "label": "AddEpollEvent()",
    "kind": "Method",
    "detail": "Function (} RAW_PTR_EXCLUSION Delegate* const delegate ; bool should_quit = false ; } ; void)",
    "insertText": "AddEpollEvent(EpollEventEntry& entry)"
  },
  {
    "label": "UpdateEpollEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateEpollEvent(EpollEventEntry& entry)"
  },
  {
    "label": "UnregisterInterest()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnregisterInterest(const scoped_refptr<Interest>& interest)"
  },
  {
    "label": "WaitForEpollEvent()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "WaitForEpollEvent(TimeDelta timeout)"
  },
  {
    "label": "OnEpollEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnEpollEvent(const epoll_event& e)"
  },
  {
    "label": "HandleEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleEvent(int fd, bool can_read, bool can_write, FdWatchController* controller)"
  },
  {
    "label": "HandleWakeUp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleWakeUp()"
  },
  {
    "label": "THREAD_CHECKER()",
    "kind": "Method",
    "detail": "Function (RunState* run_state_ = nullptr ; std::map<int,EpollEventEntry> entries_ ; ScopedFD epoll_ ; ScopedFD wake_event_ ;)",
    "insertText": "THREAD_CHECKER(thread_checker_)"
  }
]