[
  {
    "label": "KLU",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "KLU"
  },
  {
    "label": "klu_solve()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_KLUSUPPORT_H # define EIGEN_KLUSUPPORT_H namespace Eigen { int)",
    "insertText": "klu_solve(klu_symbolic *Symbolic, klu_numeric *Numeric, Index ldim, Index nrhs, double B [ ], klu_common *Common, double)"
  },
  {
    "label": "klu_solve()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "klu_solve(klu_symbolic *Symbolic, klu_numeric *Numeric, Index ldim, Index nrhs, std::complex<double>B[], klu_common *Common, std::complex<double>)"
  },
  {
    "label": "klu_tsolve()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "klu_tsolve(klu_symbolic *Symbolic, klu_numeric *Numeric, Index ldim, Index nrhs, double B[], klu_common *Common, double)"
  },
  {
    "label": "klu_tsolve()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "klu_tsolve(klu_symbolic *Symbolic, klu_numeric *Numeric, Index ldim, Index nrhs, std::complex<double>B[], klu_common *Common, std::complex<double>)"
  },
  {
    "label": "klu_factor()",
    "kind": "Method",
    "detail": "Function (} klu_numeric*)",
    "insertText": "klu_factor(int Ap [ ], int Ai [ ], double Ax [ ], klu_symbolic *Symbolic, klu_common *Common, double)"
  },
  {
    "label": "klu_factor()",
    "kind": "Method",
    "detail": "Function (} klu_numeric*)",
    "insertText": "klu_factor(int Ap[], int Ai[], std::complex<double> Ax[], klu_symbolic *Symbolic, klu_common *Common, std::complex<double>)"
  },
  {
    "label": "KLU()",
    "kind": "Method",
    "detail": "Function (} template<_MatrixType> class KLU : public SparseSolverBase<KLU<_MatrixType>> { protected : typedef SparseSolverBase<KLU<_MatrixType>> Base ; using Base::m_isInitialized ; public : using Base::_solve_impl ; typedef _MatrixType MatrixType ; typedef MatrixType::Scalar Scalar ; typedef MatrixType::RealScalar RealScalar ; typedef MatrixType::StorageIndex StorageIndex ; typedef Matrix<Scalar,Dynamic,1> Vector ; typedef Matrix<int,1,MatrixType::ColsAtCompileTime> IntRowVectorType ; typedef Matrix<int,MatrixType::RowsAtCompileTime,1> IntColVectorType ; typedef SparseMatrix<Scalar> LUMatrixType ; typedef SparseMatrix<Scalar,ColMajor,int> KLUMatrixType ; typedef Ref<const KLUMatrixType,StandardCompressedFormat> KLUMatrixRef ; enum { ColsAtCompileTime = MatrixType::ColsAtCompileTime,MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime } ; public :)",
    "insertText": "KLU() : m_dummy(0,0), mp_matrix(m_dummy)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init()"
  },
  {
    "label": "KLU()",
    "kind": "Method",
    "detail": "Function (} template<InputMatrixType>)",
    "insertText": "KLU(const InputMatrixType& matrix) : mp_matrix(matrix)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute(matrix)"
  },
  {
    "label": "KLU()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "KLU()"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (} EIGEN_CONSTEXPR Index)",
    "insertText": "rows()"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (} EIGEN_CONSTEXPR Index)",
    "insertText": "cols()"
  },
  {
    "label": "info()",
    "kind": "Method",
    "detail": "Function (} ComputationInfo)",
    "insertText": "info()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_isInitialized && \"Decomposition is not initialized.\")"
  },
  {
    "label": "grab()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "grab(matrix.derived())"
  },
  {
    "label": "analyzePattern_impl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "analyzePattern_impl()"
  },
  {
    "label": "factorize_impl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "factorize_impl()"
  },
  {
    "label": "analyzePattern()",
    "kind": "Method",
    "detail": "Function (} template<InputMatrixType> void)",
    "insertText": "analyzePattern(const InputMatrixType& matrix)"
  },
  {
    "label": "kluCommon()",
    "kind": "Method",
    "detail": "Function (} const klu_common&)",
    "insertText": "kluCommon()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_analysisIsOk && \"KLU: you must first call analyzePattern()\")"
  },
  {
    "label": "_solve_impl()",
    "kind": "Method",
    "detail": "Function (} template<BDerived,XDerived> bool)",
    "insertText": "_solve_impl(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x)"
  },
  {
    "label": "determinant()",
    "kind": "Method",
    "detail": "Function (# if 0 Scalar)",
    "insertText": "determinant()"
  },
  {
    "label": "extractData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "extractData()"
  },
  {
    "label": "klu_defaults()",
    "kind": "Method",
    "detail": "Function (m_info = InvalidInput ; m_isInitialized = false ; m_numeric = 0 ; m_symbolic = 0 ; m_extractedDataAreDirty = true ;)",
    "insertText": "klu_defaults(&m_common)"
  },
  {
    "label": "klu_analyze()",
    "kind": "Method",
    "detail": "Function (m_info = InvalidInput ; m_analysisIsOk = false ; m_factorizationIsOk = false ; m_symbolic =)",
    "insertText": "klu_analyze(internal::convert_index<int>(mp_matrix.rows()), const_cast<StorageIndex*>(mp_matrix.outerIndexPtr()), const_cast<StorageIndex*>(mp_matrix.innerIndexPtr()), &m_common)"
  },
  {
    "label": "klu_factor()",
    "kind": "Method",
    "detail": "Function (m_numeric =)",
    "insertText": "klu_factor(const_cast<StorageIndex*>(mp_matrix.outerIndexPtr()), const_cast<StorageIndex*>(mp_matrix.innerIndexPtr()), const_cast<Scalar*>(mp_matrix.valuePtr()), m_symbolic, &m_common, Scalar())"
  },
  {
    "label": "grab()",
    "kind": "Method",
    "detail": "Function (m_info = m_numeric ? Success : NumericalIssue ; m_factorizationIsOk = m_numeric ? 1 : 0 ; m_extractedDataAreDirty = true ; } template<MatrixDerived> void)",
    "insertText": "grab(const EigenBase<MatrixDerived> &A)"
  },
  {
    "label": "KLUMatrixRef()",
    "kind": "Method",
    "detail": "Function (mp_matrix . ~)",
    "insertText": "KLUMatrixRef()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&mp_matrix) KLUMatrixRef(A.derived())"
  },
  {
    "label": "grab()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "grab(const KLUMatrixRef &A)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&mp_matrix) KLUMatrixRef(A)"
  },
  {
    "label": "KLU()",
    "kind": "Method",
    "detail": "Function (} } # if 0 LUMatrixType m_l ; LUMatrixType m_u ; IntColVectorType m_p ; IntRowVectorType m_q ; # endif KLUMatrixType m_dummy ; KLUMatrixRef mp_matrix ; klu_numeric* m_numeric ; klu_symbolic* m_symbolic ; klu_common m_common ; ComputationInfo m_info ; int m_factorizationIsOk ; int m_analysisIsOk ; bool m_extractedDataAreDirty ; private :)",
    "insertText": "KLU(const KLU&)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(false && \"KLU: extractData Not Yet Implemented\")"
  },
  {
    "label": "umfpack_get_lunz()",
    "kind": "Method",
    "detail": "Function (int lnz,unz,rows,cols,nz_udiag ;)",
    "insertText": "umfpack_get_lunz(&lnz, &unz, &rows, &cols, &nz_udiag, m_numeric, Scalar())"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_l .)",
    "insertText": "resize(rows,(std::min)(rows,cols))"
  },
  {
    "label": "resizeNonZeros()",
    "kind": "Method",
    "detail": "Function (m_l .)",
    "insertText": "resizeNonZeros(lnz)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_u .)",
    "insertText": "resize((std::min)(rows,cols),cols)"
  },
  {
    "label": "resizeNonZeros()",
    "kind": "Method",
    "detail": "Function (m_u .)",
    "insertText": "resizeNonZeros(unz)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_p .)",
    "insertText": "resize(rows)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_q .)",
    "insertText": "resize(cols)"
  },
  {
    "label": "umfpack_get_numeric()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_get_numeric(m_l.outerIndexPtr(), m_l.innerIndexPtr(), m_l.valuePtr(), m_u.outerIndexPtr(), m_u.innerIndexPtr(), m_u.valuePtr(), m_p.data(), m_q.data(), 0, 0, 0, m_numeric)"
  },
  {
    "label": "EIGEN_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT((XDerived::Flags&RowMajorBit)==0, THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_factorizationIsOk && \"The decomposition is not in a valid state for solving, you must first call either compute() or analyzePattern()/factorize()\")"
  },
  {
    "label": "klu_solve()",
    "kind": "Method",
    "detail": "Function (x = b ; int info =)",
    "insertText": "klu_solve(m_symbolic, m_numeric, b.rows(), rhsCols, x.const_cast_derived().data(), const_cast<klu_common*>(&m_common), Scalar())"
  }
]