[
  {
    "label": "variant",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "variant"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "variant_size",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "variant_size"
  },
  {
    "label": "variant_alternative",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "variant_alternative"
  },
  {
    "label": "VariantAlternativeSfinae",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VariantAlternativeSfinae"
  },
  {
    "label": "T0",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T0"
  },
  {
    "label": "U",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "U"
  },
  {
    "label": "GiveQualsTo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GiveQualsTo"
  },
  {
    "label": "Variant",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Variant"
  },
  {
    "label": "IndexOfConstructedType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IndexOfConstructedType"
  },
  {
    "label": "VariantAccessResultImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VariantAccessResultImpl"
  },
  {
    "label": "Variantemplate",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Variantemplate"
  },
  {
    "label": "SimpleArray",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SimpleArray"
  },
  {
    "label": "AccessedType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AccessedType"
  },
  {
    "label": "Op",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Op"
  },
  {
    "label": "VisitIndicesResultImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VisitIndicesResultImpl"
  },
  {
    "label": "ReturnType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ReturnType"
  },
  {
    "label": "FunctionObject",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FunctionObject"
  },
  {
    "label": "EndIndices",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "EndIndices"
  },
  {
    "label": "BoundIndices",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BoundIndices"
  },
  {
    "label": "MakeVisitationMatrix",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MakeVisitationMatrix"
  },
  {
    "label": "AppendToIndexSequence",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AppendToIndexSequence"
  },
  {
    "label": "CurrIndices",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CurrIndices"
  },
  {
    "label": "MakeVisitationMatrixImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MakeVisitationMatrixImpl"
  },
  {
    "label": "UnreachableSwitchCase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UnreachableSwitchCase"
  },
  {
    "label": "ReachableSwitchCase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ReachableSwitchCase"
  },
  {
    "label": "PickCaseImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PickCaseImpl"
  },
  {
    "label": "NumCasesOfSwitch",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NumCasesOfSwitch"
  },
  {
    "label": "VisitIndicesSwitch",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VisitIndicesSwitch"
  },
  {
    "label": "VisitIndicesFallback",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VisitIndicesFallback"
  },
  {
    "label": "FlattenIndices",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FlattenIndices"
  },
  {
    "label": "UnflattenIndex",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UnflattenIndex"
  },
  {
    "label": "IndexSequence",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IndexSequence"
  },
  {
    "label": "VisitIndicesVariadicImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VisitIndicesVariadicImpl"
  },
  {
    "label": "FlattenedOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FlattenedOp"
  },
  {
    "label": "VisitIndicesVariadic",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VisitIndicesVariadic"
  },
  {
    "label": "VisitIndices",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VisitIndices"
  },
  {
    "label": "Self",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Self"
  },
  {
    "label": "VariantCoreAccess",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VariantCoreAccess"
  },
  {
    "label": "VariantType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VariantType"
  },
  {
    "label": "VType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VType"
  },
  {
    "label": "MoveAssignVisitor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MoveAssignVisitor"
  },
  {
    "label": "CopyAssignVisitor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CopyAssignVisitor"
  },
  {
    "label": "Left",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Left"
  },
  {
    "label": "QualifiedNew",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "QualifiedNew"
  },
  {
    "label": "ConversionAssignVisitor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ConversionAssignVisitor"
  },
  {
    "label": "LeftVariant",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LeftVariant"
  },
  {
    "label": "QualifiedRightVariant",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "QualifiedRightVariant"
  },
  {
    "label": "InitFromVisitor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "InitFromVisitor"
  },
  {
    "label": "Expected",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Expected"
  },
  {
    "label": "IndexOfImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IndexOfImpl"
  },
  {
    "label": "Head",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Head"
  },
  {
    "label": "IndexOfMeta",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IndexOfMeta"
  },
  {
    "label": "UnambiguousIndexOfImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UnambiguousIndexOfImpl"
  },
  {
    "label": "UnambiguousIndexOf",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UnambiguousIndexOf"
  },
  {
    "label": "NoMatch",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NoMatch"
  },
  {
    "label": "type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "type"
  },
  {
    "label": "H",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "H"
  },
  {
    "label": "VariantStateBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VariantStateBase"
  },
  {
    "label": "ImaginaryFun",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ImaginaryFun"
  },
  {
    "label": "IsNeitherSelfNorInPlace",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsNeitherSelfNorInPlace"
  },
  {
    "label": "ContainsVariantNPos",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ContainsVariantNPos"
  },
  {
    "label": "VisitResultImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VisitResultImpl"
  },
  {
    "label": "PerformVisitation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PerformVisitation"
  },
  {
    "label": "NoopConstructorTag",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NoopConstructorTag"
  },
  {
    "label": "EmplaceTag",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "EmplaceTag"
  },
  {
    "label": "LazyH",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LazyH"
  },
  {
    "label": "ConstructibleH",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConstructibleH"
  },
  {
    "label": "OverloadSet",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OverloadSet"
  },
  {
    "label": "VariantHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VariantHelper"
  },
  {
    "label": "CanAccept",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CanAccept"
  },
  {
    "label": "CanConvertFrom",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CanConvertFrom"
  },
  {
    "label": "TrivialMoveOnly",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TrivialMoveOnly"
  },
  {
    "label": "IsTriviallyMoveConstructible",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsTriviallyMoveConstructible"
  },
  {
    "label": "VariantStateBaseDestructorNontrivial",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VariantStateBaseDestructorNontrivial"
  },
  {
    "label": "VariantMoveBaseNontrivial",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VariantMoveBaseNontrivial"
  },
  {
    "label": "VariantCopyBaseNontrivial",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VariantCopyBaseNontrivial"
  },
  {
    "label": "VariantMoveAssignBaseNontrivial",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VariantMoveAssignBaseNontrivial"
  },
  {
    "label": "VariantCopyAssignBaseNontrivial",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VariantCopyAssignBaseNontrivial"
  },
  {
    "label": "Destroyer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Destroyer"
  },
  {
    "label": "Construct",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Construct"
  },
  {
    "label": "EqualsOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "EqualsOp"
  },
  {
    "label": "NotEqualsOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NotEqualsOp"
  },
  {
    "label": "LessThanOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LessThanOp"
  },
  {
    "label": "GreaterThanOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GreaterThanOp"
  },
  {
    "label": "LessThanOrEqualsOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LessThanOrEqualsOp"
  },
  {
    "label": "GreaterThanOrEqualsOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GreaterThanOrEqualsOp"
  },
  {
    "label": "SwapSameIndex",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SwapSameIndex"
  },
  {
    "label": "Swap",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Swap"
  },
  {
    "label": "VariantHashBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VariantHashBase"
  },
  {
    "label": "VariantHashVisitor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VariantHashVisitor"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_TYPES_INTERNAL_VARIANT_H_ # define ABSL_TYPES_INTERNAL_VARIANT_H_ # include<cassert> # include<cstddef> # include<cstdlib> # include<memory> # include<stdexcept> # include<tuple> # include<type_traits> # include \" absl / base / config . h \" # include \" absl / base / internal / identity . h \" # include \" absl / base / internal / inline_variable . h \" # include \" absl / base / internal / invoke . h \" # include \" absl / base / macros . h \" # include \" absl / base / optimization . h \" # include \" absl / meta / type_traits . h \" # include \" absl / types / bad_variant_access . h \" # include \" absl / utility / utility . h \" # if !)",
    "insertText": "defined(ABSL_USES_STD_VARIANT)"
  },
  {
    "label": "ABSL_INTERNAL_INLINE_CONSTEXPR()",
    "kind": "Method",
    "detail": "Function (ABSL_NAMESPACE_BEGIN template<class . . . Types> class variant ;)",
    "insertText": "ABSL_INTERNAL_INLINE_CONSTEXPR(size_t, variant_npos, static_cast<size_t>(-1))"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (template<class T> struct variant_size ; template<std::size_t I,class T> struct variant_alternative ; namespace variant_internal { template<std::size_t I,class T> struct VariantAlternativeSfinae { } ; template<std::size_t I,class T0,class . . . Tn> struct VariantAlternativeSfinae<I,variant<T0,Tn . . .>> : VariantAlternativeSfinae<I - 1,variant<Tn . . .>> { } ; template<class T0,class . . . Ts> struct VariantAlternativeSfinae<0,variant<T0,Ts . . .>> { using type = T0 ; } ; template<std::size_t I,class T> using VariantAlternativeSfinaeT = VariantAlternativeSfinae<I,T>::type ; template<class T,class U> struct GiveQualsTo ; template<class T,class U> struct GiveQualsTo<T&,U> { using type = U& ; } ; template<class T,class U> struct GiveQualsTo<T&&,U> { using type = U&& ; } ; template<class T,class U> struct GiveQualsTo<const T&,U> { using type = const U& ; } ; template<class T,class U> struct GiveQualsTo<const T&&,U> { using type = const U&& ; } ; template<class T,class U> struct GiveQualsTo<volatile T&,U> { using type = volatile U& ; } ; template<class T,class U> struct GiveQualsTo<volatile T&&,U> { using type = volatile U&& ; } ; template<class T,class U> struct GiveQualsTo<volatile const T&,U> { using type = volatile const U& ; } ; template<class T,class U> struct GiveQualsTo<volatile const T&&,U> { using type = volatile const U&& ; } ; template<class T,class U> using GiveQualsToT = GiveQualsTo<T,U>::type ; template<std::size_t I> using SizeT = std::integral_constant<std::size_t,I> ; using NPos = SizeT<variant_npos> ; template<class Variant,class T,class = void> struct IndexOfConstructedType { } ; template<std::size_t I,class Variant> struct VariantAccessResultImpl ; template<std::size_t I,template<class . . .> class Variantemplate,class . . . T> struct VariantAccessResultImpl<I,Variantemplate<T . . .>&> { using type = absl::variant_alternative<I,variant<T . . .>>::type& ; } ; template<std::size_t I,template<class . . .> class Variantemplate,class . . . T> struct VariantAccessResultImpl<I,const Variantemplate<T . . .>&> { using type = const absl::variant_alternative<I,variant<T . . .>>::type& ; } ; template<std::size_t I,template<class . . .> class Variantemplate,class . . . T> struct VariantAccessResultImpl<I,Variantemplate<T . . .>&&> { using type = absl::variant_alternative<I,variant<T . . .>>::type&& ; } ; template<std::size_t I,template<class . . .> class Variantemplate,class . . . T> struct VariantAccessResultImpl<I,const Variantemplate<T . . .>&&> { using type = const absl::variant_alternative<I,variant<T . . .>>::type&& ; } ; template<std::size_t I,class Variant> using VariantAccessResult = VariantAccessResultImpl<I,Variant&&>::type ; template<class T,std::size_t Size> struct SimpleArray {)",
    "insertText": "static_assert(Size != 0, \"\")"
  },
  {
    "label": "AccessSimpleArray()",
    "kind": "Method",
    "detail": "Function (T value [ Size ] ; } ; template<class T> struct AccessedType { using type = T ; } ; template<class T> using AccessedTypeT = AccessedType<T>::type ; template<class T,std::size_t Size> struct AccessedType<SimpleArray<T,Size>> { using type = AccessedTypeT<T> ; } ; template<class T> T)",
    "insertText": "AccessSimpleArray(const T& value)"
  },
  {
    "label": "Op()",
    "kind": "Method",
    "detail": "Function (} template<class T> using AlwaysZero = SizeT<0> ; template<class Op,class . . . Vs> struct VisitIndicesResultImpl { using type = absl::result_of_t<)",
    "insertText": "Op(AlwaysZero<Vs>...)"
  },
  {
    "label": "call_with_indices()",
    "kind": "Method",
    "detail": "Function (} ; template<class Op,class . . . Vs> using VisitIndicesResultT = VisitIndicesResultImpl<Op,Vs . . .>::type ; template<class ReturnType,class FunctionObject,class EndIndices,class BoundIndices> struct MakeVisitationMatrix ; template<class ReturnType,class FunctionObject,std::size_t . . . Indices> ReturnType)",
    "insertText": "call_with_indices(FunctionObject&& function)"
  },
  {
    "label": "ReturnType()",
    "kind": "Method",
    "detail": "Function (} template<class ReturnType,class FunctionObject,std::size_t . . . BoundIndices> struct MakeVisitationMatrix<ReturnType,FunctionObject,index_sequence<>,index_sequence<BoundIndices . . .>> { using ResultType =)",
    "insertText": "ReturnType(*)(FunctionObject&&)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (ResultType)",
    "insertText": "Run()"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} } ; template<Is,std::size_t J> struct AppendToIndexSequence ; template<Is,std::size_t J> using AppendToIndexSequenceT = AppendToIndexSequence<Is,J>::type ; template<std::size_t . . . Is,std::size_t J> struct AppendToIndexSequence<index_sequence<Is . . .>,J> { using type = index_sequence<Is . . .,J> ; } ; template<class ReturnType,class FunctionObject,class EndIndices,class CurrIndices,class BoundIndices> struct MakeVisitationMatrixImpl ; template<class ReturnType,class FunctionObject,class EndIndices,std::size_t . . . CurrIndices,class BoundIndices> struct MakeVisitationMatrixImpl<ReturnType,FunctionObject,EndIndices,index_sequence<CurrIndices . . .>,BoundIndices> { using ResultType = SimpleArray<MakeVisitationMatrix<ReturnType,FunctionObject,EndIndices,index_sequence<>>::ResultType,)",
    "insertText": "sizeof(CurrIndices)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (} } ; template<class ReturnType,class FunctionObject,std::size_t HeadEndIndex,std::size_t . . . TailEndIndices,std::size_t . . . BoundIndices> struct MakeVisitationMatrix<ReturnType,FunctionObject,index_sequence<HeadEndIndex,TailEndIndices . . .>,index_sequence<BoundIndices . . .>> : MakeVisitationMatrixImpl<ReturnType,FunctionObject,index_sequence<TailEndIndices . . .>,absl::make_index_sequence<HeadEndIndex>,index_sequence<BoundIndices . . .>> { } ; struct UnreachableSwitchCase { template<class Op> [ [ noreturn ] ] VisitIndicesResultT<Op,std::size_t>)",
    "insertText": "Run(Op&&)"
  },
  {
    "label": "ABSL_HAVE_BUILTIN()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "ABSL_HAVE_BUILTIN(__builtin_unreachable) || \\ (defined(__GNUC__) && !defined(__clang__)) __builtin_unreachable()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# elif)",
    "insertText": "defined(_MSC_VER) __assume(false)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "assert(false)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (# endif } } ; template<class Op,std::size_t I> struct ReachableSwitchCase { VisitIndicesResultT<Op,std::size_t>)",
    "insertText": "Run(Op&& op)"
  },
  {
    "label": "ABSL_INTERNAL_INLINE_CONSTEXPR()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "ABSL_INTERNAL_INLINE_CONSTEXPR(std::size_t, MaxUnrolledVisitCases, 33)"
  },
  {
    "label": "PickCaseImpl()",
    "kind": "Method",
    "detail": "Function (template<bool IsReachable> struct PickCaseImpl { template<class Op,std::size_t I> using Apply = UnreachableSwitchCase ; } ; template<> struct PickCaseImpl<true> { template<class Op,std::size_t I> using Apply = ReachableSwitchCase<Op,I> ; } ; template<class Op,std::size_t I,std::size_t EndIndex> using PickCase =)",
    "insertText": "PickCaseImpl(I < EndIndex)"
  },
  {
    "label": "TypedThrowBadVariantAccess()",
    "kind": "Method",
    "detail": "Function (template<class ReturnType> [ [ noreturn ] ] ReturnType)",
    "insertText": "TypedThrowBadVariantAccess()"
  },
  {
    "label": "ThrowBadVariantAccess()",
    "kind": "Method",
    "detail": "Function (absl::)",
    "insertText": "ThrowBadVariantAccess()"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} template<std::size_t . . . NumAlternatives> struct NumCasesOfSwitch ; template<std::size_t HeadNumAlternatives,std::size_t . . . TailNumAlternatives> struct NumCasesOfSwitch<HeadNumAlternatives,TailNumAlternatives . . .> { std::size_t)",
    "insertText": "value(HeadNumAlternatives + 1)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} ; template<> struct NumCasesOfSwitch<> { std::size_t value = 1 ; } ; template<std::size_t EndIndex> struct VisitIndicesSwitch {)",
    "insertText": "static_assert(EndIndex <= MaxUnrolledVisitCases, \"Maximum unrolled switch size exceeded.\")"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (template<class Op> VisitIndicesResultT<Op,std::size_t>)",
    "insertText": "Run(Op&& op, std::size_t i)"
  },
  {
    "label": "ABSL_ASSERT()",
    "kind": "Method",
    "detail": "Function (default :)",
    "insertText": "ABSL_ASSERT(i == variant_npos)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (} } } ; template<std::size_t . . . EndIndices> struct VisitIndicesFallback { template<class Op,class . . . SizeT> VisitIndicesResultT<Op,SizeT . . .>)",
    "insertText": "Run(Op&& op, SizeT... indices)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (} } ; template<std::size_t . . .> struct FlattenIndices ; template<std::size_t HeadSize,std::size_t . . . TailSize> struct FlattenIndices<HeadSize,TailSize . . .> { template<class . . . SizeType> std::size_t)",
    "insertText": "Run(std::size_t head, SizeType... tail)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} ; template<class IndexSequence,std::size_t . . . EndIndices> struct VisitIndicesVariadicImpl ; template<std::size_t . . . N,std::size_t . . . EndIndices> struct VisitIndicesVariadicImpl<absl::index_sequence<N . . .>,EndIndices . . .> { template<class Op> struct FlattenedOp { template<std::size_t I> VisitIndicesResultT<Op,)",
    "insertText": "decltype(EndIndices)...> operator()( SizeT<I>)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} Op&& op ; } ; template<class Op,class . . . SizeType> VisitIndicesResultT<Op,)",
    "insertText": "decltype(EndIndices)...> Run(Op&& op, SizeType... i)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} } ; template<std::size_t . . . EndIndices> struct VisitIndicesVariadic : VisitIndicesVariadicImpl<absl::make_index_sequence<)",
    "insertText": "sizeof(EndIndices)"
  },
  {
    "label": "conditional_t()",
    "kind": "Method",
    "detail": "Function (} ; template<std::size_t . . . EndIndices> struct VisitIndices :)",
    "insertText": "conditional_t(NumCasesOfSwitch<EndIndices...>::value <= MaxUnrolledVisitCases)"
  },
  {
    "label": "conditional_t()",
    "kind": "Method",
    "detail": "Function (} ; template<std::size_t EndIndex> struct VisitIndices<EndIndex> :)",
    "insertText": "conditional_t(EndIndex <= MaxUnrolledVisitCases)"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (} ; # ifdef _MSC_VER # pragma)",
    "insertText": "warning(push) #pragma warning(disable : 4172) #endif template <class Self, std::size_t I> inline VariantAccessResult<I, Self> AccessUnion(Self&& self, SizeT<I>)"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (} # ifdef _MSC_VER # pragma)",
    "insertText": "warning(pop) #endif template <class T> void DeducedDestroy(T& self)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (self . ~)",
    "insertText": "T()"
  },
  {
    "label": "Derived()",
    "kind": "Method",
    "detail": "Function (} struct VariantCoreAccess { template<class VariantType> VariantType::Variant&)",
    "insertText": "Derived(VariantType& self)"
  },
  {
    "label": "Derived()",
    "kind": "Method",
    "detail": "Function (} template<class VariantType> const VariantType::Variant&)",
    "insertText": "Derived(const VariantType& self)"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (} template<class VariantType> void)",
    "insertText": "Destroy(VariantType& self)"
  },
  {
    "label": "Derived()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Derived(self).destroy()"
  },
  {
    "label": "SetIndex()",
    "kind": "Method",
    "detail": "Function (self . index_ = absl::variant_npos ; } template<class Variant> void)",
    "insertText": "SetIndex(Variant& self, std::size_t i)"
  },
  {
    "label": "InitFrom()",
    "kind": "Method",
    "detail": "Function (self . index_ = i ; } template<class Variant> void)",
    "insertText": "InitFrom(Variant& self, Variant&& other)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (VisitIndices<absl::variant_size<Variant>::value)",
    "insertText": "Run(InitFromVisitor<Variant, Variant&&>{&self, std::forward<Variant>(other)}, other.index())"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (self . index_ = other .)",
    "insertText": "index()"
  },
  {
    "label": "Access()",
    "kind": "Method",
    "detail": "Function (} template<std::size_t I,class Variant> VariantAccessResult<I,Variant>)",
    "insertText": "Access(Variant&& self)"
  },
  {
    "label": "CheckedAccess()",
    "kind": "Method",
    "detail": "Function (} template<std::size_t I,class Variant> VariantAccessResult<I,Variant>)",
    "insertText": "CheckedAccess(Variant&& self)"
  },
  {
    "label": "Variant()",
    "kind": "Method",
    "detail": "Function (TypedThrowBadVariantAccess<VariantAccessResult<I,)",
    "insertText": "Variant()"
  },
  {
    "label": "I()",
    "kind": "Method",
    "detail": "Function (} return Access<)",
    "insertText": "I(absl::forward<Variant>(self))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class VType> struct MoveAssignVisitor { using DerivedType = VType::Variant ; template<std::size_t NewIndex> void)",
    "insertText": "operator()(SizeT<NewIndex>)"
  },
  {
    "label": "NewIndex()",
    "kind": "Method",
    "detail": "Function (Access<)",
    "insertText": "NewIndex(*left) = std::move(Access<NewIndex>(*right))"
  },
  {
    "label": "Derived()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "Derived(*left).template emplace<NewIndex>( std::move(Access<NewIndex>(*right)))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "operator()(SizeT<absl::variant_npos>)"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destroy(*left)"
  },
  {
    "label": "MakeMoveAssignVisitor()",
    "kind": "Method",
    "detail": "Function (} VType* left ; VType* right ; } ; template<class VType> MoveAssignVisitor<VType>)",
    "insertText": "MakeMoveAssignVisitor(VType* left, VType* other)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using New = absl::variant_alternative<NewIndex,DerivedType>::type ;)",
    "insertText": "if(left->index_ == NewIndex)"
  },
  {
    "label": "NewIndex()",
    "kind": "Method",
    "detail": "Function (Access<)",
    "insertText": "NewIndex(*left) = Access<NewIndex>(*right)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(std::is_nothrow_copy_constructible<New>::value || !std::is_nothrow_move_constructible<New>::value)"
  },
  {
    "label": "Derived()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Derived(*left).template emplace<NewIndex>(Access<NewIndex>(*right))"
  },
  {
    "label": "Derived()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "Derived(*left) = DerivedType(Derived(*right))"
  },
  {
    "label": "MakeCopyAssignVisitor()",
    "kind": "Method",
    "detail": "Function (} VType* left ; const VType* right ; } ; template<class VType> CopyAssignVisitor<VType>)",
    "insertText": "MakeCopyAssignVisitor(VType* left, const VType& other)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (Access<)",
    "insertText": "value(*left) = absl::forward<QualifiedNew>(other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<std::size_t OldIndex> void)",
    "insertText": "operator()(SizeT<OldIndex>)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using New = absl::variant_alternative<NewIndex::value,Left>::type ;)",
    "insertText": "if(std::is_nothrow_constructible<New, QualifiedNew>::value || !std::is_nothrow_move_constructible<New>::value)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (left -> template emplace<)",
    "insertText": "value(absl::forward<QualifiedNew>(other))"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} else { left -> template emplace<)",
    "insertText": "value(New(absl::forward<QualifiedNew>(other)))"
  },
  {
    "label": "MakeConversionAssignVisitor()",
    "kind": "Method",
    "detail": "Function (} } Left* left ; QualifiedNew&& other ; } ; template<class Left,class QualifiedNew> ConversionAssignVisitor<Left,QualifiedNew>)",
    "insertText": "MakeConversionAssignVisitor(Left* left, QualifiedNew&& qual)"
  },
  {
    "label": "Replace()",
    "kind": "Method",
    "detail": "Function (} template<std::size_t NewIndex,class Self,class . . . Args> absl::variant_alternative<NewIndex,Self>::type&)",
    "insertText": "Replace(Self* self, Args&&... args)"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destroy(*self)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (using New = absl::variant_alternative<NewIndex,Self>::type ; New* const result)",
    "insertText": "new(static_cast<void*>(&self->state_)) New(absl::forward<Args>(args)...)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (using Alternative = variant_alternative<NewIndex,LeftVariant>::type)",
    "insertText": "new(static_cast<void*>(&left->state_)) Alternative( Access<NewIndex>(std::forward<QualifiedRightVariant>(right)))"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} LeftVariant* left ; QualifiedRightVariant&& right ; } ; } ; template<class Expected,class . . . T> struct IndexOfImpl ; template<class Expected> struct IndexOfImpl<Expected> { using IndexFromEnd = SizeT<0> ; using MatchedIndexFromEnd = IndexFromEnd ; using MultipleMatches = std::false_type ; } ; template<class Expected,class Head,class . . . Tail> struct IndexOfImpl<Expected,Head,Tail . . .> : IndexOfImpl<Expected,Tail . . .> { using IndexFromEnd = SizeT<IndexOfImpl<Expected,Tail . . .>::IndexFromEnd::value + 1> ; } ; template<class Expected,class . . . Tail> struct IndexOfImpl<Expected,Expected,Tail . . .> : IndexOfImpl<Expected,Tail . . .> { using IndexFromEnd = SizeT<IndexOfImpl<Expected,Tail . . .>::IndexFromEnd::value + 1> ; using MatchedIndexFromEnd = IndexFromEnd ; using MultipleMatches = std::integral_constant<bool,IndexOfImpl<Expected,Tail . . .>::MatchedIndexFromEnd::value ! = 0> ; } ; template<class Expected,class . . . Types> struct IndexOfMeta { using Results = IndexOfImpl<Expected,Types . . .> ;)",
    "insertText": "static_assert(!Results::MultipleMatches::value, \"Attempted to access a variant by specifying a type that \" \"matches more than one alternative.\")"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (using type = SizeT<)",
    "insertText": "sizeof(Types)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} ; template<class Expected,class . . . Types> using IndexOf = IndexOfMeta<Expected,Types . . .>::type ; template<class Variant,class T,std::size_t CurrIndex> struct UnambiguousIndexOfImpl ; template<class T,std::size_t CurrIndex> struct UnambiguousIndexOfImpl<variant<>,T,CurrIndex> : SizeT<CurrIndex> { } ; template<class Head,class . . . Tail,class T,std::size_t CurrIndex> struct UnambiguousIndexOfImpl<variant<Head,Tail . . .>,T,CurrIndex> : UnambiguousIndexOfImpl<variant<Tail . . .>,T,CurrIndex + 1>::type { } ; template<class Head,class . . . Tail,std::size_t CurrIndex> struct UnambiguousIndexOfImpl<variant<Head,Tail . . .>,Head,CurrIndex> : SizeT<UnambiguousIndexOfImpl<variant<Tail . . .>,Head,0>::value = =)",
    "insertText": "sizeof(Tail) ? CurrIndex : CurrIndex + sizeof...(Tail)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} ; template<class Variant,class T> struct UnambiguousIndexOf ; struct NoMatch { struct type { } ; } ; template<class . . . Alts,class T> struct UnambiguousIndexOf<variant<Alts . . .>,T> : std::conditional<UnambiguousIndexOfImpl<variant<Alts . . .>,T,0>::value ! =)",
    "insertText": "sizeof(Alts)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (} ; template<class H,class . . . T,std::size_t I> struct ImaginaryFun<variant<H,T . . .>,I> : ImaginaryFun<variant<T . . .>,I + 1> { using ImaginaryFun<variant<T . . .>,I + 1>::Run ; SizeT<I>)",
    "insertText": "Run(const H&, SizeT<I>)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (SizeT<I>)",
    "insertText": "Run(H&&, SizeT<I>)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} ; template<class Self,class T> struct IsNeitherSelfNorInPlace : std::true_type { } ; template<class Self> struct IsNeitherSelfNorInPlace<Self,Self> : std::false_type { } ; template<class Self,class T> struct IsNeitherSelfNorInPlace<Self,in_place_type_t<T>> : std::false_type { } ; template<class Self,std::size_t I> struct IsNeitherSelfNorInPlace<Self,in_place_index_t<I>> : std::false_type { } ; template<class Variant,class T> struct IndexOfConstructedType<Variant,T,void_t<)",
    "insertText": "decltype(ImaginaryFun<Variant>::Run(std::declval<T>(), {}))>> : decltype(ImaginaryFun<Variant>::Run(std::declval<T>(), {}))"
  },
  {
    "label": "Op()",
    "kind": "Method",
    "detail": "Function (} ; template<std::size_t . . . Is> struct ContainsVariantNPos : absl::negation<std::is_same<absl::integer_sequence<bool,0<= Is . . .>,absl::integer_sequence<bool,Is ! = absl::variant_npos . . .>>> { } ; template<class Op,class . . . QualifiedVariants> using RawVisitResult = absl::result_of_t<)",
    "insertText": "Op(VariantAccessResult<0, QualifiedVariants>...)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<class Op,class . . . QualifiedVariants> using VisitResult = VisitResultImpl<Op,QualifiedVariants . . .>::type ; template<class Op,class . . . QualifiedVariants> struct PerformVisitation { using ReturnType = VisitResult<Op,QualifiedVariants . . .> ; template<std::size_t . . . Is> ReturnType)",
    "insertText": "operator()(SizeT<Is>... indices)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (} template<std::size_t . . . TupIs,std::size_t . . . Is> ReturnType)",
    "insertText": "Run(std::false_type , index_sequence<TupIs...>, SizeT<Is>...)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (} template<std::size_t . . . TupIs,std::size_t . . . Is> [ [ noreturn ] ] ReturnType)",
    "insertText": "Run(std::true_type , index_sequence<TupIs...>, SizeT<Is>...)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (} std::tuple<QualifiedVariants&& . . .> variant_tup ; Op&& op ; } ; template<class . . . T> union Union ; struct NoopConstructorTag { } ; template<std::size_t I> struct EmplaceTag { } ; template<> union Union<> {)",
    "insertText": "Union(NoopConstructorTag)"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (} } ; # ifdef _MSC_VER # pragma)",
    "insertText": "warning(push) #pragma warning(disable : 4624)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (using TailUnion = Union<Tail . . .> ;)",
    "insertText": "Union(NoopConstructorTag ) noexcept : tail(NoopConstructorTag())"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (} template<class . . . P>)",
    "insertText": "Union(EmplaceTag<0>, P&&... args) : head(absl::forward<P>(args)...)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (} template<std::size_t I,class . . . P>)",
    "insertText": "Union(EmplaceTag<I>, P&&... args) : tail(EmplaceTag<I - 1>{}, absl::forward<P>(args)...)"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (} Head head ; TailUnion tail ; } ; # ifdef _MSC_VER # pragma)",
    "insertText": "warning(pop)"
  },
  {
    "label": "DestructibleUnionImpl()",
    "kind": "Method",
    "detail": "Function (template<> union DestructibleUnionImpl<> {)",
    "insertText": "DestructibleUnionImpl(NoopConstructorTag)"
  },
  {
    "label": "DestructibleUnionImpl()",
    "kind": "Method",
    "detail": "Function (} } ; template<class Head,class . . . Tail> union DestructibleUnionImpl<Head,Tail . . .> { using TailUnion = DestructibleUnionImpl<Tail . . .> ;)",
    "insertText": "DestructibleUnionImpl(NoopConstructorTag ) noexcept : tail(NoopConstructorTag())"
  },
  {
    "label": "DestructibleUnionImpl()",
    "kind": "Method",
    "detail": "Function (} template<class . . . P>)",
    "insertText": "DestructibleUnionImpl(EmplaceTag<0>, P&&... args) : head(absl::forward<P>(args)...)"
  },
  {
    "label": "DestructibleUnionImpl()",
    "kind": "Method",
    "detail": "Function (} template<std::size_t I,class . . . P>)",
    "insertText": "DestructibleUnionImpl(EmplaceTag<I>, P&&... args) : tail(EmplaceTag<I - 1>{}, absl::forward<P>(args)...)"
  },
  {
    "label": "DestructibleUnionImpl()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "DestructibleUnionImpl()"
  },
  {
    "label": "VariantStateBase()",
    "kind": "Method",
    "detail": "Function (} Head head ; TailUnion tail ; } ; template<class . . . T> using DestructibleUnion = absl::conditional_t<std::is_destructible<Union<T . . .>>::value,Union<T . . .>,DestructibleUnionImpl<T . . .>> ; template<class H,class . . . T> class VariantStateBase { protected : using Variant = variant<H,T . . .> ; template<class LazyH = H,class ConstructibleH = absl::enable_if_t<std::is_default_constructible<LazyH>::value,LazyH>>)",
    "insertText": "VariantStateBase() noexcept( std::is_nothrow_default_constructible<ConstructibleH>::value) : state_(EmplaceTag<0>()), index_(0)"
  },
  {
    "label": "VariantStateBase()",
    "kind": "Method",
    "detail": "Function (} template<std::size_t I,class . . . P>)",
    "insertText": "VariantStateBase(EmplaceTag<I> tag, P&&... args) : state_(tag, absl::forward<P>(args)...), index_(I)"
  },
  {
    "label": "VariantStateBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VariantStateBase(NoopConstructorTag) : state_(NoopConstructorTag()), index_(variant_npos)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "destroy()"
  },
  {
    "label": "Overload()",
    "kind": "Method",
    "detail": "Function (} DestructibleUnion<H,T . . .> state_ ; std::size_t index_ ; } ; using absl::internal::identity ; template<. . . Ts> struct OverloadSet ; template<T,. . . Ts> struct OverloadSet<T,Ts . . .> : OverloadSet<Ts . . .> { using Base = OverloadSet<Ts . . .> ; identity<T>)",
    "insertText": "Overload(const T&)"
  },
  {
    "label": "Overload()",
    "kind": "Method",
    "detail": "Function (using Base::Overload ; } ; template<> struct OverloadSet<> { void)",
    "insertText": "Overload(...)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} ; template<class T> using LessThanResult =)",
    "insertText": "decltype(std::declval<T>() < std::declval<T>())"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (template<class T> using GreaterThanResult =)",
    "insertText": "decltype(std::declval<T>() > std::declval<T>())"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (template<class T> using LessThanOrEqualResult =)",
    "insertText": "decltype(std::declval<T>() <= std::declval<T>())"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (template<class T> using GreaterThanOrEqualResult =)",
    "insertText": "decltype(std::declval<T>() >= std::declval<T>())"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (template<class T> using EqualResult =)",
    "insertText": "decltype(std::declval<T>() == std::declval<T>())"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (template<class T> using NotEqualResult =)",
    "insertText": "decltype(std::declval<T>() != std::declval<T>())"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (using type_traits_internal::is_detected_convertible ; template<class . . . T> using RequireAllHaveEqualT = absl::enable_if_t<absl::conjunction<is_detected_convertible<bool,EqualResult,T> . . .>::value,bool> ; template<class . . . T> using RequireAllHaveNotEqualT = absl::enable_if_t<absl::conjunction<is_detected_convertible<bool,NotEqualResult,T> . . .>::value,bool> ; template<class . . . T> using RequireAllHaveLessThanT = absl::enable_if_t<absl::conjunction<is_detected_convertible<bool,LessThanResult,T> . . .>::value,bool> ; template<class . . . T> using RequireAllHaveLessThanOrEqualT = absl::enable_if_t<absl::conjunction<is_detected_convertible<bool,LessThanOrEqualResult,T> . . .>::value,bool> ; template<class . . . T> using RequireAllHaveGreaterThanOrEqualT = absl::enable_if_t<absl::conjunction<is_detected_convertible<bool,GreaterThanOrEqualResult,T> . . .>::value,bool> ; template<class . . . T> using RequireAllHaveGreaterThanT = absl::enable_if_t<absl::conjunction<is_detected_convertible<bool,GreaterThanResult,T> . . .>::value,bool> ; template<T> struct VariantHelper ; template<. . . Ts> struct VariantHelper<variant<Ts . . .>> { template<U> using BestMatch =)",
    "insertText": "decltype(variant_internal::OverloadSet<Ts...>::Overload( std::declval<U>()))"
  },
  {
    "label": "TrivialMoveOnly()",
    "kind": "Method",
    "detail": "Function (template<U> struct CanAccept : std::integral_constant<bool,! std::is_void<BestMatch<U>>::value> { } ; template<Other> struct CanConvertFrom ; template<. . . Us> struct CanConvertFrom<variant<Us . . .>> : public absl::conjunction<CanAccept<Us> . . .> { } ; } ; struct TrivialMoveOnly {)",
    "insertText": "TrivialMoveOnly(TrivialMoveOnly&&)"
  },
  {
    "label": "VariantStateBaseDestructorNontrivial()",
    "kind": "Method",
    "detail": "Function (} ; template<T> struct IsTriviallyMoveConstructible : std::is_move_constructible<Union<T,TrivialMoveOnly>> { } ; template<class . . . T> class VariantStateBaseDestructorNontrivial ; template<class . . . T> class VariantMoveBaseNontrivial ; template<class . . . T> class VariantCopyBaseNontrivial ; template<class . . . T> class VariantMoveAssignBaseNontrivial ; template<class . . . T> class VariantCopyAssignBaseNontrivial ; template<class . . . T> using VariantStateBaseDestructor = absl::conditional_t<std::is_destructible<Union<T . . .>>::value,VariantStateBase<T . . .>,VariantStateBaseDestructorNontrivial<T . . .>> ; template<class . . . T> using VariantMoveBase = absl::conditional_t<absl::disjunction<absl::negation<absl::conjunction<std::is_move_constructible<T> . . .>>,absl::conjunction<IsTriviallyMoveConstructible<T> . . .>>::value,VariantStateBaseDestructor<T . . .>,VariantMoveBaseNontrivial<T . . .>> ; template<class . . . T> using VariantCopyBase = absl::conditional_t<absl::disjunction<absl::negation<absl::conjunction<std::is_copy_constructible<T> . . .>>,std::is_copy_constructible<Union<T . . .>>>::value,VariantMoveBase<T . . .>,VariantCopyBaseNontrivial<T . . .>> ; template<class . . . T> using VariantMoveAssignBase = absl::conditional_t<absl::disjunction<absl::conjunction<absl::is_move_assignable<Union<T . . .>>,std::is_move_constructible<Union<T . . .>>,std::is_destructible<Union<T . . .>>>,absl::negation<absl::conjunction<std::is_move_constructible<T> . . .,is_move_assignable<T> . . .>>>::value,VariantCopyBase<T . . .>,VariantMoveAssignBaseNontrivial<T . . .>> ; template<class . . . T> using VariantCopyAssignBase = absl::conditional_t<absl::disjunction<absl::conjunction<absl::is_copy_assignable<Union<T . . .>>,std::is_copy_constructible<Union<T . . .>>,std::is_destructible<Union<T . . .>>>,absl::negation<absl::conjunction<std::is_copy_constructible<T> . . .,is_copy_assignable<T> . . .>>>::value,VariantMoveAssignBase<T . . .>,VariantCopyAssignBaseNontrivial<T . . .>> ; template<class . . . T> using VariantBase = VariantCopyAssignBase<T . . .> ; template<class . . . T> class VariantStateBaseDestructorNontrivial : protected VariantStateBase<T . . .> { private : using Base = VariantStateBase<T . . .> ; protected : using Base::Base ;)",
    "insertText": "VariantStateBaseDestructorNontrivial()"
  },
  {
    "label": "VariantStateBaseDestructorNontrivial()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VariantStateBaseDestructorNontrivial(VariantStateBaseDestructorNontrivial&&)"
  },
  {
    "label": "VariantStateBaseDestructorNontrivial()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VariantStateBaseDestructorNontrivial(const VariantStateBaseDestructorNontrivial&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (VariantStateBaseDestructorNontrivial&)",
    "insertText": "operator(VariantStateBaseDestructorNontrivial&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (VariantStateBaseDestructorNontrivial&)",
    "insertText": "operator(const VariantStateBaseDestructorNontrivial&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (struct Destroyer { template<std::size_t I> void)",
    "insertText": "operator()(SizeT<I> i)"
  },
  {
    "label": "AccessUnion()",
    "kind": "Method",
    "detail": "Function (using Alternative = absl::variant_alternative<I,variant<T . . .>>::type ;)",
    "insertText": "AccessUnion(self->state_, i).~Alternative()"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (VisitIndices<)",
    "insertText": "sizeof(T)>::Run(Destroyer{this}, index_)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (using Alternative = absl::variant_alternative<I,variant<T . . .>>::type)",
    "insertText": "new(static_cast<void*>(&self->state_)) Alternative( variant_internal::AccessUnion(absl::move(other->state_), i))"
  },
  {
    "label": "VariantMoveBaseNontrivial()",
    "kind": "Method",
    "detail": "Function (} VariantMoveBaseNontrivial* self ; VariantMoveBaseNontrivial* other ; } ;)",
    "insertText": "VariantMoveBaseNontrivial()"
  },
  {
    "label": "VariantMoveBaseNontrivial()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VariantMoveBaseNontrivial(VariantMoveBaseNontrivial&& other) noexcept( absl::conjunction<std::is_nothrow_move_constructible<T>...>::value) : Base(NoopConstructorTag())"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (VisitIndices<)",
    "insertText": "sizeof(T)>::Run(Construct{this, &other}, other.index_)"
  },
  {
    "label": "VariantMoveBaseNontrivial()",
    "kind": "Method",
    "detail": "Function (index_ = other . index_ ; })",
    "insertText": "VariantMoveBaseNontrivial(VariantMoveBaseNontrivial const&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (VariantMoveBaseNontrivial&)",
    "insertText": "operator(VariantMoveBaseNontrivial&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (VariantMoveBaseNontrivial&)",
    "insertText": "operator(VariantMoveBaseNontrivial const&)"
  },
  {
    "label": "VariantCopyBaseNontrivial()",
    "kind": "Method",
    "detail": "Function (protected : using Base::index_ ; using Base::state_ ; } ; template<class . . . T> class VariantCopyBaseNontrivial : protected VariantMoveBase<T . . .> { private : using Base = VariantMoveBase<T . . .> ; protected : using Base::Base ;)",
    "insertText": "VariantCopyBaseNontrivial()"
  },
  {
    "label": "VariantCopyBaseNontrivial()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VariantCopyBaseNontrivial(VariantCopyBaseNontrivial&&)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (using Alternative = absl::variant_alternative<I,variant<T . . .>>::type)",
    "insertText": "new(static_cast<void*>(&self->state_)) Alternative(variant_internal::AccessUnion(other->state_, i))"
  },
  {
    "label": "VariantCopyBaseNontrivial()",
    "kind": "Method",
    "detail": "Function (} VariantCopyBaseNontrivial* self ; const VariantCopyBaseNontrivial* other ; } ;)",
    "insertText": "VariantCopyBaseNontrivial(VariantCopyBaseNontrivial const& other) : Base(NoopConstructorTag())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (index_ = other . index_ ; } VariantCopyBaseNontrivial&)",
    "insertText": "operator(VariantCopyBaseNontrivial&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (VariantCopyBaseNontrivial&)",
    "insertText": "operator(VariantCopyBaseNontrivial const&)"
  },
  {
    "label": "VariantMoveAssignBaseNontrivial()",
    "kind": "Method",
    "detail": "Function (protected : using Base::index_ ; using Base::state_ ; } ; template<class . . . T> class VariantMoveAssignBaseNontrivial : protected VariantCopyBase<T . . .> { struct VariantCoreAccess ; private : using Base = VariantCopyBase<T . . .> ; protected : using Base::Base ;)",
    "insertText": "VariantMoveAssignBaseNontrivial()"
  },
  {
    "label": "VariantMoveAssignBaseNontrivial()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VariantMoveAssignBaseNontrivial(VariantMoveAssignBaseNontrivial&&)"
  },
  {
    "label": "VariantMoveAssignBaseNontrivial()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VariantMoveAssignBaseNontrivial(const VariantMoveAssignBaseNontrivial&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (VariantMoveAssignBaseNontrivial&)",
    "insertText": "operator(VariantMoveAssignBaseNontrivial const&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (VariantMoveAssignBaseNontrivial&)",
    "insertText": "operator(VariantMoveAssignBaseNontrivial&& other) noexcept( absl::conjunction<std::is_nothrow_move_constructible<T>..., std::is_nothrow_move_assignable<T>...>::value)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (VisitIndices<)",
    "insertText": "sizeof(T)>::Run( VariantCoreAccess::MakeMoveAssignVisitor(this, &other), other.index_)"
  },
  {
    "label": "VariantCopyAssignBaseNontrivial()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VariantCopyAssignBaseNontrivial(VariantCopyAssignBaseNontrivial&&)"
  },
  {
    "label": "VariantCopyAssignBaseNontrivial()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VariantCopyAssignBaseNontrivial(const VariantCopyAssignBaseNontrivial&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (VariantCopyAssignBaseNontrivial&)",
    "insertText": "operator(VariantCopyAssignBaseNontrivial&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (VariantCopyAssignBaseNontrivial&)",
    "insertText": "operator(const VariantCopyAssignBaseNontrivial& other)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (VisitIndices<)",
    "insertText": "sizeof(T)>::Run( VariantCoreAccess::MakeCopyAssignVisitor(this, other), other.index_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<class . . . Types> struct SwapSameIndex { variant<Types . . .>* v ; variant<Types . . .>* w ; template<std::size_t I> void)",
    "insertText": "operator()(SizeT<I>)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(VariantCoreAccess::Access<I>(*v), VariantCoreAccess::Access<I>(*w))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()(SizeT<variant_npos>)"
  },
  {
    "label": "generic_swap()",
    "kind": "Method",
    "detail": "Function (} } ; template<class . . . Types> struct Swap { variant<Types . . .>* v ; variant<Types . . .>* w ; void)",
    "insertText": "generic_swap()"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (variant<Types . . .>)",
    "insertText": "tmp(std::move(*w))"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destroy(*w)"
  },
  {
    "label": "InitFrom()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitFrom(*w, std::move(*v))"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destroy(*v)"
  },
  {
    "label": "InitFrom()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitFrom(*v, std::move(tmp))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } template<std::size_t Wi> void)",
    "insertText": "operator()(SizeT<Wi>)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (VisitIndices<)",
    "insertText": "sizeof(Types)>::Run(SwapSameIndex<Types...>{v, w}, Wi)"
  },
  {
    "label": "VariantHashBase()",
    "kind": "Method",
    "detail": "Function (} } } ; template<Variant,= void,. . . Ts> struct VariantHashBase {)",
    "insertText": "VariantHashBase()"
  },
  {
    "label": "VariantHashBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VariantHashBase(const VariantHashBase&)"
  },
  {
    "label": "VariantHashBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VariantHashBase(VariantHashBase&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (VariantHashBase&)",
    "insertText": "operator(const VariantHashBase&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (VariantHashBase&)",
    "insertText": "operator(VariantHashBase&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; struct VariantHashVisitor { template<T> size_t)",
    "insertText": "operator()(const T& t)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<Variant,. . . Ts> struct VariantHashBase<Variant,absl::enable_if_t<absl::conjunction<type_traits_internal::IsHashable<Ts> . . .>::value>,Ts . . .> { using argument_type = Variant ; using result_type = size_t ; size_t)",
    "insertText": "operator()(const Variant& var)"
  },
  {
    "label": "Ts()",
    "kind": "Method",
    "detail": "Function (type_traits_internal::AssertHashEnabled<)",
    "insertText": "Ts()"
  }
]