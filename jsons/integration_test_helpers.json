[
  {
    "label": "TaskQueueMetronome",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TaskQueueMetronome"
  },
  {
    "label": "SignalingMessageReceiver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SignalingMessageReceiver"
  },
  {
    "label": "MockRtpReceiverObserver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MockRtpReceiverObserver"
  },
  {
    "label": "PeerConnectionIntegrationWrapper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PeerConnectionIntegrationWrapper"
  },
  {
    "label": "PeerConnectionIntegrationBaseTest",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PeerConnectionIntegrationBaseTest"
  },
  {
    "label": "MockRtcEventLogOutput",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MockRtcEventLogOutput"
  },
  {
    "label": "MediaExpectations",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MediaExpectations"
  },
  {
    "label": "ExpectFrames",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ExpectFrames"
  },
  {
    "label": "MockIceTransport",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MockIceTransport"
  },
  {
    "label": "MockIceTransportFactory",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MockIceTransportFactory"
  },
  {
    "label": "kDefaultLocalAddress()",
    "kind": "Method",
    "detail": "Function (# ifndef PC_TEST_INTEGRATION_TEST_HELPERS_H_ # define PC_TEST_INTEGRATION_TEST_HELPERS_H_ # include<limits . h> # include<stdint . h> # include<stdio . h> # include<algorithm> # include<functional> # include<limits> # include<list> # include<map> # include<memory> # include<set> # include<string> # include<utility> # include<vector> # include \" absl / algorithm / container . h \" # include \" absl / memory / memory . h \" # include \" absl / strings / string_view . h \" # include \" absl / types / optional . h \" # include \" api / audio_options . h \" # include \" api / call / call_factory_interface . h \" # include \" api / candidate . h \" # include \" api / crypto / crypto_options . h \" # include \" api / data_channel_interface . h \" # include \" api / field_trials_view . h \" # include \" api / ice_transport_interface . h \" # include \" api / jsep . h \" # include \" api / media_stream_interface . h \" # include \" api / media_types . h \" # include \" api / peer_connection_interface . h \" # include \" api / rtc_error . h \" # include \" api / rtc_event_log / rtc_event_log_factory . h \" # include \" api / rtc_event_log / rtc_event_log_factory_interface . h \" # include \" api / rtc_event_log_output . h \" # include \" api / rtp_receiver_interface . h \" # include \" api / rtp_sender_interface . h \" # include \" api / rtp_transceiver_interface . h \" # include \" api / scoped_refptr . h \" # include \" api / stats / rtc_stats . h \" # include \" api / stats / rtc_stats_report . h \" # include \" api / stats / rtcstats_objects . h \" # include \" api / task_queue / default_task_queue_factory . h \" # include \" api / task_queue / pending_task_safety_flag . h \" # include \" api / task_queue / task_queue_factory . h \" # include \" api / transport / field_trial_based_config . h \" # include \" api / uma_metrics . h \" # include \" api / units / time_delta . h \" # include \" api / video / video_rotation . h \" # include \" api / video_codecs / sdp_video_format . h \" # include \" api / video_codecs / video_decoder_factory . h \" # include \" api / video_codecs / video_encoder_factory . h \" # include \" call / call . h \" # include \" logging / rtc_event_log / fake_rtc_event_log_factory . h \" # include \" media / base / media_engine . h \" # include \" media / base / stream_params . h \" # include \" media / engine / fake_webrtc_video_engine . h \" # include \" media / engine / webrtc_media_engine . h \" # include \" media / engine / webrtc_media_engine_defaults . h \" # include \" modules / audio_device / include / audio_device . h \" # include \" modules / audio_processing / include / audio_processing . h \" # include \" modules / audio_processing / test / audio_processing_builder_for_testing . h \" # include \" p2p / base / fake_ice_transport . h \" # include \" p2p / base / ice_transport_internal . h \" # include \" p2p / base / mock_async_resolver . h \" # include \" p2p / base / p2p_constants . h \" # include \" p2p / base / port . h \" # include \" p2p / base / port_allocator . h \" # include \" p2p / base / port_interface . h \" # include \" p2p / base / test_stun_server . h \" # include \" p2p / base / test_turn_customizer . h \" # include \" p2p / base / test_turn_server . h \" # include \" p2p / client / basic_port_allocator . h \" # include \" pc / dtmf_sender . h \" # include \" pc / local_audio_source . h \" # include \" pc / media_session . h \" # include \" pc / peer_connection . h \" # include \" pc / peer_connection_factory . h \" # include \" pc / peer_connection_proxy . h \" # include \" pc / rtp_media_utils . h \" # include \" pc / session_description . h \" # include \" pc / test / fake_audio_capture_module . h \" # include \" pc / test / fake_periodic_video_source . h \" # include \" pc / test / fake_periodic_video_track_source . h \" # include \" pc / test / fake_rtc_certificate_generator . h \" # include \" pc / test / fake_video_track_renderer . h \" # include \" pc / test / mock_peer_connection_observers . h \" # include \" pc / video_track_source . h \" # include \" rtc_base / checks . h \" # include \" rtc_base / event . h \" # include \" rtc_base / fake_clock . h \" # include \" rtc_base / fake_mdns_responder . h \" # include \" rtc_base / fake_network . h \" # include \" rtc_base / firewall_socket_server . h \" # include \" rtc_base / gunit . h \" # include \" rtc_base / helpers . h \" # include \" rtc_base / ip_address . h \" # include \" rtc_base / logging . h \" # include \" rtc_base / mdns_responder_interface . h \" # include \" rtc_base / numerics / safe_conversions . h \" # include \" rtc_base / rtc_certificate_generator . h \" # include \" rtc_base / socket_address . h \" # include \" rtc_base / ssl_stream_adapter . h \" # include \" rtc_base / task_queue_for_test . h \" # include \" rtc_base / task_utils / repeating_task . h \" # include \" rtc_base / test_certificate_verifier . h \" # include \" rtc_base / thread . h \" # include \" rtc_base / thread_annotations . h \" # include \" rtc_base / time_utils . h \" # include \" rtc_base / virtual_socket_server . h \" # include \" system_wrappers / include / metrics . h \" # include \" test / gmock . h \" # include \" test / scoped_key_value_config . h \" namespace webrtc { using::cricket::ContentInfo ; using::cricket::StreamParams ; using::rtc::SocketAddress ; using::testing::_ ; using::testing::Combine ; using::testing::Contains ; using::testing::DoAll ; using::testing::ElementsAre ; using::testing::NiceMock ; using::testing::Return ; using::testing::SetArgPointee ; using::testing::UnorderedElementsAreArray ; using::testing::Values ; using RTCConfiguration = PeerConnectionInterface::RTCConfiguration ; const int kDefaultTimeout = 1 0 0 0 0 ; const int kMaxWaitForStatsMs = 3 0 0 0 ; const int kMaxWaitForActivationMs = 5 0 0 0 ; const int kMaxWaitForFramesMs = 1 0 0 0 0 ; const int kDefaultExpectedAudioFrameCount = 3 ; const int kDefaultExpectedVideoFrameCount = 3 ; const char kDataChannelLabel [ ] = \" data_channel \" ; const int kDefaultSrtpCryptoSuite = rtc::kSrtpAes128CmSha1_80 ; const int kDefaultSrtpCryptoSuiteGcm = rtc::kSrtpAeadAes256Gcm ; const SocketAddress)",
    "insertText": "kDefaultLocalAddress(\"192.168.1.1\", 0)"
  },
  {
    "label": "IceRestartOfferAnswerOptions()",
    "kind": "Method",
    "detail": "Function (PeerConnectionInterface::RTCOfferAnswerOptions)",
    "insertText": "IceRestartOfferAnswerOptions()"
  },
  {
    "label": "RemoveSsrcsAndMsids()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveSsrcsAndMsids(cricket::SessionDescription* desc)"
  },
  {
    "label": "RemoveSsrcsAndKeepMsids()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveSsrcsAndKeepMsids(cricket::SessionDescription* desc)"
  },
  {
    "label": "FindFirstMediaStatsIndexByKind()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "FindFirstMediaStatsIndexByKind(const std::string& kind, const std::vector<const webrtc::DEPRECATED_RTCMediaStreamTrackStats*>& media_stats_vec)"
  },
  {
    "label": "TaskQueueMetronome()",
    "kind": "Method",
    "detail": "Function (class TaskQueueMetronome : public webrtc::Metronome { public :)",
    "insertText": "TaskQueueMetronome(TimeDelta tick_period)"
  },
  {
    "label": "TaskQueueMetronome()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "TaskQueueMetronome()"
  },
  {
    "label": "RequestCallOnNextTick()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RequestCallOnNextTick(absl::AnyInvocable<void() &&> callback)"
  },
  {
    "label": "TickPeriod()",
    "kind": "Method",
    "detail": "Function (TimeDelta)",
    "insertText": "TickPeriod()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (private : const TimeDelta tick_period_ ; SequenceChecker sequence_checker_ ; std::vector<absl::AnyInvocable<)",
    "insertText": "void()"
  },
  {
    "label": "ReceiveSdpMessage()",
    "kind": "Method",
    "detail": "Function (ScopedTaskSafetyDetached safety_ ; } ; class SignalingMessageReceiver { public : void)",
    "insertText": "ReceiveSdpMessage(SdpType type, const std::string& msg)"
  },
  {
    "label": "ReceiveIceMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReceiveIceMessage(const std::string& sdp_mid, int sdp_mline_index, const std::string& msg)"
  },
  {
    "label": "SignalingMessageReceiver()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "SignalingMessageReceiver()"
  },
  {
    "label": "MockRtpReceiverObserver()",
    "kind": "Method",
    "detail": "Function (} } ; class MockRtpReceiverObserver : public webrtc::RtpReceiverObserverInterface { public :)",
    "insertText": "MockRtpReceiverObserver(cricket::MediaType media_type) : expected_media_type_(media_type)"
  },
  {
    "label": "OnFirstPacketReceived()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnFirstPacketReceived(cricket::MediaType media_type)"
  },
  {
    "label": "ASSERT_EQ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ASSERT_EQ(expected_media_type_, media_type)"
  },
  {
    "label": "first_packet_received()",
    "kind": "Method",
    "detail": "Function (first_packet_received_ = true ; } bool)",
    "insertText": "first_packet_received()"
  },
  {
    "label": "pc_factory()",
    "kind": "Method",
    "detail": "Function (} private : bool first_packet_received_ = false ; cricket::MediaType expected_media_type_ ; } ; class PeerConnectionIntegrationWrapper : public webrtc::PeerConnectionObserver,public SignalingMessageReceiver { public : webrtc::PeerConnectionFactoryInterface*)",
    "insertText": "pc_factory()"
  },
  {
    "label": "pc()",
    "kind": "Method",
    "detail": "Function (} webrtc::PeerConnectionInterface*)",
    "insertText": "pc()"
  },
  {
    "label": "CreateAndSetAndSignalOffer()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CreateAndSetAndSignalOffer()"
  },
  {
    "label": "CreateOfferAndWait()",
    "kind": "Method",
    "detail": "Function (auto offer =)",
    "insertText": "CreateOfferAndWait()"
  },
  {
    "label": "ASSERT_NE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ASSERT_NE(nullptr, offer)"
  },
  {
    "label": "EXPECT_TRUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_TRUE(SetLocalDescriptionAndSendSdpMessage(std::move(offer)))"
  },
  {
    "label": "SetOfferAnswerOptions()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetOfferAnswerOptions(const PeerConnectionInterface::RTCOfferAnswerOptions& options)"
  },
  {
    "label": "SetReceivedSdpMunger()",
    "kind": "Method",
    "detail": "Function (offer_answer_options_ = options ; } void)",
    "insertText": "SetReceivedSdpMunger(std::function<void(cricket::SessionDescription*)> munger)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (received_sdp_munger_ =)",
    "insertText": "move(munger)"
  },
  {
    "label": "SetGeneratedSdpMunger()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetGeneratedSdpMunger(std::function<void(cricket::SessionDescription*)> munger)"
  },
  {
    "label": "SetRemoteOfferHandler()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetRemoteOfferHandler(std::function<void()> handler)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (remote_offer_handler_ =)",
    "insertText": "move(handler)"
  },
  {
    "label": "SetRemoteAsyncResolver()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetRemoteAsyncResolver(rtc::MockAsyncResolver* resolver)"
  },
  {
    "label": "ice_connection_state_history()",
    "kind": "Method",
    "detail": "Function (remote_async_resolver_ = resolver ; } std::vector<PeerConnectionInterface::IceConnectionState>)",
    "insertText": "ice_connection_state_history()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (ice_connection_state_history_ .)",
    "insertText": "clear()"
  },
  {
    "label": "standardized_ice_connection_state_history()",
    "kind": "Method",
    "detail": "Function (} std::vector<PeerConnectionInterface::IceConnectionState>)",
    "insertText": "standardized_ice_connection_state_history()"
  },
  {
    "label": "AddAudioTrack()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddAudioTrack()"
  },
  {
    "label": "AddVideoTrack()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddVideoTrack()"
  },
  {
    "label": "CreateLocalAudioTrack()",
    "kind": "Method",
    "detail": "Function (} rtc::scoped_refptr<webrtc::AudioTrackInterface>)",
    "insertText": "CreateLocalAudioTrack()"
  },
  {
    "label": "CreateAudioSource()",
    "kind": "Method",
    "detail": "Function (cricket::AudioOptions options ; options . highpass_filter = false ; rtc::scoped_refptr<webrtc::AudioSourceInterface> source = peer_connection_factory_ ->)",
    "insertText": "CreateAudioSource(options)"
  },
  {
    "label": "CreateLocalVideoTrack()",
    "kind": "Method",
    "detail": "Function (} rtc::scoped_refptr<webrtc::VideoTrackInterface>)",
    "insertText": "CreateLocalVideoTrack()"
  },
  {
    "label": "TimeMillis()",
    "kind": "Method",
    "detail": "Function (webrtc::FakePeriodicVideoSource::Config config ; config . timestamp_offset_ms =)",
    "insertText": "TimeMillis()"
  },
  {
    "label": "CreateLocalVideoTrackWithConfig()",
    "kind": "Method",
    "detail": "Function (} rtc::scoped_refptr<webrtc::VideoTrackInterface>)",
    "insertText": "CreateLocalVideoTrackWithConfig(webrtc::FakePeriodicVideoSource::Config config)"
  },
  {
    "label": "CreateLocalVideoTrackWithRotation()",
    "kind": "Method",
    "detail": "Function (} rtc::scoped_refptr<webrtc::VideoTrackInterface>)",
    "insertText": "CreateLocalVideoTrackWithRotation(webrtc::VideoRotation rotation)"
  },
  {
    "label": "AddTrack()",
    "kind": "Method",
    "detail": "Function (} rtc::scoped_refptr<RtpSenderInterface>)",
    "insertText": "AddTrack(rtc::scoped_refptr<MediaStreamTrackInterface> track, const std::vector<std::string>& stream_ids = {})"
  },
  {
    "label": "EXPECT_TRUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_TRUE(track)"
  },
  {
    "label": "EXPECT_EQ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_EQ(RTCErrorType::NONE, result.error().type())"
  },
  {
    "label": "GetReceiversOfType()",
    "kind": "Method",
    "detail": "Function (} else { return nullptr ; } } std::vector<rtc::scoped_refptr<RtpReceiverInterface>>)",
    "insertText": "GetReceiversOfType(cricket::MediaType media_type)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::vector<rtc::scoped_refptr<RtpReceiverInterface>> receivers ;)",
    "insertText": "for(const auto& receiver : pc()->GetReceivers())"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (receivers .)",
    "insertText": "push_back(receiver)"
  },
  {
    "label": "GetFirstTransceiverOfType()",
    "kind": "Method",
    "detail": "Function (} } return receivers ; } rtc::scoped_refptr<RtpTransceiverInterface>)",
    "insertText": "GetFirstTransceiverOfType(cricket::MediaType media_type)"
  },
  {
    "label": "IceGatheringStateComplete()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IceGatheringStateComplete()"
  },
  {
    "label": "CreateDataChannel()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CreateDataChannel()"
  },
  {
    "label": "CreateDataChannel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateDataChannel(nullptr)"
  },
  {
    "label": "CreateDataChannel()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CreateDataChannel(const webrtc::DataChannelInit* init)"
  },
  {
    "label": "CreateDataChannel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateDataChannel(kDataChannelLabel, init)"
  },
  {
    "label": "CreateDataChannel()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CreateDataChannel(const std::string& label, const webrtc::DataChannelInit* init)"
  },
  {
    "label": "pc()",
    "kind": "Method",
    "detail": "Function (auto data_channel_or_error =)",
    "insertText": "pc()->CreateDataChannelOrError(label, init)"
  },
  {
    "label": "ASSERT_TRUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ASSERT_TRUE(data_channel_or_error.ok())"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (data_channels_ .)",
    "insertText": "push_back(data_channel_or_error.MoveValue())"
  },
  {
    "label": "ASSERT_TRUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ASSERT_TRUE(data_channels_.back().get() != nullptr)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (data_observers_ .)",
    "insertText": "push_back(std::make_unique<MockDataChannelObserver>(data_channels_.back().get()))"
  },
  {
    "label": "data_channel()",
    "kind": "Method",
    "detail": "Function (} DataChannelInterface*)",
    "insertText": "data_channel()"
  },
  {
    "label": "data_channels()",
    "kind": "Method",
    "detail": "Function (} std::vector<rtc::scoped_refptr<DataChannelInterface>>&)",
    "insertText": "data_channels()"
  },
  {
    "label": "data_observers()",
    "kind": "Method",
    "detail": "Function (} std::vector<std::unique_ptr<MockDataChannelObserver>>&)",
    "insertText": "data_observers()"
  },
  {
    "label": "min_video_frames_received_per_track()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "min_video_frames_received_per_track()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int min_frames = INT_MAX ;)",
    "insertText": "if(fake_video_renderers_.empty())"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (min_frames =)",
    "insertText": "min(min_frames, pair.second->num_rendered_frames())"
  },
  {
    "label": "OldGetStatsForTrack()",
    "kind": "Method",
    "detail": "Function (} return min_frames ; } rtc::scoped_refptr<MockStatsObserver>)",
    "insertText": "OldGetStatsForTrack(webrtc::MediaStreamTrackInterface* track)"
  },
  {
    "label": "MockStatsObserver()",
    "kind": "Method",
    "detail": "Function (auto observer = rtc::make_ref_counted<)",
    "insertText": "MockStatsObserver()"
  },
  {
    "label": "EXPECT_TRUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_TRUE(peer_connection_->GetStats( observer.get(), nullptr, PeerConnectionInterface::kStatsOutputLevelStandard))"
  },
  {
    "label": "EXPECT_TRUE_WAIT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_TRUE_WAIT(observer->called(), kDefaultTimeout)"
  },
  {
    "label": "NewGetStats()",
    "kind": "Method",
    "detail": "Function (} rtc::scoped_refptr<const webrtc::RTCStatsReport>)",
    "insertText": "NewGetStats()"
  },
  {
    "label": "MockRTCStatsCollectorCallback()",
    "kind": "Method",
    "detail": "Function (auto callback = rtc::make_ref_counted<)",
    "insertText": "MockRTCStatsCollectorCallback()"
  },
  {
    "label": "GetStats()",
    "kind": "Method",
    "detail": "Function (peer_connection_ ->)",
    "insertText": "GetStats(callback.get())"
  },
  {
    "label": "EXPECT_TRUE_WAIT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_TRUE_WAIT(callback->called(), kDefaultTimeout)"
  },
  {
    "label": "rendered_width()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "rendered_width()"
  },
  {
    "label": "EXPECT_FALSE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_FALSE(fake_video_renderers_.empty())"
  },
  {
    "label": "rendered_height()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "rendered_height()"
  },
  {
    "label": "rendered_aspect_ratio()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "rendered_aspect_ratio()"
  },
  {
    "label": "rendered_rotation()",
    "kind": "Method",
    "detail": "Function (} webrtc::VideoRotation)",
    "insertText": "rendered_rotation()"
  },
  {
    "label": "local_rendered_width()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "local_rendered_width()"
  },
  {
    "label": "local_rendered_height()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "local_rendered_height()"
  },
  {
    "label": "local_rendered_aspect_ratio()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "local_rendered_aspect_ratio()"
  },
  {
    "label": "number_of_remote_streams()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "number_of_remote_streams()"
  },
  {
    "label": "remote_streams()",
    "kind": "Method",
    "detail": "Function (} StreamCollectionInterface*)",
    "insertText": "remote_streams()"
  },
  {
    "label": "ADD_FAILURE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ADD_FAILURE()"
  },
  {
    "label": "local_streams()",
    "kind": "Method",
    "detail": "Function (} StreamCollectionInterface*)",
    "insertText": "local_streams()"
  },
  {
    "label": "signaling_state()",
    "kind": "Method",
    "detail": "Function (} webrtc::PeerConnectionInterface::SignalingState)",
    "insertText": "signaling_state()"
  },
  {
    "label": "ice_connection_state()",
    "kind": "Method",
    "detail": "Function (} webrtc::PeerConnectionInterface::IceConnectionState)",
    "insertText": "ice_connection_state()"
  },
  {
    "label": "standardized_ice_connection_state()",
    "kind": "Method",
    "detail": "Function (} webrtc::PeerConnectionInterface::IceConnectionState)",
    "insertText": "standardized_ice_connection_state()"
  },
  {
    "label": "ice_gathering_state()",
    "kind": "Method",
    "detail": "Function (} webrtc::PeerConnectionInterface::IceGatheringState)",
    "insertText": "ice_gathering_state()"
  },
  {
    "label": "rtp_receiver_observers()",
    "kind": "Method",
    "detail": "Function (} const std::vector<std::unique_ptr<MockRtpReceiverObserver>>&)",
    "insertText": "rtp_receiver_observers()"
  },
  {
    "label": "observer()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<MockRtpReceiverObserver>)",
    "insertText": "observer(new MockRtpReceiverObserver(receiver->media_type()))"
  },
  {
    "label": "SetObserver()",
    "kind": "Method",
    "detail": "Function (receiver ->)",
    "insertText": "SetObserver(observer.get())"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (rtp_receiver_observers_ .)",
    "insertText": "push_back(std::move(observer))"
  },
  {
    "label": "network_manager()",
    "kind": "Method",
    "detail": "Function (} } rtc::FakeNetworkManager*)",
    "insertText": "network_manager()"
  },
  {
    "label": "port_allocator()",
    "kind": "Method",
    "detail": "Function (} cricket::PortAllocator*)",
    "insertText": "port_allocator()"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK(mdns_responder != nullptr)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (mdns_responder_ = mdns_responder .)",
    "insertText": "get()"
  },
  {
    "label": "network_manager()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "network_manager()->set_mdns_responder(std::move(mdns_responder))"
  },
  {
    "label": "MockCreateSessionDescriptionObserver()",
    "kind": "Method",
    "detail": "Function (auto observer = rtc::make_ref_counted<)",
    "insertText": "MockCreateSessionDescriptionObserver()"
  },
  {
    "label": "pc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pc()->CreateOffer(observer.get(), offer_answer_options_)"
  },
  {
    "label": "Rollback()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Rollback()"
  },
  {
    "label": "StartWatchingDelayStats()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "StartWatchingDelayStats()"
  },
  {
    "label": "RTCInboundRTPStreamStats()",
    "kind": "Method",
    "detail": "Function (auto rtp_stats = received_stats -> GetStatsOfType<)",
    "insertText": "RTCInboundRTPStreamStats()"
  },
  {
    "label": "ASSERT_TRUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ASSERT_TRUE(rtp_stats->relative_packet_arrival_delay.is_defined())"
  },
  {
    "label": "ASSERT_TRUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ASSERT_TRUE(rtp_stats->packets_received.is_defined())"
  },
  {
    "label": "ASSERT_TRUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ASSERT_TRUE(rtp_stats->track_id.is_defined())"
  },
  {
    "label": "id()",
    "kind": "Method",
    "detail": "Function (rtp_stats_id_ = rtp_stats ->)",
    "insertText": "id()"
  },
  {
    "label": "UpdateDelayStats()",
    "kind": "Method",
    "detail": "Function (audio_packets_stat_ =* rtp_stats -> packets_received ; audio_delay_stat_ =* rtp_stats -> relative_packet_arrival_delay ; audio_samples_stat_ =* rtp_stats -> total_samples_received ; audio_concealed_stat_ =* rtp_stats -> concealed_samples ; } void)",
    "insertText": "UpdateDelayStats(std::string tag, int desc_size)"
  },
  {
    "label": "RTCInboundRTPStreamStats()",
    "kind": "Method",
    "detail": "Function (auto rtp_stats = report -> GetAs<)",
    "insertText": "RTCInboundRTPStreamStats(rtp_stats_id_)"
  },
  {
    "label": "ASSERT_TRUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ASSERT_TRUE(rtp_stats)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (auto delta_packets =* rtp_stats -> packets_received - audio_packets_stat_ ; auto delta_rpad =* rtp_stats -> relative_packet_arrival_delay - audio_delay_stat_ ; auto recent_delay = delta_packets> 0 ? delta_rpad / delta_packets : - 1 ; # if !)",
    "insertText": "defined(NDEBUG) EXPECT_GT(0.25, recent_delay)"
  },
  {
    "label": "EXPECT_GT()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "EXPECT_GT(0.1, recent_delay)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif auto delta_samples =* rtp_stats -> total_samples_received - audio_samples_stat_ ; auto delta_concealed =* rtp_stats -> concealed_samples - audio_concealed_stat_ ; # if !)",
    "insertText": "defined(NDEBUG) EXPECT_GT(18000U, delta_concealed)"
  },
  {
    "label": "EXPECT_GT()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "EXPECT_GT(15000U, delta_concealed)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(delta_samples > 0)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if !)",
    "insertText": "defined(NDEBUG) EXPECT_LT(1.0 * delta_concealed / delta_samples, 0.95)"
  },
  {
    "label": "EXPECT_LT()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "EXPECT_LT(1.0 * delta_concealed / delta_samples, 0.7)"
  },
  {
    "label": "ExpectCandidates()",
    "kind": "Method",
    "detail": "Function (# endif } audio_packets_stat_ =* rtp_stats -> packets_received ; audio_delay_stat_ =* rtp_stats -> relative_packet_arrival_delay ; audio_samples_stat_ =* rtp_stats -> total_samples_received ; audio_concealed_stat_ =* rtp_stats -> concealed_samples ; } void)",
    "insertText": "ExpectCandidates(int candidate_count)"
  },
  {
    "label": "PeerConnectionIntegrationWrapper()",
    "kind": "Method",
    "detail": "Function (candidates_expected_ = candidate_count ; } private :)",
    "insertText": "PeerConnectionIntegrationWrapper(const std::string& debug_name) : debug_name_(debug_name)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Init(const PeerConnectionFactory::Options* options, const PeerConnectionInterface::RTCConfiguration* config, webrtc::PeerConnectionDependencies dependencies, rtc::SocketServer* socket_server, rtc::Thread* network_thread, rtc::Thread* worker_thread, std::unique_ptr<webrtc::FakeRtcEventLogFactory> event_log_factory, bool reset_encoder_factory, bool reset_decoder_factory, bool create_media_engine)"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK(!peer_connection_)"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK(!peer_connection_factory_)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (fake_network_manager_ .)",
    "insertText": "reset(new rtc::FakeNetworkManager())"
  },
  {
    "label": "AddInterface()",
    "kind": "Method",
    "detail": "Function (fake_network_manager_ ->)",
    "insertText": "AddInterface(kDefaultLocalAddress)"
  },
  {
    "label": "port_allocator()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<cricket::PortAllocator>)",
    "insertText": "port_allocator(new cricket::BasicPortAllocator( fake_network_manager_.get(), std::make_unique<rtc::BasicPacketSocketFactory>(socket_server)))"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (fake_audio_capture_module_ =)",
    "insertText": "Create()"
  },
  {
    "label": "CreateDefaultTaskQueueFactory()",
    "kind": "Method",
    "detail": "Function (webrtc::PeerConnectionFactoryDependencies pc_factory_dependencies ; pc_factory_dependencies . network_thread = network_thread ; pc_factory_dependencies . worker_thread = worker_thread ; pc_factory_dependencies . signaling_thread = signaling_thread ; pc_factory_dependencies . task_queue_factory =)",
    "insertText": "CreateDefaultTaskQueueFactory()"
  },
  {
    "label": "FieldTrialBasedConfig()",
    "kind": "Method",
    "detail": "Function (pc_factory_dependencies . trials = std::make_unique<)",
    "insertText": "FieldTrialBasedConfig()"
  },
  {
    "label": "TaskQueueMetronome()",
    "kind": "Method",
    "detail": "Function (pc_factory_dependencies . metronome = std::make_unique<)",
    "insertText": "TaskQueueMetronome(TimeDelta::Millis(8))"
  },
  {
    "label": "SetMediaEngineDefaults()",
    "kind": "Method",
    "detail": "Function (media_deps . adm = fake_audio_capture_module_ ;)",
    "insertText": "SetMediaEngineDefaults(&media_deps)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (media_deps . video_encoder_factory .)",
    "insertText": "reset()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(reset_decoder_factory)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!media_deps.audio_processing)"
  },
  {
    "label": "AudioProcessingBuilderForTesting()",
    "kind": "Method",
    "detail": "Function (media_deps . audio_processing =)",
    "insertText": "AudioProcessingBuilderForTesting().Create()"
  },
  {
    "label": "CreateMediaEngine()",
    "kind": "Method",
    "detail": "Function (pc_factory_dependencies . media_engine =)",
    "insertText": "CreateMediaEngine(std::move(media_deps))"
  },
  {
    "label": "CreateCallFactory()",
    "kind": "Method",
    "detail": "Function (} pc_factory_dependencies . call_factory =)",
    "insertText": "CreateCallFactory()"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (pc_factory_dependencies . event_log_factory =)",
    "insertText": "move(event_log_factory)"
  },
  {
    "label": "RtcEventLogFactory()",
    "kind": "Method",
    "detail": "Function (} else { pc_factory_dependencies . event_log_factory = std::make_unique<)",
    "insertText": "RtcEventLogFactory(pc_factory_dependencies.task_queue_factory.get())"
  },
  {
    "label": "CreateModularPeerConnectionFactory()",
    "kind": "Method",
    "detail": "Function (} peer_connection_factory_ =)",
    "insertText": "CreateModularPeerConnectionFactory(std::move(pc_factory_dependencies))"
  },
  {
    "label": "SetOptions()",
    "kind": "Method",
    "detail": "Function (peer_connection_factory_ ->)",
    "insertText": "SetOptions(*options)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(config)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (sdp_semantics_ = config -> sdp_semantics ; } dependencies . allocator =)",
    "insertText": "move(port_allocator)"
  },
  {
    "label": "CreatePeerConnection()",
    "kind": "Method",
    "detail": "Function (peer_connection_ =)",
    "insertText": "CreatePeerConnection(config, std::move(dependencies))"
  },
  {
    "label": "CreatePeerConnection()",
    "kind": "Method",
    "detail": "Function (} rtc::scoped_refptr<webrtc::PeerConnectionInterface>)",
    "insertText": "CreatePeerConnection(const PeerConnectionInterface::RTCConfiguration* config, webrtc::PeerConnectionDependencies dependencies)"
  },
  {
    "label": "set_cpu_adaptation()",
    "kind": "Method",
    "detail": "Function (modified_config =* config ; } modified_config .)",
    "insertText": "set_cpu_adaptation(false)"
  },
  {
    "label": "CreatePeerConnectionOrError()",
    "kind": "Method",
    "detail": "Function (dependencies . observer = this ; auto peer_connection_or_error = peer_connection_factory_ ->)",
    "insertText": "CreatePeerConnectionOrError(modified_config, std::move(dependencies))"
  },
  {
    "label": "set_signaling_message_receiver()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_signaling_message_receiver(SignalingMessageReceiver* signaling_message_receiver)"
  },
  {
    "label": "set_signaling_delay_ms()",
    "kind": "Method",
    "detail": "Function (signaling_message_receiver_ = signaling_message_receiver ; } void)",
    "insertText": "set_signaling_delay_ms(int delay_ms)"
  },
  {
    "label": "set_signal_ice_candidates()",
    "kind": "Method",
    "detail": "Function (signaling_delay_ms_ = delay_ms ; } void)",
    "insertText": "set_signal_ice_candidates(bool signal)"
  },
  {
    "label": "CreateLocalVideoTrackInternal()",
    "kind": "Method",
    "detail": "Function (signal_ice_candidates_ = signal ; } rtc::scoped_refptr<webrtc::VideoTrackInterface>)",
    "insertText": "CreateLocalVideoTrackInternal(webrtc::FakePeriodicVideoSource::Config config)"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (config . frame_interval_ms = 1 0 0 ; video_track_sources_ .)",
    "insertText": "emplace_back(rtc::make_ref_counted<webrtc::FakePeriodicVideoTrackSource>( config, false ))"
  },
  {
    "label": "track()",
    "kind": "Method",
    "detail": "Function (rtc::scoped_refptr<webrtc::VideoTrackInterface>)",
    "insertText": "track(peer_connection_factory_->CreateVideoTrack( rtc::CreateRandomUuid(), video_track_sources_.back().get()))"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (local_video_renderer_ .)",
    "insertText": "reset(new webrtc::FakeVideoTrackRenderer(track.get()))"
  },
  {
    "label": "HandleIncomingOffer()",
    "kind": "Method",
    "detail": "Function (} return track ; } void)",
    "insertText": "HandleIncomingOffer(const std::string& msg)"
  },
  {
    "label": "RTC_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_LOG(LS_INFO)"
  },
  {
    "label": "CreateSessionDescription()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<SessionDescriptionInterface> desc =)",
    "insertText": "CreateSessionDescription(SdpType::kOffer, msg)"
  },
  {
    "label": "received_sdp_munger_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "received_sdp_munger_(desc->description())"
  },
  {
    "label": "EXPECT_TRUE()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "EXPECT_TRUE(SetRemoteDescription(std::move(desc)))"
  },
  {
    "label": "ResetRtpReceiverObservers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetRtpReceiverObservers()"
  },
  {
    "label": "remote_offer_handler_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "remote_offer_handler_()"
  },
  {
    "label": "CreateAnswer()",
    "kind": "Method",
    "detail": "Function (} auto answer =)",
    "insertText": "CreateAnswer()"
  },
  {
    "label": "ASSERT_NE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ASSERT_NE(nullptr, answer)"
  },
  {
    "label": "EXPECT_TRUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_TRUE(SetLocalDescriptionAndSendSdpMessage(std::move(answer)))"
  },
  {
    "label": "HandleIncomingAnswer()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "HandleIncomingAnswer(const std::string& msg)"
  },
  {
    "label": "CreateSessionDescription()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<SessionDescriptionInterface> desc =)",
    "insertText": "CreateSessionDescription(SdpType::kAnswer, msg)"
  },
  {
    "label": "pc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pc()->CreateAnswer(observer.get(), offer_answer_options_)"
  },
  {
    "label": "WaitForDescriptionFromObserver()",
    "kind": "Method",
    "detail": "Function (} std::unique_ptr<SessionDescriptionInterface>)",
    "insertText": "WaitForDescriptionFromObserver(MockCreateSessionDescriptionObserver* observer)"
  },
  {
    "label": "EXPECT_EQ_WAIT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_EQ_WAIT(true, observer->called(), kDefaultTimeout)"
  },
  {
    "label": "generated_sdp_munger_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "generated_sdp_munger_(description->description())"
  },
  {
    "label": "SetLocalDescriptionAndSendSdpMessage()",
    "kind": "Method",
    "detail": "Function (} return description ; } bool)",
    "insertText": "SetLocalDescriptionAndSendSdpMessage(std::unique_ptr<SessionDescriptionInterface> desc)"
  },
  {
    "label": "MockSetSessionDescriptionObserver()",
    "kind": "Method",
    "detail": "Function (auto observer = rtc::make_ref_counted<)",
    "insertText": "MockSetSessionDescriptionObserver()"
  },
  {
    "label": "GetType()",
    "kind": "Method",
    "detail": "Function (SdpType type = desc ->)",
    "insertText": "GetType()"
  },
  {
    "label": "EXPECT_TRUE()",
    "kind": "Method",
    "detail": "Function (std::string sdp ;)",
    "insertText": "EXPECT_TRUE(desc->ToString(&sdp))"
  },
  {
    "label": "pc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pc()->SetLocalDescription(observer.get(), desc.release())"
  },
  {
    "label": "RemoveUnusedVideoRenderers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveUnusedVideoRenderers()"
  },
  {
    "label": "SendSdpMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SendSdpMessage(type, sdp)"
  },
  {
    "label": "pc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pc()->SetRemoteDescription(observer.get(), desc.release())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::set<std::string> active_renderers ;)",
    "insertText": "for(auto& transceiver : transceivers)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (active_renderers .)",
    "insertText": "insert(transceiver->receiver()->track()->id())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(auto it = fake_video_renderers_.begin(); it != fake_video_renderers_.end();)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (it = fake_video_renderers_ .)",
    "insertText": "erase(it)"
  },
  {
    "label": "SendSdpMessage()",
    "kind": "Method",
    "detail": "Function (} else { it + + ; } } } void)",
    "insertText": "SendSdpMessage(SdpType type, const std::string& msg)"
  },
  {
    "label": "RelaySdpMessageIfReceiverExists()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RelaySdpMessageIfReceiverExists(type, msg)"
  },
  {
    "label": "Current()",
    "kind": "Method",
    "detail": "Function (} else { rtc::)",
    "insertText": "Current()->PostDelayedTask( SafeTask(task_safety_.flag(), [this, type, msg] { RelaySdpMessageIfReceiverExists(type, msg); }), TimeDelta::Millis(signaling_delay_ms_))"
  },
  {
    "label": "RelaySdpMessageIfReceiverExists()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "RelaySdpMessageIfReceiverExists(SdpType type, const std::string& msg)"
  },
  {
    "label": "ReceiveSdpMessage()",
    "kind": "Method",
    "detail": "Function (signaling_message_receiver_ ->)",
    "insertText": "ReceiveSdpMessage(type, msg)"
  },
  {
    "label": "SendIceMessage()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SendIceMessage(const std::string& sdp_mid, int sdp_mline_index, const std::string& msg)"
  },
  {
    "label": "RelayIceMessageIfReceiverExists()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RelayIceMessageIfReceiverExists(sdp_mid, sdp_mline_index, msg)"
  },
  {
    "label": "Current()",
    "kind": "Method",
    "detail": "Function (} else { rtc::)",
    "insertText": "Current()->PostDelayedTask( SafeTask(task_safety_.flag(), [this, sdp_mid, sdp_mline_index, msg] { RelayIceMessageIfReceiverExists(sdp_mid, sdp_mline_index, msg); }), TimeDelta::Millis(signaling_delay_ms_))"
  },
  {
    "label": "RelayIceMessageIfReceiverExists()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "RelayIceMessageIfReceiverExists(const std::string& sdp_mid, int sdp_mline_index, const std::string& msg)"
  },
  {
    "label": "ReceiveIceMessage()",
    "kind": "Method",
    "detail": "Function (signaling_message_receiver_ ->)",
    "insertText": "ReceiveIceMessage(sdp_mid, sdp_mline_index, msg)"
  },
  {
    "label": "HandleIncomingOffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleIncomingOffer(msg)"
  },
  {
    "label": "HandleIncomingAnswer()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "HandleIncomingAnswer(msg)"
  },
  {
    "label": "pc()",
    "kind": "Method",
    "detail": "Function (absl::optional<RTCError> result ;)",
    "insertText": "pc()->AddIceCandidate(absl::WrapUnique(webrtc::CreateIceCandidate( sdp_mid, sdp_mline_index, msg, nullptr)), [&result](RTCError r) { result = r; })"
  },
  {
    "label": "EXPECT_TRUE_WAIT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_TRUE_WAIT(result.has_value(), kDefaultTimeout)"
  },
  {
    "label": "EXPECT_TRUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_TRUE(result.value().ok())"
  },
  {
    "label": "OnSignalingChange()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnSignalingChange(webrtc::PeerConnectionInterface::SignalingState new_state)"
  },
  {
    "label": "EXPECT_EQ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_EQ(pc()->signaling_state(), new_state)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (peer_connection_signaling_state_history_ .)",
    "insertText": "push_back(new_state)"
  },
  {
    "label": "OnAddTrack()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnAddTrack(rtc::scoped_refptr<RtpReceiverInterface> receiver, const std::vector<rtc::scoped_refptr<MediaStreamInterface>>& streams)"
  },
  {
    "label": "video_track()",
    "kind": "Method",
    "detail": "Function (rtc::scoped_refptr<VideoTrackInterface>)",
    "insertText": "video_track(static_cast<VideoTrackInterface*>(receiver->track().get()))"
  },
  {
    "label": "ASSERT_TRUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ASSERT_TRUE(fake_video_renderers_.find(video_track->id()) == fake_video_renderers_.end())"
  },
  {
    "label": "id()",
    "kind": "Method",
    "detail": "Function (fake_video_renderers_ [ video_track ->)",
    "insertText": "id()] = std::make_unique<FakeVideoTrackRenderer>(video_track.get())"
  },
  {
    "label": "OnRemoveTrack()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "OnRemoveTrack(rtc::scoped_refptr<RtpReceiverInterface> receiver)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (auto it = fake_video_renderers_ .)",
    "insertText": "find(receiver->track()->id())"
  },
  {
    "label": "RTC_LOG()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "RTC_LOG(LS_ERROR)"
  },
  {
    "label": "OnRenegotiationNeeded()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "OnRenegotiationNeeded()"
  },
  {
    "label": "OnIceConnectionChange()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnIceConnectionChange(webrtc::PeerConnectionInterface::IceConnectionState new_state)"
  },
  {
    "label": "EXPECT_EQ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_EQ(pc()->ice_connection_state(), new_state)"
  },
  {
    "label": "OnStandardizedIceConnectionChange()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnStandardizedIceConnectionChange(webrtc::PeerConnectionInterface::IceConnectionState new_state)"
  },
  {
    "label": "OnConnectionChange()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnConnectionChange(webrtc::PeerConnectionInterface::PeerConnectionState new_state)"
  },
  {
    "label": "OnIceGatheringChange()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnIceGatheringChange(webrtc::PeerConnectionInterface::IceGatheringState new_state)"
  },
  {
    "label": "EXPECT_EQ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_EQ(pc()->ice_gathering_state(), new_state)"
  },
  {
    "label": "OnIceSelectedCandidatePairChanged()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnIceSelectedCandidatePairChanged(const cricket::CandidatePairChangeEvent& event)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (ice_candidate_pair_change_history_ .)",
    "insertText": "push_back(event)"
  },
  {
    "label": "OnIceCandidate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnIceCandidate(const webrtc::IceCandidateInterface* candidate)"
  },
  {
    "label": "candidate()",
    "kind": "Method",
    "detail": "Function (const auto& local_candidate = candidate ->)",
    "insertText": "candidate()"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK(local_candidate.type() == cricket::LOCAL_PORT_TYPE)"
  },
  {
    "label": "resolved_addr()",
    "kind": "Method",
    "detail": "Function (rtc::SocketAddress)",
    "insertText": "resolved_addr(local_candidate.address())"
  },
  {
    "label": "GetMappedAddressForName()",
    "kind": "Method",
    "detail": "Function (const auto resolved_ip = mdns_responder_ ->)",
    "insertText": "GetMappedAddressForName(local_candidate.address().hostname())"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK(!resolved_ip.IsNil())"
  },
  {
    "label": "SetResolvedIP()",
    "kind": "Method",
    "detail": "Function (resolved_addr .)",
    "insertText": "SetResolvedIP(resolved_ip)"
  },
  {
    "label": "EXPECT_CALL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_CALL(*remote_async_resolver_, GetResolvedAddress(_, _)) .WillOnce(DoAll(SetArgPointee<1>(resolved_addr), Return(true)))"
  },
  {
    "label": "EXPECT_CALL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_CALL(*remote_async_resolver_, Destroy(_))"
  },
  {
    "label": "EXPECT_GT()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "EXPECT_GT(candidates_expected_, 1)"
  },
  {
    "label": "EXPECT_TRUE()",
    "kind": "Method",
    "detail": "Function (candidates_expected_ - - ; std::string ice_sdp ;)",
    "insertText": "EXPECT_TRUE(candidate->ToString(&ice_sdp))"
  },
  {
    "label": "OnIceCandidateError()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnIceCandidateError(const std::string& address, int port, const std::string& url, int error_code, const std::string& error_text)"
  },
  {
    "label": "IceCandidateErrorEvent()",
    "kind": "Method",
    "detail": "Function (error_event_ =)",
    "insertText": "IceCandidateErrorEvent(address, port, url, error_code, error_text)"
  },
  {
    "label": "OnDataChannel()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnDataChannel(rtc::scoped_refptr<DataChannelInterface> data_channel)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (data_channels_ .)",
    "insertText": "push_back(data_channel)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (data_observers_ .)",
    "insertText": "push_back(std::make_unique<MockDataChannelObserver>(data_channel.get()))"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} std::string debug_name_ ; std::unique_ptr<rtc::FakeNetworkManager> fake_network_manager_ ; webrtc::FakeMdnsResponder* mdns_responder_ = nullptr ; rtc::scoped_refptr<webrtc::PeerConnectionInterface> peer_connection_ ; rtc::scoped_refptr<webrtc::PeerConnectionFactoryInterface> peer_connection_factory_ ; cricket::PortAllocator* port_allocator_ ; rtc::scoped_refptr<FakeAudioCaptureModule> fake_audio_capture_module_ ; std::map<std::string,std::unique_ptr<webrtc::FakeVideoTrackRenderer>> fake_video_renderers_ ; std::vector<std::unique_ptr<webrtc::FakeVideoTrackRenderer>> removed_fake_video_renderers_ ; SignalingMessageReceiver* signaling_message_receiver_ = nullptr ; int signaling_delay_ms_ = 0 ; bool signal_ice_candidates_ = true ; cricket::Candidate last_candidate_gathered_ ; cricket::IceCandidateErrorEvent error_event_ ; std::vector<rtc::scoped_refptr<webrtc::VideoTrackSource>> video_track_sources_ ; std::unique_ptr<webrtc::FakeVideoTrackRenderer> local_video_renderer_ ; SdpSemantics sdp_semantics_ ; PeerConnectionInterface::RTCOfferAnswerOptions offer_answer_options_ ; std::function<)",
    "insertText": "void(cricket::SessionDescription*)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (rtc::MockAsyncResolver* remote_async_resolver_ = nullptr ; std::vector<rtc::scoped_refptr<DataChannelInterface>> data_channels_ ; std::vector<std::unique_ptr<MockDataChannelObserver>> data_observers_ ; std::vector<std::unique_ptr<MockRtpReceiverObserver>> rtp_receiver_observers_ ; std::vector<PeerConnectionInterface::IceConnectionState> ice_connection_state_history_ ; std::vector<PeerConnectionInterface::IceConnectionState> standardized_ice_connection_state_history_ ; std::vector<PeerConnectionInterface::PeerConnectionState> peer_connection_state_history_ ; std::vector<PeerConnectionInterface::IceGatheringState> ice_gathering_state_history_ ; std::vector<cricket::CandidatePairChangeEvent> ice_candidate_pair_change_history_ ; std::vector<PeerConnectionInterface::SignalingState> peer_connection_signaling_state_history_ ; webrtc::FakeRtcEventLogFactory* event_log_factory_ ; int candidates_expected_ = std::numeric_limits<int)",
    "insertText": "max()"
  },
  {
    "label": "MockRtcEventLogOutput()",
    "kind": "Method",
    "detail": "Function (int audio_packets_stat_ = 0 ; double audio_delay_stat_ = 0 . 0 ; uint64_t audio_samples_stat_ = 0 ; uint64_t audio_concealed_stat_ = 0 ; std::string rtp_stats_id_ ; ScopedTaskSafety task_safety_ ; class PeerConnectionIntegrationBaseTest ; } ; class MockRtcEventLogOutput : public webrtc::RtcEventLogOutput { public : ~)",
    "insertText": "MockRtcEventLogOutput()"
  },
  {
    "label": "MOCK_METHOD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MOCK_METHOD(bool, IsActive, (), (const, override))"
  },
  {
    "label": "MOCK_METHOD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MOCK_METHOD(bool, Write, (absl::string_view), (override))"
  },
  {
    "label": "ExpectBidirectionalAudioAndVideo()",
    "kind": "Method",
    "detail": "Function (} ; class MediaExpectations { public : enum ExpectFrames { kExpectSomeFrames,kExpectNoFrames,kNoExpectation,} ; void)",
    "insertText": "ExpectBidirectionalAudioAndVideo()"
  },
  {
    "label": "ExpectBidirectionalAudio()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpectBidirectionalAudio()"
  },
  {
    "label": "ExpectBidirectionalVideo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpectBidirectionalVideo()"
  },
  {
    "label": "CallerExpectsSomeAudio()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CallerExpectsSomeAudio()"
  },
  {
    "label": "CalleeExpectsSomeAudio()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalleeExpectsSomeAudio()"
  },
  {
    "label": "ExpectNoAudio()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExpectNoAudio()"
  },
  {
    "label": "CallerExpectsNoAudio()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CallerExpectsNoAudio()"
  },
  {
    "label": "CalleeExpectsNoAudio()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalleeExpectsNoAudio()"
  },
  {
    "label": "CallerExpectsSomeVideo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CallerExpectsSomeVideo()"
  },
  {
    "label": "CalleeExpectsSomeVideo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalleeExpectsSomeVideo()"
  },
  {
    "label": "ExpectNoVideo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExpectNoVideo()"
  },
  {
    "label": "CallerExpectsNoVideo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CallerExpectsNoVideo()"
  },
  {
    "label": "CalleeExpectsNoVideo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalleeExpectsNoVideo()"
  },
  {
    "label": "CallerExpectsSomeAudioAndVideo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CallerExpectsSomeAudioAndVideo()"
  },
  {
    "label": "CalleeExpectsSomeAudioAndVideo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CalleeExpectsSomeAudioAndVideo()"
  },
  {
    "label": "CallerExpectsSomeAudio()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CallerExpectsSomeAudio(int expected_audio_frames = kDefaultExpectedAudioFrameCount)"
  },
  {
    "label": "CallerExpectsSomeVideo()",
    "kind": "Method",
    "detail": "Function (caller_audio_expectation_ = kExpectNoFrames ; caller_audio_frames_expected_ = 0 ; } void)",
    "insertText": "CallerExpectsSomeVideo(int expected_video_frames = kDefaultExpectedVideoFrameCount)"
  },
  {
    "label": "CalleeExpectsSomeAudio()",
    "kind": "Method",
    "detail": "Function (caller_video_expectation_ = kExpectNoFrames ; caller_video_frames_expected_ = 0 ; } void)",
    "insertText": "CalleeExpectsSomeAudio(int expected_audio_frames = kDefaultExpectedAudioFrameCount)"
  },
  {
    "label": "CalleeExpectsSomeVideo()",
    "kind": "Method",
    "detail": "Function (callee_audio_expectation_ = kExpectNoFrames ; callee_audio_frames_expected_ = 0 ; } void)",
    "insertText": "CalleeExpectsSomeVideo(int expected_video_frames = kDefaultExpectedVideoFrameCount)"
  },
  {
    "label": "MockIceTransport()",
    "kind": "Method",
    "detail": "Function (callee_video_expectation_ = kExpectNoFrames ; callee_video_frames_expected_ = 0 ; } ExpectFrames caller_audio_expectation_ = kNoExpectation ; ExpectFrames caller_video_expectation_ = kNoExpectation ; ExpectFrames callee_audio_expectation_ = kNoExpectation ; ExpectFrames callee_video_expectation_ = kNoExpectation ; int caller_audio_frames_expected_ = 0 ; int caller_video_frames_expected_ = 0 ; int callee_audio_frames_expected_ = 0 ; int callee_video_frames_expected_ = 0 ; } ; class MockIceTransport : public webrtc::IceTransportInterface { public :)",
    "insertText": "MockIceTransport(const std::string& name, int component) : internal_(std::make_unique<cricket::FakeIceTransport>( name, component, nullptr ))"
  },
  {
    "label": "MockIceTransport()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "MockIceTransport()"
  },
  {
    "label": "internal()",
    "kind": "Method",
    "detail": "Function (cricket::IceTransportInternal*)",
    "insertText": "internal()"
  },
  {
    "label": "MockIceTransportFactory()",
    "kind": "Method",
    "detail": "Function (} private : std::unique_ptr<cricket::FakeIceTransport> internal_ ; } ; class MockIceTransportFactory : public IceTransportFactory { public : ~)",
    "insertText": "MockIceTransportFactory()"
  },
  {
    "label": "CreateIceTransport()",
    "kind": "Method",
    "detail": "Function (rtc::scoped_refptr<IceTransportInterface>)",
    "insertText": "CreateIceTransport(const std::string& transport_name, int component, IceTransportInit init)"
  },
  {
    "label": "RecordIceTransportCreated()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RecordIceTransportCreated()"
  },
  {
    "label": "MOCK_METHOD()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MOCK_METHOD(void, RecordIceTransportCreated, ())"
  },
  {
    "label": "PeerConnectionIntegrationBaseTest()",
    "kind": "Method",
    "detail": "Function (} ; class PeerConnectionIntegrationBaseTest : public::testing::Test { public :)",
    "insertText": "PeerConnectionIntegrationBaseTest(SdpSemantics sdp_semantics, absl::optional<std::string> field_trials = absl::nullopt) : sdp_semantics_(sdp_semantics), ss_(new rtc::VirtualSocketServer()), fss_(new rtc::FirewallSocketServer(ss_.get())), network_thread_(new rtc::Thread(fss_.get())), worker_thread_(rtc::Thread::Create()), field_trials_(new test::ScopedKeyValueConfig( field_trials.has_value() ? *field_trials : \"\"))"
  },
  {
    "label": "SetName()",
    "kind": "Method",
    "detail": "Function (network_thread_ ->)",
    "insertText": "SetName(\"PCNetworkThread\", this)"
  },
  {
    "label": "SetName()",
    "kind": "Method",
    "detail": "Function (worker_thread_ ->)",
    "insertText": "SetName(\"PCWorkerThread\", this)"
  },
  {
    "label": "RTC_CHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_CHECK(network_thread_->Start())"
  },
  {
    "label": "RTC_CHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_CHECK(worker_thread_->Start())"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (webrtc::)",
    "insertText": "Reset()"
  },
  {
    "label": "PeerConnectionIntegrationBaseTest()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "PeerConnectionIntegrationBaseTest()"
  },
  {
    "label": "set_signaling_message_receiver()",
    "kind": "Method",
    "detail": "Function (caller_ ->)",
    "insertText": "set_signaling_message_receiver(nullptr)"
  },
  {
    "label": "pc()",
    "kind": "Method",
    "detail": "Function (caller_ ->)",
    "insertText": "pc()->Close()"
  },
  {
    "label": "SetCallerPcWrapperAndReturnCurrent()",
    "kind": "Method",
    "detail": "Function (delete)",
    "insertText": "SetCallerPcWrapperAndReturnCurrent(nullptr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(callee_)"
  },
  {
    "label": "SetCalleePcWrapperAndReturnCurrent()",
    "kind": "Method",
    "detail": "Function (delete)",
    "insertText": "SetCalleePcWrapperAndReturnCurrent(nullptr)"
  },
  {
    "label": "SendTask()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SendTask(network_thread(), [this] { turn_servers_.clear(); turn_customizers_.clear(); })"
  },
  {
    "label": "SignalingStateStable()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "SignalingStateStable()"
  },
  {
    "label": "DtlsConnected()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "DtlsConnected()"
  },
  {
    "label": "CreatePeerConnectionWrapper()",
    "kind": "Method",
    "detail": "Function (} std::unique_ptr<PeerConnectionIntegrationWrapper>)",
    "insertText": "CreatePeerConnectionWrapper(const std::string& debug_name, const PeerConnectionFactory::Options* options, const RTCConfiguration* config, webrtc::PeerConnectionDependencies dependencies, std::unique_ptr<webrtc::FakeRtcEventLogFactory> event_log_factory, bool reset_encoder_factory, bool reset_decoder_factory, bool create_media_engine = true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (modified_config =* config ; } modified_config . sdp_semantics = sdp_semantics_ ;)",
    "insertText": "if(!dependencies.cert_generator)"
  },
  {
    "label": "FakeRTCCertificateGenerator()",
    "kind": "Method",
    "detail": "Function (dependencies . cert_generator = std::make_unique<)",
    "insertText": "FakeRTCCertificateGenerator()"
  },
  {
    "label": "client()",
    "kind": "Method",
    "detail": "Function (} std::unique_ptr<PeerConnectionIntegrationWrapper>)",
    "insertText": "client(new PeerConnectionIntegrationWrapper(debug_name))"
  },
  {
    "label": "CreatePeerConnectionWrappers()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "CreatePeerConnectionWrappers()"
  },
  {
    "label": "CreatePeerConnectionWrappersWithSdpSemantics()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "CreatePeerConnectionWrappersWithSdpSemantics(SdpSemantics caller_semantics, SdpSemantics callee_semantics)"
  },
  {
    "label": "CreatePeerConnectionWrapper()",
    "kind": "Method",
    "detail": "Function (SdpSemantics original_semantics = sdp_semantics_ ; sdp_semantics_ = caller_semantics ; caller_ =)",
    "insertText": "CreatePeerConnectionWrapper(\"Caller\", nullptr, nullptr, webrtc::PeerConnectionDependencies(nullptr), nullptr, false, false)"
  },
  {
    "label": "CreatePeerConnectionWrapper()",
    "kind": "Method",
    "detail": "Function (sdp_semantics_ = callee_semantics ; callee_ =)",
    "insertText": "CreatePeerConnectionWrapper(\"Callee\", nullptr, nullptr, webrtc::PeerConnectionDependencies(nullptr), nullptr, false, false)"
  },
  {
    "label": "CreatePeerConnectionWrappersWithConfig()",
    "kind": "Method",
    "detail": "Function (sdp_semantics_ = original_semantics ; return caller_&& callee_ ; } bool)",
    "insertText": "CreatePeerConnectionWrappersWithConfig(const PeerConnectionInterface::RTCConfiguration& caller_config, const PeerConnectionInterface::RTCConfiguration& callee_config)"
  },
  {
    "label": "CreatePeerConnectionWrapper()",
    "kind": "Method",
    "detail": "Function (caller_ =)",
    "insertText": "CreatePeerConnectionWrapper(\"Caller\", nullptr, &caller_config, webrtc::PeerConnectionDependencies(nullptr), nullptr, false, false)"
  },
  {
    "label": "CreatePeerConnectionWrapper()",
    "kind": "Method",
    "detail": "Function (callee_ =)",
    "insertText": "CreatePeerConnectionWrapper(\"Callee\", nullptr, &callee_config, webrtc::PeerConnectionDependencies(nullptr), nullptr, false, false)"
  },
  {
    "label": "CreatePeerConnectionWrapper()",
    "kind": "Method",
    "detail": "Function (caller_ =)",
    "insertText": "CreatePeerConnectionWrapper(\"Caller\", nullptr, &caller_config, std::move(caller_dependencies), nullptr, false, false)"
  },
  {
    "label": "CreatePeerConnectionWrapper()",
    "kind": "Method",
    "detail": "Function (callee_ =)",
    "insertText": "CreatePeerConnectionWrapper(\"Callee\", nullptr, &callee_config, std::move(callee_dependencies), nullptr, false, false)"
  },
  {
    "label": "CreatePeerConnectionWrapper()",
    "kind": "Method",
    "detail": "Function (caller_ =)",
    "insertText": "CreatePeerConnectionWrapper(\"Caller\", &caller_options, nullptr, webrtc::PeerConnectionDependencies(nullptr), nullptr, false, false)"
  },
  {
    "label": "CreatePeerConnectionWrapper()",
    "kind": "Method",
    "detail": "Function (callee_ =)",
    "insertText": "CreatePeerConnectionWrapper(\"Callee\", &callee_options, nullptr, webrtc::PeerConnectionDependencies(nullptr), nullptr, false, false)"
  },
  {
    "label": "CreatePeerConnectionWrapperWithFakeRtcEventLog()",
    "kind": "Method",
    "detail": "Function (PeerConnectionInterface::RTCConfiguration default_config ; caller_ =)",
    "insertText": "CreatePeerConnectionWrapperWithFakeRtcEventLog(\"Caller\", nullptr, &default_config, webrtc::PeerConnectionDependencies(nullptr))"
  },
  {
    "label": "CreatePeerConnectionWrapperWithFakeRtcEventLog()",
    "kind": "Method",
    "detail": "Function (callee_ =)",
    "insertText": "CreatePeerConnectionWrapperWithFakeRtcEventLog(\"Callee\", nullptr, &default_config, webrtc::PeerConnectionDependencies(nullptr))"
  },
  {
    "label": "cert_generator()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<FakeRTCCertificateGenerator>)",
    "insertText": "cert_generator(new FakeRTCCertificateGenerator())"
  },
  {
    "label": "use_alternate_key()",
    "kind": "Method",
    "detail": "Function (cert_generator ->)",
    "insertText": "use_alternate_key()"
  },
  {
    "label": "dependencies()",
    "kind": "Method",
    "detail": "Function (webrtc::PeerConnectionDependencies)",
    "insertText": "dependencies(nullptr)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (dependencies . cert_generator =)",
    "insertText": "move(cert_generator)"
  },
  {
    "label": "CreateOneDirectionalPeerConnectionWrappers()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "CreateOneDirectionalPeerConnectionWrappers(bool caller_to_callee)"
  },
  {
    "label": "CreatePeerConnectionWrapper()",
    "kind": "Method",
    "detail": "Function (caller_ =)",
    "insertText": "CreatePeerConnectionWrapper(\"Caller\", nullptr, nullptr, webrtc::PeerConnectionDependencies(nullptr), nullptr, !caller_to_callee, caller_to_callee)"
  },
  {
    "label": "CreatePeerConnectionWrapper()",
    "kind": "Method",
    "detail": "Function (callee_ =)",
    "insertText": "CreatePeerConnectionWrapper(\"Callee\", nullptr, nullptr, webrtc::PeerConnectionDependencies(nullptr), nullptr, caller_to_callee, !caller_to_callee)"
  },
  {
    "label": "CreatePeerConnectionWrapper()",
    "kind": "Method",
    "detail": "Function (caller_ =)",
    "insertText": "CreatePeerConnectionWrapper(\"Caller\", nullptr, nullptr, webrtc::PeerConnectionDependencies(nullptr), nullptr, false, false, false)"
  },
  {
    "label": "CreatePeerConnectionWrapper()",
    "kind": "Method",
    "detail": "Function (callee_ =)",
    "insertText": "CreatePeerConnectionWrapper(\"Callee\", nullptr, nullptr, webrtc::PeerConnectionDependencies(nullptr), nullptr, false, false, false)"
  },
  {
    "label": "network_thread()",
    "kind": "Method",
    "detail": "Function (rtc::Thread* thread =)",
    "insertText": "network_thread()"
  },
  {
    "label": "SendTask()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<cricket::TestTurnServer> turn_server ;)",
    "insertText": "SendTask(network_thread(), [&] { turn_server = std::make_unique<cricket::TestTurnServer>( thread, socket_factory, internal_address, external_address, type, true, common_name); })"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (turn_servers_ .)",
    "insertText": "push_back(std::move(turn_server))"
  },
  {
    "label": "CreateTurnCustomizer()",
    "kind": "Method",
    "detail": "Function (} cricket::TestTurnCustomizer*)",
    "insertText": "CreateTurnCustomizer()"
  },
  {
    "label": "SendTask()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<cricket::TestTurnCustomizer> turn_customizer ;)",
    "insertText": "SendTask(network_thread(), [&] { turn_customizer = std::make_unique<cricket::TestTurnCustomizer>(); })"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (turn_customizers_ .)",
    "insertText": "push_back(std::move(turn_customizer))"
  },
  {
    "label": "ExpectTurnCustomizerCountersIncremented()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExpectTurnCustomizerCountersIncremented(cricket::TestTurnCustomizer* turn_customizer)"
  },
  {
    "label": "SendTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SendTask(network_thread(), [turn_customizer] { EXPECT_GT(turn_customizer->allow_channel_data_cnt_, 0u); EXPECT_GT(turn_customizer->modify_cnt_, 0u); })"
  },
  {
    "label": "ConnectFakeSignaling()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ConnectFakeSignaling()"
  },
  {
    "label": "set_signaling_message_receiver()",
    "kind": "Method",
    "detail": "Function (caller_ ->)",
    "insertText": "set_signaling_message_receiver(callee_.get())"
  },
  {
    "label": "set_signaling_message_receiver()",
    "kind": "Method",
    "detail": "Function (callee_ ->)",
    "insertText": "set_signaling_message_receiver(caller_.get())"
  },
  {
    "label": "ConnectFakeSignalingForSdpOnly()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ConnectFakeSignalingForSdpOnly()"
  },
  {
    "label": "SetSignalIceCandidates()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSignalIceCandidates(false)"
  },
  {
    "label": "SetSignalingDelayMs()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetSignalingDelayMs(int delay_ms)"
  },
  {
    "label": "set_signaling_delay_ms()",
    "kind": "Method",
    "detail": "Function (caller_ ->)",
    "insertText": "set_signaling_delay_ms(delay_ms)"
  },
  {
    "label": "SetSignalIceCandidates()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetSignalIceCandidates(bool signal)"
  },
  {
    "label": "set_signal_ice_candidates()",
    "kind": "Method",
    "detail": "Function (caller_ ->)",
    "insertText": "set_signal_ice_candidates(signal)"
  },
  {
    "label": "SendRtpDataWithRetries()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SendRtpDataWithRetries(webrtc::DataChannelInterface* dc, const std::string& data, int retries)"
  },
  {
    "label": "Send()",
    "kind": "Method",
    "detail": "Function (dc ->)",
    "insertText": "Send(DataBuffer(data))"
  },
  {
    "label": "virtual_socket_server()",
    "kind": "Method",
    "detail": "Function (} rtc::VirtualSocketServer*)",
    "insertText": "virtual_socket_server()"
  },
  {
    "label": "caller()",
    "kind": "Method",
    "detail": "Function (} PeerConnectionIntegrationWrapper*)",
    "insertText": "caller()"
  },
  {
    "label": "DestroyPeerConnections()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DestroyPeerConnections()"
  },
  {
    "label": "SetCallerPcWrapperAndReturnCurrent()",
    "kind": "Method",
    "detail": "Function (} PeerConnectionIntegrationWrapper*)",
    "insertText": "SetCallerPcWrapperAndReturnCurrent(PeerConnectionIntegrationWrapper* wrapper)"
  },
  {
    "label": "release()",
    "kind": "Method",
    "detail": "Function (PeerConnectionIntegrationWrapper* old = caller_ .)",
    "insertText": "release()"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (caller_ .)",
    "insertText": "reset(wrapper)"
  },
  {
    "label": "SetCalleePcWrapperAndReturnCurrent()",
    "kind": "Method",
    "detail": "Function (} PeerConnectionIntegrationWrapper*)",
    "insertText": "SetCalleePcWrapperAndReturnCurrent(PeerConnectionIntegrationWrapper* wrapper)"
  },
  {
    "label": "SendTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SendTask(network_thread(), [this, caller_flags] { caller()->port_allocator()->set_flags(caller_flags); })"
  },
  {
    "label": "SendTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SendTask(network_thread(), [this, callee_flags] { callee()->port_allocator()->set_flags(callee_flags); })"
  },
  {
    "label": "firewall()",
    "kind": "Method",
    "detail": "Function (} rtc::FirewallSocketServer*)",
    "insertText": "firewall()"
  },
  {
    "label": "ExpectNewFrames()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ExpectNewFrames(const MediaExpectations& media_expectations)"
  },
  {
    "label": "caller()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "caller()->RemoveUnusedVideoRenderers()"
  },
  {
    "label": "callee()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "callee()->RemoveUnusedVideoRenderers()"
  },
  {
    "label": "caller()",
    "kind": "Method",
    "detail": "Function (int total_caller_audio_frames_expected =)",
    "insertText": "caller()->audio_frames_received()"
  },
  {
    "label": "caller()",
    "kind": "Method",
    "detail": "Function (total_caller_audio_frames_expected + = media_expectations . caller_audio_frames_expected_ ; } int total_caller_video_frames_expected =)",
    "insertText": "caller()->min_video_frames_received_per_track()"
  },
  {
    "label": "callee()",
    "kind": "Method",
    "detail": "Function (total_caller_video_frames_expected + = media_expectations . caller_video_frames_expected_ ; } int total_callee_audio_frames_expected =)",
    "insertText": "callee()->audio_frames_received()"
  },
  {
    "label": "callee()",
    "kind": "Method",
    "detail": "Function (total_callee_audio_frames_expected + = media_expectations . callee_audio_frames_expected_ ; } int total_callee_video_frames_expected =)",
    "insertText": "callee()->min_video_frames_received_per_track()"
  },
  {
    "label": "EXPECT_TRUE_WAIT()",
    "kind": "Method",
    "detail": "Function (total_callee_video_frames_expected + = media_expectations . callee_video_frames_expected_ ; })",
    "insertText": "EXPECT_TRUE_WAIT(caller()->audio_frames_received() >= total_caller_audio_frames_expected && caller()->min_video_frames_received_per_track() >= total_caller_video_frames_expected && callee()->audio_frames_received() >= total_callee_audio_frames_expected && callee()->min_video_frames_received_per_track() >= total_callee_video_frames_expected, kMaxWaitForFramesMs)"
  },
  {
    "label": "caller()",
    "kind": "Method",
    "detail": "Function (bool expectations_correct =)",
    "insertText": "caller()->audio_frames_received() >= total_caller_audio_frames_expected && caller()->min_video_frames_received_per_track() >= total_caller_video_frames_expected && callee()->audio_frames_received() >= total_callee_audio_frames_expected && callee()->min_video_frames_received_per_track()"
  },
  {
    "label": "EXPECT_GE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_GE(caller()->audio_frames_received(), total_caller_audio_frames_expected)"
  },
  {
    "label": "EXPECT_GE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_GE(caller()->min_video_frames_received_per_track(), total_caller_video_frames_expected)"
  },
  {
    "label": "EXPECT_GE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_GE(callee()->audio_frames_received(), total_callee_audio_frames_expected)"
  },
  {
    "label": "EXPECT_GE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_GE(callee()->min_video_frames_received_per_track(), total_callee_video_frames_expected)"
  },
  {
    "label": "EXPECT_EQ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_EQ(caller()->audio_frames_received(), total_caller_audio_frames_expected)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (expectations_correct = false ; } })",
    "insertText": "if(media_expectations.caller_video_expectation_ == MediaExpectations::kExpectNoFrames)"
  },
  {
    "label": "EXPECT_EQ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_EQ(caller()->min_video_frames_received_per_track(), total_caller_video_frames_expected)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (expectations_correct = false ; } })",
    "insertText": "if(media_expectations.callee_audio_expectation_ == MediaExpectations::kExpectNoFrames)"
  },
  {
    "label": "EXPECT_EQ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_EQ(callee()->audio_frames_received(), total_callee_audio_frames_expected)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (expectations_correct = false ; } })",
    "insertText": "if(media_expectations.callee_video_expectation_ == MediaExpectations::kExpectNoFrames)"
  },
  {
    "label": "EXPECT_EQ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_EQ(callee()->min_video_frames_received_per_track(), total_callee_video_frames_expected)"
  },
  {
    "label": "ClosePeerConnections()",
    "kind": "Method",
    "detail": "Function (expectations_correct = false ; } } return expectations_correct ; } void)",
    "insertText": "ClosePeerConnections()"
  },
  {
    "label": "TestNegotiatedCipherSuite()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "TestNegotiatedCipherSuite(const PeerConnectionFactory::Options& caller_options, const PeerConnectionFactory::Options& callee_options, int expected_cipher_suite)"
  },
  {
    "label": "ASSERT_TRUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ASSERT_TRUE(CreatePeerConnectionWrappersWithOptions(caller_options, callee_options))"
  },
  {
    "label": "caller()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "caller()->AddAudioVideoTracks()"
  },
  {
    "label": "callee()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "callee()->AddAudioVideoTracks()"
  },
  {
    "label": "caller()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "caller()->CreateAndSetAndSignalOffer()"
  },
  {
    "label": "ASSERT_TRUE_WAIT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ASSERT_TRUE_WAIT(DtlsConnected(), kDefaultTimeout)"
  },
  {
    "label": "EXPECT_EQ_WAIT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_EQ_WAIT(rtc::SrtpCryptoSuiteToName(expected_cipher_suite), caller()->OldGetStats()->SrtpCipher(), kDefaultTimeout)"
  },
  {
    "label": "EXPECT_METRIC_EQ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_METRIC_EQ(1, webrtc::metrics::NumEvents( \"WebRTC.PeerConnection.SrtpCryptoSuite.Audio\", expected_cipher_suite))"
  },
  {
    "label": "TestGcmNegotiationUsesCipherSuite()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "TestGcmNegotiationUsesCipherSuite(bool local_gcm_enabled, bool remote_gcm_enabled, bool aes_ctr_enabled, int expected_cipher_suite)"
  },
  {
    "label": "TestNegotiatedCipherSuite()",
    "kind": "Method",
    "detail": "Function (PeerConnectionFactory::Options caller_options ; caller_options . crypto_options . srtp . enable_gcm_crypto_suites = local_gcm_enabled ; caller_options . crypto_options . srtp . enable_aes128_sha1_80_crypto_cipher = aes_ctr_enabled ; PeerConnectionFactory::Options callee_options ; callee_options . crypto_options . srtp . enable_gcm_crypto_suites = remote_gcm_enabled ; callee_options . crypto_options . srtp . enable_aes128_sha1_80_crypto_cipher = aes_ctr_enabled ;)",
    "insertText": "TestNegotiatedCipherSuite(caller_options, callee_options, expected_cipher_suite)"
  },
  {
    "label": "trials()",
    "kind": "Method",
    "detail": "Function (} const FieldTrialsView&)",
    "insertText": "trials()"
  }
]