[
  {
    "label": "SameLeafConfig",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SameLeafConfig"
  },
  {
    "label": "PointIndexLeafNode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PointIndexLeafNode"
  },
  {
    "label": "PointIndexIterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PointIndexIterator"
  },
  {
    "label": "PointIndexFilter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PointIndexFilter"
  },
  {
    "label": "ValidPartitioningOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValidPartitioningOp"
  },
  {
    "label": "PopulateLeafNodesOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PopulateLeafNodesOp"
  },
  {
    "label": "BBoxFilter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BBoxFilter"
  },
  {
    "label": "RadialRangeFilter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RadialRangeFilter"
  },
  {
    "label": "tree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "tree"
  },
  {
    "label": "createPointIndexGrid()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_TOOLS_POINT_INDEX_GRID_HAS_BEEN_INCLUDED # define OPENVDB_TOOLS_POINT_INDEX_GRID_HAS_BEEN_INCLUDED # include \" PointPartitioner . h \" # include<openvdb / version . h> # include<openvdb / Exceptions . h> # include<openvdb / Grid . h> # include<openvdb / Types . h> # include<openvdb / math / Transform . h> # include<openvdb / tree / LeafManager . h> # include<openvdb / tree / LeafNode . h> # include<openvdb / tree / Tree . h> # include<tbb / blocked_range . h> # include<tbb / parallel_for . h> # include<atomic> # include<algorithm> # include<cmath> # include<deque> # include<iostream> # include<type_traits> # include<utility> # include<vector> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace tree { template<Index,> struct SameLeafConfig ; } namespace tools { template<T,Index Log2Dim> struct PointIndexLeafNode ; using PointIndexTree = tree::Tree<tree::RootNode<tree::InternalNode<tree::InternalNode<PointIndexLeafNode<PointIndex32,3>,4>,5>>> ; using PointIndexGrid = Grid<PointIndexTree> ; template<GridT,PointArrayT> GridT::Ptr)",
    "insertText": "createPointIndexGrid(const PointArrayT& points, double voxelSize)"
  },
  {
    "label": "createPointIndexGrid()",
    "kind": "Method",
    "detail": "Function (template<GridT,PointArrayT> GridT::Ptr)",
    "insertText": "createPointIndexGrid(const PointArrayT& points, const math::Transform& xform)"
  },
  {
    "label": "isValidPartition()",
    "kind": "Method",
    "detail": "Function (template<PointArrayT,GridT> bool)",
    "insertText": "isValidPartition(const PointArrayT& points, const GridT& grid)"
  },
  {
    "label": "getValidPointIndexGrid()",
    "kind": "Method",
    "detail": "Function (template<GridT,PointArrayT> GridT::ConstPtr)",
    "insertText": "getValidPointIndexGrid(const PointArrayT& points, const typename GridT::ConstPtr& grid)"
  },
  {
    "label": "getValidPointIndexGrid()",
    "kind": "Method",
    "detail": "Function (template<GridT,PointArrayT> GridT::Ptr)",
    "insertText": "getValidPointIndexGrid(const PointArrayT& points, const typename GridT::Ptr& grid)"
  },
  {
    "label": "PointIndexIterator()",
    "kind": "Method",
    "detail": "Function (template<TreeType = PointIndexTree> struct PointIndexIterator { using ConstAccessor = tree::ValueAccessor<const TreeType> ; using LeafNodeType = TreeType::LeafNodeType ; using ValueType = TreeType::ValueType ;)",
    "insertText": "PointIndexIterator()"
  },
  {
    "label": "PointIndexIterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PointIndexIterator(const PointIndexIterator& rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (PointIndexIterator&)",
    "insertText": "operator(const PointIndexIterator& rhs)"
  },
  {
    "label": "PointIndexIterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PointIndexIterator(const Coord& ijk, ConstAccessor& acc)"
  },
  {
    "label": "PointIndexIterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PointIndexIterator(const CoordBBox& bbox, ConstAccessor& acc)"
  },
  {
    "label": "searchAndUpdate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "searchAndUpdate(const Coord& ijk, ConstAccessor& acc)"
  },
  {
    "label": "searchAndUpdate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "searchAndUpdate(const CoordBBox& bbox, ConstAccessor& acc)"
  },
  {
    "label": "searchAndUpdate()",
    "kind": "Method",
    "detail": "Function (template<PointArray> void)",
    "insertText": "searchAndUpdate(const BBoxd& bbox, ConstAccessor& acc, const PointArray& points, const math::Transform& xform)"
  },
  {
    "label": "searchAndUpdate()",
    "kind": "Method",
    "detail": "Function (template<PointArray> void)",
    "insertText": "searchAndUpdate(const Vec3d& center, double radius, ConstAccessor& acc, const PointArray& points, const math::Transform& xform, bool subvoxelAccuracy = true)"
  },
  {
    "label": "worldSpaceSearchAndUpdate()",
    "kind": "Method",
    "detail": "Function (template<PointArray> void)",
    "insertText": "worldSpaceSearchAndUpdate(const BBoxd& bbox, ConstAccessor& acc, const PointArray& points, const math::Transform& xform)"
  },
  {
    "label": "worldSpaceSearchAndUpdate()",
    "kind": "Method",
    "detail": "Function (template<PointArray> void)",
    "insertText": "worldSpaceSearchAndUpdate(const Vec3d& center, double radius, ConstAccessor& acc, const PointArray& points, const math::Transform& xform, bool subvoxelAccuracy = true)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reset()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (const ValueType&)",
    "insertText": "operator()"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "increment()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "increment()"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "next()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "size()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(const PointIndexIterator& p)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} private : using Range = std::pair<const ValueType*,const ValueType*> ; using RangeDeque = std::deque<Range> ; using RangeDequeCIter = RangeDeque::const_iterator ; using IndexArray = std::unique_ptr<ValueType [ ]> ; void)",
    "insertText": "clear()"
  },
  {
    "label": "PointIndexFilter()",
    "kind": "Method",
    "detail": "Function (Range mRange ; RangeDeque mRangeList ; RangeDequeCIter mIter ; IndexArray mIndexArray ; size_t mIndexArraySize ; } ; template<PointArray,TreeType = PointIndexTree> struct PointIndexFilter { using PosType = PointArray::PosType ; using ScalarType = PosType::value_type ; using ConstAccessor = tree::ValueAccessor<const TreeType> ;)",
    "insertText": "PointIndexFilter(const PointArray& points, const TreeType& tree, const math::Transform& xform)"
  },
  {
    "label": "PointIndexFilter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PointIndexFilter(const PointIndexFilter& rhs)"
  },
  {
    "label": "searchAndApply()",
    "kind": "Method",
    "detail": "Function (template<FilterType> void)",
    "insertText": "searchAndApply(const PosType& center, ScalarType radius, FilterType& op)"
  },
  {
    "label": "ValidPartitioningOp()",
    "kind": "Method",
    "detail": "Function (private : PointArray const* const mPoints ; ConstAccessor mAcc ; const math::Transform mXform ; const ScalarType mInvVoxelSize ; PointIndexIterator<TreeType> mIter ; } ; namespace point_index_grid_internal { template<PointArrayT> struct ValidPartitioningOp {)",
    "insertText": "ValidPartitioningOp(std::atomic<bool>& hasChanged, const PointArrayT& points, const math::Transform& xform) : mPoints(&points) , mTransform(&xform) , mHasChanged(&hasChanged)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<LeafT> void)",
    "insertText": "operator()(LeafT &leaf, size_t)"
  },
  {
    "label": "self()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "self().cancel_group_execution()"
  },
  {
    "label": "getCoord()",
    "kind": "Method",
    "detail": "Function (voxelCoord = iter .)",
    "insertText": "getCoord()"
  },
  {
    "label": "getIndices()",
    "kind": "Method",
    "detail": "Function (leaf .)",
    "insertText": "getIndices(iter.pos(), begin, end)"
  },
  {
    "label": "getPos()",
    "kind": "Method",
    "detail": "Function (mPoints ->)",
    "insertText": "getPos(*begin, point)"
  },
  {
    "label": "store()",
    "kind": "Method",
    "detail": "Function (mHasChanged ->)",
    "insertText": "store(true)"
  },
  {
    "label": "PopulateLeafNodesOp()",
    "kind": "Method",
    "detail": "Function (break ; } + + begin ; } } } private : PointArrayT const* const mPoints ; math::Transform const* const mTransform ; std::atomic<bool>* const mHasChanged ; } ; template<LeafNodeT> struct PopulateLeafNodesOp { using IndexT = uint32_t ; using Partitioner = PointPartitioner<IndexT,LeafNodeT::LOG2DIM> ;)",
    "insertText": "PopulateLeafNodesOp(std::unique_ptr<LeafNodeT*[]>& leafNodes, const Partitioner& partitioner) : mLeafNodes(leafNodes.get()) , mPartitioner(&partitioner)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()(const tbb::blocked_range<size_t>& range)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (using VoxelOffsetT = Partitioner::VoxelOffsetType ; size_t maxPointCount = 0 ;)",
    "insertText": "for(size_t n = range.begin(), N = range.end(); n != N; ++n)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (maxPointCount =)",
    "insertText": "max(maxPointCount, mPartitioner->indices(n).size())"
  },
  {
    "label": "voxelOffsets()",
    "kind": "Method",
    "detail": "Function (} const IndexT voxelCount = LeafNodeT::SIZE ; std::unique_ptr<VoxelOffsetT [ ]> offsets { new VoxelOffsetT [ maxPointCount ] } ; std::unique_ptr<IndexT [ ]> histogram { new IndexT [ voxelCount ] } ; VoxelOffsetT const* const voxelOffsets = mPartitioner ->)",
    "insertText": "voxelOffsets().get()"
  },
  {
    "label": "LeafNodeT()",
    "kind": "Method",
    "detail": "Function (LeafNodeT* node = new)",
    "insertText": "LeafNodeT()"
  },
  {
    "label": "setOrigin()",
    "kind": "Method",
    "detail": "Function (node ->)",
    "insertText": "setOrigin(mPartitioner->origin(n))"
  },
  {
    "label": "indices()",
    "kind": "Method",
    "detail": "Function (Partitioner::IndexIterator it = mPartitioner ->)",
    "insertText": "indices(n)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (IndexT const* const indices =&* it ;)",
    "insertText": "for(IndexT i = 0; i < pointCount; ++i)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (offsets [ i ] = voxelOffsets [ indices [ i ] ] ; })",
    "insertText": "memset(&histogram[0], 0, voxelCount * sizeof(IndexT))"
  },
  {
    "label": "getValueMask()",
    "kind": "Method",
    "detail": "Function (+ + histogram [ offsets [ i ] ] ; } LeafNodeT::NodeMaskType& mask = node ->)",
    "insertText": "getValueMask()"
  },
  {
    "label": "buffer()",
    "kind": "Method",
    "detail": "Function (LeafNodeT::Buffer& buffer = node ->)",
    "insertText": "buffer()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (IndexT count = 0,startOffset ;)",
    "insertText": "for(int i = 0; i < int(voxelCount); ++i)"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (startOffset = count ; count + = histogram [ i ] ; histogram [ i ] = startOffset ; mask .)",
    "insertText": "setOn(i)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} buffer .)",
    "insertText": "setValue(i, count)"
  },
  {
    "label": "indices()",
    "kind": "Method",
    "detail": "Function (} node ->)",
    "insertText": "indices().resize(pointCount)"
  },
  {
    "label": "indices()",
    "kind": "Method",
    "detail": "Function (LeafNodeT::ValueType* const orderedIndices = node ->)",
    "insertText": "indices().data()"
  },
  {
    "label": "constructPointTree()",
    "kind": "Method",
    "detail": "Function (orderedIndices [ histogram [ offsets [ i ] ] + + ] = indices [ i ] ; } mLeafNodes [ n ] = node ; } } LeafNodeT** const mLeafNodes ; Partitioner const* const mPartitioner ; } ; template<TreeType,PointArray> void)",
    "insertText": "constructPointTree(TreeType& tree, const math::Transform& xform, const PointArray& points)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (using LeafType = TreeType::LeafNodeType ; std::unique_ptr<LeafType* [ ]> leafNodes ; size_t leafNodeCount = 0 ; { PointPartitioner<uint32_t,LeafType::LOG2DIM> partitioner ; partitioner .)",
    "insertText": "construct(points, xform, false, true)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(LookupError, \"The PointIndexGrid requires a \" \"cell-centered transform.\")"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (leafNodes .)",
    "insertText": "reset(new LeafType*[leafNodeCount])"
  },
  {
    "label": "range()",
    "kind": "Method",
    "detail": "Function (const tbb::blocked_range<size_t>)",
    "insertText": "range(0, leafNodeCount)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(range, PopulateLeafNodesOp<LeafType>(leafNodes, partitioner))"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (} tree::ValueAccessor<TreeType>)",
    "insertText": "acc(tree)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (acc .)",
    "insertText": "addLeaf(leafNodes[n])"
  },
  {
    "label": "dequeToArray()",
    "kind": "Method",
    "detail": "Function (} } template<T> void)",
    "insertText": "dequeToArray(const std::deque<T>& d, std::unique_ptr<T[]>& a, size_t& size)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (a .)",
    "insertText": "reset(new T[size])"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (std::deque<T>::const_iterator it = d .)",
    "insertText": "begin(), itEnd = d.end()"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (T* item = a .)",
    "insertText": "get()"
  },
  {
    "label": "constructExclusiveRegions()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "constructExclusiveRegions(std::vector<CoordBBox>& regions, const CoordBBox& bbox, const CoordBBox& ibox)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (regions .)",
    "insertText": "reserve(6)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (Coord cmin = ibox .)",
    "insertText": "min()"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (Coord cmax = ibox .)",
    "insertText": "max()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (regions .)",
    "insertText": "push_back(bbox)"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (regions .)",
    "insertText": "back().max().z() = cmin.z()"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (regions .)",
    "insertText": "back().min().z() = cmax.z()"
  },
  {
    "label": "z()",
    "kind": "Method",
    "detail": "Function (- - cmax .)",
    "insertText": "z()"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (CoordBBox* lastRegion =& regions .)",
    "insertText": "back()"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (lastRegion ->)",
    "insertText": "min().z() = cmin.z()"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (lastRegion ->)",
    "insertText": "max().z() = cmax.z()"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (lastRegion ->)",
    "insertText": "max().x() = cmin.x()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (regions .)",
    "insertText": "push_back(*lastRegion)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (lastRegion ->)",
    "insertText": "min().x() = cmax.x()"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (lastRegion ->)",
    "insertText": "max().x() = bbox.max().x()"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (- - cmax .)",
    "insertText": "x()"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (lastRegion ->)",
    "insertText": "min().x() = cmin.x()"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (lastRegion ->)",
    "insertText": "max().x() = cmax.x()"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (lastRegion ->)",
    "insertText": "max().y() = cmin.y()"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (lastRegion ->)",
    "insertText": "min().y() = cmax.y()"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (lastRegion ->)",
    "insertText": "max().y() = bbox.max().y()"
  },
  {
    "label": "BBoxFilter()",
    "kind": "Method",
    "detail": "Function (} template<PointArray,IndexT> struct BBoxFilter { using PosType = PointArray::PosType ; using ScalarType = PosType::value_type ; using Range = std::pair<const IndexT*,const IndexT*> ; using RangeDeque = std::deque<Range> ; using IndexDeque = std::deque<IndexT> ;)",
    "insertText": "BBoxFilter(RangeDeque& ranges, IndexDeque& indices, const BBoxd& bbox, const PointArray& points, const math::Transform& xform) : mRanges(ranges) , mIndices(indices) , mRegion(bbox) , mPoints(points) , mMap(*xform.baseMap())"
  },
  {
    "label": "filterLeafNode()",
    "kind": "Method",
    "detail": "Function (} template<LeafNodeType> void)",
    "insertText": "filterLeafNode(const LeafNodeType& leaf)"
  },
  {
    "label": "IndexT()",
    "kind": "Method",
    "detail": "Function (LeafNodeType::ValueOnCIter iter ; const IndexT* begin = static_cast<)",
    "insertText": "IndexT(nullptr), *end = static_cast<IndexT*>(nullptr)"
  },
  {
    "label": "filterVoxel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "filterVoxel(iter.getCoord(), begin, end)"
  },
  {
    "label": "filterVoxel()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "filterVoxel(const Coord&, const IndexT* begin, const IndexT* end)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (PosType vec ;)",
    "insertText": "for(; begin < end; ++begin)"
  },
  {
    "label": "getPos()",
    "kind": "Method",
    "detail": "Function (mPoints .)",
    "insertText": "getPos(*begin, vec)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (mIndices .)",
    "insertText": "push_back(*begin)"
  },
  {
    "label": "RadialRangeFilter()",
    "kind": "Method",
    "detail": "Function (} } } private : RangeDeque& mRanges ; IndexDeque& mIndices ; const BBoxd mRegion ; const PointArray& mPoints ; const math::MapBase& mMap ; } ; template<PointArray,IndexT> struct RadialRangeFilter { using PosType = PointArray::PosType ; using ScalarType = PosType::value_type ; using Range = std::pair<const IndexT*,const IndexT*> ; using RangeDeque = std::deque<Range> ; using IndexDeque = std::deque<IndexT> ;)",
    "insertText": "RadialRangeFilter(RangeDeque& ranges, IndexDeque& indices, const Vec3d& xyz, double radius, const PointArray& points, const math::Transform& xform, const double leafNodeDim, const bool subvoxelAccuracy) : mRanges(ranges) , mIndices(indices) , mCenter(xyz) , mWSCenter(xform.indexToWorld(xyz)) , mVoxelDist1(ScalarType(0.0)) , mVoxelDist2(ScalarType(0.0)) , mLeafNodeDist1(ScalarType(0.0)) , mLeafNodeDist2(ScalarType(0.0)) , mWSRadiusSqr(ScalarType(radius * xform.voxelSize()[0])) , mPoints(points) , mSubvoxelAccuracy(subvoxelAccuracy)"
  },
  {
    "label": "ScalarType()",
    "kind": "Method",
    "detail": "Function (const ScalarType voxelRadius =)",
    "insertText": "ScalarType(std::sqrt(3.0) * 0.5)"
  },
  {
    "label": "ScalarType()",
    "kind": "Method",
    "detail": "Function (mVoxelDist1 = voxelRadius +)",
    "insertText": "ScalarType(radius)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mVoxelDist1* = mVoxelDist1 ;)",
    "insertText": "if(radius > voxelRadius)"
  },
  {
    "label": "ScalarType()",
    "kind": "Method",
    "detail": "Function (mVoxelDist2* = mVoxelDist2 ; } const ScalarType leafNodeRadius =)",
    "insertText": "ScalarType(leafNodeDim * std::sqrt(3.0) * 0.5)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mLeafNodeDist1* = mLeafNodeDist1 ;)",
    "insertText": "if(radius > leafNodeRadius)"
  },
  {
    "label": "origin()",
    "kind": "Method",
    "detail": "Function ({ const Coord& ijk = leaf .)",
    "insertText": "origin()"
  },
  {
    "label": "ScalarType()",
    "kind": "Method",
    "detail": "Function (PosType vec ; vec [ 0 ] =)",
    "insertText": "ScalarType(ijk[0])"
  },
  {
    "label": "ScalarType()",
    "kind": "Method",
    "detail": "Function (vec [ 1 ] =)",
    "insertText": "ScalarType(ijk[1])"
  },
  {
    "label": "ScalarType()",
    "kind": "Method",
    "detail": "Function (vec [ 2 ] =)",
    "insertText": "ScalarType(ijk[2])"
  },
  {
    "label": "ScalarType()",
    "kind": "Method",
    "detail": "Function (vec + =)",
    "insertText": "ScalarType(LeafNodeType::DIM - 1)"
  },
  {
    "label": "lengthSqr()",
    "kind": "Method",
    "detail": "Function (vec - = mCenter ; const ScalarType dist = vec .)",
    "insertText": "lengthSqr()"
  },
  {
    "label": "indices()",
    "kind": "Method",
    "detail": "Function (const IndexT* begin =& leaf .)",
    "insertText": "indices().front()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (mRanges .)",
    "insertText": "push_back(Range(begin, begin + leaf.indices().size()))"
  },
  {
    "label": "filterVoxel()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "filterVoxel(const Coord& ijk, const IndexT* begin, const IndexT* end)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} else { mRanges .)",
    "insertText": "push_back(Range(begin, end))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} return ; } })",
    "insertText": "while(begin < end)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (vec = mWSCenter - vec ;)",
    "insertText": "if(vec.lengthSqr() < mWSRadiusSqr)"
  },
  {
    "label": "filteredPointIndexSearchVoxels()",
    "kind": "Method",
    "detail": "Function (} + + begin ; } } private : RangeDeque& mRanges ; IndexDeque& mIndices ; const PosType mCenter,mWSCenter ; ScalarType mVoxelDist1,mVoxelDist2,mLeafNodeDist1,mLeafNodeDist2,mWSRadiusSqr ; const PointArray& mPoints ; const bool mSubvoxelAccuracy ; } ; template<RangeFilterType,LeafNodeType> void)",
    "insertText": "filteredPointIndexSearchVoxels(RangeFilterType& filter, const LeafNodeType& leaf, const Coord& min, const Coord& max)"
  },
  {
    "label": "xPos()",
    "kind": "Method",
    "detail": "Function (using PointIndexT = LeafNodeType::ValueType ; Index)",
    "insertText": "xPos(0), yPos(0), pos(0)"
  },
  {
    "label": "ijk()",
    "kind": "Method",
    "detail": "Function (Coord)",
    "insertText": "ijk(0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (PointIndexT beginOffset,endOffset ;)",
    "insertText": "for(ijk[0] = min[0]; ijk[0] <= max[0]; ++ijk[0])"
  },
  {
    "label": "xPos()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "xPos(ijk[0] & (LeafNodeType::DIM - 1u)) << (2 * LeafNodeType::LOG2DIM)"
  },
  {
    "label": "xPos()",
    "kind": "Method",
    "detail": "Function (yPos =)",
    "insertText": "xPos((ijk[1] & (LeafNodeType::DIM - 1u)) << LeafNodeType::LOG2DIM)"
  },
  {
    "label": "yPos()",
    "kind": "Method",
    "detail": "Function (pos =)",
    "insertText": "yPos(ijk[2] & (LeafNodeType::DIM - 1u))"
  },
  {
    "label": "beginOffset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "beginOffset(pos == 0 ? PointIndexT(0) : leaf.getValue(pos - 1))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (endOffset = leaf .)",
    "insertText": "getValue(pos)"
  },
  {
    "label": "filterVoxel()",
    "kind": "Method",
    "detail": "Function (filter .)",
    "insertText": "filterVoxel(ijk, dataPtr + beginOffset, dataPtr + endOffset)"
  },
  {
    "label": "filteredPointIndexSearch()",
    "kind": "Method",
    "detail": "Function (} } } } } template<RangeFilterType,ConstAccessor> void)",
    "insertText": "filteredPointIndexSearch(RangeFilterType& filter, ConstAccessor& acc, const CoordBBox& bbox)"
  },
  {
    "label": "ijk()",
    "kind": "Method",
    "detail": "Function (using LeafNodeType = ConstAccessor::TreeType::LeafNodeType ; Coord)",
    "insertText": "ijk(0), ijkMax(0), ijkA(0), ijkB(0)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (const Coord leafMin = bbox .)",
    "insertText": "min() & ~(LeafNodeType::DIM - 1)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (const Coord leafMax = bbox .)",
    "insertText": "max() & ~(LeafNodeType::DIM - 1)"
  },
  {
    "label": "offset()",
    "kind": "Method",
    "detail": "Function (ijkMax = ijk ; ijkMax .)",
    "insertText": "offset(LeafNodeType::DIM - 1)"
  },
  {
    "label": "maxComponent()",
    "kind": "Method",
    "detail": "Function (ijkA =)",
    "insertText": "maxComponent(bbox.min(), ijk)"
  },
  {
    "label": "minComponent()",
    "kind": "Method",
    "detail": "Function (ijkB =)",
    "insertText": "minComponent(bbox.max(), ijkMax)"
  },
  {
    "label": "filteredPointIndexSearchVoxels()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "filteredPointIndexSearchVoxels(filter, *leaf, ijkA, ijkB)"
  },
  {
    "label": "filterLeafNode()",
    "kind": "Method",
    "detail": "Function (} else { filter .)",
    "insertText": "filterLeafNode(*leaf)"
  },
  {
    "label": "pointIndexSearchVoxels()",
    "kind": "Method",
    "detail": "Function (} } } } } } template<RangeDeque,LeafNodeType> void)",
    "insertText": "pointIndexSearchVoxels(RangeDeque& rangeList, const LeafNodeType& leaf, const Coord& min, const Coord& max)"
  },
  {
    "label": "xPos()",
    "kind": "Method",
    "detail": "Function (using PointIndexT = LeafNodeType::ValueType ; using IntT = PointIndexT::IntType ; using Range = RangeDeque::value_type ; Index)",
    "insertText": "xPos(0), pos(0), zStride = Index(max[2] - min[2])"
  },
  {
    "label": "beginOffset()",
    "kind": "Method",
    "detail": "Function (PointIndexT)",
    "insertText": "beginOffset(0), endOffset(0), previousOffset(static_cast<IntT>(leaf.indices().size() + 1u))"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pos(min[2] & (LeafNodeType::DIM - 1u))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (endOffset = leaf .)",
    "insertText": "getValue(pos+zStride)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} else { rangeList .)",
    "insertText": "push_back(Range(dataPtr + beginOffset, dataPtr + endOffset))"
  },
  {
    "label": "pointIndexSearch()",
    "kind": "Method",
    "detail": "Function (} previousOffset = endOffset ; } } } } template<RangeDeque,ConstAccessor> void)",
    "insertText": "pointIndexSearch(RangeDeque& rangeList, ConstAccessor& acc, const CoordBBox& bbox)"
  },
  {
    "label": "pointIndexSearchVoxels()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pointIndexSearchVoxels(rangeList, *leaf, ijkA, ijkB)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (rangeList .)",
    "insertText": "push_back(Range(begin, (begin + leaf->indices().size())))"
  },
  {
    "label": "PointIndexIterator()",
    "kind": "Method",
    "detail": "Function (} } } } } } } template<TreeType> PointIndexIterator<TreeType)",
    "insertText": "PointIndexIterator() : mRange(static_cast<ValueType*>(nullptr), static_cast<ValueType*>(nullptr)) , mRangeList() , mIter(mRangeList.begin()) , mIndexArray() , mIndexArraySize(0)"
  },
  {
    "label": "PointIndexIterator()",
    "kind": "Method",
    "detail": "Function (} template<TreeType> PointIndexIterator<TreeType)",
    "insertText": "PointIndexIterator(const PointIndexIterator& rhs) : mRange(rhs.mRange) , mRangeList(rhs.mRangeList) , mIter(mRangeList.begin()) , mIndexArray() , mIndexArraySize(rhs.mIndexArraySize)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (mIndexArray .)",
    "insertText": "reset(new ValueType[mIndexArraySize])"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(mIndexArray.get(), rhs.mIndexArray.get(), mIndexArraySize * sizeof(ValueType))"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (mRange = rhs . mRange ; mRangeList = rhs . mRangeList ; mIter = mRangeList .)",
    "insertText": "begin()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mIndexArraySize = rhs . mIndexArraySize ;)",
    "insertText": "if(rhs.mIndexArray)"
  },
  {
    "label": "PointIndexIterator()",
    "kind": "Method",
    "detail": "Function (} } return* this ; } template<TreeType> PointIndexIterator<TreeType)",
    "insertText": "PointIndexIterator(const Coord& ijk, ConstAccessor& acc) : mRange(static_cast<ValueType*>(nullptr), static_cast<ValueType*>(nullptr)) , mRangeList() , mIter(mRangeList.begin()) , mIndexArray() , mIndexArraySize(0)"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (const LeafNodeType* leaf = acc .)",
    "insertText": "probeConstLeaf(ijk)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (mRangeList .)",
    "insertText": "push_back(mRange)"
  },
  {
    "label": "PointIndexIterator()",
    "kind": "Method",
    "detail": "Function (} } template<TreeType> PointIndexIterator<TreeType)",
    "insertText": "PointIndexIterator(const CoordBBox& bbox, ConstAccessor& acc) : mRange(static_cast<ValueType*>(nullptr), static_cast<ValueType*>(nullptr)) , mRangeList() , mIter(mRangeList.begin()) , mIndexArray() , mIndexArraySize(0)"
  },
  {
    "label": "pointIndexSearch()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pointIndexSearch(mRangeList, acc, bbox)"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (mRange = mRangeList .)",
    "insertText": "front()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(mIndexArray)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (mRange . second = mRange . first + mIndexArraySize ; } else { mRange . first = static_cast<)",
    "insertText": "ValueType(nullptr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + mRange . first ;)",
    "insertText": "if(mRange.first >= mRange.second && mIter != mRangeList.end())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + mIter ;)",
    "insertText": "if(mIter != mRangeList.end())"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (mIter = mRangeList .)",
    "insertText": "end()"
  },
  {
    "label": "region()",
    "kind": "Method",
    "detail": "Function (std::vector<CoordBBox> searchRegions ; CoordBBox)",
    "insertText": "region(Coord::round(bbox.min()), Coord::round(bbox.max()))"
  },
  {
    "label": "dim()",
    "kind": "Method",
    "detail": "Function (const Coord dim = region .)",
    "insertText": "dim()"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (const int minExtent =)",
    "insertText": "min(dim[0], std::min(dim[1], dim[2]))"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (CoordBBox ibox = region ; ibox .)",
    "insertText": "expand(-1)"
  },
  {
    "label": "pointIndexSearch()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pointIndexSearch(mRangeList, acc, ibox)"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (ibox .)",
    "insertText": "expand(1)"
  },
  {
    "label": "constructExclusiveRegions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "constructExclusiveRegions(searchRegions, region, ibox)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} else { searchRegions .)",
    "insertText": "push_back(region)"
  },
  {
    "label": "filter()",
    "kind": "Method",
    "detail": "Function (} std::deque<ValueType> filteredIndices ; point_index_grid_internal::BBoxFilter<PointArray,ValueType>)",
    "insertText": "filter(mRangeList, filteredIndices, bbox, points, xform)"
  },
  {
    "label": "filteredPointIndexSearch()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "filteredPointIndexSearch(filter, acc, searchRegions[n])"
  },
  {
    "label": "dequeToArray()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "dequeToArray(filteredIndices, mIndexArray, mIndexArraySize)"
  },
  {
    "label": "searchAndUpdate()",
    "kind": "Method",
    "detail": "Function (} template<TreeType> template<PointArray> void PointIndexIterator<TreeType)",
    "insertText": "searchAndUpdate(const Vec3d& center, double radius, ConstAccessor& acc, const PointArray& points, const math::Transform& xform, bool subvoxelAccuracy)"
  },
  {
    "label": "bbox()",
    "kind": "Method",
    "detail": "Function (std::vector<CoordBBox> searchRegions ; CoordBBox)",
    "insertText": "bbox(Coord::round(Vec3d(center[0] - radius, center[1] - radius, center[2] - radius)), Coord::round(Vec3d(center[0] + radius, center[1] + radius, center[2] + radius)))"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (const double iRadius = radius*)",
    "insertText": "double(1.0 / std::sqrt(3.0))"
  },
  {
    "label": "ibox()",
    "kind": "Method",
    "detail": "Function (CoordBBox)",
    "insertText": "ibox(Coord::round(Vec3d(center[0] - iRadius, center[1] - iRadius, center[2] - iRadius)), Coord::round(Vec3d(center[0] + iRadius, center[1] + iRadius, center[2] + iRadius)))"
  },
  {
    "label": "constructExclusiveRegions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "constructExclusiveRegions(searchRegions, bbox, ibox)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (} std::deque<ValueType> filteredIndices ; const double leafNodeDim =)",
    "insertText": "double(TreeType::LeafNodeType::DIM)"
  },
  {
    "label": "filter()",
    "kind": "Method",
    "detail": "Function (using FilterT = point_index_grid_internal::RadialRangeFilter<PointArray,ValueType> ; FilterT)",
    "insertText": "filter(mRangeList, filteredIndices, center, radius, points, xform, leafNodeDim, subvoxelAccuracy)"
  },
  {
    "label": "searchAndUpdate()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "searchAndUpdate(BBoxd(xform.worldToIndex(bbox.min()), xform.worldToIndex(bbox.max())), acc, points, xform)"
  },
  {
    "label": "worldSpaceSearchAndUpdate()",
    "kind": "Method",
    "detail": "Function (} template<TreeType> template<PointArray> void PointIndexIterator<TreeType)",
    "insertText": "worldSpaceSearchAndUpdate(const Vec3d& center, double radius, ConstAccessor& acc, const PointArray& points, const math::Transform& xform, bool subvoxelAccuracy)"
  },
  {
    "label": "searchAndUpdate()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "searchAndUpdate(xform.worldToIndex(center), (radius / xform.voxelSize()[0]), acc, points, xform, subvoxelAccuracy)"
  },
  {
    "label": "PointIndexFilter()",
    "kind": "Method",
    "detail": "Function (} template<PointArray,TreeType> PointIndexFilter<PointArray,TreeType)",
    "insertText": "PointIndexFilter(const PointArray& points, const TreeType& tree, const math::Transform& xform) : mPoints(&points), mAcc(tree), mXform(xform), mInvVoxelSize(1.0/xform.voxelSize()[0])"
  },
  {
    "label": "PointIndexFilter()",
    "kind": "Method",
    "detail": "Function (} template<PointArray,TreeType> PointIndexFilter<PointArray,TreeType)",
    "insertText": "PointIndexFilter(const PointIndexFilter& rhs) : mPoints(rhs.mPoints) , mAcc(rhs.mAcc.tree()) , mXform(rhs.mXform) , mInvVoxelSize(rhs.mInvVoxelSize)"
  },
  {
    "label": "searchAndUpdate()",
    "kind": "Method",
    "detail": "Function (mIter .)",
    "insertText": "searchAndUpdate(openvdb::CoordBBox( mXform.worldToIndexCellCentered(center - radius), mXform.worldToIndexCellCentered(center + radius)), mAcc)"
  },
  {
    "label": "worldSpaceSearchAndUpdate()",
    "kind": "Method",
    "detail": "Function (} else { mIter .)",
    "insertText": "worldSpaceSearchAndUpdate(center, radius, mAcc, *mPoints, mXform, false)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} const ScalarType radiusSqr = radius* radius ; ScalarType distSqr = 0 . 0 ; PosType pos ;)",
    "insertText": "for(; mIter; ++mIter)"
  },
  {
    "label": "getPos()",
    "kind": "Method",
    "detail": "Function (mPoints ->)",
    "insertText": "getPos(*mIter, pos)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(distSqr, *mIter)"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (GridT::Ptr grid =)",
    "insertText": "create(typename GridT::ValueType(0))"
  },
  {
    "label": "setTransform()",
    "kind": "Method",
    "detail": "Function (grid ->)",
    "insertText": "setTransform(xform.copy())"
  },
  {
    "label": "constructPointTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "constructPointTree(grid->tree(), grid->transform(), points)"
  },
  {
    "label": "createLinearTransform()",
    "kind": "Method",
    "detail": "Function (math::Transform::Ptr xform = math::)",
    "insertText": "createLinearTransform(voxelSize)"
  },
  {
    "label": "leafs()",
    "kind": "Method",
    "detail": "Function (tree::LeafManager<const GridT::TreeType>)",
    "insertText": "leafs(grid.tree())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t pointCount = 0 ;)",
    "insertText": "for(size_t n = 0, N = leafs.leafCount(); n < N; ++n)"
  },
  {
    "label": "leaf()",
    "kind": "Method",
    "detail": "Function (pointCount + = leafs .)",
    "insertText": "leaf(n).indices().size()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(points.size() != pointCount)"
  },
  {
    "label": "foreach()",
    "kind": "Method",
    "detail": "Function (leafs .)",
    "insertText": "foreach(op)"
  },
  {
    "label": "indices()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> struct PointIndexLeafNode : public tree::LeafNode<T,Log2Dim> { using LeafNodeType = PointIndexLeafNode<T,Log2Dim> ; using Ptr = SharedPtr<PointIndexLeafNode> ; using ValueType = T ; using IndexArray = std::vector<ValueType> ; IndexArray&)",
    "insertText": "indices()"
  },
  {
    "label": "getIndices()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "getIndices(Index offset, const ValueType*& begin, const ValueType*& end)"
  },
  {
    "label": "setOffsetOn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setOffsetOn(Index offset, const ValueType& val)"
  },
  {
    "label": "setOffsetOnly()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setOffsetOnly(Index offset, const ValueType& val)"
  },
  {
    "label": "isEmpty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isEmpty(const CoordBBox& bbox)"
  },
  {
    "label": "PointIndexLeafNode()",
    "kind": "Method",
    "detail": "Function (private : IndexArray mIndices ; public : using BaseLeaf = tree::LeafNode<T,Log2Dim> ; using NodeMaskType = util::NodeMask<Log2Dim> ; using BaseLeaf::LOG2DIM ; using BaseLeaf::TOTAL ; using BaseLeaf::DIM ; using BaseLeaf::NUM_VALUES ; using BaseLeaf::NUM_VOXELS ; using BaseLeaf::SIZE ; using BaseLeaf::LEVEL ;)",
    "insertText": "PointIndexLeafNode() : BaseLeaf(), mIndices()"
  },
  {
    "label": "PointIndexLeafNode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PointIndexLeafNode(const Coord& coords, const T& value = zeroVal<T>(), bool active = false) : BaseLeaf(coords, value, active) , mIndices()"
  },
  {
    "label": "PointIndexLeafNode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PointIndexLeafNode(PartialCreate, const Coord& coords, const T& value = zeroVal<T>(), bool active = false) : BaseLeaf(PartialCreate(), coords, value, active) , mIndices()"
  },
  {
    "label": "PointIndexLeafNode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PointIndexLeafNode(const PointIndexLeafNode& rhs) : BaseLeaf(rhs), mIndices(rhs.mIndices)"
  },
  {
    "label": "hasSameTopology()",
    "kind": "Method",
    "detail": "Function (} template<OtherType,Index OtherLog2Dim> bool)",
    "insertText": "hasSameTopology(const PointIndexLeafNode<OtherType, OtherLog2Dim>* other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const PointIndexLeafNode& other)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (} template<MergePolicy Policy> void)",
    "insertText": "merge(const PointIndexLeafNode& rhs)"
  },
  {
    "label": "Policy()",
    "kind": "Method",
    "detail": "Function (BaseLeaf::merge<)",
    "insertText": "Policy(rhs)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (} template<MergePolicy Policy> void)",
    "insertText": "merge(const ValueType& tileValue, bool tileActive)"
  },
  {
    "label": "Policy()",
    "kind": "Method",
    "detail": "Function (BaseLeaf::template merge<)",
    "insertText": "Policy(tileValue, tileActive)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (} template<MergePolicy Policy> void)",
    "insertText": "merge(const PointIndexLeafNode& other, const ValueType& , const ValueType&)"
  },
  {
    "label": "Policy()",
    "kind": "Method",
    "detail": "Function (BaseLeaf::template merge<)",
    "insertText": "Policy(other)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addLeaf(PointIndexLeafNode*)"
  },
  {
    "label": "addLeafAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> void)",
    "insertText": "addLeafAndCache(PointIndexLeafNode*, AccessorT&)"
  },
  {
    "label": "touchLeaf()",
    "kind": "Method",
    "detail": "Function (} PointIndexLeafNode*)",
    "insertText": "touchLeaf(const Coord&)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN)",
    "insertText": "if(!(std::is_same<NodeT, PointIndexLeafNode>::value))"
  },
  {
    "label": "probeLeaf()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_END } PointIndexLeafNode*)",
    "insertText": "probeLeaf(const Coord&)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_END } void)",
    "insertText": "readBuffers(std::istream& is, bool fromHalf = false)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(std::istream& is, const CoordBBox&, bool fromHalf = false)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeBuffers(std::ostream& os, bool toHalf = false)"
  },
  {
    "label": "memUsage()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "memUsage()"
  },
  {
    "label": "assertNonmodifiable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assertNonmodifiable()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(false && \"Cannot modify voxel values in a PointIndexTree.\")"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setActiveState(const Coord&, bool)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setActiveState(Index, bool)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOnly(const Coord&, const ValueType&)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOnly(Index, const ValueType&)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOff(const Coord&)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOff(Index)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOff(const Coord&, const ValueType&)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOff(Index, const ValueType&)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOn(const Coord&)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOn(Index)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOn(const Coord&, const ValueType&)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOn(Index, const ValueType&)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValue(const Coord&, const ValueType&)"
  },
  {
    "label": "setValuesOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValuesOn()"
  },
  {
    "label": "setValuesOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValuesOff()"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp> void)",
    "insertText": "modifyValue(Index, const ModifyOp&)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp> void)",
    "insertText": "modifyValue(const Coord&, const ModifyOp&)"
  },
  {
    "label": "modifyValueAndActiveState()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp> void)",
    "insertText": "modifyValueAndActiveState(const Coord&, const ModifyOp&)"
  },
  {
    "label": "clip()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "clip(const CoordBBox&, const ValueType&)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "fill(const CoordBBox&, const ValueType&, bool)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "fill(const ValueType&)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "fill(const ValueType&, bool)"
  },
  {
    "label": "setValueOnlyAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> void)",
    "insertText": "setValueOnlyAndCache(const Coord&, const ValueType&, AccessorT&)"
  },
  {
    "label": "modifyValueAndActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp,AccessorT> void)",
    "insertText": "modifyValueAndActiveStateAndCache(const Coord&, const ModifyOp&, AccessorT&)"
  },
  {
    "label": "setValueOffAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> void)",
    "insertText": "setValueOffAndCache(const Coord&, const ValueType&, AccessorT&)"
  },
  {
    "label": "setActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> void)",
    "insertText": "setActiveStateAndCache(const Coord&, bool, AccessorT&)"
  },
  {
    "label": "resetBackground()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resetBackground(const ValueType&, const ValueType&)"
  },
  {
    "label": "signedFloodFill()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "signedFloodFill(const ValueType&)"
  },
  {
    "label": "signedFloodFill()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "signedFloodFill(const ValueType&, const ValueType&)"
  },
  {
    "label": "negate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "negate()"
  },
  {
    "label": "getValueMask()",
    "kind": "Method",
    "detail": "Function (} protected : using ValueOn = BaseLeaf::ValueOn ; using ValueOff = BaseLeaf::ValueOff ; using ValueAll = BaseLeaf::ValueAll ; using ChildOn = BaseLeaf::ChildOn ; using ChildOff = BaseLeaf::ChildOff ; using ChildAll = BaseLeaf::ChildAll ; using MaskOnIterator = NodeMaskType::OnIterator ; using MaskOffIterator = NodeMaskType::OffIterator ; using MaskDenseIterator = NodeMaskType::DenseIterator ; template<,Index> struct PointIndexLeafNode ; class tree::IteratorBase<MaskOnIterator,PointIndexLeafNode> ; class tree::IteratorBase<MaskOffIterator,PointIndexLeafNode> ; class tree::IteratorBase<MaskDenseIterator,PointIndexLeafNode> ; public : using ValueOnIter = BaseLeaf::template ValueIter<MaskOnIterator,PointIndexLeafNode,const ValueType,ValueOn> ; using ValueOnCIter = BaseLeaf::template ValueIter<MaskOnIterator,const PointIndexLeafNode,const ValueType,ValueOn> ; using ValueOffIter = BaseLeaf::template ValueIter<MaskOffIterator,PointIndexLeafNode,const ValueType,ValueOff> ; using ValueOffCIter = BaseLeaf::template ValueIter<MaskOffIterator,const PointIndexLeafNode,const ValueType,ValueOff> ; using ValueAllIter = BaseLeaf::template ValueIter<MaskDenseIterator,PointIndexLeafNode,const ValueType,ValueAll> ; using ValueAllCIter = BaseLeaf::template ValueIter<MaskDenseIterator,const PointIndexLeafNode,const ValueType,ValueAll> ; using ChildOnIter = BaseLeaf::template ChildIter<MaskOnIterator,PointIndexLeafNode,ChildOn> ; using ChildOnCIter = BaseLeaf::template ChildIter<MaskOnIterator,const PointIndexLeafNode,ChildOn> ; using ChildOffIter = BaseLeaf::template ChildIter<MaskOffIterator,PointIndexLeafNode,ChildOff> ; using ChildOffCIter = BaseLeaf::template ChildIter<MaskOffIterator,const PointIndexLeafNode,ChildOff> ; using ChildAllIter = BaseLeaf::template DenseIter<PointIndexLeafNode,ValueType,ChildAll> ; using ChildAllCIter = BaseLeaf::template DenseIter<const PointIndexLeafNode,const ValueType,ChildAll> ; # define VMASK_ this ->)",
    "insertText": "getValueMask() ValueOnCIter cbeginValueOn()"
  },
  {
    "label": "beginValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnCIter)",
    "insertText": "beginValueOn()"
  },
  {
    "label": "cbeginValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "cbeginValueOff()"
  },
  {
    "label": "beginValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "beginValueOff()"
  },
  {
    "label": "cbeginValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "cbeginValueAll()"
  },
  {
    "label": "beginValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "beginValueAll()"
  },
  {
    "label": "cendValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnCIter)",
    "insertText": "cendValueOn()"
  },
  {
    "label": "endValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnCIter)",
    "insertText": "endValueOn()"
  },
  {
    "label": "cendValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "cendValueOff()"
  },
  {
    "label": "endValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "endValueOff()"
  },
  {
    "label": "cendValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "cendValueAll()"
  },
  {
    "label": "endValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "endValueAll()"
  },
  {
    "label": "cbeginChildOn()",
    "kind": "Method",
    "detail": "Function (} ChildOnCIter)",
    "insertText": "cbeginChildOn()"
  },
  {
    "label": "beginChildOn()",
    "kind": "Method",
    "detail": "Function (} ChildOnCIter)",
    "insertText": "beginChildOn()"
  },
  {
    "label": "cbeginChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "cbeginChildOff()"
  },
  {
    "label": "beginChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "beginChildOff()"
  },
  {
    "label": "cbeginChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "cbeginChildAll()"
  },
  {
    "label": "beginChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "beginChildAll()"
  },
  {
    "label": "cendChildOn()",
    "kind": "Method",
    "detail": "Function (} ChildOnCIter)",
    "insertText": "cendChildOn()"
  },
  {
    "label": "endChildOn()",
    "kind": "Method",
    "detail": "Function (} ChildOnCIter)",
    "insertText": "endChildOn()"
  },
  {
    "label": "cendChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "cendChildOff()"
  },
  {
    "label": "endChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "endChildOff()"
  },
  {
    "label": "cendChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "cendChildAll()"
  },
  {
    "label": "endChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "endChildAll()"
  },
  {
    "label": "getIndices()",
    "kind": "Method",
    "detail": "Function (} # undef VMASK_ } ; template<T,Index Log2Dim> bool PointIndexLeafNode<T,Log2Dim)",
    "insertText": "getIndices(const Coord& ijk, const ValueType*& begin, const ValueType*& end)"
  },
  {
    "label": "dataPtr()",
    "kind": "Method",
    "detail": "Function (begin =)",
    "insertText": "dataPtr(offset == 0 ? ValueType(0) : this->buffer()[offset - 1])"
  },
  {
    "label": "buffer()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "buffer().setValue(offset, val)"
  },
  {
    "label": "setValueMaskOn()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueMaskOn(offset)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (Index xPos,pos,zStride =)",
    "insertText": "Index(bbox.max()[2] - bbox.min()[2])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Coord ijk ;)",
    "insertText": "for(ijk[0] = bbox.min()[0]; ijk[0] <= bbox.max()[0]; ++ijk[0])"
  },
  {
    "label": "xPos()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "xPos(ijk[0] & (DIM - 1u)) << (2 * LOG2DIM)"
  },
  {
    "label": "xPos()",
    "kind": "Method",
    "detail": "Function (pos =)",
    "insertText": "xPos((ijk[1] & (DIM - 1u)) << LOG2DIM)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pos(bbox.min()[2] & (DIM - 1u))"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(is, fromHalf)"
  },
  {
    "label": "Index64()",
    "kind": "Method",
    "detail": "Function (Index64 numIndices =)",
    "insertText": "Index64(0)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(&numIndices), sizeof(Index64))"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (mIndices .)",
    "insertText": "resize(size_t(numIndices))"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(mIndices.data()), numIndices * sizeof(T))"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> void PointIndexLeafNode<T,Log2Dim)",
    "insertText": "readBuffers(std::istream& is, const CoordBBox& bbox, bool fromHalf)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(is, bbox, fromHalf)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (const Index64 numBytes = numIndices*)",
    "insertText": "sizeof(T)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(mIndices.data()), numBytes)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (} else { std::unique_ptr<char [ ]> buf { new char [ numBytes ] } ; is .)",
    "insertText": "read(buf.get(), numBytes)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(&auxDataBytes), sizeof(Index64))"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<char [ ]> auxData { new char [ auxDataBytes ] } ; is .)",
    "insertText": "read(auxData.get(), auxDataBytes)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (} } template<T,Index Log2Dim> void PointIndexLeafNode<T,Log2Dim)",
    "insertText": "writeBuffers(std::ostream& os, bool toHalf)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeBuffers(os, toHalf)"
  },
  {
    "label": "Index64()",
    "kind": "Method",
    "detail": "Function (Index64 numIndices =)",
    "insertText": "Index64(mIndices.size())"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&numIndices), sizeof(Index64))"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(mIndices.data()), numIndices * sizeof(T))"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&auxDataBytes), sizeof(Index64))"
  }
]