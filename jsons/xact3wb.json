[
  {
    "label": "WAVEBANKSEGIDX",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "WAVEBANKSEGIDX"
  },
  {
    "label": "WAVEBANKREGION",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "WAVEBANKREGION"
  },
  {
    "label": "WAVEBANKSAMPLEREGION",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "WAVEBANKSAMPLEREGION"
  },
  {
    "label": "WAVEBANKHEADER",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "WAVEBANKHEADER"
  },
  {
    "label": "WAVEBANKENTRY",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "WAVEBANKENTRY"
  },
  {
    "label": "WAVEBANKENTRYCOMPACT",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "WAVEBANKENTRYCOMPACT"
  },
  {
    "label": "WAVEBANKDATA",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "WAVEBANKDATA"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (# ifndef __XACT3WB_H__ # define __XACT3WB_H__ # ifdef _XBOX # include<xtl . h> # else # include<math . h> # endif # include<audiodefs . h> # include<xma2defs . h> # pragma)",
    "insertText": "warning(push) #pragma warning(disable:4201) #pragma warning(disable:4214) #pragma pack(push, 1) #if !defined(_X86_) #define XACTUNALIGNED __unaligned #else #define XACTUNALIGNED #endif #ifdef _M_PPCBE #pragma bitfield_order(push, lsb_to_msb)"
  },
  {
    "label": "WAVEBANK_DVD_BLOCK_SIZE()",
    "kind": "Method",
    "detail": "Function (# define WAVEBANK_TYPE_BUFFER 0 x00000000 # define WAVEBANK_TYPE_STREAMING 0 x00000001 # define WAVEBANK_TYPE_MASK 0 x00000001 # define WAVEBANK_FLAGS_ENTRYNAMES 0 x00010000 # define WAVEBANK_FLAGS_COMPACT 0 x00020000 # define WAVEBANK_FLAGS_SYNC_DISABLED 0 x00040000 # define WAVEBANK_FLAGS_SEEKTABLES 0 x00080000 # define WAVEBANK_FLAGS_MASK 0 x000F0000 # define WAVEBANKENTRY_FLAGS_READAHEAD 0 x00000001 # define WAVEBANKENTRY_FLAGS_LOOPCACHE 0 x00000002 # define WAVEBANKENTRY_FLAGS_REMOVELOOPTAIL 0 x00000004 # define WAVEBANKENTRY_FLAGS_IGNORELOOP 0 x00000008 # define WAVEBANKENTRY_FLAGS_MASK 0 x00000008 # define WAVEBANKMINIFORMAT_TAG_PCM 0 x0 # define WAVEBANKMINIFORMAT_TAG_XMA 0 x1 # define WAVEBANKMINIFORMAT_TAG_ADPCM 0 x2 # define WAVEBANKMINIFORMAT_TAG_WMA 0 x3 # define WAVEBANKMINIFORMAT_BITDEPTH_8 0 x0 # define WAVEBANKMINIFORMAT_BITDEPTH_16 0 x1 # define WAVEBANKENTRY_XMASTREAMS_MAX 3 # define WAVEBANKENTRY_XMACHANNELS_MAX 6 # define WAVEBANK_DVD_SECTOR_SIZE 2 0 4 8 # define)",
    "insertText": "WAVEBANK_DVD_BLOCK_SIZE(WAVEBANK_DVD_SECTOR_SIZE * 16)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (WAVEBANK_SEGIDX_BANKDATA = 0,WAVEBANK_SEGIDX_ENTRYMETADATA,WAVEBANK_SEGIDX_SEEKTABLES,WAVEBANK_SEGIDX_ENTRYNAMES,WAVEBANK_SEGIDX_ENTRYWAVEDATA,WAVEBANK_SEGIDX_COUNT } WAVEBANKSEGIDX,* LPWAVEBANKSEGIDX ; typedef const WAVEBANKSEGIDX* LPCWAVEBANKSEGIDX ; # ifdef __cplusplus namespace XACTWaveBank { __inline void)",
    "insertText": "SwapBytes(XACTUNALIGNED DWORD &dw)"
  },
  {
    "label": "_byteswap_ulong()",
    "kind": "Method",
    "detail": "Function (# ifdef _X86_ __asm { mov edi,dw mov eax,[ edi ] bswap eax mov [ edi ],eax } # else dw =)",
    "insertText": "_byteswap_ulong(dw)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (# endif } __inline void)",
    "insertText": "SwapBytes(XACTUNALIGNED WORD &w)"
  },
  {
    "label": "_byteswap_ushort()",
    "kind": "Method",
    "detail": "Function (# ifdef _X86_ __asm { mov edi,w mov ax,[ edi ] xchg ah,al mov [ edi ],ax } # else w =)",
    "insertText": "_byteswap_ushort(w)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (# endif } } # endif typedef struct WAVEBANKREGION { DWORD dwOffset ; DWORD dwLength ; # ifdef __cplusplus void)",
    "insertText": "SwapBytes(void)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapBytes(dwOffset)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapBytes(dwLength)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapBytes(dwStartSample)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapBytes(dwTotalSamples)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapBytes(dwSignature)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapBytes(dwVersion)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapBytes(dwHeaderVersion)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (Segments [ i ] .)",
    "insertText": "SwapBytes()"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapBytes(dwValue)"
  },
  {
    "label": "BitsPerSample()",
    "kind": "Method",
    "detail": "Function (} WORD)",
    "insertText": "BitsPerSample()"
  },
  {
    "label": "BlockAlign()",
    "kind": "Method",
    "detail": "Function (} # define ADPCM_MINIWAVEFORMAT_BLOCKALIGN_CONVERSION_OFFSET 2 2 DWORD)",
    "insertText": "BlockAlign()"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (DWORD dwReturn = 0 ;)",
    "insertText": "switch(wFormatTag)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case WAVEBANKMINIFORMAT_TAG_WMA : { DWORD dwBlockAlignIndex = wBlockAlign& 0 x1F ;)",
    "insertText": "if(dwBlockAlignIndex < MAX_WMA_BLOCK_ALIGN_ENTRIES)"
  },
  {
    "label": "AvgBytesPerSec()",
    "kind": "Method",
    "detail": "Function (} break ; } return dwReturn ; } DWORD)",
    "insertText": "AvgBytesPerSec()"
  },
  {
    "label": "AdpcmSamplesPerBlock()",
    "kind": "Method",
    "detail": "Function (DWORD samplesPerAdpcmBlock =)",
    "insertText": "AdpcmSamplesPerBlock()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (dwReturn = blockAlign* nSamplesPerSec / samplesPerAdpcmBlock ; } break ; case WAVEBANKMINIFORMAT_TAG_WMA : { DWORD dwBytesPerSecIndex = wBlockAlign>> 5 ;)",
    "insertText": "if(dwBytesPerSecIndex < MAX_WMA_AVG_BYTES_PER_SEC_ENTRIES)"
  },
  {
    "label": "EncodeWMABlockAlign()",
    "kind": "Method",
    "detail": "Function (} break ; } return dwReturn ; } DWORD)",
    "insertText": "EncodeWMABlockAlign(DWORD dwBlockAlign, DWORD dwAvgBytesPerSec)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (DWORD dwReturn = 0 ; DWORD dwBlockAlignIndex = 0 ; DWORD dwBytesPerSecIndex = 0 ;)",
    "insertText": "for(; dwBlockAlignIndex < MAX_WMA_BLOCK_ALIGN_ENTRIES && dwBlockAlign != aWMABlockAlign[dwBlockAlignIndex]; dwBlockAlignIndex++)"
  },
  {
    "label": "dwBlockAlignIndex()",
    "kind": "Method",
    "detail": "Function (dwReturn =)",
    "insertText": "dwBlockAlignIndex(dwBytesPerSecIndex << 5)"
  },
  {
    "label": "XMA2FillFormatEx()",
    "kind": "Method",
    "detail": "Function (} } return dwReturn ; } void)",
    "insertText": "XMA2FillFormatEx(XMA2WAVEFORMATEX *fmt, WORD blockCount, const struct WAVEBANKENTRY* entry)"
  },
  {
    "label": "nBlockAlign()",
    "kind": "Method",
    "detail": "Function (DWORD)",
    "insertText": "nBlockAlign(wBlockAlign + ADPCM_MINIWAVEFORMAT_BLOCKALIGN_CONVERSION_OFFSET)"
  },
  {
    "label": "AdpcmFillCoefficientTable()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AdpcmFillCoefficientTable(ADPCMWAVEFORMAT *fmt)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (fmt -> wNumCoef = 7 ; ADPCMCOEFSET aCoef [ 7 ] = { { 2 5 6,0 },{ 5 1 2,- 2 5 6 },{ 0,0 },{ 1 9 2,6 4 },{ 2 4 0,0 },{ 4 6 0,- 2 0 8 },{ 3 9 2,- 2 3 2 } } ;)",
    "insertText": "memcpy(&fmt->aCoef, aCoef, sizeof(aCoef))"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapBytes(dwFlagsAndDuration)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapBytes(*(LPDWORD)this)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapBytes(dwFlags)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapBytes(dwEntryCount)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapBytes(dwEntryMetaDataElementSize)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapBytes(dwEntryNameElementSize)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapBytes(dwAlignment)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapBytes(BuildTime.dwLowDateTime)"
  },
  {
    "label": "SwapBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapBytes(BuildTime.dwHighDateTime)"
  },
  {
    "label": "XMA2FillFormatEx()",
    "kind": "Method",
    "detail": "Function (} # endif } WAVEBANKDATA,* LPWAVEBANKDATA ; typedef const WAVEBANKDATA* LPCWAVEBANKDATA ; void)",
    "insertText": "XMA2FillFormatEx(XMA2WAVEFORMATEX *fmt, WORD blockCount, const WAVEBANKENTRY* entry)"
  },
  {
    "label": "NumStreams()",
    "kind": "Method",
    "detail": "Function (fmt ->)",
    "insertText": "NumStreams(WORD)( (nChannels + 1) / 2)"
  }
]