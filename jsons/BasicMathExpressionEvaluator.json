[
  {
    "label": "FDecimalNumberFormattingRules",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDecimalNumberFormattingRules"
  },
  {
    "label": "EXPORTAPI",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "EXPORTAPI"
  },
  {
    "label": "FBasicMathExpressionEvaluator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FBasicMathExpressionEvaluator"
  },
  {
    "label": "DEFINE_EXPRESSION_OPERATOR_NODE()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Internationalization / FastDecimalFormat . h \" # include \" Misc / ExpressionParserTypes . h \" # include \" Misc / Optional . h \" # include \" Templates / ValueOrError . h \" struct FDecimalNumberFormattingRules ; # define)",
    "insertText": "DEFINE_EXPRESSION_OPERATOR_NODE(EXPORTAPI, TYPE, ...)"
  },
  {
    "label": "DEFINE_EXPRESSION_NODE_TYPE()",
    "kind": "Method",
    "detail": "Function (\\ struct EXPORTAPI TYPE { const TCHAR* const Moniker ; } ; \\ } \\)",
    "insertText": "DEFINE_EXPRESSION_NODE_TYPE(ExpressionParser::TYPE, __VA_ARGS__) DEFINE_EXPRESSION_OPERATOR_NODE(CORE_API, FSubExpressionStart, 0xCC40A083, 0xADBF46E2, 0xA93D12BB, 0x525D7417) DEFINE_EXPRESSION_OPERATOR_NODE(CORE_API, FSubExpressionEnd, 0x125E4C67, 0x96EB48C4, 0x8894E09C, 0xB3CD56BF) DEFINE_EXPRESSION_OPERATOR_NODE(CORE_API, FPlus, 0x6F88756B, 0xF9234263, 0x9B13614F, 0x2706074B) DEFINE_EXPRESSION_OPERATOR_NODE(CORE_API, FPlusEquals, 0x05A878C9, 0x0E6C44A4, 0x9A73920D, 0x3175AB48) DEFINE_EXPRESSION_OPERATOR_NODE(CORE_API, FMinus, 0xE6240779, 0xEE2849CF, 0x95A0E648, 0x22D58713) DEFINE_EXPRESSION_OPERATOR_NODE(CORE_API, FMinusEquals, 0x8D1E08E3, 0x5F534245, 0xA987AD7E, 0xDB78A4B7) DEFINE_EXPRESSION_OPERATOR_NODE(CORE_API, FStar, 0xF287B3BF, 0x35DF4141, 0xA8B4F57B, 0x7E06DF47) DEFINE_EXPRESSION_OPERATOR_NODE(CORE_API, FStarEquals, 0xBA359BB0, 0xCEB54682, 0x9160EB4F, 0xD1687C7F) DEFINE_EXPRESSION_OPERATOR_NODE(CORE_API, FForwardSlash, 0xF99670F8, 0x74794256, 0xBB0CAE6D, 0xC67CD5B6) DEFINE_EXPRESSION_OPERATOR_NODE(CORE_API, FForwardSlashEquals, 0x4AFE0CF8, 0xF9054360, 0xBE5DCE80, 0xDC2E22F6) DEFINE_EXPRESSION_OPERATOR_NODE(CORE_API, FPercent, 0x936E4434, 0x0A014F2D, 0xBEEC90D3, 0x4D3ECEA2) DEFINE_EXPRESSION_OPERATOR_NODE(CORE_API, FSquareRoot, 0xE7C03E11, 0x9DE84B4B, 0xBA4C2B76, 0x69BF028E) DEFINE_EXPRESSION_OPERATOR_NODE(CORE_API, FPower, 0x93388F8D, 0x1D9B4DFE, 0xBD4D6CC4, 0x12D1DE99)"
  },
  {
    "label": "GetLocalizedNumberFormattingRules()",
    "kind": "Method",
    "detail": "Function (const FDecimalNumberFormattingRules&)",
    "insertText": "GetLocalizedNumberFormattingRules()"
  },
  {
    "label": "ParseNumberWithFallback()",
    "kind": "Method",
    "detail": "Function (TOptional<FStringToken>)",
    "insertText": "ParseNumberWithFallback(const FTokenStream& InStream, const FDecimalNumberFormattingRules& InPrimaryFormattingRules, const FDecimalNumberFormattingRules& InFallbackFormattingRules, FStringToken* Accumulate = nullptr, double* OutValue = nullptr)"
  },
  {
    "label": "ParseNumberWithRules()",
    "kind": "Method",
    "detail": "Function (TOptional<FStringToken>)",
    "insertText": "ParseNumberWithRules(const FTokenStream& InStream, const FDecimalNumberFormattingRules& InFormattingRules, FStringToken* Accumulate = nullptr, double* OutValue = nullptr)"
  },
  {
    "label": "ParseLocalizedNumberWithAgnosticFallback()",
    "kind": "Method",
    "detail": "Function (TOptional<FStringToken>)",
    "insertText": "ParseLocalizedNumberWithAgnosticFallback(const FTokenStream& InStream, FStringToken* Accumulate = nullptr, double* OutValue = nullptr)"
  },
  {
    "label": "ParseLocalizedNumber()",
    "kind": "Method",
    "detail": "Function (TOptional<FStringToken>)",
    "insertText": "ParseLocalizedNumber(const FTokenStream& InStream, FStringToken* Accumulate = nullptr, double* OutValue = nullptr)"
  },
  {
    "label": "ParseNumber()",
    "kind": "Method",
    "detail": "Function (TOptional<FStringToken>)",
    "insertText": "ParseNumber(const FTokenStream& InStream, FStringToken* Accumulate = nullptr, double* OutValue = nullptr)"
  },
  {
    "label": "ConsumeNumberWithRules()",
    "kind": "Method",
    "detail": "Function (TOptional<FExpressionError>)",
    "insertText": "ConsumeNumberWithRules(FExpressionTokenConsumer& Consumer, const FDecimalNumberFormattingRules& InFormattingRules)"
  },
  {
    "label": "ConsumeLocalizedNumberWithAgnosticFallback()",
    "kind": "Method",
    "detail": "Function (TOptional<FExpressionError>)",
    "insertText": "ConsumeLocalizedNumberWithAgnosticFallback(FExpressionTokenConsumer& Consumer)"
  },
  {
    "label": "ConsumeLocalizedNumber()",
    "kind": "Method",
    "detail": "Function (TOptional<FExpressionError>)",
    "insertText": "ConsumeLocalizedNumber(FExpressionTokenConsumer& Consumer)"
  },
  {
    "label": "ConsumeNumber()",
    "kind": "Method",
    "detail": "Function (TOptional<FExpressionError>)",
    "insertText": "ConsumeNumber(FExpressionTokenConsumer& Consumer)"
  },
  {
    "label": "ConsumeSymbol()",
    "kind": "Method",
    "detail": "Function (template<TSymbol> TOptional<FExpressionError>)",
    "insertText": "ConsumeSymbol(FExpressionTokenConsumer& Consumer)"
  },
  {
    "label": "GetStream()",
    "kind": "Method",
    "detail": "Function (TOptional<FStringToken> Token = Consumer .)",
    "insertText": "GetStream().ParseToken(TSymbol::Moniker)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Consumer .)",
    "insertText": "Add(Token.GetValue(), TSymbol())"
  },
  {
    "label": "FExpressionError()",
    "kind": "Method",
    "detail": "Function (} return TOptional<)",
    "insertText": "FExpressionError()"
  },
  {
    "label": "FBasicMathExpressionEvaluator()",
    "kind": "Method",
    "detail": "Function (} } class FBasicMathExpressionEvaluator { public :)",
    "insertText": "FBasicMathExpressionEvaluator()"
  },
  {
    "label": "Evaluate()",
    "kind": "Method",
    "detail": "Function (TValueOrError<double,FExpressionError>)",
    "insertText": "Evaluate(const TCHAR* InExpression, double InExistingValue = 0)"
  }
]