[
  {
    "label": "TDeque",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TDeque"
  },
  {
    "label": "TIteratorBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TIteratorBase"
  },
  {
    "label": "WrapAround()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" GenericPlatform / GenericPlatformMath . h \" # include \" IteratorAdapter . h \" # include \" Math / UnrealMathUtility . h \" # include \" Misc / AssertionMacros . h \" # include \" Templates / MemoryOps . h \" # include<initializer_list> template<InElementType,InAllocatorType = FDefaultAllocator> class TDeque ; namespace UE { namespace Deque { namespace Private { template<InSizeType> InSizeType)",
    "insertText": "WrapAround(InSizeType Index, InSizeType Range)"
  },
  {
    "label": "TIteratorBase()",
    "kind": "Method",
    "detail": "Function (} template<InElementType,InSizeType> class TIteratorBase { public : using ElementType = InElementType ; using SizeType = InSizeType ;)",
    "insertText": "TIteratorBase()"
  },
  {
    "label": "TIteratorBase()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "TIteratorBase(ElementType* Data, SizeType Range, SizeType Offset) : Data(Data), Range(Range), Offset(Offset)"
  },
  {
    "label": "Dereference()",
    "kind": "Method",
    "detail": "Function (} ElementType&)",
    "insertText": "Dereference()"
  },
  {
    "label": "Increment()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Increment()"
  },
  {
    "label": "Equals()",
    "kind": "Method",
    "detail": "Function (Offset + + ; } bool)",
    "insertText": "Equals(const TIteratorBase& Other)"
  },
  {
    "label": "TDeque()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TDeque(TDeque&& Other)"
  },
  {
    "label": "MoveUnchecked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MoveUnchecked(MoveTemp(Other))"
  },
  {
    "label": "TDeque()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TDeque(const TDeque& Other)"
  },
  {
    "label": "CopyUnchecked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyUnchecked(Other)"
  },
  {
    "label": "TDeque()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TDeque(std::initializer_list<ElementType> InList)"
  },
  {
    "label": "CopyUnchecked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyUnchecked(InList)"
  },
  {
    "label": "TDeque()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TDeque()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TDeque&)",
    "insertText": "operator(TDeque&& Other)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return* this ; } TDeque&)",
    "insertText": "operator(const TDeque& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return* this ; } TDeque&)",
    "insertText": "operator(std::initializer_list<ElementType> InList)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ElementType&)",
    "insertText": "operator(SizeType Index)"
  },
  {
    "label": "Last()",
    "kind": "Method",
    "detail": "Function (} const ElementType&)",
    "insertText": "Last()"
  },
  {
    "label": "First()",
    "kind": "Method",
    "detail": "Function (} const ElementType&)",
    "insertText": "First()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "EmplaceLast()",
    "kind": "Method",
    "detail": "Function (} template<. . . ArgsType> ElementType&)",
    "insertText": "EmplaceLast(ArgsType&&... Args)"
  },
  {
    "label": "GrowIfRequired()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GrowIfRequired()"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (ElementType* Target =)",
    "insertText": "GetData()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)Target) ElementType(Forward<ArgsType>(Args)...)"
  },
  {
    "label": "WrapAround()",
    "kind": "Method",
    "detail": "Function (Tail = UE::Deque::)",
    "insertText": "WrapAround(Tail + 1, Capacity)"
  },
  {
    "label": "EmplaceFirst()",
    "kind": "Method",
    "detail": "Function (Count + + ; return* Target ; } template<. . . ArgsType> ElementType&)",
    "insertText": "EmplaceFirst(ArgsType&&... Args)"
  },
  {
    "label": "WrapAround()",
    "kind": "Method",
    "detail": "Function (Head = UE::Deque::)",
    "insertText": "WrapAround(Head + Capacity - 1, Capacity)"
  },
  {
    "label": "PushLast()",
    "kind": "Method",
    "detail": "Function (Count + + ; return* Target ; } void)",
    "insertText": "PushLast(const ElementType& Element)"
  },
  {
    "label": "EmplaceLast()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EmplaceLast(Element)"
  },
  {
    "label": "PushLast()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PushLast(ElementType&& Element)"
  },
  {
    "label": "EmplaceLast()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EmplaceLast(MoveTempIfPossible(Element))"
  },
  {
    "label": "PushFirst()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PushFirst(const ElementType& Element)"
  },
  {
    "label": "EmplaceFirst()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EmplaceFirst(Element)"
  },
  {
    "label": "PushFirst()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PushFirst(ElementType&& Element)"
  },
  {
    "label": "EmplaceFirst()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EmplaceFirst(MoveTempIfPossible(Element))"
  },
  {
    "label": "PopLast()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PopLast()"
  },
  {
    "label": "WrapAround()",
    "kind": "Method",
    "detail": "Function (const SizeType NextTail = UE::Deque::)",
    "insertText": "WrapAround(Tail + Capacity - 1, Capacity)"
  },
  {
    "label": "DestructItem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructItem(GetData() + NextTail)"
  },
  {
    "label": "PopFirst()",
    "kind": "Method",
    "detail": "Function (Tail = NextTail ; Count - - ; } void)",
    "insertText": "PopFirst()"
  },
  {
    "label": "DestructItem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructItem(GetData() + Head)"
  },
  {
    "label": "WrapAround()",
    "kind": "Method",
    "detail": "Function (Head = UE::Deque::)",
    "insertText": "WrapAround(Head + 1, Capacity)"
  },
  {
    "label": "TryPopLast()",
    "kind": "Method",
    "detail": "Function (Count - - ; } bool)",
    "insertText": "TryPopLast(ElementType& OutValue)"
  },
  {
    "label": "MoveTempIfPossible()",
    "kind": "Method",
    "detail": "Function (OutValue =)",
    "insertText": "MoveTempIfPossible(GetData()[NextTail])"
  },
  {
    "label": "TryPopFirst()",
    "kind": "Method",
    "detail": "Function (Tail = NextTail ; Count - - ; return true ; } bool)",
    "insertText": "TryPopFirst(ElementType& OutValue)"
  },
  {
    "label": "DestructItems()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructItems(GetData() + Head, Count)"
  },
  {
    "label": "DestructItems()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "DestructItems(GetData(), Tail)"
  },
  {
    "label": "DestructItems()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructItems(GetData() + Head, Capacity - Head)"
  },
  {
    "label": "ResizeAllocation()",
    "kind": "Method",
    "detail": "Function (Storage .)",
    "insertText": "ResizeAllocation(0, 0, sizeof(ElementType))"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Capacity = 0 ; } } void)",
    "insertText": "Reserve(SizeType InCount)"
  },
  {
    "label": "Grow()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Grow(Storage.CalculateSlackReserve(InCount, sizeof(ElementType)))"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} } ConstIteratorType)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} ConstIteratorType)",
    "insertText": "end()"
  },
  {
    "label": "GetIterator()",
    "kind": "Method",
    "detail": "Function (} ConstIteratorType)",
    "insertText": "GetIterator(SizeType HeadOffset)"
  },
  {
    "label": "Grow()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Grow(SizeType InCapacity)"
  },
  {
    "label": "Linearize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Linearize()"
  },
  {
    "label": "ResizeAllocation()",
    "kind": "Method",
    "detail": "Function (} Storage .)",
    "insertText": "ResizeAllocation(Count, InCapacity, sizeof(ElementType))"
  },
  {
    "label": "Grow()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Grow(Storage.CalculateSlackGrow(Count + 1, Capacity, sizeof(ElementType)))"
  },
  {
    "label": "CopyUnchecked()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "CopyUnchecked(const TDeque& Other)"
  },
  {
    "label": "Grow()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Grow(Storage.CalculateSlackReserve(Other.Count, sizeof(ElementType)))"
  },
  {
    "label": "CopyElements()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyElements(Other)"
  },
  {
    "label": "CopyUnchecked()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "CopyUnchecked(std::initializer_list<ElementType> InList)"
  },
  {
    "label": "SizeType()",
    "kind": "Method",
    "detail": "Function (const SizeType InCount = static_cast<)",
    "insertText": "SizeType(InList.size())"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (ConstructItems<)",
    "insertText": "ElementType(GetData(), &*InList.begin(), InCount)"
  },
  {
    "label": "MoveUnchecked()",
    "kind": "Method",
    "detail": "Function (Tail = Count = InCount ; } } void)",
    "insertText": "MoveUnchecked(TDeque&& Other)"
  },
  {
    "label": "MoveToEmpty()",
    "kind": "Method",
    "detail": "Function (Storage .)",
    "insertText": "MoveToEmpty(Other.Storage)"
  },
  {
    "label": "GetInitialCapacity()",
    "kind": "Method",
    "detail": "Function (Capacity = Other . Capacity ; Count = Other . Count ; Head = Other . Head ; Tail = Other . Tail ; Other . Capacity = Other . Storage .)",
    "insertText": "GetInitialCapacity()"
  },
  {
    "label": "CopyElements()",
    "kind": "Method",
    "detail": "Function (Other . Count = Other . Head = Other . Tail = 0 ; } } void)",
    "insertText": "CopyElements(const TDeque& Other)"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (ConstructItems<)",
    "insertText": "ElementType(GetData(), Other.GetData() + Other.Head, Other.Count)"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (} else { const SizeType HeadToEndOffset = Other . Capacity - Other . Head ; ConstructItems<)",
    "insertText": "ElementType(GetData(), Other.GetData() + Other.Head, HeadToEndOffset)"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (ConstructItems<)",
    "insertText": "ElementType(GetData() + HeadToEndOffset, Other.GetData(), Other.Tail)"
  },
  {
    "label": "MoveElements()",
    "kind": "Method",
    "detail": "Function (} Head = 0 ; Tail = Count = Other . Count ; } void)",
    "insertText": "MoveElements(TDeque& Other)"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (RelocateConstructItems<)",
    "insertText": "ElementType(GetData(), Other.GetData(), Other.Count)"
  },
  {
    "label": "ShiftElementsLeft()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ShiftElementsLeft(Count)"
  },
  {
    "label": "ResizeAllocation()",
    "kind": "Method",
    "detail": "Function (} else { ElementAllocatorType TempStorage ; TempStorage .)",
    "insertText": "ResizeAllocation(0, Tail, sizeof(ElementType))"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (RelocateConstructItems<)",
    "insertText": "ElementType(TempStorage.GetAllocation(), GetData(), Tail)"
  },
  {
    "label": "ShiftElementsLeft()",
    "kind": "Method",
    "detail": "Function (const SizeType HeadToEndOffset = Capacity - Head ;)",
    "insertText": "ShiftElementsLeft(HeadToEndOffset)"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (RelocateConstructItems<)",
    "insertText": "ElementType(GetData() + HeadToEndOffset, (ElementType*)TempStorage.GetAllocation(), Tail)"
  },
  {
    "label": "ShiftElementsLeft()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "ShiftElementsLeft(SizeType InCount)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (const SizeType Step =)",
    "insertText": "Min(Head, InCount - Offset)"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (RelocateConstructItems<)",
    "insertText": "ElementType(GetData() + Offset, GetData() + Head + Offset, Step)"
  },
  {
    "label": "CheckValidIndex()",
    "kind": "Method",
    "detail": "Function (Offset + = Step ; } } void)",
    "insertText": "CheckValidIndex(SizeType Index)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } public : bool)",
    "insertText": "operator(const TDeque& Right)"
  }
]