[
  {
    "label": "_Tp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tp"
  },
  {
    "label": "_LIBCPP_TEMPLATE_VIS",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_LIBCPP_TEMPLATE_VIS"
  },
  {
    "label": "_Up",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Up"
  },
  {
    "label": "_EnableIfConvertible",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_EnableIfConvertible"
  },
  {
    "label": "_Deleter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Deleter"
  },
  {
    "label": "__unique_ptr_deleter_sfinae",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__unique_ptr_deleter_sfinae"
  },
  {
    "label": "_Dp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Dp"
  },
  {
    "label": "_LIBCPP_UNIQUE_PTR_TRIVIAL_ABI",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_LIBCPP_UNIQUE_PTR_TRIVIAL_ABI"
  },
  {
    "label": "__nat",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__nat"
  },
  {
    "label": "_ArgType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_ArgType"
  },
  {
    "label": "_UPtr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_UPtr"
  },
  {
    "label": "_UDel",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_UDel"
  },
  {
    "label": "_Ep",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Ep"
  },
  {
    "label": "_From",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_From"
  },
  {
    "label": "_CheckArrayPointerConversion",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_CheckArrayPointerConversion"
  },
  {
    "label": "_FromElem",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_FromElem"
  },
  {
    "label": "_Pp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Pp"
  },
  {
    "label": "_ElemT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_ElemT"
  },
  {
    "label": "_T1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_T1"
  },
  {
    "label": "_D1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_D1"
  },
  {
    "label": "_T2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_T2"
  },
  {
    "label": "_D2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_D2"
  },
  {
    "label": "__unique_if",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__unique_if"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___MEMORY_UNIQUE_PTR_H # define _LIBCPP___MEMORY_UNIQUE_PTR_H # include<__config> # include<__functional / hash . h> # include<__functional / operations . h> # include<__memory / allocator_traits . h> # include<__memory / auto_ptr . h> # include<__memory / compressed_pair . h> # include<__utility / forward . h> # include<__utility / move . h> # include<cstddef> # include<type_traits> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)"
  },
  {
    "label": "default_delete()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP_CXX03_LANG _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "default_delete()"
  },
  {
    "label": "default_delete()",
    "kind": "Method",
    "detail": "Function (} # endif template<class _Up> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "default_delete(const default_delete<_Up>&, typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY void)",
    "insertText": "operator()(_Tp* __ptr)"
  },
  {
    "label": "_Up()",
    "kind": "Method",
    "detail": "Function (delete __ptr ; } } ; template<class _Tp> struct _LIBCPP_TEMPLATE_VIS default_delete<_Tp [ ]> { private : template<class _Up> struct _EnableIfConvertible : enable_if<is_convertible<)",
    "insertText": "_Up(*)[], _Tp(*)"
  },
  {
    "label": "default_delete()",
    "kind": "Method",
    "detail": "Function (} # endif template<class _Up> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "default_delete(const default_delete<_Up[]>&, typename _EnableIfConvertible<_Up>::type* = 0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _Up> _LIBCPP_INLINE_VISIBILITY _EnableIfConvertible<_Up>::type)",
    "insertText": "operator()(_Up* __ptr)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (delete [ ] __ptr ; } } ; template<class _Deleter> struct __unique_ptr_deleter_sfinae {)",
    "insertText": "static_assert(!is_reference<_Deleter>::value, \"incorrect specialization\")"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (typedef const _Deleter& __lval_ref_type ; typedef _Deleter&& __good_rval_ref_type ; typedef true_type __enable_rval_overload ; } ; template<class _Deleter> struct __unique_ptr_deleter_sfinae<_Deleter const&> { typedef const _Deleter& __lval_ref_type ; typedef const _Deleter&& __bad_rval_ref_type ; typedef false_type __enable_rval_overload ; } ; template<class _Deleter> struct __unique_ptr_deleter_sfinae<_Deleter&> { typedef _Deleter& __lval_ref_type ; typedef _Deleter&& __bad_rval_ref_type ; typedef false_type __enable_rval_overload ; } ; # if)",
    "insertText": "defined(_LIBCPP_ABI_ENABLE_UNIQUE_PTR_TRIVIAL_ABI) # define _LIBCPP_UNIQUE_PTR_TRIVIAL_ABI __attribute__((trivial_abi))"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (public : typedef _Tp element_type ; typedef _Dp deleter_type ; typedef _LIBCPP_NODEBUG __pointer<_Tp,deleter_type>::type pointer ;)",
    "insertText": "static_assert(!is_rvalue_reference<deleter_type>::value, \"the specified deleter type cannot be an rvalue reference\")"
  },
  {
    "label": "enable_if()",
    "kind": "Method",
    "detail": "Function (private : __compressed_pair<pointer,deleter_type> __ptr_ ; struct __nat { int __for_bool_ ; } ; typedef _LIBCPP_NODEBUG __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE ; template<bool _Dummy> using _LValRefType _LIBCPP_NODEBUG = __dependent_type<_DeleterSFINAE,_Dummy>::__lval_ref_type ; template<bool _Dummy> using _GoodRValRefType _LIBCPP_NODEBUG = __dependent_type<_DeleterSFINAE,_Dummy>::__good_rval_ref_type ; template<bool _Dummy> using _BadRValRefType _LIBCPP_NODEBUG = __dependent_type<_DeleterSFINAE,_Dummy>::__bad_rval_ref_type ; template<bool _Dummy,class _Deleter = __dependent_type<__type_identity<deleter_type>,_Dummy>::type> using _EnableIfDeleterDefaultConstructible _LIBCPP_NODEBUG = enable_if<is_default_constructible<_Deleter>::value&& ! is_pointer<_Deleter>::value>::type ; template<class _ArgType> using _EnableIfDeleterConstructible _LIBCPP_NODEBUG = enable_if<is_constructible<deleter_type,_ArgType>::value>::type ; template<class _UPtr,class _Up> using _EnableIfMoveConvertible _LIBCPP_NODEBUG = enable_if<is_convertible<_UPtr::pointer,pointer>::value&& ! is_array<_Up>::value>::type ; template<class _UDel> using _EnableIfDeleterConvertible _LIBCPP_NODEBUG =)",
    "insertText": "enable_if(is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) || (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)"
  },
  {
    "label": "unique_ptr()",
    "kind": "Method",
    "detail": "Function (template<class _UDel> using _EnableIfDeleterAssignable = enable_if<is_assignable<_Dp&,_UDel&&>::value>::type ; public : template<bool _Dummy = true,class = _EnableIfDeleterDefaultConstructible<_Dummy>> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR)",
    "insertText": "unique_ptr() _NOEXCEPT : __ptr_(__value_init_tag(), __value_init_tag())"
  },
  {
    "label": "unique_ptr()",
    "kind": "Method",
    "detail": "Function (} template<bool _Dummy = true,class = _EnableIfDeleterDefaultConstructible<_Dummy>> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR)",
    "insertText": "unique_ptr(nullptr_t) _NOEXCEPT : __ptr_(__value_init_tag(), __value_init_tag())"
  },
  {
    "label": "unique_ptr()",
    "kind": "Method",
    "detail": "Function (} template<bool _Dummy = true,class = _EnableIfDeleterDefaultConstructible<_Dummy>> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "unique_ptr(pointer __p) _NOEXCEPT : __ptr_(__p, __value_init_tag())"
  },
  {
    "label": "unique_ptr()",
    "kind": "Method",
    "detail": "Function (} template<bool _Dummy = true,class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "unique_ptr(pointer __p, _LValRefType<_Dummy> __d) _NOEXCEPT : __ptr_(__p, __d)"
  },
  {
    "label": "unique_ptr()",
    "kind": "Method",
    "detail": "Function (} template<bool _Dummy = true,class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) _NOEXCEPT : __ptr_(__p, _VSTD::move(__d))"
  },
  {
    "label": "unique_ptr()",
    "kind": "Method",
    "detail": "Function (} template<bool _Dummy = true,class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d)"
  },
  {
    "label": "unique_ptr()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_INLINE_VISIBILITY)",
    "insertText": "unique_ptr(unique_ptr&& __u) _NOEXCEPT : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter()))"
  },
  {
    "label": "unique_ptr()",
    "kind": "Method",
    "detail": "Function (} template<class _Up,class _Ep,class = _EnableIfMoveConvertible<unique_ptr<_Up,_Ep>,_Up>,class = _EnableIfDeleterConvertible<_Ep>> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "unique_ptr(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter()))"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if _LIBCPP_STD_VER<= 1 4 | |)",
    "insertText": "defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR) template <class _Up> _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p, typename enable_if<is_convertible<_Up*, _Tp*>::value && is_same<_Dp, default_delete<_Tp> >::value, __nat>::type = __nat()) _NOEXCEPT : __ptr_(__p.release(), __value_init_tag())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif _LIBCPP_INLINE_VISIBILITY unique_ptr&)",
    "insertText": "operator(unique_ptr&& __u)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reset(__u.release())"
  },
  {
    "label": "second()",
    "kind": "Method",
    "detail": "Function (__ptr_ .)",
    "insertText": "second() = _VSTD::forward<deleter_type>(__u.get_deleter())"
  },
  {
    "label": "second()",
    "kind": "Method",
    "detail": "Function (__ptr_ .)",
    "insertText": "second() = _VSTD::forward<_Ep>(__u.get_deleter())"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reset(__p.release())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (unique_ptr&)",
    "insertText": "operator(unique_ptr const&)"
  },
  {
    "label": "unique_ptr()",
    "kind": "Method",
    "detail": "Function (# endif _LIBCPP_INLINE_VISIBILITY ~)",
    "insertText": "unique_ptr()"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reset()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY unique_ptr&)",
    "insertText": "operator(nullptr_t)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY pointer)",
    "insertText": "operator()"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY pointer)",
    "insertText": "get()"
  },
  {
    "label": "get_deleter()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY deleter_type&)",
    "insertText": "get_deleter()"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY operator)",
    "insertText": "bool()"
  },
  {
    "label": "release()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY pointer)",
    "insertText": "release()"
  },
  {
    "label": "first()",
    "kind": "Method",
    "detail": "Function (pointer __t = __ptr_ .)",
    "insertText": "first()"
  },
  {
    "label": "first()",
    "kind": "Method",
    "detail": "Function (__ptr_ .)",
    "insertText": "first() = pointer()"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY void)",
    "insertText": "swap(unique_ptr& __u)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (__ptr_ .)",
    "insertText": "swap(__u.__ptr_)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} } ; template<class _Tp,class _Dp> class _LIBCPP_UNIQUE_PTR_TRIVIAL_ABI _LIBCPP_TEMPLATE_VIS unique_ptr<_Tp [ ],_Dp> { public : typedef _Tp element_type ; typedef _Dp deleter_type ; typedef __pointer<_Tp,deleter_type>::type pointer ; private : __compressed_pair<pointer,deleter_type> __ptr_ ; template<class _From> struct _CheckArrayPointerConversion : is_same<_From,pointer> { } ; template<class _FromElem> struct _CheckArrayPointerConversion<_FromElem*> : integral_constant<bool,is_same<_FromElem*,pointer)",
    "insertText": "value(is_same<pointer, element_type*>::value && is_convertible<_FromElem(*)[], element_type(*)[]>::value)"
  },
  {
    "label": "_ElemT()",
    "kind": "Method",
    "detail": "Function (} ; typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE ; template<bool _Dummy> using _LValRefType _LIBCPP_NODEBUG = __dependent_type<_DeleterSFINAE,_Dummy>::__lval_ref_type ; template<bool _Dummy> using _GoodRValRefType _LIBCPP_NODEBUG = __dependent_type<_DeleterSFINAE,_Dummy>::__good_rval_ref_type ; template<bool _Dummy> using _BadRValRefType _LIBCPP_NODEBUG = __dependent_type<_DeleterSFINAE,_Dummy>::__bad_rval_ref_type ; template<bool _Dummy,class _Deleter = __dependent_type<__type_identity<deleter_type>,_Dummy>::type> using _EnableIfDeleterDefaultConstructible _LIBCPP_NODEBUG = enable_if<is_default_constructible<_Deleter>::value&& ! is_pointer<_Deleter>::value>::type ; template<class _ArgType> using _EnableIfDeleterConstructible _LIBCPP_NODEBUG = enable_if<is_constructible<deleter_type,_ArgType>::value>::type ; template<class _Pp> using _EnableIfPointerConvertible _LIBCPP_NODEBUG = enable_if<_CheckArrayPointerConversion<_Pp>::value>::type ; template<class _UPtr,class _Up,class _ElemT = _UPtr::element_type> using _EnableIfMoveConvertible _LIBCPP_NODEBUG = enable_if<is_array<_Up>::value&& is_same<pointer,element_type*>::value&& is_same<_UPtr::pointer,_ElemT*>::value&& is_convertible<)",
    "insertText": "_ElemT(*)[], element_type(*)"
  },
  {
    "label": "unique_ptr()",
    "kind": "Method",
    "detail": "Function (} template<class _Pp,bool _Dummy = true,class = _EnableIfDeleterDefaultConstructible<_Dummy>,class = _EnableIfPointerConvertible<_Pp>> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "unique_ptr(_Pp __p) _NOEXCEPT : __ptr_(__p, __value_init_tag())"
  },
  {
    "label": "unique_ptr()",
    "kind": "Method",
    "detail": "Function (} template<class _Pp,bool _Dummy = true,class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>,class = _EnableIfPointerConvertible<_Pp>> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) _NOEXCEPT : __ptr_(__p, __d)"
  },
  {
    "label": "unique_ptr()",
    "kind": "Method",
    "detail": "Function (} template<bool _Dummy = true,class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) _NOEXCEPT : __ptr_(nullptr, __d)"
  },
  {
    "label": "unique_ptr()",
    "kind": "Method",
    "detail": "Function (} template<class _Pp,bool _Dummy = true,class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>,class = _EnableIfPointerConvertible<_Pp>> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) _NOEXCEPT : __ptr_(__p, _VSTD::move(__d))"
  },
  {
    "label": "unique_ptr()",
    "kind": "Method",
    "detail": "Function (} template<bool _Dummy = true,class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) _NOEXCEPT : __ptr_(nullptr, _VSTD::move(__d))"
  },
  {
    "label": "unique_ptr()",
    "kind": "Method",
    "detail": "Function (} template<class _Pp,bool _Dummy = true,class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>,class = _EnableIfPointerConvertible<_Pp>> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _Up,class _Ep,class = _EnableIfMoveConvertible<unique_ptr<_Up,_Ep>,_Up>,class = _EnableIfDeleterAssignable<_Ep>> _LIBCPP_INLINE_VISIBILITY unique_ptr&)",
    "insertText": "operator(unique_ptr<_Up, _Ep>&& __u)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY void)",
    "insertText": "reset(nullptr_t = nullptr)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} } ; template<class _Tp,class _Dp> _LIBCPP_INLINE_VISIBILITY enable_if<__is_swappable<_Dp>::value,void>::type)",
    "insertText": "swap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (__x .)",
    "insertText": "swap(__y)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _T1,class _D1,class _T2,class _D2> _LIBCPP_INLINE_VISIBILITY bool)",
    "insertText": "operator(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)"
  },
  {
    "label": "_Vp()",
    "kind": "Method",
    "detail": "Function (typedef unique_ptr<_T1,_D1>::pointer _P1 ; typedef unique_ptr<_T2,_D2>::pointer _P2 ; typedef common_type<_P1,_P2>::type _Vp ; return less<)",
    "insertText": "_Vp()(__x.get(), __y.get())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _T1,class _D1> _LIBCPP_INLINE_VISIBILITY bool)",
    "insertText": "operator(const unique_ptr<_T1, _D1>& __x, nullptr_t)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _T1,class _D1> _LIBCPP_INLINE_VISIBILITY bool)",
    "insertText": "operator(nullptr_t, const unique_ptr<_T1, _D1>& __x)"
  },
  {
    "label": "_P1()",
    "kind": "Method",
    "detail": "Function (typedef unique_ptr<_T1,_D1>::pointer _P1 ; return less<)",
    "insertText": "_P1()(__x.get(), nullptr)"
  },
  {
    "label": "_P1()",
    "kind": "Method",
    "detail": "Function (typedef unique_ptr<_T1,_D1>::pointer _P1 ; return less<)",
    "insertText": "_P1()(nullptr, __x.get())"
  },
  {
    "label": "make_unique()",
    "kind": "Method",
    "detail": "Function (} # if _LIBCPP_STD_VER> 1 1 template<class _Tp> struct __unique_if { typedef unique_ptr<_Tp> __unique_single ; } ; template<class _Tp> struct __unique_if<_Tp [ ]> { typedef unique_ptr<_Tp [ ]> __unique_array_unknown_bound ; } ; template<class _Tp,size_t _Np> struct __unique_if<_Tp [ _Np ]> { typedef void __unique_array_known_bound ; } ; template<class _Tp,class . . . _Args> _LIBCPP_INLINE_VISIBILITY __unique_if<_Tp>::__unique_single)",
    "insertText": "make_unique(_Args&&... __args)"
  },
  {
    "label": "make_unique()",
    "kind": "Method",
    "detail": "Function (} template<class _Tp> _LIBCPP_INLINE_VISIBILITY __unique_if<_Tp>::__unique_array_unknown_bound)",
    "insertText": "make_unique(size_t __n)"
  },
  {
    "label": "_Tp()",
    "kind": "Method",
    "detail": "Function (typedef remove_extent<_Tp>::type _Up ; return unique_ptr<)",
    "insertText": "_Tp(new _Up[__n]())"
  },
  {
    "label": "make_unique()",
    "kind": "Method",
    "detail": "Function (} template<class _Tp,class . . . _Args> __unique_if<_Tp>::__unique_array_known_bound)",
    "insertText": "make_unique(_Args&&...)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif template<class _Tp> struct _LIBCPP_TEMPLATE_VIS hash ; template<class _Tp,class _Dp> # ifdef _LIBCPP_CXX03_LANG struct _LIBCPP_TEMPLATE_VIS hash<unique_ptr<_Tp,_Dp>> # else struct _LIBCPP_TEMPLATE_VIS hash<__enable_hash_helper<unique_ptr<_Tp,_Dp>,unique_ptr<_Tp,_Dp>::pointer>> # endif { # if _LIBCPP_STD_VER<= 1 7 | |)",
    "insertText": "defined(_LIBCPP_ENABLE_CXX20_REMOVED_BINDER_TYPEDEFS)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_DEPRECATED_IN_CXX17 typedef size_t result_type ; # endif _LIBCPP_INLINE_VISIBILITY size_t)",
    "insertText": "operator()(const unique_ptr<_Tp, _Dp>& __ptr)"
  },
  {
    "label": "pointer()",
    "kind": "Method",
    "detail": "Function (typedef unique_ptr<_Tp,_Dp>::pointer pointer ; return hash<)",
    "insertText": "pointer()(__ptr.get())"
  }
]