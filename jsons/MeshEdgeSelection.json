[
  {
    "label": "FMeshEdgeSelection",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMeshEdgeSelection"
  },
  {
    "label": "FMeshEdgeSelection()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" DynamicMesh / DynamicMesh3 . h \" # include \" CoreMinimal . h \" # include \" Containers / Set . h \" # include \" Selections / MeshVertexSelection . h \" namespace UE { namespace Geometry { class FMeshEdgeSelection { private : const FDynamicMesh3* Mesh ; TSet<int> Selected ; public :)",
    "insertText": "FMeshEdgeSelection(const FDynamicMesh3* mesh)"
  },
  {
    "label": "FMeshEdgeSelection()",
    "kind": "Method",
    "detail": "Function (Mesh = mesh ; })",
    "insertText": "FMeshEdgeSelection(const FDynamicMesh3* mesh, const FMeshVertexSelection& convertV, int minCount = 2)"
  },
  {
    "label": "FMeshEdgeSelection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FMeshEdgeSelection(const FDynamicMesh3* mesh, const FMeshFaceSelection& convertT, int minCount = 1)"
  },
  {
    "label": "AsSet()",
    "kind": "Method",
    "detail": "Function (TSet<int>)",
    "insertText": "AsSet()"
  },
  {
    "label": "AsBitArray()",
    "kind": "Method",
    "detail": "Function (} TBitArray<FDefaultBitArrayAllocator>)",
    "insertText": "AsBitArray()"
  },
  {
    "label": "Bitmap()",
    "kind": "Method",
    "detail": "Function (TBitArray<FDefaultBitArrayAllocator>)",
    "insertText": "Bitmap(false, Mesh->MaxEdgeID())"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (Bitmap [ tid ] = true ; } return Bitmap ; } public : TSet<int>::TRangedForIterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} TSet<int>::TRangedForIterator)",
    "insertText": "end()"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (} private : void)",
    "insertText": "add(int eid)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Selected .)",
    "insertText": "Add(eid)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "remove(int eid)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (Selected .)",
    "insertText": "Remove(eid)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} public : int)",
    "insertText": "Num()"
  },
  {
    "label": "IsSelected()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsSelected(int eid)"
  },
  {
    "label": "Select()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Select(int eid)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(eid)"
  },
  {
    "label": "Select()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Select(const TArray<int>& edges)"
  },
  {
    "label": "Select()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "Select(TArrayView<const int> edges)"
  },
  {
    "label": "Select()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "Select(TFunctionRef<bool(int)> SelectF)"
  },
  {
    "label": "MaxEdgeID()",
    "kind": "Method",
    "detail": "Function (int NT = Mesh ->)",
    "insertText": "MaxEdgeID()"
  },
  {
    "label": "SelectVertexEdges()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "SelectVertexEdges(TArrayView<const int> vertices)"
  },
  {
    "label": "SelectTriangleEdges()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "SelectTriangleEdges(TArrayView<const int> Triangles)"
  },
  {
    "label": "GetTriEdges()",
    "kind": "Method",
    "detail": "Function (FIndex3i et = Mesh ->)",
    "insertText": "GetTriEdges(tid)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(et.A)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(et.B)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(et.C)"
  },
  {
    "label": "ExpandToOneRingNeighbors_FindNeighborsHelper()",
    "kind": "Method",
    "detail": "Function (} } private : template<bool bHasFilter,ExpandContainerType> void)",
    "insertText": "ExpandToOneRingNeighbors_FindNeighborsHelper(const ExpandContainerType& ToExpand, TArray<int32>& ToAdd, TFunctionRef<bool(int)> FilterF)"
  },
  {
    "label": "GetEdgeV()",
    "kind": "Method",
    "detail": "Function (FIndex2i EdgeV = Mesh ->)",
    "insertText": "GetEdgeV(EID)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; } })",
    "insertText": "if(!IsSelected(NbrEID))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ToAdd .)",
    "insertText": "Add(NbrEID)"
  },
  {
    "label": "ExpandToOneRingNeighbors_Helper()",
    "kind": "Method",
    "detail": "Function (} } } } } template<bool bHasFilter> void)",
    "insertText": "ExpandToOneRingNeighbors_Helper(int32 NumRings, TFunctionRef<bool(int)> FilterF)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (bool bAlreadyInSet ; Selected .)",
    "insertText": "Add(ToAdd[Idx], &bAlreadyInSet)"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (ToAdd .)",
    "insertText": "RemoveAtSwap(Idx, EAllowShrinking::No)"
  },
  {
    "label": "bHasFilter()",
    "kind": "Method",
    "detail": "Function (- - Idx ; } } } ; TArray<int32> ToAdd ; ExpandToOneRingNeighbors_FindNeighborsHelper<)",
    "insertText": "bHasFilter(Selected, ToAdd, FilterF)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(ID)"
  },
  {
    "label": "AddToSelectionAndRemoveRedundant()",
    "kind": "Method",
    "detail": "Function (} return ; } else {)",
    "insertText": "AddToSelectionAndRemoveRedundant(ToAdd)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TArray<int32> ToExpand ;)",
    "insertText": "for(int32 Iter = 1; Iter < NumRings; ++Iter)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(ToAdd, ToExpand)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (ToAdd .)",
    "insertText": "Reset()"
  },
  {
    "label": "bHasFilter()",
    "kind": "Method",
    "detail": "Function (ExpandToOneRingNeighbors_FindNeighborsHelper<)",
    "insertText": "bHasFilter(ToExpand, ToAdd, FilterF)"
  },
  {
    "label": "ExpandToOneRingNeighbors()",
    "kind": "Method",
    "detail": "Function (} } } public : void)",
    "insertText": "ExpandToOneRingNeighbors(TFunctionRef<bool(int32)> FilterF)"
  },
  {
    "label": "true()",
    "kind": "Method",
    "detail": "Function (ExpandToOneRingNeighbors_Helper<)",
    "insertText": "true(1, FilterF)"
  },
  {
    "label": "ExpandToOneRingNeighbors()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExpandToOneRingNeighbors()"
  },
  {
    "label": "false()",
    "kind": "Method",
    "detail": "Function (ExpandToOneRingNeighbors_Helper<)",
    "insertText": "false(1, [](int32) {return true;})"
  },
  {
    "label": "ExpandToOneRingNeighbors()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExpandToOneRingNeighbors(int NumRings, TFunctionRef<bool(int32)> FilterF)"
  },
  {
    "label": "true()",
    "kind": "Method",
    "detail": "Function (ExpandToOneRingNeighbors_Helper<)",
    "insertText": "true(NumRings, FilterF)"
  },
  {
    "label": "ExpandToOneRingNeighbors()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExpandToOneRingNeighbors(int NumRings)"
  },
  {
    "label": "false()",
    "kind": "Method",
    "detail": "Function (ExpandToOneRingNeighbors_Helper<)",
    "insertText": "false(NumRings, [](int32) {return true;})"
  },
  {
    "label": "ContractByBorderEdges()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ContractByBorderEdges(int32 nRings = 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TArray<int> BorderEdges ;)",
    "insertText": "for(int32 k = 0; k < nRings; ++k)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bEitherSideBoundary = false ;)",
    "insertText": "for(int32 SubIdx = 0; SubIdx < 2; ++SubIdx)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bIsBoundary = false ;)",
    "insertText": "for(int32 NbrEID : Mesh->VtxEdgesItr(EdgeV[SubIdx]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bIsBoundary = true ; } })",
    "insertText": "if(bIsBoundary)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bEitherSideBoundary = true ; break ; } })",
    "insertText": "if(bEitherSideBoundary)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (BorderEdges .)",
    "insertText": "Add(EID)"
  },
  {
    "label": "Deselect()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "Deselect(BorderEdges)"
  },
  {
    "label": "SelectBoundaryTriEdges()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SelectBoundaryTriEdges(const FMeshFaceSelection& Triangles)"
  },
  {
    "label": "Deselect()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Deselect(int tid)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "remove(tid)"
  },
  {
    "label": "Deselect()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Deselect(TArrayView<const int> edges)"
  },
  {
    "label": "DeselectAll()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "DeselectAll()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (Selected .)",
    "insertText": "Empty()"
  }
]