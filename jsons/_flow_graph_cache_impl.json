[
  {
    "label": "node_cache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "node_cache"
  },
  {
    "label": "predecessor_cache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "predecessor_cache"
  },
  {
    "label": "reservable_predecessor_cache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "reservable_predecessor_cache"
  },
  {
    "label": "successor_cache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "successor_cache"
  },
  {
    "label": "broadcast_cache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "broadcast_cache"
  },
  {
    "label": "round_robin_cache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "round_robin_cache"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB__flow_graph_cache_impl_H # define __TBB__flow_graph_cache_impl_H # ifndef __TBB_flow_graph_H # error Do not # include this internal file directly ; use public TBB headers instead . # endif namespace internal { template<T,M = spin_mutex> class node_cache { public : typedef size_t size_type ; bool)",
    "insertText": "empty()"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (mutex_type::scoped_lock)",
    "insertText": "lock(my_mutex)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "add(T &n)"
  },
  {
    "label": "internal_push()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_push(n)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "remove(T &n)"
  },
  {
    "label": "internal_pop()",
    "kind": "Method",
    "detail": "Function (T& s =)",
    "insertText": "internal_pop()"
  },
  {
    "label": "internal_push()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_push(s)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "clear()"
  },
  {
    "label": "built_predecessors()",
    "kind": "Method",
    "detail": "Function (# endif } # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION typedef edge_container<T> built_predecessors_type ; built_predecessors_type&)",
    "insertText": "built_predecessors()"
  },
  {
    "label": "add_edge()",
    "kind": "Method",
    "detail": "Function (my_built_predecessors .)",
    "insertText": "add_edge(n)"
  },
  {
    "label": "internal_delete_built_predecessor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_delete_built_predecessor(T &n)"
  },
  {
    "label": "delete_edge()",
    "kind": "Method",
    "detail": "Function (my_built_predecessors .)",
    "insertText": "delete_edge(n)"
  },
  {
    "label": "copy_predecessors()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "copy_predecessors(predecessor_list_type &v)"
  },
  {
    "label": "copy_edges()",
    "kind": "Method",
    "detail": "Function (my_built_predecessors .)",
    "insertText": "copy_edges(v)"
  },
  {
    "label": "predecessor_count()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "predecessor_count()"
  },
  {
    "label": "internal_empty()",
    "kind": "Method",
    "detail": "Function (} # endif protected : typedef M mutex_type ; mutex_type my_mutex ; std::queue<T*> my_q ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION built_predecessors_type my_built_predecessors ; # endif bool)",
    "insertText": "internal_empty()"
  },
  {
    "label": "internal_size()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "internal_size()"
  },
  {
    "label": "internal_push()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_push(T &n)"
  },
  {
    "label": "push()",
    "kind": "Method",
    "detail": "Function (my_q .)",
    "insertText": "push(&n)"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (T* v = my_q .)",
    "insertText": "front()"
  },
  {
    "label": "pop()",
    "kind": "Method",
    "detail": "Function (my_q .)",
    "insertText": "pop()"
  },
  {
    "label": "set_owner()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_owner(successor_type *owner)"
  },
  {
    "label": "get_item()",
    "kind": "Method",
    "detail": "Function (my_owner = owner ; } bool)",
    "insertText": "get_item(output_type &v)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (bool msg = false ; do { predecessor_type* src ; { mutex_type::scoped_lock)",
    "insertText": "lock(this->my_mutex)"
  },
  {
    "label": "try_get()",
    "kind": "Method",
    "detail": "Function (} msg = src ->)",
    "insertText": "try_get(v)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (} else { this ->)",
    "insertText": "add(*src)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "while(msg == false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (predecessor_type* src ; {)",
    "insertText": "if(this->internal_empty())"
  },
  {
    "label": "register_successor()",
    "kind": "Method",
    "detail": "Function (} src ->)",
    "insertText": "register_successor(*my_owner)"
  },
  {
    "label": "reservable_predecessor_cache()",
    "kind": "Method",
    "detail": "Function (} } } protected : # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION using node_cache<predecessor_type,M>::my_built_predecessors ; # endif successor_type* my_owner ; } ; template<T,M = spin_mutex> class reservable_predecessor_cache : public predecessor_cache<T,M> { public : typedef M mutex_type ; typedef T output_type ; # if __TBB_PREVIEW_ASYNC_MSG typedef untyped_sender predecessor_type ; typedef untyped_receiver successor_type ; # else typedef sender<T> predecessor_type ; typedef receiver<T> successor_type ; # endif)",
    "insertText": "reservable_predecessor_cache() : reserved_src(NULL)"
  },
  {
    "label": "try_reserve()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "try_reserve(output_type &v)"
  },
  {
    "label": "try_reserve()",
    "kind": "Method",
    "detail": "Function (} msg = reserved_src ->)",
    "insertText": "try_reserve(v)"
  },
  {
    "label": "register_successor()",
    "kind": "Method",
    "detail": "Function (reserved_src ->)",
    "insertText": "register_successor(*this->my_owner)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (reserved_src = NULL ; } else { this ->)",
    "insertText": "add(*reserved_src)"
  },
  {
    "label": "try_release()",
    "kind": "Method",
    "detail": "Function (reserved_src ->)",
    "insertText": "try_release()"
  },
  {
    "label": "try_consume()",
    "kind": "Method",
    "detail": "Function (reserved_src = NULL ; return true ; } bool)",
    "insertText": "try_consume()"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (reserved_src = NULL ; return true ; } void)",
    "insertText": "reset()"
  },
  {
    "label": "built_successors()",
    "kind": "Method",
    "detail": "Function (} private : predecessor_type* reserved_src ; } ; template<T,M = spin_rw_mutex> class successor_cache : tbb::internal::no_copy { protected : typedef M mutex_type ; mutex_type my_mutex ; # if __TBB_PREVIEW_ASYNC_MSG typedef untyped_receiver successor_type ; typedef untyped_receiver* pointer_type ; typedef untyped_sender owner_type ; # else typedef receiver<T> successor_type ; typedef receiver<T>* pointer_type ; typedef sender<T> owner_type ; # endif typedef std::list<pointer_type> successors_type ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION edge_container<successor_type> my_built_successors ; # endif successors_type my_successors ; owner_type* my_owner ; public : # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION typedef edge_container<successor_type>::edge_list_type successor_list_type ; edge_container<successor_type>&)",
    "insertText": "built_successors()"
  },
  {
    "label": "l()",
    "kind": "Method",
    "detail": "Function (mutex_type::scoped_lock)",
    "insertText": "l(my_mutex, true)"
  },
  {
    "label": "add_edge()",
    "kind": "Method",
    "detail": "Function (my_built_successors .)",
    "insertText": "add_edge(r)"
  },
  {
    "label": "internal_delete_built_successor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_delete_built_successor(successor_type &r)"
  },
  {
    "label": "delete_edge()",
    "kind": "Method",
    "detail": "Function (my_built_successors .)",
    "insertText": "delete_edge(r)"
  },
  {
    "label": "copy_successors()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "copy_successors(successor_list_type &v)"
  },
  {
    "label": "l()",
    "kind": "Method",
    "detail": "Function (mutex_type::scoped_lock)",
    "insertText": "l(my_mutex, false)"
  },
  {
    "label": "successor_count()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "successor_count()"
  },
  {
    "label": "l()",
    "kind": "Method",
    "detail": "Function (mutex_type::scoped_lock)",
    "insertText": "l(my_mutex,false)"
  },
  {
    "label": "successor_cache()",
    "kind": "Method",
    "detail": "Function (} # endif)",
    "insertText": "successor_cache() : my_owner(NULL)"
  },
  {
    "label": "set_owner()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_owner(owner_type *owner)"
  },
  {
    "label": "successor_cache()",
    "kind": "Method",
    "detail": "Function (my_owner = owner ; } ~)",
    "insertText": "successor_cache()"
  },
  {
    "label": "register_successor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "register_successor(successor_type &r)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (my_successors .)",
    "insertText": "push_back(&r)"
  },
  {
    "label": "remove_successor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "remove_successor(successor_type &r)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (my_successors .)",
    "insertText": "erase(i)"
  },
  {
    "label": "try_put_task()",
    "kind": "Method",
    "detail": "Function (# endif } # if ! __TBB_PREVIEW_ASYNC_MSG task*)",
    "insertText": "try_put_task(const T &t)"
  },
  {
    "label": "set_owner()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_owner(sender<continue_msg> *owner)"
  },
  {
    "label": "register_predecessor()",
    "kind": "Method",
    "detail": "Function (r .)",
    "insertText": "register_predecessor(*my_owner)"
  },
  {
    "label": "try_put_task()",
    "kind": "Method",
    "detail": "Function (# endif } # if ! __TBB_PREVIEW_ASYNC_MSG task*)",
    "insertText": "try_put_task(const continue_msg &t)"
  },
  {
    "label": "broadcast_cache()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<T,M = spin_rw_mutex> class broadcast_cache : public successor_cache<T,M> { typedef M mutex_type ; typedef successor_cache<T,M>::successors_type successors_type ; public :)",
    "insertText": "broadcast_cache()"
  },
  {
    "label": "try_put_task()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_PREVIEW_ASYNC_MSG template<X> task*)",
    "insertText": "try_put_task(const X &t)"
  },
  {
    "label": "l()",
    "kind": "Method",
    "detail": "Function (# endif task* last_task = NULL ; bool upgraded = true ; mutex_type::scoped_lock)",
    "insertText": "l(this->my_mutex, upgraded)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (successors_type::iterator i = this -> my_successors .)",
    "insertText": "begin()"
  },
  {
    "label": "new_task()",
    "kind": "Method",
    "detail": "Function (task*)",
    "insertText": "new_task(*i)->try_put_task(t)"
  },
  {
    "label": "graph_ref()",
    "kind": "Method",
    "detail": "Function (graph&)",
    "insertText": "graph_ref(*i)->graph_reference()"
  },
  {
    "label": "combine_tasks()",
    "kind": "Method",
    "detail": "Function (last_task =)",
    "insertText": "combine_tasks(graph_ref, last_task, new_task)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + i ; } else {)",
    "insertText": "if((*i)->register_predecessor(*this->my_owner))"
  },
  {
    "label": "upgrade_to_writer()",
    "kind": "Method",
    "detail": "Function (l .)",
    "insertText": "upgrade_to_writer()"
  },
  {
    "label": "gather_successful_try_puts()",
    "kind": "Method",
    "detail": "Function (} else { + + i ; } } } return last_task ; } # if __TBB_PREVIEW_ASYNC_MSG template<X> bool)",
    "insertText": "gather_successful_try_puts(const X &t, task_list &tasks)"
  },
  {
    "label": "gather_successful_try_puts()",
    "kind": "Method",
    "detail": "Function (# else bool)",
    "insertText": "gather_successful_try_puts(const T &t, task_list &tasks)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + i ;)",
    "insertText": "if(new_task != SUCCESSFULLY_ENQUEUED)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (tasks .)",
    "insertText": "push_back(*new_task)"
  },
  {
    "label": "round_robin_cache()",
    "kind": "Method",
    "detail": "Function (} else { + + i ; } } } return is_at_least_one_put_successful ; } } ; template<T,M = spin_rw_mutex> class round_robin_cache : public successor_cache<T,M> { typedef size_t size_type ; typedef M mutex_type ; typedef successor_cache<T,M>::successors_type successors_type ; public :)",
    "insertText": "round_robin_cache()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "size()"
  },
  {
    "label": "l()",
    "kind": "Method",
    "detail": "Function (mutex_type::scoped_lock)",
    "insertText": "l(this->my_mutex, false)"
  }
]