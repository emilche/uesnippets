[
  {
    "label": "SparseLU",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseLU"
  },
  {
    "label": "SparseLUMatrixLReturnType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SparseLUMatrixLReturnType"
  },
  {
    "label": "SparseLUMatrixUReturnType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SparseLUMatrixUReturnType"
  },
  {
    "label": "SparseLUType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseLUType"
  },
  {
    "label": "SparseLUTransposeView",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseLUTransposeView"
  },
  {
    "label": "SparseLU",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseLU"
  },
  {
    "label": "implements",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "implements"
  },
  {
    "label": "is",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "is"
  },
  {
    "label": "SparseLU",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseLU"
  },
  {
    "label": "SparseLU",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseLU"
  },
  {
    "label": "SparseLUMatrixLReturnType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SparseLUMatrixLReturnType"
  },
  {
    "label": "SparseLUMatrixUReturnType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SparseLUMatrixUReturnType"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (permutations)",
    "insertText": "for(Index j = 0; j < B.cols()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (solution)",
    "insertText": "for(Index j = 0; j < B.cols()"
  },
  {
    "label": "analyzePattern()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "analyzePattern(const MatrixType& matrix)"
  },
  {
    "label": "factorize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "factorize(const MatrixType& matrix)"
  },
  {
    "label": "simplicialfactorize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "simplicialfactorize(const MatrixType& matrix)"
  },
  {
    "label": "analyzePattern()",
    "kind": "Method",
    "detail": "Function (Analyze)",
    "insertText": "analyzePattern(matrix)"
  },
  {
    "label": "factorize()",
    "kind": "Method",
    "detail": "Function (Factorize)",
    "insertText": "factorize(matrix)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (permutations)",
    "insertText": "for(Index j = 0; j < B.cols()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (solution)",
    "insertText": "for(Index j = 0; j < B.cols()"
  },
  {
    "label": "it()",
    "kind": "Method",
    "detail": "Function (SCMatrix::InnerIterator)",
    "insertText": "it(m_Lstore, j)"
  },
  {
    "label": "it()",
    "kind": "Method",
    "detail": "Function (SCMatrix::InnerIterator)",
    "insertText": "it(m_Lstore, j)"
  },
  {
    "label": "it()",
    "kind": "Method",
    "detail": "Function (SCMatrix::InnerIterator)",
    "insertText": "it(m_Lstore, j)"
  },
  {
    "label": "it()",
    "kind": "Method",
    "detail": "Function (SCMatrix::InnerIterator)",
    "insertText": "it(m_Lstore, j)"
  },
  {
    "label": "SparseLU()",
    "kind": "Method",
    "detail": "Function (constructor)",
    "insertText": "SparseLU(const SparseLU& )"
  },
  {
    "label": "post_perm()",
    "kind": "Method",
    "detail": "Function (PermutationType)",
    "insertText": "post_perm(m)"
  },
  {
    "label": "segrep()",
    "kind": "Method",
    "detail": "Function (IndexVector)",
    "insertText": "segrep(m)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (IndexVector)",
    "insertText": "parent(m)"
  },
  {
    "label": "xplore()",
    "kind": "Method",
    "detail": "Function (IndexVector)",
    "insertText": "xplore(m)"
  },
  {
    "label": "repfnz()",
    "kind": "Method",
    "detail": "Function (IndexVector)",
    "insertText": "repfnz(maxpanel)"
  },
  {
    "label": "panel_lsub()",
    "kind": "Method",
    "detail": "Function (IndexVector)",
    "insertText": "panel_lsub(maxpanel)"
  },
  {
    "label": "xprune()",
    "kind": "Method",
    "detail": "Function (IndexVector)",
    "insertText": "xprune(n)"
  },
  {
    "label": "marker()",
    "kind": "Method",
    "detail": "Function (IndexVector)",
    "insertText": "marker(m*internal::LUNoMarker)"
  },
  {
    "label": "relax_end()",
    "kind": "Method",
    "detail": "Function (IndexVector)",
    "insertText": "relax_end(n)"
  },
  {
    "label": "panel_lsubk()",
    "kind": "Method",
    "detail": "Function (VectorBlock<IndexVector>)",
    "insertText": "panel_lsubk(panel_lsub, k, m)"
  },
  {
    "label": "repfnz_k()",
    "kind": "Method",
    "detail": "Function (VectorBlock<IndexVector>)",
    "insertText": "repfnz_k(repfnz, k, m)"
  },
  {
    "label": "dense_k()",
    "kind": "Method",
    "detail": "Function (VectorBlock<ScalarVector>)",
    "insertText": "dense_k(dense, k, m)"
  },
  {
    "label": "segrep_k()",
    "kind": "Method",
    "detail": "Function (VectorBlock<IndexVector>)",
    "insertText": "segrep_k(segrep, nseg1, m-nseg1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (U)",
    "insertText": "for(Index k = m_mapL.nsuper()"
  },
  {
    "label": "it()",
    "kind": "Method",
    "detail": "Function (MatrixUType::InnerIterator)",
    "insertText": "it(m_mapU, jcol)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (U)",
    "insertText": "for(Index k = 0; k <=  m_mapL.nsuper()"
  },
  {
    "label": "it()",
    "kind": "Method",
    "detail": "Function (MatrixUType::InnerIterator)",
    "insertText": "it(m_mapU, jcol)"
  }
]