[
  {
    "label": "VectorToScalarGrid",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VectorToScalarGrid"
  },
  {
    "label": "ComputeNeumannVelocityOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ComputeNeumannVelocityOp"
  },
  {
    "label": "ComputeNeumannVelocityOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ComputeNeumannVelocityOp"
  },
  {
    "label": "SolveBoundaryOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SolveBoundaryOp"
  },
  {
    "label": "SolveBoundaryOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SolveBoundaryOp"
  },
  {
    "label": "createPotentialFlowMask()",
    "kind": "Method",
    "detail": "Function (MaskT::Ptr)",
    "insertText": "createPotentialFlowMask(const GridT& grid, int dilation = 5)"
  },
  {
    "label": "createPotentialFlowNeumannVelocities()",
    "kind": "Method",
    "detail": "Function (ValueConverter<Vec3T>::Type::Ptr)",
    "insertText": "createPotentialFlowNeumannVelocities(const GridT& collider, const MaskT& domain,\n    const typename GridT::template ValueConverter<Vec3T>::Type::ConstPtr boundaryVelocity,\n    const Vec3T& backgroundVelocity)"
  },
  {
    "label": "computeScalarPotential()",
    "kind": "Method",
    "detail": "Function (VectorToScalarGrid<Vec3GridT>::Ptr)",
    "insertText": "computeScalarPotential(const MaskT& domain, const Vec3GridT& neumann, math::pcg::State& state,\n    InterrupterT* interrupter = nullptr)"
  },
  {
    "label": "leafManager()",
    "kind": "Method",
    "detail": "Function (tree::LeafManager<TreeT>)",
    "insertText": "leafManager(*neumannTree)"
  },
  {
    "label": "neumannOp()",
    "kind": "Method",
    "detail": "Function (GradientT>)",
    "insertText": "neumannOp(*gradient, *boundaryVelocity, backgroundVelocity)"
  },
  {
    "label": "neumannOp()",
    "kind": "Method",
    "detail": "Function (GradientT>)",
    "insertText": "neumannOp(*gradient, backgroundVelocity)"
  },
  {
    "label": "solve()",
    "kind": "Method",
    "detail": "Function (MaskT>)",
    "insertText": "solve(neumann, domain)"
  },
  {
    "label": "leafManager()",
    "kind": "Method",
    "detail": "Function (MaskGrid::TreeType>)",
    "insertText": "leafManager(*boundary)"
  }
]