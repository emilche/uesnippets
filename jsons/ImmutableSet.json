[
  {
    "label": "ImutAVLFactory",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ImutAVLFactory"
  },
  {
    "label": "ImutIntervalAVLFactory",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ImutIntervalAVLFactory"
  },
  {
    "label": "ImutAVLTreeInOrderIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ImutAVLTreeInOrderIterator"
  },
  {
    "label": "ImutAVLTreeGenericIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ImutAVLTreeGenericIterator"
  },
  {
    "label": "ImutAVLTree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ImutAVLTree"
  },
  {
    "label": "VisitFlag",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "VisitFlag"
  },
  {
    "label": "ImutAVLValueIterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ImutAVLValueIterator"
  },
  {
    "label": "ImutProfileInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ImutProfileInfo"
  },
  {
    "label": "ImutProfileInteger",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ImutProfileInteger"
  },
  {
    "label": "ImutContainerInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ImutContainerInfo"
  },
  {
    "label": "ImmutableSet",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ImmutableSet"
  },
  {
    "label": "Factory",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Factory"
  },
  {
    "label": "ImmutableSetRef",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ImmutableSetRef"
  },
  {
    "label": "getLeft()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_ADT_IMMUTABLESET_H # define LLVM_ADT_IMMUTABLESET_H # include \" llvm / ADT / DenseMap . h \" # include \" llvm / ADT / FoldingSet . h \" # include \" llvm / Support / Allocator . h \" # include \" llvm / Support / DataTypes . h \" # include \" llvm / Support / ErrorHandling . h \" # include<cassert> # include<functional> # include<vector> namespace llvm { template<ImutInfo> class ImutAVLFactory ; template<ImutInfo> class ImutIntervalAVLFactory ; template<ImutInfo> class ImutAVLTreeInOrderIterator ; template<ImutInfo> class ImutAVLTreeGenericIterator ; template<ImutInfo> class ImutAVLTree { public : typedef ImutInfo::key_type_ref key_type_ref ; typedef ImutInfo::value_type value_type ; typedef ImutInfo::value_type_ref value_type_ref ; typedef ImutAVLFactory<ImutInfo> Factory ; class ImutAVLFactory<ImutInfo> ; class ImutIntervalAVLFactory<ImutInfo> ; class ImutAVLTreeGenericIterator<ImutInfo> ; typedef ImutAVLTreeInOrderIterator<ImutInfo> iterator ; ImutAVLTree*)",
    "insertText": "getLeft()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (ImutAVLTree* T = this ;)",
    "insertText": "while(T)"
  },
  {
    "label": "KeyOfValue()",
    "kind": "Method",
    "detail": "Function (key_type_ref CurrentKey =)",
    "insertText": "KeyOfValue(T->getValue())"
  },
  {
    "label": "getMaxElement()",
    "kind": "Method",
    "detail": "Function (} return nullptr ; } ImutAVLTree*)",
    "insertText": "getMaxElement()"
  },
  {
    "label": "getRight()",
    "kind": "Method",
    "detail": "Function (ImutAVLTree* T = this ; ImutAVLTree* Right = T ->)",
    "insertText": "getRight()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} return T ; } unsigned)",
    "insertText": "size()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unsigned n = 1 ;)",
    "insertText": "if(const ImutAVLTree* L = getLeft()) n += L->size()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "isElementEqual()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isElementEqual(value_type_ref V)"
  },
  {
    "label": "isEqual()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isEqual(const ImutAVLTree& RHS)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (iterator LItr =)",
    "insertText": "begin(), LEnd = end()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (iterator RItr = RHS .)",
    "insertText": "begin(), REnd = RHS.end()"
  },
  {
    "label": "skipSubTree()",
    "kind": "Method",
    "detail": "Function (LItr .)",
    "insertText": "skipSubTree()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(!LItr->isElementEqual(&*RItr))"
  },
  {
    "label": "isNotEqual()",
    "kind": "Method",
    "detail": "Function (+ + LItr ; + + RItr ; } return LItr = = LEnd&& RItr = = REnd ; } bool)",
    "insertText": "isNotEqual(const ImutAVLTree& RHS)"
  },
  {
    "label": "contains()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "contains(key_type_ref K)"
  },
  {
    "label": "foreach()",
    "kind": "Method",
    "detail": "Function (} template<Callback> void)",
    "insertText": "foreach(Callback& C)"
  },
  {
    "label": "C()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "C(value)"
  },
  {
    "label": "validateTree()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "validateTree()"
  },
  {
    "label": "getLeft()",
    "kind": "Method",
    "detail": "Function (unsigned HL =)",
    "insertText": "getLeft() ? getLeft()->validateTree()"
  },
  {
    "label": "getRight()",
    "kind": "Method",
    "detail": "Function (unsigned HR =)",
    "insertText": "getRight() ? getRight()->validateTree()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(getHeight() == ( HL > HR ? HL : HR ) + 1 && \"Height calculation wrong\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((HL > HR ? HL-HR : HR-HL) <= 2 && \"Balancing invariant violated\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((!getLeft() || ImutInfo::isLess(ImutInfo::KeyOfValue(getLeft()->getValue()), ImutInfo::KeyOfValue(getValue()))) && \"Value in left child is not less that current value\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!(getRight() || ImutInfo::isLess(ImutInfo::KeyOfValue(getValue()), ImutInfo::KeyOfValue(getRight()->getValue()))) && \"Current value is not less that value of right child\")"
  },
  {
    "label": "ImutAVLTree()",
    "kind": "Method",
    "detail": "Function (} private : Factory* factory ; ImutAVLTree* left ; ImutAVLTree* right ; ImutAVLTree* prev ; ImutAVLTree* next ; unsigned height : 2 8 ; unsigned IsMutable : 1 ; unsigned IsDigestCached : 1 ; unsigned IsCanonicalized : 1 ; value_type value ; uint32_t digest ; uint32_t refCount ; private :)",
    "insertText": "ImutAVLTree(Factory *f, ImutAVLTree* l, ImutAVLTree* r, value_type_ref v, unsigned height) : factory(f), left(l), right(r), prev(nullptr), next(nullptr), height(height), IsMutable(true), IsDigestCached(false), IsCanonicalized(0), value(v), digest(0), refCount(0)"
  },
  {
    "label": "isMutable()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isMutable()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(isMutable() && \"Mutable flag already removed.\")"
  },
  {
    "label": "markedCachedDigest()",
    "kind": "Method",
    "detail": "Function (IsMutable = false ; } void)",
    "insertText": "markedCachedDigest()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!hasCachedDigest() && \"NoCachedDigest flag already removed.\")"
  },
  {
    "label": "setHeight()",
    "kind": "Method",
    "detail": "Function (IsDigestCached = true ; } void)",
    "insertText": "setHeight(unsigned h)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(isMutable() && \"Only a mutable tree can have its height changed.\")"
  },
  {
    "label": "computeDigest()",
    "kind": "Method",
    "detail": "Function (height = h ; } uint32_t)",
    "insertText": "computeDigest(ImutAVLTree *L, ImutAVLTree *R, value_type_ref V)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uint32_t digest = 0 ;)",
    "insertText": "if(L) digest += L->computeDigest()"
  },
  {
    "label": "Profile()",
    "kind": "Method",
    "detail": "Function (FoldingSetNodeID ID ;)",
    "insertText": "Profile(ID,V)"
  },
  {
    "label": "ComputeHash()",
    "kind": "Method",
    "detail": "Function (digest + = ID .)",
    "insertText": "ComputeHash()"
  },
  {
    "label": "computeDigest()",
    "kind": "Method",
    "detail": "Function (uint32_t X =)",
    "insertText": "computeDigest(getLeft(), getRight(), getValue())"
  },
  {
    "label": "release()",
    "kind": "Method",
    "detail": "Function (+ + refCount ; } void)",
    "insertText": "release()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(refCount > 0)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "destroy()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} IsMutable = false ; factory -> freeNodes .)",
    "insertText": "push_back(this)"
  },
  {
    "label": "ownsAllocator()",
    "kind": "Method",
    "detail": "Function (} } ; template<ImutInfo> class ImutAVLFactory { class ImutAVLTree<ImutInfo> ; typedef ImutAVLTree<ImutInfo> TreeTy ; typedef TreeTy::value_type_ref value_type_ref ; typedef TreeTy::key_type_ref key_type_ref ; typedef DenseMap<unsigned,TreeTy*> CacheTy ; CacheTy Cache ; uintptr_t Allocator ; std::vector<TreeTy*> createdNodes ; std::vector<TreeTy*> freeNodes ; bool)",
    "insertText": "ownsAllocator()"
  },
  {
    "label": "ImutAVLFactory()",
    "kind": "Method",
    "detail": "Function (} public :)",
    "insertText": "ImutAVLFactory() : Allocator(reinterpret_cast<uintptr_t>(new BumpPtrAllocator()))"
  },
  {
    "label": "ImutAVLFactory()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ImutAVLFactory(BumpPtrAllocator& Alloc) : Allocator(reinterpret_cast<uintptr_t>(&Alloc) | 0x1)"
  },
  {
    "label": "ImutAVLFactory()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ImutAVLFactory()"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (} TreeTy*)",
    "insertText": "add(TreeTy* T, value_type_ref V)"
  },
  {
    "label": "add_internal()",
    "kind": "Method",
    "detail": "Function (T =)",
    "insertText": "add_internal(V,T)"
  },
  {
    "label": "markImmutable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "markImmutable(T)"
  },
  {
    "label": "recoverNodes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "recoverNodes()"
  },
  {
    "label": "remove_internal()",
    "kind": "Method",
    "detail": "Function (T =)",
    "insertText": "remove_internal(V,T)"
  },
  {
    "label": "getLeft()",
    "kind": "Method",
    "detail": "Function (} TreeTy*)",
    "insertText": "getLeft(TreeTy* T)"
  },
  {
    "label": "getRight()",
    "kind": "Method",
    "detail": "Function (} TreeTy*)",
    "insertText": "getRight(TreeTy* T)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (} value_type_ref)",
    "insertText": "getValue(TreeTy* T)"
  },
  {
    "label": "incrementHeight()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "incrementHeight(TreeTy* L, TreeTy* R)"
  },
  {
    "label": "getHeight()",
    "kind": "Method",
    "detail": "Function (unsigned hl =)",
    "insertText": "getHeight(L)"
  },
  {
    "label": "getHeight()",
    "kind": "Method",
    "detail": "Function (unsigned hr =)",
    "insertText": "getHeight(R)"
  },
  {
    "label": "compareTreeWithSection()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "compareTreeWithSection(TreeTy* T, typename TreeTy::iterator& TI, typename TreeTy::iterator& TE)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (TreeTy::iterator I = T ->)",
    "insertText": "begin(), E = T->end()"
  },
  {
    "label": "createNode()",
    "kind": "Method",
    "detail": "Function (} return true ; } TreeTy*)",
    "insertText": "createNode(TreeTy* L, value_type_ref V, TreeTy* R)"
  },
  {
    "label": "getAllocator()",
    "kind": "Method",
    "detail": "Function (BumpPtrAllocator& A =)",
    "insertText": "getAllocator()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TreeTy* T ;)",
    "insertText": "if(!freeNodes.empty())"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (T = freeNodes .)",
    "insertText": "back()"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (freeNodes .)",
    "insertText": "pop_back()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(T != L)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(T != R)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "T(TreeTy*) A.Allocate<TreeTy>()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "new(T) TreeTy(this, L, R, V, incrementHeight(L,R))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (createdNodes .)",
    "insertText": "push_back(T)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TreeTy* N = createdNodes [ i ] ;)",
    "insertText": "if(N->isMutable() && N->refCount == 0) N->destroy()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} createdNodes .)",
    "insertText": "clear()"
  },
  {
    "label": "balanceTree()",
    "kind": "Method",
    "detail": "Function (} TreeTy*)",
    "insertText": "balanceTree(TreeTy* L, value_type_ref V, TreeTy* R)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!isEmpty(L) && \"Left tree cannot be empty to have a height >= 2\")"
  },
  {
    "label": "getLeft()",
    "kind": "Method",
    "detail": "Function (TreeTy* LL =)",
    "insertText": "getLeft(L)"
  },
  {
    "label": "getRight()",
    "kind": "Method",
    "detail": "Function (TreeTy* LR =)",
    "insertText": "getRight(L)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!isEmpty(LR) && \"LR cannot be empty because it has a height >= 1\")"
  },
  {
    "label": "getLeft()",
    "kind": "Method",
    "detail": "Function (TreeTy* LRL =)",
    "insertText": "getLeft(LR)"
  },
  {
    "label": "getRight()",
    "kind": "Method",
    "detail": "Function (TreeTy* LRR =)",
    "insertText": "getRight(LR)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(hr > hl + 2)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!isEmpty(R) && \"Right tree cannot be empty to have a height >= 2\")"
  },
  {
    "label": "getLeft()",
    "kind": "Method",
    "detail": "Function (TreeTy* RL =)",
    "insertText": "getLeft(R)"
  },
  {
    "label": "getRight()",
    "kind": "Method",
    "detail": "Function (TreeTy* RR =)",
    "insertText": "getRight(R)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!isEmpty(RL) && \"RL cannot be empty because it has a height >= 1\")"
  },
  {
    "label": "getLeft()",
    "kind": "Method",
    "detail": "Function (TreeTy* RLL =)",
    "insertText": "getLeft(RL)"
  },
  {
    "label": "getRight()",
    "kind": "Method",
    "detail": "Function (TreeTy* RLR =)",
    "insertText": "getRight(RL)"
  },
  {
    "label": "createNode()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "createNode(L,V,R)"
  },
  {
    "label": "add_internal()",
    "kind": "Method",
    "detail": "Function (} TreeTy*)",
    "insertText": "add_internal(value_type_ref V, TreeTy* T)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!T->isMutable())"
  },
  {
    "label": "KeyOfValue()",
    "kind": "Method",
    "detail": "Function (key_type_ref K =)",
    "insertText": "KeyOfValue(V)"
  },
  {
    "label": "KeyOfValue()",
    "kind": "Method",
    "detail": "Function (key_type_ref KCurrent =)",
    "insertText": "KeyOfValue(getValue(T))"
  },
  {
    "label": "remove_internal()",
    "kind": "Method",
    "detail": "Function (} TreeTy*)",
    "insertText": "remove_internal(key_type_ref K, TreeTy* T)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(ImutInfo::isLess(K,KCurrent))"
  },
  {
    "label": "balanceTree()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "balanceTree(getLeft(T), getValue(T), remove_internal(K, getRight(T)))"
  },
  {
    "label": "combineTrees()",
    "kind": "Method",
    "detail": "Function (} } TreeTy*)",
    "insertText": "combineTrees(TreeTy* L, TreeTy* R)"
  },
  {
    "label": "removeMinBinding()",
    "kind": "Method",
    "detail": "Function (TreeTy* OldNode ; TreeTy* newRight =)",
    "insertText": "removeMinBinding(R,OldNode)"
  },
  {
    "label": "removeMinBinding()",
    "kind": "Method",
    "detail": "Function (} TreeTy*)",
    "insertText": "removeMinBinding(TreeTy* T, TreeTy*& Noderemoved)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!isEmpty(T))"
  },
  {
    "label": "getRight()",
    "kind": "Method",
    "detail": "Function (Noderemoved = T ; return)",
    "insertText": "getRight(T)"
  },
  {
    "label": "balanceTree()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "balanceTree(removeMinBinding(getLeft(T), Noderemoved), getValue(T), getRight(T))"
  },
  {
    "label": "markImmutable()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "markImmutable(TreeTy* T)"
  },
  {
    "label": "markImmutable()",
    "kind": "Method",
    "detail": "Function (T ->)",
    "insertText": "markImmutable()"
  },
  {
    "label": "markImmutable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "markImmutable(getLeft(T))"
  },
  {
    "label": "markImmutable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "markImmutable(getRight(T))"
  },
  {
    "label": "getCanonicalTree()",
    "kind": "Method",
    "detail": "Function (} public : TreeTy*)",
    "insertText": "getCanonicalTree(TreeTy *TNew)"
  },
  {
    "label": "computeDigest()",
    "kind": "Method",
    "detail": "Function (unsigned digest = TNew ->)",
    "insertText": "computeDigest()"
  },
  {
    "label": "maskCacheIndex()",
    "kind": "Method",
    "detail": "Function (TreeTy*& entry = Cache [)",
    "insertText": "maskCacheIndex(digest)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (TreeTy::iterator TI = T ->)",
    "insertText": "begin(), TE = T->end()"
  },
  {
    "label": "ImutAVLTreeGenericIterator()",
    "kind": "Method",
    "detail": "Function (entry = TNew ; TNew -> IsCanonicalized = true ; return TNew ; } } ; template<ImutInfo> class ImutAVLTreeGenericIterator { SmallVector<uintptr_t,2 0> stack ; public : using iterator_category = std::bidirectional_iterator_tag ; using value_type = ImutAVLTree<ImutInfo> ; using difference_type = std::ptrdiff_t ; using pointer = value_type* ; using reference = value_type& ; enum VisitFlag { VisitedNone = 0 x0,VisitedLeft = 0 x1,VisitedRight = 0 x3,Flags = 0 x3 } ; typedef ImutAVLTree<ImutInfo> TreeTy ;)",
    "insertText": "ImutAVLTreeGenericIterator()"
  },
  {
    "label": "ImutAVLTreeGenericIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ImutAVLTreeGenericIterator(const TreeTy *Root)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TreeTy&)",
    "insertText": "operator()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!stack.empty())"
  },
  {
    "label": "atEnd()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "atEnd()"
  },
  {
    "label": "atBeginning()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "atBeginning()"
  },
  {
    "label": "skipToParent()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "skipToParent()"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (break ; default :)",
    "insertText": "llvm_unreachable(\"Unreachable.\")"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "operator(const ImutAVLTreeGenericIterator &x)"
  },
  {
    "label": "TreeTy()",
    "kind": "Method",
    "detail": "Function (TreeTy* Current = reinterpret_cast<)",
    "insertText": "TreeTy(stack.back() & ~Flags)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Current)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case VisitedLeft :)",
    "insertText": "if(TreeTy* R = Current->getRight()) stack.push_back(reinterpret_cast<uintptr_t>(R))"
  },
  {
    "label": "ImutAVLTreeInOrderIterator()",
    "kind": "Method",
    "detail": "Function (} return* this ; } } ; template<ImutInfo> class ImutAVLTreeInOrderIterator { typedef ImutAVLTreeGenericIterator<ImutInfo> InternalIteratorTy ; InternalIteratorTy InternalItr ; public : using iterator_category = std::bidirectional_iterator_tag ; using value_type = ImutAVLTree<ImutInfo> ; using difference_type = std::ptrdiff_t ; using pointer = value_type* ; using reference = value_type& ; typedef ImutAVLTree<ImutInfo> TreeTy ;)",
    "insertText": "ImutAVLTreeInOrderIterator(const TreeTy* Root) : InternalItr(Root)"
  },
  {
    "label": "ImutAVLTreeInOrderIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ImutAVLTreeInOrderIterator() : InternalItr()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const ImutAVLTreeInOrderIterator &x)"
  },
  {
    "label": "ImutAVLValueIterator()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> struct ImutAVLValueIterator : iterator_adaptor_base<ImutAVLValueIterator<T>,T::TreeTy::iterator,std::iterator_traits<T::TreeTy::iterator>::iterator_category,const T::value_type> {)",
    "insertText": "ImutAVLValueIterator()"
  },
  {
    "label": "ImutAVLValueIterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ImutAVLValueIterator(typename T::TreeTy *Tree) : ImutAVLValueIterator::iterator_adaptor_base(Tree)"
  },
  {
    "label": "Profile()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> struct ImutProfileInfo { typedef const T value_type ; typedef const T& value_type_ref ; void)",
    "insertText": "Profile(FoldingSetNodeID &ID, value_type_ref X)"
  },
  {
    "label": "Profile()",
    "kind": "Method",
    "detail": "Function (FoldingSetTrait<T)",
    "insertText": "Profile(X,ID)"
  },
  {
    "label": "AddInteger()",
    "kind": "Method",
    "detail": "Function (ID .)",
    "insertText": "AddInteger(X)"
  },
  {
    "label": "PROFILE_INTEGER_INFO()",
    "kind": "Method",
    "detail": "Function (} } ; # define)",
    "insertText": "PROFILE_INTEGER_INFO(X)"
  },
  {
    "label": "PROFILE_INTEGER_INFO()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "PROFILE_INTEGER_INFO(char) PROFILE_INTEGER_INFO(unsigned char) PROFILE_INTEGER_INFO(short) PROFILE_INTEGER_INFO(unsigned short) PROFILE_INTEGER_INFO(unsigned) PROFILE_INTEGER_INFO(signed) PROFILE_INTEGER_INFO(long) PROFILE_INTEGER_INFO(unsigned long) PROFILE_INTEGER_INFO(long long) PROFILE_INTEGER_INFO(unsigned long long)"
  },
  {
    "label": "AddBoolean()",
    "kind": "Method",
    "detail": "Function (ID .)",
    "insertText": "AddBoolean(X)"
  },
  {
    "label": "AddPointer()",
    "kind": "Method",
    "detail": "Function (ID .)",
    "insertText": "AddPointer(X)"
  },
  {
    "label": "KeyOfValue()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> struct ImutContainerInfo : public ImutProfileInfo<T> { typedef ImutProfileInfo<T>::value_type value_type ; typedef ImutProfileInfo<T>::value_type_ref value_type_ref ; typedef value_type key_type ; typedef value_type_ref key_type_ref ; typedef bool data_type ; typedef bool data_type_ref ; key_type_ref)",
    "insertText": "KeyOfValue(value_type_ref D)"
  },
  {
    "label": "isLess()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isLess(key_type_ref LHS, key_type_ref RHS)"
  },
  {
    "label": "isDataEqual()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isDataEqual(data_type_ref, data_type_ref)"
  },
  {
    "label": "retain()",
    "kind": "Method",
    "detail": "Function (Root ->)",
    "insertText": "retain()"
  },
  {
    "label": "ImmutableSet()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "ImmutableSet(const ImmutableSet &X) : Root(X.Root)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ImmutableSet&)",
    "insertText": "operator(const ImmutableSet &X)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Root)"
  },
  {
    "label": "ImmutableSet()",
    "kind": "Method",
    "detail": "Function (} Root = X . Root ; } return* this ; } ~)",
    "insertText": "ImmutableSet()"
  },
  {
    "label": "Factory()",
    "kind": "Method",
    "detail": "Function (} } class Factory { TreeTy::Factory F ; const bool Canonicalize ; public :)",
    "insertText": "Factory(bool canonicalize = true) : Canonicalize(canonicalize)"
  },
  {
    "label": "Factory()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Factory(BumpPtrAllocator& Alloc, bool canonicalize = true) : F(Alloc), Canonicalize(canonicalize)"
  },
  {
    "label": "getEmptySet()",
    "kind": "Method",
    "detail": "Function (} ImmutableSet)",
    "insertText": "getEmptySet()"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (} ImmutableSet)",
    "insertText": "add(ImmutableSet Old, value_type_ref V)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (TreeTy* NewT = F .)",
    "insertText": "add(Old.Root, V)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (} ImmutableSet)",
    "insertText": "remove(ImmutableSet Old, value_type_ref V)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (TreeTy* NewT = F .)",
    "insertText": "remove(Old.Root, V)"
  },
  {
    "label": "getTreeFactory()",
    "kind": "Method",
    "detail": "Function (} TreeTy::Factory*)",
    "insertText": "getTreeFactory()"
  },
  {
    "label": "Factory()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "Factory(const Factory& RHS)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(const Factory& RHS)"
  },
  {
    "label": "contains()",
    "kind": "Method",
    "detail": "Function (} ; class Factory ; bool)",
    "insertText": "contains(value_type_ref V)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const ImmutableSet &RHS)"
  },
  {
    "label": "getRoot()",
    "kind": "Method",
    "detail": "Function (} TreeTy*)",
    "insertText": "getRoot()"
  },
  {
    "label": "getRootWithoutRetain()",
    "kind": "Method",
    "detail": "Function (} return Root ; } TreeTy*)",
    "insertText": "getRootWithoutRetain()"
  },
  {
    "label": "foreach()",
    "kind": "Method",
    "detail": "Function (} template<Callback> void)",
    "insertText": "foreach()"
  },
  {
    "label": "foreach()",
    "kind": "Method",
    "detail": "Function (Callback C ; Root ->)",
    "insertText": "foreach(C)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} } typedef ImutAVLValueIterator<ImmutableSet> iterator ; iterator)",
    "insertText": "begin()"
  },
  {
    "label": "getHeight()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getHeight()"
  },
  {
    "label": "Profile()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Profile(FoldingSetNodeID &ID, const ImmutableSet &S)"
  },
  {
    "label": "AddPointer()",
    "kind": "Method",
    "detail": "Function (ID .)",
    "insertText": "AddPointer(S.Root)"
  },
  {
    "label": "Profile()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Profile(FoldingSetNodeID &ID)"
  },
  {
    "label": "ImmutableSetRef()",
    "kind": "Method",
    "detail": "Function (} } ; template<ValT,ValInfo = ImutContainerInfo<ValT>> class ImmutableSetRef { public : typedef ValInfo::value_type value_type ; typedef ValInfo::value_type_ref value_type_ref ; typedef ImutAVLTree<ValInfo> TreeTy ; typedef TreeTy::Factory FactoryTy ; private : TreeTy* Root ; FactoryTy* Factory ; public :)",
    "insertText": "ImmutableSetRef(TreeTy* R, FactoryTy *F) : Root(R), Factory(F)"
  },
  {
    "label": "ImmutableSetRef()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "ImmutableSetRef(const ImmutableSetRef &X) : Root(X.Root), Factory(X.Factory)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ImmutableSetRef&)",
    "insertText": "operator(const ImmutableSetRef &X)"
  },
  {
    "label": "ImmutableSetRef()",
    "kind": "Method",
    "detail": "Function (} Root = X . Root ; Factory = X . Factory ; } return* this ; } ~)",
    "insertText": "ImmutableSetRef()"
  },
  {
    "label": "getEmptySet()",
    "kind": "Method",
    "detail": "Function (} } ImmutableSetRef)",
    "insertText": "getEmptySet(FactoryTy *F)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (} ImmutableSetRef)",
    "insertText": "add(value_type_ref V)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (} ImmutableSetRef)",
    "insertText": "remove(value_type_ref V)"
  },
  {
    "label": "asImmutableSet()",
    "kind": "Method",
    "detail": "Function (} ImmutableSet<ValT>)",
    "insertText": "asImmutableSet(bool canonicalize = true)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const ImmutableSetRef &RHS)"
  },
  {
    "label": "isEmpty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isEmpty()"
  },
  {
    "label": "Profile()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Profile(FoldingSetNodeID &ID, const ImmutableSetRef &S)"
  }
]