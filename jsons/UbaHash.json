[
  {
    "label": "StringKey",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StringKey"
  },
  {
    "label": "CasKey",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CasKey"
  },
  {
    "label": "GuidToString",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GuidToString"
  },
  {
    "label": "KeyToString",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "KeyToString"
  },
  {
    "label": "HashString",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HashString"
  },
  {
    "label": "EqualString",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "EqualString"
  },
  {
    "label": "HashStringNoCase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HashStringNoCase"
  },
  {
    "label": "EqualStringNoCase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "EqualStringNoCase"
  },
  {
    "label": "StringKeyHasher",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StringKeyHasher"
  },
  {
    "label": "CasKeyHasher",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CasKeyHasher"
  },
  {
    "label": "CasKeyString",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CasKeyString"
  },
  {
    "label": "std",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "std"
  },
  {
    "label": "Map",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Map"
  },
  {
    "label": "StringKey()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" UbaStringBuffer . h \" # include \" UbaPlatform . h \" namespace uba { struct StringKey {)",
    "insertText": "StringKey() : a(0), b(0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} u64 a ; u64 b ; bool)",
    "insertText": "operator(const StringKey& o)"
  },
  {
    "label": "CasKey()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CasKey() : a(0), b(0), c(0)"
  },
  {
    "label": "CasKey()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CasKey(u64 a_, u64 b_, u32 c_) : a(a_), b(b_), c(c_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} u64 a ; u64 b ; u32 c ; bool)",
    "insertText": "operator(const CasKey& o)"
  },
  {
    "label": "CasKeyInvalid()",
    "kind": "Method",
    "detail": "Function (CasKey)",
    "insertText": "CasKeyInvalid(~0ull, ~0ull, ~0u)"
  },
  {
    "label": "GuidToStr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GuidToStr(tchar* out, u32 capacity, const Guid& g)"
  },
  {
    "label": "TSprintf_s()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TSprintf_s(out, capacity, TC(\"%08x-%04hx-%04hx-%02hhx%02hhx-%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx\"), g.data1, g.data2, g.data3, g.data4[0], g.data4[1], g.data4[2], g.data4[3], g.data4[4], g.data4[5], g.data4[6], g.data4[7])"
  },
  {
    "label": "GuidToString()",
    "kind": "Method",
    "detail": "Function (} struct GuidToString {)",
    "insertText": "GuidToString(const Guid& g)"
  },
  {
    "label": "GuidToStr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GuidToStr(str, 37, g)"
  },
  {
    "label": "KeyToString()",
    "kind": "Method",
    "detail": "Function (} tchar str [ 3 7 ] ; } ; struct KeyToString : StringBuffer<3 3> {)",
    "insertText": "KeyToString(const StringKey& key)"
  },
  {
    "label": "AppendHex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendHex(key.a)"
  },
  {
    "label": "AppendHex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendHex(key.b)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; struct HashString { size_t)",
    "insertText": "operator()(const tchar* s)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (size_t h = 5 3 8 1 ;)",
    "insertText": "while(tchar c = *s++) h = ((h << 5) + h) + size_t(c)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (size_t h = 5 3 8 1 ;)",
    "insertText": "while(tchar c = *s++) h = ((h << 5) + h) + size_t(ToLower(c))"
  },
  {
    "label": "StringKeyHasher()",
    "kind": "Method",
    "detail": "Function (} } ; struct StringKeyHasher {)",
    "insertText": "StringKeyHasher()"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Update(const tchar* str, u64 strLen)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (u64 hasher [ 1 9 1 2 /)",
    "insertText": "sizeof(u64)"
  },
  {
    "label": "ToStringKey()",
    "kind": "Method",
    "detail": "Function (} ; StringKey)",
    "insertText": "ToStringKey(const tchar* str, u64 strLen)"
  },
  {
    "label": "ToStringKeyLower()",
    "kind": "Method",
    "detail": "Function (StringKey)",
    "insertText": "ToStringKeyLower(const tchar* str, u64 strLen)"
  },
  {
    "label": "ToStringKey()",
    "kind": "Method",
    "detail": "Function (StringKey)",
    "insertText": "ToStringKey(const StringBufferBase& b)"
  },
  {
    "label": "ToStringKeyLower()",
    "kind": "Method",
    "detail": "Function (StringKey)",
    "insertText": "ToStringKeyLower(const StringBufferBase& b)"
  },
  {
    "label": "ToStringKey()",
    "kind": "Method",
    "detail": "Function (StringKey)",
    "insertText": "ToStringKey(const StringKeyHasher& hasher, const tchar* str, u64 strLen)"
  },
  {
    "label": "ToStringKey()",
    "kind": "Method",
    "detail": "Function (StringKey)",
    "insertText": "ToStringKey(const StringKeyHasher& hasher)"
  },
  {
    "label": "ToStringKeyNoCheck()",
    "kind": "Method",
    "detail": "Function (StringKey)",
    "insertText": "ToStringKeyNoCheck(const tchar* str, u64 strLen)"
  },
  {
    "label": "AlignUp()",
    "kind": "Method",
    "detail": "Function (u64)",
    "insertText": "AlignUp(u64 v, u64 a)"
  },
  {
    "label": "IsCompressed()",
    "kind": "Method",
    "detail": "Function (} u64 InvalidValue = 0 x7ffffffff ; bool)",
    "insertText": "IsCompressed(const CasKey& key)"
  },
  {
    "label": "UBA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UBA_ASSERT(key != CasKeyZero)"
  },
  {
    "label": "AsCompressed()",
    "kind": "Method",
    "detail": "Function (} CasKey)",
    "insertText": "AsCompressed(const CasKey& key, bool compressed)"
  },
  {
    "label": "flagField()",
    "kind": "Method",
    "detail": "Function (CasKey newKey = key ; # ifndef __clang_analyzer__ u8)",
    "insertText": "flagField((u8*)&key)"
  },
  {
    "label": "CasKeyHasher()",
    "kind": "Method",
    "detail": "Function (# endif return newKey ; } struct CasKeyHasher {)",
    "insertText": "CasKeyHasher()"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (CasKeyHasher&)",
    "insertText": "Update(const void* data, u64 bytes)"
  },
  {
    "label": "ToCasKey()",
    "kind": "Method",
    "detail": "Function (} ; CasKey)",
    "insertText": "ToCasKey(const CasKeyHasher& hasher, bool compressed)"
  },
  {
    "label": "CasKeyFromString()",
    "kind": "Method",
    "detail": "Function (CasKey)",
    "insertText": "CasKeyFromString(const tchar* str)"
  },
  {
    "label": "UBA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UBA_ASSERT(TStrlen(str) == 40)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (CasKey key ; u8*)",
    "insertText": "data(u8*)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const tchar* pos = str ;)",
    "insertText": "while(*pos)"
  },
  {
    "label": "HexToByte()",
    "kind": "Method",
    "detail": "Function (u8 a =)",
    "insertText": "HexToByte(*pos++)"
  },
  {
    "label": "u8()",
    "kind": "Method",
    "detail": "Function (* data + + =)",
    "insertText": "u8(a << 4)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (} return key ; } void)",
    "insertText": "ToString(tchar* out, int capacity, const CasKey& key)"
  },
  {
    "label": "__clang_analyzer__()",
    "kind": "Method",
    "detail": "Function (tchar* pos = out ; # ifndef)",
    "insertText": "__clang_analyzer__(void)"
  },
  {
    "label": "first()",
    "kind": "Method",
    "detail": "Function (u8)",
    "insertText": "first(data[i] >> 4)"
  },
  {
    "label": "second()",
    "kind": "Method",
    "detail": "Function (u8)",
    "insertText": "second(data[i] & 0xf)"
  },
  {
    "label": "CasKeyString()",
    "kind": "Method",
    "detail": "Function (* pos + + = g_hexChars [ first ] ;* pos + + = g_hexChars [ second ] ; } # endif* pos = 0 ; } struct CasKeyString {)",
    "insertText": "CasKeyString(const CasKey& g)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ToString(str, 41, g)"
  },
  {
    "label": "CheckPath()",
    "kind": "Method",
    "detail": "Function (} tchar str [ 4 1 ] ; } ; # if UBA_DEBUG void)",
    "insertText": "CheckPath(const tchar* fileName)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (auto pos = fileName ; tchar history [ 3 ] = { 0 } ;)",
    "insertText": "while(tchar c = *pos++)"
  },
  {
    "label": "UBA_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UBA_ASSERTF(!CaseInsensitiveFs || c < 'A' || c > 'Z', TC(\"Path is not valid (%s)\"), fileName)"
  },
  {
    "label": "UBA_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UBA_ASSERTF(!(c == PathSeparator && history[0] == '.' && history[1] == PathSeparator) || (IsWindows && TStrstr(fileName, TC(\"\\\\\\\\.\\\\pipe\"))), TC(\"Path is not valid (%s)\"), fileName)"
  },
  {
    "label": "UBA_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UBA_ASSERTF(!(c == PathSeparator && history[0] == '.' && history[1] == '.' && history[2] == PathSeparator), TC(\"Path is not valid (%s)\"), fileName)"
  },
  {
    "label": "UBA_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UBA_ASSERTF(c != NonPathSeparator, TC(\"Path is not valid (%s)\"), fileName)"
  },
  {
    "label": "UBA_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UBA_ASSERTF(c != PathSeparator || history[0] != PathSeparator || (IsWindows && TStrstr(fileName, TC(\"\\\\\\\\.\\\\pipe\"))), TC(\"Path is not valid (%s)\"), fileName)"
  },
  {
    "label": "UBA_ASSERTF()",
    "kind": "Method",
    "detail": "Function (history [ 2 ] = history [ 1 ] ; history [ 1 ] = history [ 0 ] ; history [ 0 ] = c ; })",
    "insertText": "UBA_ASSERTF(history[0] != ' ' && (history[0] != PathSeparator || (fileName[1] == ':' && fileName[3] == 0)), TC(\"Path is not valid (%s)\"), fileName)"
  },
  {
    "label": "CHECK_PATH()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "CHECK_PATH(path) CheckPath((const tchar*)path)"
  },
  {
    "label": "CHECK_PATH()",
    "kind": "Method",
    "detail": "Function (# else # define)",
    "insertText": "CHECK_PATH(path) while (false)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif } template<> struct std::hash<uba::StringKey> { size_t)",
    "insertText": "operator()(const uba::StringKey& g)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (c / = map .)",
    "insertText": "size()"
  },
  {
    "label": "printf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "printf(\"%s Size: %llu Buckets: %llu Quality: %f\\r\\n\", name, map.size(), map.bucket_count(), quality)"
  }
]