[
  {
    "label": "FPhysInterface_Chaos",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPhysInterface_Chaos"
  },
  {
    "label": "FBodyInstance",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBodyInstance"
  },
  {
    "label": "FPhysxUserData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPhysxUserData"
  },
  {
    "label": "IPhysicsReplicationFactory",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IPhysicsReplicationFactory"
  },
  {
    "label": "FConstraintDrive",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FConstraintDrive"
  },
  {
    "label": "FLinearDriveConstraint",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FLinearDriveConstraint"
  },
  {
    "label": "FAngularDriveConstraint",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAngularDriveConstraint"
  },
  {
    "label": "AWorldSettings",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AWorldSettings"
  },
  {
    "label": "FPhysInterface_Chaos()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" ChaosInterfaceWrapper . h \" # include \" Chaos / Declares . h \" # include \" Chaos / PhysicsObject . h \" # include \" PhysicsEngine / ConstraintTypes . h \" # include \" PhysicsInterfaceWrapperShared . h \" # include \" Physics / PhysicsInterfaceDeclares . h \" # include \" Physics / PhysicsInterfaceTypes . h \" # include \" Physics / GenericPhysicsInterface . h \" # include \" Physics / Experimental / PhysicsUserData_Chaos . h \" # include \" Chaos / ChaosEngineInterface . h \" int32 NextBodyIdValue = 0 ; int32 NextConstraintIdValue = 0 ; class FPhysInterface_Chaos ; struct FBodyInstance ; struct FPhysxUserData ; class IPhysicsReplicationFactory ; struct FConstraintDrive ; struct FLinearDriveConstraint ; struct FAngularDriveConstraint ; class AWorldSettings ; class FPhysInterface_Chaos : public FGenericPhysicsInterface,public FChaosEngineInterface { public :)",
    "insertText": "FPhysInterface_Chaos(const AWorldSettings* Settings=nullptr)"
  },
  {
    "label": "FPhysInterface_Chaos()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FPhysInterface_Chaos()"
  },
  {
    "label": "GetInterfaceDescription()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "GetInterfaceDescription()"
  },
  {
    "label": "ShapeToOriginalBodyInstance()",
    "kind": "Method",
    "detail": "Function (} const FBodyInstance*)",
    "insertText": "ShapeToOriginalBodyInstance(const FBodyInstance* InCurrentInstance, const Chaos::FPerShapeData* InShape)"
  },
  {
    "label": "CreateMaterialMask()",
    "kind": "Method",
    "detail": "Function (FPhysicsMaterialMaskHandle)",
    "insertText": "CreateMaterialMask(const UPhysicalMaterialMask* InMaterialMask)"
  },
  {
    "label": "UpdateMaterialMask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateMaterialMask(FPhysicsMaterialMaskHandle& InHandle, const UPhysicalMaterialMask* InMaterialMask)"
  },
  {
    "label": "FlushScene()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FlushScene(FPhysScene* InScene)"
  },
  {
    "label": "IsInScene()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsInScene(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "SetLinearMotionLimitType_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetLinearMotionLimitType_AssumesLocked(const FPhysicsConstraintHandle& InConstraintRef, PhysicsInterfaceTypes::ELimitAxis InAxis, ELinearConstraintMotion InMotion)"
  },
  {
    "label": "SetAngularMotionLimitType_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAngularMotionLimitType_AssumesLocked(const FPhysicsConstraintHandle& InConstraintRef, PhysicsInterfaceTypes::ELimitAxis InAxis, EAngularConstraintMotion InMotion)"
  },
  {
    "label": "UpdateLinearLimitParams_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateLinearLimitParams_AssumesLocked(const FPhysicsConstraintHandle& InConstraintRef, float InLimit, float InAverageMass, const FLinearConstraint& InParams)"
  },
  {
    "label": "UpdateConeLimitParams_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateConeLimitParams_AssumesLocked(const FPhysicsConstraintHandle& InConstraintRef, float InAverageMass, const FConeConstraint& InParams)"
  },
  {
    "label": "UpdateTwistLimitParams_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateTwistLimitParams_AssumesLocked(const FPhysicsConstraintHandle& InConstraintRef, float InAverageMass, const FTwistConstraint& InParams)"
  },
  {
    "label": "UpdateLinearDrive_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateLinearDrive_AssumesLocked(const FPhysicsConstraintHandle& InConstraintRef, const FLinearDriveConstraint& InDriveParams, bool InInitialize = false)"
  },
  {
    "label": "UpdateAngularDrive_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateAngularDrive_AssumesLocked(const FPhysicsConstraintHandle& InConstraintRef, const FAngularDriveConstraint& InDriveParams, bool InInitialize = false)"
  },
  {
    "label": "UpdateDriveTarget_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateDriveTarget_AssumesLocked(const FPhysicsConstraintHandle& InConstraintRef, const FLinearDriveConstraint& InLinDrive, const FAngularDriveConstraint& InAngDrive, bool InInitialize = false)"
  },
  {
    "label": "ExecuteOnUnbrokenConstraintReadOnly()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExecuteOnUnbrokenConstraintReadOnly(const FPhysicsConstraintHandle& InConstraintRef, TFunctionRef<void(const FPhysicsConstraintHandle&)> Func)"
  },
  {
    "label": "ExecuteOnUnbrokenConstraintReadWrite()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExecuteOnUnbrokenConstraintReadWrite(const FPhysicsConstraintHandle& InConstraintRef, TFunctionRef<void(const FPhysicsConstraintHandle&)> Func)"
  },
  {
    "label": "ExecuteRead()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExecuteRead(const FPhysicsActorHandle& InActorReference, TFunctionRef<void(const FPhysicsActorHandle& Actor)> InCallable)"
  },
  {
    "label": "ExecuteRead()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExecuteRead(USkeletalMeshComponent* InMeshComponent, TFunctionRef<void()> InCallable)"
  },
  {
    "label": "ExecuteRead()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExecuteRead(const FPhysicsActorHandle& InActorReferenceA, const FPhysicsActorHandle& InActorReferenceB, TFunctionRef<void(const FPhysicsActorHandle& ActorA, const FPhysicsActorHandle& ActorB)> InCallable)"
  },
  {
    "label": "ExecuteRead()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExecuteRead(const FPhysicsConstraintHandle& InConstraintRef, TFunctionRef<void(const FPhysicsConstraintHandle& Constraint)> InCallable)"
  },
  {
    "label": "ExecuteRead()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExecuteRead(FPhysScene* InScene, TFunctionRef<void()> InCallable)"
  },
  {
    "label": "ExecuteRead()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExecuteRead(Chaos::FPhysicsObject* InObjectA, Chaos::FPhysicsObject* InObjectB, TFunctionRef<void(Chaos::FPhysicsObject* InObjectA, Chaos::FPhysicsObject* InObjectB)> InCallable)"
  },
  {
    "label": "ExecuteWrite()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExecuteWrite(const FPhysicsActorHandle& InActorReference, TFunctionRef<void(const FPhysicsActorHandle& Actor)> InCallable)"
  },
  {
    "label": "ExecuteWrite()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExecuteWrite(FPhysicsActorHandle& InActorReference, TFunctionRef<void(FPhysicsActorHandle& Actor)> InCallable)"
  },
  {
    "label": "ExecuteWrite()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExecuteWrite(USkeletalMeshComponent* InMeshComponent, TFunctionRef<void()> InCallable)"
  },
  {
    "label": "ExecuteWrite()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExecuteWrite(const FPhysicsActorHandle& InActorReferenceA, const FPhysicsActorHandle& InActorReferenceB, TFunctionRef<void(const FPhysicsActorHandle& ActorA, const FPhysicsActorHandle& ActorB)> InCallable)"
  },
  {
    "label": "ExecuteWrite()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExecuteWrite(const FPhysicsConstraintHandle& InConstraintRef, TFunctionRef<void(const FPhysicsConstraintHandle& Constraint)> InCallable)"
  },
  {
    "label": "ExecuteWrite()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExecuteWrite(FPhysScene* InScene, TFunctionRef<void()> InCallable)"
  },
  {
    "label": "ExecuteWrite()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExecuteWrite(FPhysScene* InScene, TFunctionRef<void(FPhysScene* Scene)> InCallable)"
  },
  {
    "label": "ExecuteWrite()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExecuteWrite(Chaos::FPhysicsObject* InObjectA, Chaos::FPhysicsObject* InObjectB, TFunctionRef<void(Chaos::FPhysicsObject* InObjectA, Chaos::FPhysicsObject* InObjectB)> InCallable)"
  },
  {
    "label": "ExecuteShapeWrite()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExecuteShapeWrite(FBodyInstance* InInstance, FPhysicsShapeHandle& InShape, TFunctionRef<void(FPhysicsShapeHandle& InShape)> InCallable)"
  },
  {
    "label": "ExecPhysCommands()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExecPhysCommands(const TCHAR* Cmd, FOutputDevice* Ar, UWorld* InWorld)"
  },
  {
    "label": "CalculateMassPropertiesFromShapeCollection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalculateMassPropertiesFromShapeCollection(Chaos::FMassProperties& OutProperties, const TArray<FPhysicsShapeHandle>& InShapes, float InDensityKGPerCM)"
  },
  {
    "label": "CreateShape()",
    "kind": "Method",
    "detail": "Function (FPhysicsShapeHandle)",
    "insertText": "CreateShape(physx::PxGeometry* InGeom, bool bSimulation = true, bool bQuery = true, UPhysicalMaterial* InSimpleMaterial = nullptr, TArray<UPhysicalMaterial*>* InComplexMaterials = nullptr)"
  },
  {
    "label": "AddGeometry()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddGeometry(FPhysicsActorHandle& InActor, const FGeometryAddParams& InParams, TArray<FPhysicsShapeHandle>* OutOptShapes = nullptr)"
  },
  {
    "label": "CreateGeometry()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateGeometry(const FGeometryAddParams& InParams, TArray<Chaos::FImplicitObjectPtr>& OutGeoms, Chaos::FShapesArray& OutShapes, TArray<FPhysicsShapeHandle>* OutOptShapes)"
  },
  {
    "label": "LineTrace_Geom()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "LineTrace_Geom(FHitResult& OutHit, const FBodyInstance* InInstance, const FVector& InStart, const FVector& InEnd, bool bTraceComplex, bool bExtractPhysMaterial = false)"
  },
  {
    "label": "Sweep_Geom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Sweep_Geom(FHitResult& OutHit, const FBodyInstance* InInstance, const FVector& InStart, const FVector& InEnd, const FQuat& InShapeRotation, const FCollisionShape& InShape, bool bSweepComplex)"
  },
  {
    "label": "Overlap_Geom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Overlap_Geom(const FBodyInstance* InBodyInstance, const FPhysicsGeometryCollection& InGeometry, const FTransform& InShapeTransform, FMTDResult* OutOptResult = nullptr, bool bTraceComplex = false)"
  },
  {
    "label": "Overlap_Geom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Overlap_Geom(const FBodyInstance* InBodyInstance, const FCollisionShape& InCollisionShape, const FQuat& InShapeRotation, const FTransform& InShapeTransform, FMTDResult* OutOptResult = nullptr, bool bTraceComplex = false)"
  },
  {
    "label": "GetSquaredDistanceToBody()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetSquaredDistanceToBody(const FBodyInstance* InInstance, const FVector& InPoint, float& OutDistanceSquared, FVector* OutOptPointOnBody = nullptr)"
  },
  {
    "label": "SetMaterials()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMaterials(const FPhysicsShapeHandle& InShape, const TArrayView<UPhysicalMaterial*>InMaterials)"
  },
  {
    "label": "SetMaterials()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMaterials(const FPhysicsShapeHandle& InShape, const TArrayView<UPhysicalMaterial*> InMaterials, const TArrayView<FPhysicalMaterialMaskParams>& InMaterialMasks)"
  },
  {
    "label": "GetGeometryType()",
    "kind": "Method",
    "detail": "Function (} ; ECollisionShapeType)",
    "insertText": "GetGeometryType(const Chaos::FPerShapeData& Shape)"
  },
  {
    "label": "ComputeZeroDistanceImpactNormalAndPenetration()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ComputeZeroDistanceImpactNormalAndPenetration(const UWorld* World, const ChaosInterface::FLocationHit& Hit, const Chaos::FImplicitObject& Geom, const FTransform& QueryTM, FHitResult& OutResult)"
  },
  {
    "label": "DrawOverlappingTris()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DrawOverlappingTris(const UWorld* World, const ChaosInterface::FPTLocationHit& Hit, const Chaos::FImplicitObject& Geom, const FTransform& QueryTM)"
  },
  {
    "label": "ComputeZeroDistanceImpactNormalAndPenetration()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ComputeZeroDistanceImpactNormalAndPenetration(const UWorld* World, const ChaosInterface::FPTLocationHit& Hit, const Chaos::FImplicitObject& Geom, const FTransform& QueryTM, FHitResult& OutResult)"
  },
  {
    "label": "GetMaterialFromInternalFaceIndex()",
    "kind": "Method",
    "detail": "Function (} Chaos::FChaosPhysicsMaterial*)",
    "insertText": "GetMaterialFromInternalFaceIndex(const FPhysicsShape& Shape, const FPhysicsActor& Actor, uint32 InternalFaceIndex)"
  },
  {
    "label": "GetMaterialFromInternalFaceIndexAndHitLocation()",
    "kind": "Method",
    "detail": "Function (Chaos::FChaosPhysicsMaterial*)",
    "insertText": "GetMaterialFromInternalFaceIndexAndHitLocation(const FPhysicsShape& Shape, const FPhysicsActor& Actor, uint32 InternalFaceIndex, const FVector& HitLocation)"
  },
  {
    "label": "GetTriangleMeshExternalFaceIndex()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetTriangleMeshExternalFaceIndex(const FPhysicsShape& Shape, uint32 InternalFaceIndex)"
  },
  {
    "label": "GetShapes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetShapes(const FPhysActorDummy& RigidActor, FPhysTypeDummy** ShapesBuffer, uint32 NumShapes)"
  },
  {
    "label": "SetShape()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetShape(FPhysTypeDummy& Hit, FPhysTypeDummy* Shape)"
  },
  {
    "label": "IsBlocking()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsBlocking(const FPhysicsShape& PShape, const FCollisionFilterData& QueryFilter)"
  }
]