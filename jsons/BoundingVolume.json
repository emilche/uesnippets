[
  {
    "label": "FChaosVDDataWrapperUtils",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FChaosVDDataWrapperUtils"
  },
  {
    "label": "TSpatialAccelerationTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TSpatialAccelerationTraits"
  },
  {
    "label": "CParticleView",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CParticleView"
  },
  {
    "label": "FBoundingVolumeCVars",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBoundingVolumeCVars"
  },
  {
    "label": "TBVCellElement",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TBVCellElement"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TBVPayloadInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TBVPayloadInfo"
  },
  {
    "label": "TBoundingVolume",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TBoundingVolume"
  },
  {
    "label": "FSimpleVisitor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSimpleVisitor"
  },
  {
    "label": "FCellIntersection",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCellIntersection"
  },
  {
    "label": "FGridSet",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGridSet"
  },
  {
    "label": "CHAOS_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CHAOS_API"
  },
  {
    "label": "FAccelerationStructureHandle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAccelerationStructureHandle"
  },
  {
    "label": "Requires()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Requires(typename T::THandleType)"
  },
  {
    "label": "DECLARE_CYCLE_STAT()",
    "kind": "Method",
    "detail": "Function (} ; struct FBoundingVolumeCVars { int32 FilterFarBodies ; FAutoConsoleVariableRef CVarFilterFarBodies ; } ;)",
    "insertText": "DECLARE_CYCLE_STAT(TEXT(\"BoundingVolumeGenerateTree\"), STAT_BoundingVolumeGenerateTree, STATGROUP_Chaos)"
  },
  {
    "label": "DECLARE_CYCLE_STAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT(TEXT(\"BoundingVolumeComputeGlobalBox\"), STAT_BoundingVolumeComputeGlobalBox, STATGROUP_Chaos)"
  },
  {
    "label": "DECLARE_CYCLE_STAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT(TEXT(\"BoundingVolumeFillGrid\"), STAT_BoundingVolumeFillGrid, STATGROUP_Chaos)"
  },
  {
    "label": "DECLARE_CYCLE_STAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT(TEXT(\"BoundingVolumeRemoveElement\"), STAT_BoundingVolumeRemoveElement, STATGROUP_Chaos)"
  },
  {
    "label": "DECLARE_CYCLE_STAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT(TEXT(\"BoundingVolumeUpdateElement\"), STAT_BoundingVolumeUpdateElement, STATGROUP_Chaos)"
  },
  {
    "label": "DECLARE_CYCLE_STAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT(TEXT(\"BoundingVolumeAddElement\"), STAT_BoundingVolumeAddElement, STATGROUP_Chaos)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (namespace Chaos { template<TPayloadType,T,int d> struct TBVCellElement { TAABB<T,d> Bounds ; TPayloadType Payload ; TVector<int32,3> StartIdx ; TVector<int32,3> EndIdx ; void)",
    "insertText": "Serialize(FChaosArchive& Ar)"
  },
  {
    "label": "SerializeAsAABB()",
    "kind": "Method",
    "detail": "Function (TBox<T,d)",
    "insertText": "SerializeAsAABB(Ar, Bounds)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Ar<<Payload ; Ar<<StartIdx ; Ar<<EndIdx ; } } ; template<TPayloadType,class T,int d> FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar, TBVCellElement<TPayloadType, T, d>& Elem)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Elem .)",
    "insertText": "Serialize(Ar)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Ar<<GlobalPayloadIdx ; Ar<<DirtyPayloadIdx ; Ar<<StartIdx ; Ar<<EndIdx ; } } ; template<T,int d> FArchive&)",
    "insertText": "operator(FArchive& Ar, TBVPayloadInfo<T, d>& Info)"
  },
  {
    "label": "TBoundingVolume()",
    "kind": "Method",
    "detail": "Function (} template<ParticleView>)",
    "insertText": "TBoundingVolume(const ParticleView& Particles, const bool bUseVelocity = false, const T Dt = 0, const int32 MaxCells = DefaultMaxCells, const T InMaxPayloadBounds = DefaultMaxPayloadBounds) : ISpatialAcceleration<InPayloadType, T, d>(StaticType) , MaxPayloadBounds(InMaxPayloadBounds)"
  },
  {
    "label": "Reinitialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reinitialize(Particles, bUseVelocity, Dt, MaxCells)"
  },
  {
    "label": "TBoundingVolume()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBoundingVolume(TBoundingVolume<TPayloadType, T, d>&& Other) : ISpatialAcceleration<InPayloadType, T, d>(StaticType) , MGlobalPayloads(MoveTemp(Other.MGlobalPayloads)) , MGrid(MoveTemp(Other.MGrid)) , MElements(MoveTemp(Other.MElements)) , MDirtyElements(MoveTemp(Other.MDirtyElements)) , MPayloadInfo(MoveTemp(Other.MPayloadInfo)) , MaxPayloadBounds(Other.MaxPayloadBounds) , bIsEmpty(Other.bIsEmpty)"
  },
  {
    "label": "TBoundingVolume()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBoundingVolume(const TBoundingVolume<TPayloadType, T, d>& Other) : ISpatialAcceleration<InPayloadType, T, d>(StaticType) , MGlobalPayloads(Other.MGlobalPayloads) , MGrid(Other.MGrid) , MElements(Other.MElements.Copy()) , MDirtyElements(Other.MDirtyElements) , MPayloadInfo(Other.MPayloadInfo) , MaxPayloadBounds(Other.MaxPayloadBounds) , bIsEmpty(Other.bIsEmpty)"
  },
  {
    "label": "DeepAssign()",
    "kind": "Method",
    "detail": "Function (} public : void)",
    "insertText": "DeepAssign(const ISpatialAcceleration<TPayloadType, T, d>& Other)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (* this = static_cast<const TBoundingVolume<TPayloadType,T,)",
    "insertText": "d(Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TBoundingVolume<TPayloadType,T,d>&)",
    "insertText": "operator(const TBoundingVolume<TPayloadType, T, d>& Other)"
  },
  {
    "label": "DeepAssign()",
    "kind": "Method",
    "detail": "Function (ISpatialAcceleration<TPayloadType,FReal,3)",
    "insertText": "DeepAssign(Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MGlobalPayloads = Other . MGlobalPayloads ; MGrid = Other . MGrid ; MElements = Other . MElements ; MDirtyElements = Other . MDirtyElements ; MPayloadInfo = Other . MPayloadInfo ; MaxPayloadBounds = Other . MaxPayloadBounds ; bIsEmpty = Other . bIsEmpty ; return* this ; } TBoundingVolume<TPayloadType,T,d>&)",
    "insertText": "operator(TBoundingVolume<TPayloadType, T, d>&& Other)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MGlobalPayloads =)",
    "insertText": "MoveTemp(Other.MGlobalPayloads)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MGrid =)",
    "insertText": "MoveTemp(Other.MGrid)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MElements =)",
    "insertText": "MoveTemp(Other.MElements)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MDirtyElements =)",
    "insertText": "MoveTemp(Other.MDirtyElements)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MPayloadInfo =)",
    "insertText": "MoveTemp(Other.MPayloadInfo)"
  },
  {
    "label": "Copy()",
    "kind": "Method",
    "detail": "Function (MaxPayloadBounds = Other . MaxPayloadBounds ; bIsEmpty = Other . bIsEmpty ; return* this ; } TUniquePtr<ISpatialAcceleration<TPayloadType,T,d>>)",
    "insertText": "Copy()"
  },
  {
    "label": "Reinitialize()",
    "kind": "Method",
    "detail": "Function (} template<ParticleView> void)",
    "insertText": "Reinitialize(const ParticleView& Particles, const bool bUseVelocity = false, const T Dt = 0, const int32 MaxCells = DefaultMaxCells)"
  },
  {
    "label": "GenerateTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GenerateTree(Particles, bUseVelocity, Dt, MaxCells)"
  },
  {
    "label": "FindAllIntersectionsImp()",
    "kind": "Method",
    "detail": "Function (} TArray<TPayloadType>)",
    "insertText": "FindAllIntersectionsImp(const TAABB<T,d>& Intersection)"
  },
  {
    "label": "FSimpleVisitor()",
    "kind": "Method",
    "detail": "Function (struct FSimpleVisitor {)",
    "insertText": "FSimpleVisitor(TArray<TPayloadType>& InResults) : CollectedResults(InResults)"
  },
  {
    "label": "VisitOverlap()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "VisitOverlap(const TSpatialVisitorData<TPayloadType>& Instance)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (CollectedResults .)",
    "insertText": "Add(Instance.Payload)"
  },
  {
    "label": "Overlap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Overlap(Intersection, Collector)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (MGlobalPayloads .)",
    "insertText": "Reset()"
  },
  {
    "label": "RemoveElement()",
    "kind": "Method",
    "detail": "Function (bIsEmpty = true ; } bool)",
    "insertText": "RemoveElement(const TPayloadType& Payload)"
  },
  {
    "label": "SCOPE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SCOPE_CYCLE_COUNTER(STAT_BoundingVolumeRemoveElement)"
  },
  {
    "label": "RemoveGlobalElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveGlobalElement(Payload, *PayloadInfo)"
  },
  {
    "label": "RemoveElementFromExistingGrid()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "RemoveElementFromExistingGrid(Payload, *PayloadInfo)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} MPayloadInfo .)",
    "insertText": "Remove(Payload)"
  },
  {
    "label": "SCOPE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SCOPE_CYCLE_COUNTER(STAT_BoundingVolumeUpdateElement)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bElementExisted = true ;)",
    "insertText": "if(FPayloadInfo* PayloadInfo = MPayloadInfo.Find(Payload))"
  },
  {
    "label": "AddElementToExistingGrid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddElementToExistingGrid(Payload, *PayloadInfo, NewBounds, bHasBounds)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(bHasBounds)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} } else { bElementExisted = false ; FPayloadInfo& NewPayloadInfo = MPayloadInfo .)",
    "insertText": "Add(Payload)"
  },
  {
    "label": "AddElementToExistingGrid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddElementToExistingGrid(Payload, NewPayloadInfo, NewBounds, bHasBounds)"
  },
  {
    "label": "AddElement()",
    "kind": "Method",
    "detail": "Function (} return bElementExisted ; } void)",
    "insertText": "AddElement(const TPayloadBoundsElement<TPayloadType, T>& Payload)"
  },
  {
    "label": "RecomputeBounds()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RecomputeBounds()"
  },
  {
    "label": "GetElementCount()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetElementCount()"
  },
  {
    "label": "GlobalObjects()",
    "kind": "Method",
    "detail": "Function (} const TArray<TPayloadBoundsElement<TPayloadType,T>>&)",
    "insertText": "GlobalObjects()"
  },
  {
    "label": "ProxyVisitor()",
    "kind": "Method",
    "detail": "Function (TSpatialVisitor<TPayloadType,T>)",
    "insertText": "ProxyVisitor(Visitor)"
  },
  {
    "label": "RaycastFast()",
    "kind": "Method",
    "detail": "Function (} template<SQVisitor> bool)",
    "insertText": "RaycastFast(const TVector<T,d>& Start, FQueryFastData& CurData, SQVisitor& Visitor, const FVec3& Dir, const FVec3 InvDir, const bool bParallel[3])"
  },
  {
    "label": "RaycastFastSimd()",
    "kind": "Method",
    "detail": "Function (} template<SQVisitor> bool)",
    "insertText": "RaycastFastSimd(const VectorRegister4Double& Start, FQueryFastData& CurData, SQVisitor& Visitor, const VectorRegister4Double& Dir, const VectorRegister4Double& InvDir, const VectorRegister4Double& Parallel, const VectorRegister4Double& Length)"
  },
  {
    "label": "VectorStoreDouble3()",
    "kind": "Method",
    "detail": "Function (FVec3 StartReal ;)",
    "insertText": "VectorStoreDouble3(Start, &StartReal[0])"
  },
  {
    "label": "Raycast()",
    "kind": "Method",
    "detail": "Function (} template<SQVisitor,bool bPruneDuplicates = true> void)",
    "insertText": "Raycast(const TVector<T, d>& Start, const TVector<T, d>& Dir, const T Length, SQVisitor& Visitor)"
  },
  {
    "label": "CurData()",
    "kind": "Method",
    "detail": "Function (FQueryFastData)",
    "insertText": "CurData(Dir, Length)"
  },
  {
    "label": "bPruneDuplicates()",
    "kind": "Method",
    "detail": "Function (RaycastImp<SQVisitor,)",
    "insertText": "bPruneDuplicates(Start, CurData, Visitor, CurData.Dir, CurData.InvDir, CurData.bParallel)"
  },
  {
    "label": "Sweep()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Sweep(const TVector<T, d>& Start, const TVector<T, d>& Dir, const T Length, const TVector<T, d> QueryHalfExtents, ISpatialVisitor<TPayloadType, T>& Visitor)"
  },
  {
    "label": "Sweep()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Sweep(Start, Dir, Length, QueryHalfExtents, ProxyVisitor)"
  },
  {
    "label": "SweepFast()",
    "kind": "Method",
    "detail": "Function (} template<SQVisitor> bool)",
    "insertText": "SweepFast(const TVector<T,d>& Start, FQueryFastData& CurData, const TVector<T,d>& QueryHalfExtents, SQVisitor& Visitor, const FVec3& Dir, const FVec3 InvDir, const bool bParallel[3])"
  },
  {
    "label": "Sweep()",
    "kind": "Method",
    "detail": "Function (} template<SQVisitor,bool bPruneDuplicates = true> void)",
    "insertText": "Sweep(const TVector<T, d>& Start, const TVector<T, d>& Dir, const T Length, const TVector<T, d> QueryHalfExtents, SQVisitor& Visitor)"
  },
  {
    "label": "bPruneDuplicates()",
    "kind": "Method",
    "detail": "Function (SweepImp<SQVisitor,)",
    "insertText": "bPruneDuplicates(Start, CurData, QueryHalfExtents, Visitor, CurData.Dir, CurData.InvDir, CurData.bParallel)"
  },
  {
    "label": "Overlap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Overlap(const TAABB<T, d>& QueryBounds, ISpatialVisitor<TPayloadType, T>& Visitor)"
  },
  {
    "label": "Overlap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Overlap(QueryBounds, ProxyVisitor)"
  },
  {
    "label": "OverlapFast()",
    "kind": "Method",
    "detail": "Function (} template<SQVisitor> bool)",
    "insertText": "OverlapFast(const TAABB<T, d>& QueryBounds, SQVisitor& Visitor)"
  },
  {
    "label": "Overlap()",
    "kind": "Method",
    "detail": "Function (} template<SQVisitor,bool bPruneDuplicates = true> void)",
    "insertText": "Overlap(const TAABB<T, d>& QueryBounds, SQVisitor& Visitor)"
  },
  {
    "label": "bPruneDuplicates()",
    "kind": "Method",
    "detail": "Function (OverlapImp<SQVisitor,)",
    "insertText": "bPruneDuplicates(QueryBounds, Visitor)"
  },
  {
    "label": "IsLeafDirty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsLeafDirty()"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FExternalPhysicsCustomObjectVersion::GUID)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (TArray<TPayloadType> TmpPayloads ; Ar<<TmpPayloads ; MGlobalPayloads .)",
    "insertText": "Reserve(TmpPayloads.Num())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (MGlobalPayloads .)",
    "insertText": "Add({ Payload, TAABB<T,d>(TVector<T,d>(TNumericLimits<T>::Lowest()), TVector<T,d>(TNumericLimits<T>::Max())) })"
  },
  {
    "label": "GatherElements()",
    "kind": "Method",
    "detail": "Function (} MaxPayloadBounds = DefaultMaxPayloadBounds ; } else { Ar<<MGlobalPayloads ; Ar<<MaxPayloadBounds ; } Ar<<MGrid ; Ar<<MElements ; Ar<<MDirtyElements ; Ar<<bIsEmpty ; Ar<<MPayloadInfo ; } void)",
    "insertText": "GatherElements(TArray<TPayloadBoundsElement<TPayloadType, T>>& OutElements)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (OutElements .)",
    "insertText": "Reserve(GetReserveCount())"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (OutElements .)",
    "insertText": "Append(MGlobalPayloads)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutElements .)",
    "insertText": "Add(TPayloadBoundsElement<TPayloadType,T>{Elem.Payload,Elem.Bounds})"
  },
  {
    "label": "Counts()",
    "kind": "Method",
    "detail": "Function (} const auto& Counts = MGrid .)",
    "insertText": "Counts()"
  },
  {
    "label": "MElements()",
    "kind": "Method",
    "detail": "Function (const auto& Elems =)",
    "insertText": "MElements(X, Y, Z)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutElements .)",
    "insertText": "Add(TPayloadBoundsElement<TPayloadType, T>{Elem.Payload, Elem.Bounds})"
  },
  {
    "label": "GetReserveCount()",
    "kind": "Method",
    "detail": "Function (} } } } } } int32)",
    "insertText": "GetReserveCount()"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const int32 GridCount = Counts [ 0 ]* Counts [ 1 ]* Counts [ 2 ]* MElements .)",
    "insertText": "Num()"
  },
  {
    "label": "GetBounds()",
    "kind": "Method",
    "detail": "Function (} TAABB<T,d>)",
    "insertText": "GetBounds()"
  },
  {
    "label": "RemoveGlobalElement()",
    "kind": "Method",
    "detail": "Function (} private : using FCellElement = TBVCellElement<TPayloadType,T,d> ; using FPayloadInfo = TBVPayloadInfo<T,d> ; void)",
    "insertText": "RemoveGlobalElement(const TPayloadType& Payload, const FPayloadInfo& PayloadInfo)"
  },
  {
    "label": "Last()",
    "kind": "Method",
    "detail": "Function (auto LastGlobalPayload = MGlobalPayloads .)",
    "insertText": "Last()"
  },
  {
    "label": "FindChecked()",
    "kind": "Method",
    "detail": "Function (MPayloadInfo .)",
    "insertText": "FindChecked(LastGlobalPayload)"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (} MGlobalPayloads .)",
    "insertText": "RemoveAtSwap(PayloadInfo.GlobalPayloadIdx)"
  },
  {
    "label": "RaycastImp()",
    "kind": "Method",
    "detail": "Function (} template<SQVisitor,bool bPruneDuplicates = true> bool)",
    "insertText": "RaycastImp(const TVector<T, d>& Start, FQueryFastData& CurData, SQVisitor& Visitor, const FVec3& Dir, const FVec3 InvDir, const bool bParallel[3])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (T TOI,ExitTime ;)",
    "insertText": "for(const auto& Elem : MGlobalPayloads)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; } const auto& InstanceBounds = Elem . Bounds ;)",
    "insertText": "if(InstanceBounds.RaycastFast(Start, Dir, InvDir, bParallel, CurData.CurrentLength, CurData.InvCurrentLength, TOI, ExitTime))"
  },
  {
    "label": "VisitData()",
    "kind": "Method",
    "detail": "Function (TSpatialVisitorData<TPayloadType>)",
    "insertText": "VisitData(Elem.Payload, true, InstanceBounds)"
  },
  {
    "label": "VisitRaycast()",
    "kind": "Method",
    "detail": "Function (const bool bContinue = Visitor .)",
    "insertText": "VisitRaycast(VisitData, CurData)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (TVector<T,d> NextStart ; TVector<int32,d> CellIdx ; bool bCellsLeft = MElements .)",
    "insertText": "Num() && GlobalBounds.RaycastFast(Start, Dir, InvDir, bParallel, CurData.CurrentLength, CurData.InvCurrentLength, TOI, NextStart)"
  },
  {
    "label": "Cell()",
    "kind": "Method",
    "detail": "Function (CellIdx = MGrid .)",
    "insertText": "Cell(NextStart)"
  },
  {
    "label": "CellsVisited()",
    "kind": "Method",
    "detail": "Function (FGridSet)",
    "insertText": "CellsVisited(MGrid.Counts())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(bPruneDuplicates)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bSkip = false ;)",
    "insertText": "if(Elem.StartIdx[0] != Elem.EndIdx[0] || Elem.StartIdx[1] != Elem.EndIdx[1] || Elem.StartIdx[2] != Elem.EndIdx[2])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bSkip = true ; break ; } } } })",
    "insertText": "if(bSkip)"
  },
  {
    "label": "Location()",
    "kind": "Method",
    "detail": "Function (const TVector<T,d> CellCenter = MGrid .)",
    "insertText": "Location(CellIdx)"
  },
  {
    "label": "Dx()",
    "kind": "Method",
    "detail": "Function (const TVector<T,d>& Dx = MGrid .)",
    "insertText": "Dx()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (T Times [ 3 ] ; T BestTime = CurData . CurrentLength ; bool bTerminate = true ;)",
    "insertText": "for(int Axis = 0; Axis < d; ++Axis)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const T CrossPoint = Dir [ Axis ]> 0 ? CellCenter [ Axis ] + Dx [ Axis ] / 2 : CellCenter [ Axis ] - Dx [ Axis ] / 2 ; const T Distance = CrossPoint - NextStart [ Axis ] ; const T Time = Distance* InvDir [ Axis ] ; Times [ Axis ] = Time ;)",
    "insertText": "if(Time < BestTime)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (bTerminate = false ; BestTime = Time ; } } else { Times [ Axis ] = TNumericLimits<T)",
    "insertText": "Max()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(bTerminate)"
  },
  {
    "label": "Axis()",
    "kind": "Method",
    "detail": "Function (T Epsilon = 1 e - 2 f ; CellIdx [)",
    "insertText": "Axis(Times[Axis] <= BestTime + Epsilon) ? (Dir[Axis] > 0 ? 1 : -1)"
  },
  {
    "label": "SweepImp()",
    "kind": "Method",
    "detail": "Function (} return true ; } template<SQVisitor,bool bPruneDuplicates = true> bool)",
    "insertText": "SweepImp(const TVector<T, d>& Start, FQueryFastData& CurData, const TVector<T, d> QueryHalfExtents, SQVisitor& Visitor, const FVec3& Dir, const FVec3 InvDir, const bool bParallel[3])"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (continue ; } const TAABB<T,d>& InstanceBounds = Elem . Bounds ; const TVector<T,d> Min = InstanceBounds .)",
    "insertText": "Min()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TVector<T,d> TmpPosition ;)",
    "insertText": "if(TAABB<T, d>(Min,Max).RaycastFast(Start, Dir, InvDir, bParallel, CurData.CurrentLength, CurData.InvCurrentLength, TOI, TmpPosition))"
  },
  {
    "label": "VisitSweep()",
    "kind": "Method",
    "detail": "Function (const bool bContinue = Visitor .)",
    "insertText": "VisitSweep(VisitData, CurData)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TVector<T,d> TmpPosition ;)",
    "insertText": "if(TAABB<T, d>(Min, Max).RaycastFast(Start, Dir, InvDir, bParallel, CurData.CurrentLength, CurData.InvCurrentLength, TOI, TmpPosition))"
  },
  {
    "label": "Cell()",
    "kind": "Method",
    "detail": "Function (struct FCellIntersection { TVector<int32,d> CellIdx ; T TOI ; } ; const TVector<int32,d> StartMinIndex = MGrid .)",
    "insertText": "Cell(Start - QueryHalfExtents)"
  },
  {
    "label": "Cell()",
    "kind": "Method",
    "detail": "Function (const TVector<int32,d> StartMaxIndex = MGrid .)",
    "insertText": "Cell(Start + QueryHalfExtents)"
  },
  {
    "label": "Cell()",
    "kind": "Method",
    "detail": "Function (const TVector<T,d> End = Start + CurData . CurrentLength* Dir ; const TVector<int32,d> EndMinIndex = MGrid .)",
    "insertText": "Cell(End - QueryHalfExtents)"
  },
  {
    "label": "Cell()",
    "kind": "Method",
    "detail": "Function (const TVector<int32,d> EndMaxIndex = MGrid .)",
    "insertText": "Cell(End + QueryHalfExtents)"
  },
  {
    "label": "MElements()",
    "kind": "Method",
    "detail": "Function (const auto& Elems =)",
    "insertText": "MElements(StartMinIndex)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TVector<T,d> TmpPoint ;)",
    "insertText": "for(const auto& Elem : Elems)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TArray<FCellIntersection> IdxsQueue ;)",
    "insertText": "for(int32 X = StartMinIndex[0]; X <= StartMaxIndex[0]; ++X)"
  },
  {
    "label": "Idx()",
    "kind": "Method",
    "detail": "Function (const TVector<int32,3>)",
    "insertText": "Idx(X, Y, Z)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (IdxsQueue .)",
    "insertText": "Add({Idx, 0 })"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (IdxsSeen .)",
    "insertText": "Add(Idx)"
  },
  {
    "label": "RaycastFast()",
    "kind": "Method",
    "detail": "Function (} } } TVector<T,d> HitPoint ; const bool bInitialHit = GlobalBounds .)",
    "insertText": "RaycastFast(Start, Dir, InvDir, bParallel, CurData.CurrentLength, CurData.InvCurrentLength, TOI, HitPoint)"
  },
  {
    "label": "Cell()",
    "kind": "Method",
    "detail": "Function (TVector<int32,d> HitCellIdx = MGrid .)",
    "insertText": "Cell(HitPoint)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (IdxsQueue .)",
    "insertText": "Add({ HitCellIdx, TOI })"
  },
  {
    "label": "Dx()",
    "kind": "Method",
    "detail": "Function (} const TVector<T,d> HalfDx = MGrid .)",
    "insertText": "Dx() * (T)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int32 QueueIdx = 0 ;)",
    "insertText": "while(QueueIdx < IdxsQueue.Num())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const FCellIntersection CellIntersection = IdxsQueue [ QueueIdx + + ] ;)",
    "insertText": "if(CellIntersection.TOI > CurData.CurrentLength)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "check(d == 3)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const TVector<int32,3> Neighbors [ ] = { { - 1,- 1,- 1 },{ 0,- 1,- 1 },{ 1,- 1,- 1 },{ - 1,0,- 1 },{ 0,0,- 1 },{ 1,0,- 1 },{ - 1,1,- 1 },{ 0,1,- 1 },{ 1,1,- 1 },{ - 1,- 1,0 },{ 0,- 1,0 },{ 1,- 1,0 },{ - 1,0,0 },{ 1,0,0 },{ - 1,1,0 },{ 0,1,0 },{ 1,0,0 },{ - 1,- 1,1 },{ 0,- 1,1 },{ 1,- 1,1 },{ - 1,0,1 },{ 0,0,1 },{ 1,0,1 },{ - 1,1,1 },{ 0,1,1 },{ 1,1,1 } } ;)",
    "insertText": "for(const TVector<int32, 3>& Neighbor : Neighbors)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const TVector<int32,3> NeighborIdx = Neighbor + CellIntersection . CellIdx ; bool bSkip = false ;)",
    "insertText": "for(int32 Axis = 0; Axis < d; ++Axis)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bSkip = true ; break ; } })",
    "insertText": "if(!bSkip && !IdxsSeen.Contains(NeighborIdx))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (IdxsSeen .)",
    "insertText": "Add(NeighborIdx)"
  },
  {
    "label": "Location()",
    "kind": "Method",
    "detail": "Function (const TVector<T,d> NeighborCenter = MGrid .)",
    "insertText": "Location(NeighborIdx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const TVector<T,d> Min = NeighborCenter - QueryHalfExtents - HalfDx ; const TVector<T,d> Max = NeighborCenter + QueryHalfExtents + HalfDx ;)",
    "insertText": "if(TAABB<T, d>(Min, Max).RaycastFast(Start, Dir, InvDir, bParallel, CurData.CurrentLength, CurData.InvCurrentLength, TOI, HitPoint))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (IdxsQueue .)",
    "insertText": "Add({ NeighborIdx, TOI })"
  },
  {
    "label": "MElements()",
    "kind": "Method",
    "detail": "Function (} } } const auto& Elems =)",
    "insertText": "MElements(CellIntersection.CellIdx)"
  },
  {
    "label": "OverlapImp()",
    "kind": "Method",
    "detail": "Function (} } return true ; } template<SQVisitor,bool bPruneDuplicates = true> bool)",
    "insertText": "OverlapImp(const TAABB<T, d>& QueryBounds, SQVisitor& Visitor)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; } const TAABB<T,d>& InstanceBounds = Elem . Bounds ;)",
    "insertText": "if(QueryBounds.Intersects(InstanceBounds))"
  },
  {
    "label": "Cell()",
    "kind": "Method",
    "detail": "Function (const TVector<int32,d> StartIndex = MGrid .)",
    "insertText": "Cell(QueryBounds.Min())"
  },
  {
    "label": "Cell()",
    "kind": "Method",
    "detail": "Function (const TVector<int32,d> EndIndex = MGrid .)",
    "insertText": "Cell(QueryBounds.Max())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TSet<FUniqueIdx> InstancesSeen ;)",
    "insertText": "for(int32 X = StartIndex[0]; X <= EndIndex[0]; ++X)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (continue ; } InstancesSeen .)",
    "insertText": "Add(GetUniqueIdx(Elem.Payload))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bIsEmpty = true ;)",
    "insertText": "if(!Particles.Num())"
  },
  {
    "label": "SCOPE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (bIsEmpty = true ; return ; })",
    "insertText": "SCOPE_CYCLE_COUNTER(STAT_BoundingVolumeGenerateTree)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (TArray<TAABB<T,d>> AllBounds ; TArray<bool> HasBounds ; AllBounds .)",
    "insertText": "SetNum(Particles.Num())"
  },
  {
    "label": "Dt()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Dt(const auto& Particle, TAABB<T,d>& OutBounds)"
  },
  {
    "label": "ComputeWorldSpaceBoundingBox()",
    "kind": "Method",
    "detail": "Function (OutBounds =)",
    "insertText": "ComputeWorldSpaceBoundingBox(Particle, bUseVelocity, Dt)"
  },
  {
    "label": "SCOPE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SCOPE_CYCLE_COUNTER(STAT_BoundingVolumeComputeGlobalBox)"
  },
  {
    "label": "EmptyAABB()",
    "kind": "Method",
    "detail": "Function (OutGlobalBox = TAABB<T,d)",
    "insertText": "EmptyAABB()"
  },
  {
    "label": "InvD()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "InvD(T)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 Idx = 0 ; T Dx = 0 ; NumObjectsWithBounds = 0 ;)",
    "insertText": "for(auto& Particle : Particles)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TAABB<T,d>& Bounds = AllBounds [ Idx ] ;)",
    "insertText": "if((bFirstPass && GetValidBounds(Particle, Bounds)) || (!bFirstPass && HasBounds[Idx]))"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (HasBounds [ Idx ] = true ; OutGlobalBox .)",
    "insertText": "GrowToInclude(Bounds)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (Dx + = TVector<T,d)",
    "insertText": "DotProduct(Bounds.Extents(), TVector<T, d>(1))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (; NumObjectsWithBounds + = 1 ; } else)",
    "insertText": "if(bFirstPass)"
  },
  {
    "label": "TPayloadType()",
    "kind": "Method",
    "detail": "Function (HasBounds [ Idx ] = false ; auto Payload = Particle . template GetPayload<)",
    "insertText": "TPayloadType(Idx)"
  },
  {
    "label": "HasBoundingBox()",
    "kind": "Method",
    "detail": "Function (bool bTooBig =)",
    "insertText": "HasBoundingBox(Particle)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (GlobalPayloads .)",
    "insertText": "Add({ Payload, bTooBig ? Bounds : TAABB<T,d>(TVector<T,d>(TNumericLimits<T>::Lowest()), TVector<T,d>(TNumericLimits<T>::Max())) })"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (PayloadInfos .)",
    "insertText": "Add(Payload, FPayloadInfo{ GlobalPayloadIdx, INDEX_NONE })"
  },
  {
    "label": "NumObjectsWithBounds()",
    "kind": "Method",
    "detail": "Function (} + + Idx ; } Dx = NumObjectsWithBounds> 0 ? Dx /)",
    "insertText": "NumObjectsWithBounds(T)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bEvictElement = true ; break ; } })",
    "insertText": "if(bEvictElement)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (GlobalPayloads .)",
    "insertText": "Add({ Payload, WorldSpaceBox })"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (MPayloadInfo .)",
    "insertText": "Add(Payload, FPayloadInfo{ GlobalPayloadIdx, INDEX_NONE})"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } + + Idx ; })",
    "insertText": "if(bRecomputeBoxAndDx)"
  },
  {
    "label": "ComputeBoxAndDx()",
    "kind": "Method",
    "detail": "Function (Dx =)",
    "insertText": "ComputeBoxAndDx(GlobalBox, false)"
  },
  {
    "label": "Extents()",
    "kind": "Method",
    "detail": "Function (} } TVector<int32,d> Cells = Dx> 0 ? GlobalBox .)",
    "insertText": "Extents() / Dx : TVector<int32, d>(MaxCells)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (Cells + = TVector<int32,)",
    "insertText": "d(1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Cells [ Axis ] = MaxCells ; } } # if ENABLE_NAN_DIAGNOSTIC)",
    "insertText": "if(!ensure(!GlobalBox.Min().ContainsNaN() && !GlobalBox.Max().ContainsNaN()))"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (} # endif MGrid = TUniformGrid<T,)",
    "insertText": "d(GlobalBox.Min(), GlobalBox.Max(), Cells)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (MElements = TArrayND<TArray<FCellElement>,)",
    "insertText": "d(MGrid)"
  },
  {
    "label": "SCOPE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (T NumObjectsInCells = 0 ; {)",
    "insertText": "SCOPE_CYCLE_COUNTER(STAT_BoundingVolumeFillGrid)"
  },
  {
    "label": "Cell()",
    "kind": "Method",
    "detail": "Function (const TAABB<T,d>& ObjectBox = AllBounds [ Idx ] ; NumObjectsWithBounds + = 1 ; const auto StartIndex = MGrid .)",
    "insertText": "Cell(ObjectBox.Min())"
  },
  {
    "label": "Cell()",
    "kind": "Method",
    "detail": "Function (const auto EndIndex = MGrid .)",
    "insertText": "Cell(ObjectBox.Max())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (MPayloadInfo .)",
    "insertText": "Add(Payload, FPayloadInfo{ INDEX_NONE, INDEX_NONE, StartIndex, EndIndex })"
  },
  {
    "label": "MElements()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MElements(x, y, z).Add({ ObjectBox, Payload, StartIndex, EndIndex })"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (NumObjectsInCells + = 1 ; } } } } + + Idx ; } } bIsEmpty = NumObjectsInCells = = 0 ;)",
    "insertText": "UE_LOG(LogChaos, Verbose, TEXT(\"Generated Tree with (%d, %d, %d) Nodes and %f Per Cell\"), MGrid.Counts()[0], MGrid.Counts()[1], MGrid.Counts()[2], NumObjectsInCells / NumObjectsWithBounds)"
  },
  {
    "label": "RemoveElementFromExistingGrid()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveElementFromExistingGrid(const TPayloadType& Payload, const FPayloadInfo& PayloadInfo)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 ElemIdx = 0 ;)",
    "insertText": "for(FCellElement& Elem : Elems)"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (Elems .)",
    "insertText": "RemoveAtSwap(ElemIdx)"
  },
  {
    "label": "FindChecked()",
    "kind": "Method",
    "detail": "Function (MPayloadInfo .)",
    "insertText": "FindChecked(LastPayload)"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (} MDirtyElements .)",
    "insertText": "RemoveAtSwap(PayloadInfo.DirtyPayloadIdx)"
  },
  {
    "label": "AddElementToExistingGrid()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "AddElementToExistingGrid(const TPayloadType& Payload, FPayloadInfo& PayloadInfo, const TAABB<T, d>& NewBounds, bool bHasBounds)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (PayloadInfo . GlobalPayloadIdx = INDEX_NONE ;)",
    "insertText": "if(bIsEmpty == false)"
  },
  {
    "label": "CellUnsafe()",
    "kind": "Method",
    "detail": "Function (TVector<int32,3> StartIndex = MGrid .)",
    "insertText": "CellUnsafe(NewBounds.Min())"
  },
  {
    "label": "CellUnsafe()",
    "kind": "Method",
    "detail": "Function (TVector<int32,3> EndIndex = MGrid .)",
    "insertText": "CellUnsafe(NewBounds.Max())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bDirty = true ; break ; } })",
    "insertText": "if(!bDirty)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (PayloadInfo . DirtyPayloadIdx = INDEX_NONE ; PayloadInfo . StartIdx = StartIndex ; PayloadInfo . EndIdx = EndIndex ;)",
    "insertText": "for(int32 x = StartIndex[0]; x <= EndIndex[0]; ++x)"
  },
  {
    "label": "MElements()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MElements(x, y, z).Add({ NewBounds, Payload, StartIndex, EndIndex })"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (MDirtyElements .)",
    "insertText": "Add({ NewBounds, Payload })"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (PayloadInfo . DirtyPayloadIdx = INDEX_NONE ; MGlobalPayloads .)",
    "insertText": "Add({ Payload, bTooBig ? NewBounds : TAABB<T,d>(TVector<T,d>(TNumericLimits<T>::Lowest()), TVector<T,d>(TNumericLimits<T>::Max())) })"
  },
  {
    "label": "FindAllIntersectionsHelper()",
    "kind": "Method",
    "detail": "Function (} } TArray<TPayloadType>)",
    "insertText": "FindAllIntersectionsHelper(const TAABB<T, d>& ObjectBox)"
  },
  {
    "label": "MElements()",
    "kind": "Method",
    "detail": "Function (const TArray<FCellElement>& CellElements =)",
    "insertText": "MElements(x, y, z)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Intersections .)",
    "insertText": "Reserve(Intersections.Num() + CellElements.Num())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Intersections .)",
    "insertText": "Add(Elem.Payload)"
  },
  {
    "label": "Sort()",
    "kind": "Method",
    "detail": "Function (} } } } })",
    "insertText": "Sort(Intersections,[](const TPayloadType& A,const TPayloadType& B) { return GetUniqueIdx(A) < GetUniqueIdx(B); })"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (Intersections .)",
    "insertText": "RemoveAtSwap(i, EAllowShrinking::No)"
  },
  {
    "label": "FGridSet()",
    "kind": "Method",
    "detail": "Function (} } return Intersections ; } struct FGridSet {)",
    "insertText": "FGridSet(TVector<int32, 3> Size) : NumX(Size[0]) , NumY(Size[1]) , NumZ(Size[2])"
  },
  {
    "label": "BytesNeeded()",
    "kind": "Method",
    "detail": "Function (int32 BitsNeeded = NumX* NumY* NumZ ; int32)",
    "insertText": "BytesNeeded(BitsNeeded)"
  },
  {
    "label": "Memzero()",
    "kind": "Method",
    "detail": "Function (Data = new uint8 [ BytesNeeded ] ;)",
    "insertText": "Memzero(Data, BytesNeeded)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Contains(const TVector<int32, 3>& Coordinate)"
  },
  {
    "label": "Idx()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Idx(NumY * NumZ) * Coordinate[0] + (NumZ * Coordinate[1])"
  },
  {
    "label": "bContains()",
    "kind": "Method",
    "detail": "Function (int32 ByteIdx = Idx / 8 ; int32 BitIdx = Idx % 8 ; bool)",
    "insertText": "bContains(Data[ByteIdx] >> BitIdx)"
  },
  {
    "label": "uint8()",
    "kind": "Method",
    "detail": "Function (int32 ByteIdx = Idx / 8 ; int32 BitIdx = Idx % 8 ; uint8 Mask = static_cast<)",
    "insertText": "uint8(1 << BitIdx)"
  },
  {
    "label": "FGridSet()",
    "kind": "Method",
    "detail": "Function (Data [ ByteIdx ] | = Mask ; } ~)",
    "insertText": "FGridSet()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (delete [ ] Data ; } private : int32 NumX ; int32 NumY ; int32 NumZ ; uint8* Data ; } ; TArray<TPayloadBoundsElement<TPayloadType,T>> MGlobalPayloads ; TUniformGrid<T,d> MGrid ; TArrayND<TArray<FCellElement>,d> MElements ; TArray<FCellElement> MDirtyElements ; TArrayAsMap<TPayloadType,FPayloadInfo> MPayloadInfo ; T MaxPayloadBounds ; bool bIsEmpty ;::FChaosVDDataWrapperUtils ; } ; template<TPayloadType,class T,int d> FArchive&)",
    "insertText": "operator(FArchive& Ar, TBoundingVolume<TPayloadType, T, d>& BoundingVolume)"
  }
]