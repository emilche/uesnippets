[
  {
    "label": "FChaosSolversModule",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FChaosSolversModule"
  },
  {
    "label": "FPhysicsReplicationAsync",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPhysicsReplicationAsync"
  },
  {
    "label": "FPhysicsSolverBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPhysicsSolverBase"
  },
  {
    "label": "FPendingSpatialDataQueue",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPendingSpatialDataQueue"
  },
  {
    "label": "FChaosResultsManager",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FChaosResultsManager"
  },
  {
    "label": "FRewindData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRewindData"
  },
  {
    "label": "IRewindCallback",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IRewindCallback"
  },
  {
    "label": "EPendingSpatialDataOperation",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EPendingSpatialDataOperation"
  },
  {
    "label": "FSubStepInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSubStepInfo"
  },
  {
    "label": "EAsyncBlockMode",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EAsyncBlockMode"
  },
  {
    "label": "FPhysicsSolverProcessPushDataTask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPhysicsSolverProcessPushDataTask"
  },
  {
    "label": "FPhysicsSolverFrozenGTPreSimCallbacks",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPhysicsSolverFrozenGTPreSimCallbacks"
  },
  {
    "label": "FPhysicsSolverAdvanceTask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPhysicsSolverAdvanceTask"
  },
  {
    "label": "FAllSolverTasks",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAllSolverTasks"
  },
  {
    "label": "FSolverTasksPTOnly",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSolverTasksPTOnly"
  },
  {
    "label": "FPersistentPhysicsTask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPersistentPhysicsTask"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FPhysicsSolverEvents",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPhysicsSolverEvents"
  },
  {
    "label": "FScopedTraceSolverCallback",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FScopedTraceSolverCallback"
  },
  {
    "label": "TSolverSimMaterialScope",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TSolverSimMaterialScope"
  },
  {
    "label": "DECLARE_MULTICAST_DELEGATE_OneParam()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Framework / MultiBufferResource . h \" # include \" Chaos / Matrix . h \" # include \" Misc / ScopeLock . h \" # include \" ChaosLog . h \" # include \" Chaos / Framework / PhysicsProxyBase . h \" # include \" Framework / Threading . h \" # include \" Chaos / ParticleDirtyFlags . h \" # include \" Async / ParallelFor . h \" # include \" Containers / Queue . h \" # include \" Chaos / ChaosMarshallingManager . h \" # include \" Chaos / AsyncInitBodyHelper . h \" # include \" Stats / Stats2 . h \" # include \" ChaosSolversModule . h \" # if WITH_CHAOS_VISUAL_DEBUGGER # include \" ChaosVisualDebugger / ChaosVDContextProvider . h \" # endif # include \" ChaosDebugDraw / ChaosDDTypes . h \" class FChaosSolversModule ; class FPhysicsReplicationAsync ;)",
    "insertText": "DECLARE_MULTICAST_DELEGATE_OneParam(FSolverPreAdvance, Chaos::FReal)"
  },
  {
    "label": "DECLARE_MULTICAST_DELEGATE_OneParam()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_MULTICAST_DELEGATE_OneParam(FSolverPreBuffer, Chaos::FReal)"
  },
  {
    "label": "DECLARE_MULTICAST_DELEGATE_OneParam()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_MULTICAST_DELEGATE_OneParam(FSolverPostAdvance, Chaos::FReal)"
  },
  {
    "label": "DECLARE_MULTICAST_DELEGATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_MULTICAST_DELEGATE(FSolverTeardown)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (# ifndef UE_CHAOS_CALLBACK_TRACESTATS # define UE_CHAOS_CALLBACK_TRACESTATS STATS&& ! UE_BUILD_SHIPPING # endif)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"Async Pull Results\"), STAT_AsyncPullResults, STATGROUP_Chaos, CHAOS_API)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"Async Interpolate Results\"), STAT_AsyncInterpolateResults, STATGROUP_Chaos, CHAOS_API)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"Sync Pull Results\"), STAT_SyncPullResults, STATGROUP_Chaos, CHAOS_API)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"Process Single Particle Proxies\"), STAT_ProcessSingleProxy, STATGROUP_Chaos, CHAOS_API)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"Process Geometry Collections Proxies\"), STAT_ProcessGCProxy, STATGROUP_Chaos, CHAOS_API)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"Process Cluster Union Proxies\"), STAT_ProcessClusterUnionProxy, STATGROUP_Chaos, CHAOS_API)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"Pull Constraints\"), STAT_PullConstraints, STATGROUP_Chaos, CHAOS_API)"
  },
  {
    "label": "FSubStepInfo()",
    "kind": "Method",
    "detail": "Function (namespace Chaos { class FPhysicsSolverBase ; struct FPendingSpatialDataQueue ; class FChaosResultsManager ; class FRewindData ; class IRewindCallback ; enum EPendingSpatialDataOperation : uint8 ; int32 GSingleThreadedPhysics ; int32 UseAsyncInterpolation ; int32 ForceDisableAsyncPhysics ; FRealSingle AsyncInterpolationMultiplier ; struct FSubStepInfo {)",
    "insertText": "FSubStepInfo() : PseudoFraction(1.0) , Step(1) , NumSteps(1) , bSolverSubstepped(false)"
  },
  {
    "label": "FSubStepInfo()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FSubStepInfo(const FReal InPseudoFraction, const int32 InStep, const int32 InNumSteps) : PseudoFraction(InPseudoFraction) , Step(InStep) , NumSteps(InNumSteps) , bSolverSubstepped(false)"
  },
  {
    "label": "FSubStepInfo()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FSubStepInfo(const FReal InPseudoFraction, const int32 InStep, const int32 InNumSteps, bool bInSolverSubstepped) : PseudoFraction(InPseudoFraction) , Step(InStep) , NumSteps(InNumSteps) , bSolverSubstepped(bInSolverSubstepped)"
  },
  {
    "label": "FPhysicsSolverProcessPushDataTask()",
    "kind": "Method",
    "detail": "Function (} FReal PseudoFraction ; int32 Step ; int32 NumSteps ; bool bSolverSubstepped ; } ; enum EAsyncBlockMode { BlockOnlyPastFrames = 0,BlockForBestInterpolation = 1,DoNoBlock = 2 } ; class FPhysicsSolverProcessPushDataTask { public :)",
    "insertText": "FPhysicsSolverProcessPushDataTask(FPhysicsSolverBase& InSolver, FPushPhysicsData* InPushData) : Solver(InSolver) , PushData(InPushData)"
  },
  {
    "label": "GetStatId()",
    "kind": "Method",
    "detail": "Function (} TStatId)",
    "insertText": "GetStatId()"
  },
  {
    "label": "GetDesiredThread()",
    "kind": "Method",
    "detail": "Function (} ENamedThreads::Type)",
    "insertText": "GetDesiredThread()"
  },
  {
    "label": "GetSubsequentsMode()",
    "kind": "Method",
    "detail": "Function (ESubsequentsMode::Type)",
    "insertText": "GetSubsequentsMode()"
  },
  {
    "label": "ProcessPushData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ProcessPushData()"
  },
  {
    "label": "FPhysicsSolverFrozenGTPreSimCallbacks()",
    "kind": "Method",
    "detail": "Function (private : FPhysicsSolverBase& Solver ; FPushPhysicsData* PushData ; } ; class FPhysicsSolverFrozenGTPreSimCallbacks { public :)",
    "insertText": "FPhysicsSolverFrozenGTPreSimCallbacks(FPhysicsSolverBase& InSolver) : Solver(InSolver)"
  },
  {
    "label": "GTPreSimCallbacks()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GTPreSimCallbacks()"
  },
  {
    "label": "FPhysicsSolverAdvanceTask()",
    "kind": "Method",
    "detail": "Function (private : FPhysicsSolverBase& Solver ; } ; class FPhysicsSolverAdvanceTask { public :)",
    "insertText": "FPhysicsSolverAdvanceTask(FPhysicsSolverBase& InSolver, FPushPhysicsData* InPushData)"
  },
  {
    "label": "AdvanceSolver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AdvanceSolver()"
  },
  {
    "label": "GetChaosVDContextData()",
    "kind": "Method",
    "detail": "Function (private : FPhysicsSolverBase& Solver ; FPushPhysicsData* PushData ; # if WITH_CHAOS_VISUAL_DEBUGGER FChaosVDContext CVDContext ; public : FChaosVDContext&)",
    "insertText": "GetChaosVDContextData()"
  },
  {
    "label": "FSolverTasksPTOnly()",
    "kind": "Method",
    "detail": "Function (FPhysicsSolverBase& Solver ; } ; struct FSolverTasksPTOnly {)",
    "insertText": "FSolverTasksPTOnly()"
  },
  {
    "label": "FSolverTasksPTOnly()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FSolverTasksPTOnly(const FSolverTasksPTOnly&)"
  },
  {
    "label": "FSolverTasksPTOnly()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FSolverTasksPTOnly(FSolverTasksPTOnly&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FSolverTasksPTOnly&)",
    "insertText": "operator(const FSolverTasksPTOnly&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FSolverTasksPTOnly&)",
    "insertText": "operator(FSolverTasksPTOnly&&)"
  },
  {
    "label": "FSolverTasksPTOnly()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FSolverTasksPTOnly(FPhysicsSolverBase& InSolver, FPushPhysicsData* InPushData) : ProcessPushData(InSolver, InPushData) , AdvanceTask(InSolver, InPushData) , Solver(InSolver)"
  },
  {
    "label": "FPhysicsSolverEvents()",
    "kind": "Method",
    "detail": "Function (FPhysicsSolverBase& Solver ; } ; class FPersistentPhysicsTask ; enum class ELockType : uint8 ; enum class EThreadingModeTemp : uint8 { DedicatedThread,TaskGraph,SingleThread } ; class FPhysicsSolverEvents { public : ~)",
    "insertText": "FPhysicsSolverEvents()"
  },
  {
    "label": "Broadcast()",
    "kind": "Method",
    "detail": "Function (EventTeardown .)",
    "insertText": "Broadcast()"
  },
  {
    "label": "ClearCallbacks()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearCallbacks()"
  },
  {
    "label": "AddPreAdvanceCallback()",
    "kind": "Method",
    "detail": "Function (} FDelegateHandle)",
    "insertText": "AddPreAdvanceCallback(FSolverPreAdvance::FDelegate InDelegate)"
  },
  {
    "label": "RemovePreAdvanceCallback()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RemovePreAdvanceCallback(FDelegateHandle InHandle)"
  },
  {
    "label": "AddPreBufferCallback()",
    "kind": "Method",
    "detail": "Function (FDelegateHandle)",
    "insertText": "AddPreBufferCallback(FSolverPreAdvance::FDelegate InDelegate)"
  },
  {
    "label": "RemovePreBufferCallback()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RemovePreBufferCallback(FDelegateHandle InHandle)"
  },
  {
    "label": "AddPostAdvanceCallback()",
    "kind": "Method",
    "detail": "Function (FDelegateHandle)",
    "insertText": "AddPostAdvanceCallback(FSolverPostAdvance::FDelegate InDelegate)"
  },
  {
    "label": "RemovePostAdvanceCallback()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RemovePostAdvanceCallback(FDelegateHandle InHandle)"
  },
  {
    "label": "AddTeardownCallback()",
    "kind": "Method",
    "detail": "Function (FDelegateHandle)",
    "insertText": "AddTeardownCallback(FSolverTeardown::FDelegate InDelegate)"
  },
  {
    "label": "RemoveTeardownCallback()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RemoveTeardownCallback(FDelegateHandle InHandle)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (EventPreSolve .)",
    "insertText": "Clear()"
  },
  {
    "label": "FScopedTraceSolverCallback()",
    "kind": "Method",
    "detail": "Function (} protected : FSolverPreAdvance EventPreSolve ; FSolverPreBuffer EventPreBuffer ; FSolverPostAdvance EventPostSolve ; FSolverTeardown EventTeardown ; } ; # if UE_CHAOS_CALLBACK_TRACESTATS class FScopedTraceSolverCallback : public FCycleCounter { public :)",
    "insertText": "FScopedTraceSolverCallback(ISimCallbackObject* InCallback)"
  },
  {
    "label": "Start()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Start(CallbackStatId)"
  },
  {
    "label": "FScopedTraceSolverCallback()",
    "kind": "Method",
    "detail": "Function (} } } ~)",
    "insertText": "FScopedTraceSolverCallback()"
  },
  {
    "label": "Stop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Stop()"
  },
  {
    "label": "CastHelper()",
    "kind": "Method",
    "detail": "Function (} } ; # endif class FPhysicsSolverBase : public FPhysicsSolverEvents { public : template<Lambda> void)",
    "insertText": "CastHelper(const Lambda& Func)"
  },
  {
    "label": "Func()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Func((FPBDRigidsSolver&)*this)"
  },
  {
    "label": "CastChecked()",
    "kind": "Method",
    "detail": "Function (} FPBDRigidsSolver&)",
    "insertText": "CastChecked()"
  },
  {
    "label": "ChangeBufferMode()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ChangeBufferMode(EMultiBufferMode InBufferMode)"
  },
  {
    "label": "AddDirtyProxy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddDirtyProxy(IPhysicsProxyBase * ProxyBaseIn)"
  },
  {
    "label": "AddDirtyProxy()",
    "kind": "Method",
    "detail": "Function (MarshallingManager .)",
    "insertText": "AddDirtyProxy(ProxyBaseIn)"
  },
  {
    "label": "RemoveDirtyProxy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveDirtyProxy(IPhysicsProxyBase * ProxyBaseIn)"
  },
  {
    "label": "RemoveDirtyProxy()",
    "kind": "Method",
    "detail": "Function (MarshallingManager .)",
    "insertText": "RemoveDirtyProxy(ProxyBaseIn)"
  },
  {
    "label": "RemoveDirtyProxyIfNoShapesAreDirty()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveDirtyProxyIfNoShapesAreDirty(IPhysicsProxyBase* ProxyBaseIn)"
  },
  {
    "label": "RemoveDirtyProxyIfNoShapesAreDirty()",
    "kind": "Method",
    "detail": "Function (MarshallingManager .)",
    "insertText": "RemoveDirtyProxyIfNoShapesAreDirty(ProxyBaseIn)"
  },
  {
    "label": "GetDirtyProxyBucketInfo_External()",
    "kind": "Method",
    "detail": "Function (} const FDirtyProxiesBucketInfo&)",
    "insertText": "GetDirtyProxyBucketInfo_External()"
  },
  {
    "label": "GetDirtyProxyBucketInfoNum_External()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetDirtyProxyBucketInfoNum_External(EPhysicsProxyType Type)"
  },
  {
    "label": "AddDirtyProxiesUnsafe()",
    "kind": "Method",
    "detail": "Function (} template<TProxiesArray> void)",
    "insertText": "AddDirtyProxiesUnsafe(TProxiesArray& ProxiesArray)"
  },
  {
    "label": "AddDirtyProxiesUnsafe()",
    "kind": "Method",
    "detail": "Function (MarshallingManager .)",
    "insertText": "AddDirtyProxiesUnsafe(ProxiesArray)"
  },
  {
    "label": "AddDirtyProxyShape()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddDirtyProxyShape(IPhysicsProxyBase* ProxyBaseIn, int32 ShapeIdx)"
  },
  {
    "label": "AddDirtyProxyShape()",
    "kind": "Method",
    "detail": "Function (MarshallingManager .)",
    "insertText": "AddDirtyProxyShape(ProxyBaseIn, ShapeIdx)"
  },
  {
    "label": "SetNumDirtyShapes()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetNumDirtyShapes(IPhysicsProxyBase* Proxy, int32 NumShapes)"
  },
  {
    "label": "SetNumDirtyShapes()",
    "kind": "Method",
    "detail": "Function (MarshallingManager .)",
    "insertText": "SetNumDirtyShapes(Proxy, NumShapes)"
  },
  {
    "label": "CreateAndRegisterSimCallbackObject_External()",
    "kind": "Method",
    "detail": "Function (} template<TSimCallbackObjectType> TSimCallbackObjectType*)",
    "insertText": "CreateAndRegisterSimCallbackObject_External()"
  },
  {
    "label": "TSimCallbackObjectType()",
    "kind": "Method",
    "detail": "Function (auto NewCallbackObject = new)",
    "insertText": "TSimCallbackObjectType()"
  },
  {
    "label": "RegisterSimCallbackObject_External()",
    "kind": "Method",
    "detail": "Function (bSolverHasFrozenGameThreadCallbacks = true ; })",
    "insertText": "RegisterSimCallbackObject_External(NewCallbackObject)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ESimCallbackOptions& Options = CallbackObject -> Options ;)",
    "insertText": "if(bContactModification)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Options | = ESimCallbackOptions::ContactModification ; } else { Options& = ~ ESimCallbackOptions::ContactModification ; })",
    "insertText": "if(bRegisterRewindCallback)"
  },
  {
    "label": "EnqueueSimcallbackRewindRegisteration()",
    "kind": "Method",
    "detail": "Function (Options | = ESimCallbackOptions::Rewind ; } else { Options& = ~ ESimCallbackOptions::Rewind ; } return CallbackObject ; } void)",
    "insertText": "EnqueueSimcallbackRewindRegisteration(ISimCallbackObject* Callback)"
  },
  {
    "label": "UnregisterAndFreeSimCallbackObject_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnregisterAndFreeSimCallbackObject_External(ISimCallbackObject* SimCallbackObject)"
  },
  {
    "label": "UnregisterSimCallbackObject_External()",
    "kind": "Method",
    "detail": "Function (MarshallingManager .)",
    "insertText": "UnregisterSimCallbackObject_External(SimCallbackObject)"
  },
  {
    "label": "RegisterSimOneShotCallback()",
    "kind": "Method",
    "detail": "Function (} template<Lambda> void)",
    "insertText": "RegisterSimOneShotCallback(Lambda&& Func)"
  },
  {
    "label": "FSimCallbackCommandObject()",
    "kind": "Method",
    "detail": "Function (auto CommandObject = new)",
    "insertText": "FSimCallbackCommandObject(MoveTemp(Func))"
  },
  {
    "label": "RegisterSimCommand_External()",
    "kind": "Method",
    "detail": "Function (MarshallingManager .)",
    "insertText": "RegisterSimCommand_External(CommandObject)"
  },
  {
    "label": "EnqueueCommandImmediate()",
    "kind": "Method",
    "detail": "Function (} template<Lambda> void)",
    "insertText": "EnqueueCommandImmediate(Lambda&& Func)"
  },
  {
    "label": "RegisterSimOneShotCallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterSimOneShotCallback(MoveTemp(Func))"
  },
  {
    "label": "SetRewindCallback()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetRewindCallback(TUniquePtr<IRewindCallback>&& RewindCallback)"
  },
  {
    "label": "GetRewindData()",
    "kind": "Method",
    "detail": "Function (FRewindData*)",
    "insertText": "GetRewindData()"
  },
  {
    "label": "GetRewindCallback()",
    "kind": "Method",
    "detail": "Function (} IRewindCallback*)",
    "insertText": "GetRewindCallback()"
  },
  {
    "label": "ShouldApplyRewindCallbacks()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ShouldApplyRewindCallbacks()"
  },
  {
    "label": "SetUseCollisionResimCache()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetUseCollisionResimCache(bool InUseCollisionResimCache)"
  },
  {
    "label": "GetUseCollisionResimCache()",
    "kind": "Method",
    "detail": "Function (bUseCollisionResimCache = InUseCollisionResimCache ; } bool)",
    "insertText": "GetUseCollisionResimCache()"
  },
  {
    "label": "GetPhysicsReplication()",
    "kind": "Method",
    "detail": "Function (PhysicsReplication = InPhysicsReplication ; } FPhysicsReplicationAsync*)",
    "insertText": "GetPhysicsReplication()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FGeometryParticle* Result = nullptr ;)",
    "insertText": "if(ensure(UniqueIdx.Idx < UniqueIdxToGTParticles.Num()))"
  },
  {
    "label": "WaitOnPendingTasks_External()",
    "kind": "Method",
    "detail": "Function (Result = UniqueIdxToGTParticles [ UniqueIdx . Idx ] ; } return Result ; } void)",
    "insertText": "WaitOnPendingTasks_External()"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Get().WaitUntilTaskCompletes(PendingTasks)"
  },
  {
    "label": "KillSafeAsyncTasks()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "KillSafeAsyncTasks()"
  },
  {
    "label": "AreAnyTasksPending()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "AreAnyTasksPending()"
  },
  {
    "label": "SetThreadingMode_External()",
    "kind": "Method",
    "detail": "Function (Owner = InOwner ; } void)",
    "insertText": "SetThreadingMode_External(EThreadingModeTemp InThreadingMode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (InThreadingMode = EThreadingModeTemp::SingleThread ; })",
    "insertText": "if(InThreadingMode != ThreadingMode)"
  },
  {
    "label": "MarkShuttingDown()",
    "kind": "Method",
    "detail": "Function (} ThreadingMode = InThreadingMode ; } } void)",
    "insertText": "MarkShuttingDown()"
  },
  {
    "label": "IsShuttingDown()",
    "kind": "Method",
    "detail": "Function (bIsShuttingDown = true ; } bool)",
    "insertText": "IsShuttingDown()"
  },
  {
    "label": "GetAsyncDeltaTime()",
    "kind": "Method",
    "detail": "Function (FReal)",
    "insertText": "GetAsyncDeltaTime()"
  },
  {
    "label": "ConditionalApplyRewind_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConditionalApplyRewind_Internal()"
  },
  {
    "label": "IsResimming()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsResimming()"
  },
  {
    "label": "SetDebugName()",
    "kind": "Method",
    "detail": "Function (# if CHAOS_DEBUG_NAME void)",
    "insertText": "SetDebugName(const FName& Name)"
  },
  {
    "label": "GetDebugName()",
    "kind": "Method",
    "detail": "Function (# endif FName)",
    "insertText": "GetDebugName()"
  },
  {
    "label": "IsGameThreadFrozen()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsGameThreadFrozen()"
  },
  {
    "label": "ApplyCallbacks_Internal()",
    "kind": "Method",
    "detail": "Function (bGameThreadFrozen = InGameThreadFrozen ; } void)",
    "insertText": "ApplyCallbacks_Internal()"
  },
  {
    "label": "QUICK_SCOPE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "QUICK_SCOPE_CYCLE_COUNTER(ApplySimCallbacks)"
  },
  {
    "label": "GetSolverTime()",
    "kind": "Method",
    "detail": "Function (const FReal SimTime =)",
    "insertText": "GetSolverTime()"
  },
  {
    "label": "TraceCallback()",
    "kind": "Method",
    "detail": "Function (FScopedTraceSolverCallback)",
    "insertText": "TraceCallback(Callback)"
  },
  {
    "label": "SetSimAndDeltaTime_Internal()",
    "kind": "Method",
    "detail": "Function (Callback ->)",
    "insertText": "SetSimAndDeltaTime_Internal(SimTime, MLastDt)"
  },
  {
    "label": "PreSimulate_Internal()",
    "kind": "Method",
    "detail": "Function (Callback ->)",
    "insertText": "PreSimulate_Internal()"
  },
  {
    "label": "FinalizeCallbackData_Internal()",
    "kind": "Method",
    "detail": "Function (} } } } void)",
    "insertText": "FinalizeCallbackData_Internal()"
  },
  {
    "label": "FinalizeOutputData_Internal()",
    "kind": "Method",
    "detail": "Function (Callback ->)",
    "insertText": "FinalizeOutputData_Internal()"
  },
  {
    "label": "SetCurrentInput_Internal()",
    "kind": "Method",
    "detail": "Function (Callback ->)",
    "insertText": "SetCurrentInput_Internal(nullptr)"
  },
  {
    "label": "UpdateParticleInAccelerationStructure_External()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "UpdateParticleInAccelerationStructure_External(FGeometryParticle* Particle, EPendingSpatialDataOperation InOperation)"
  },
  {
    "label": "IsPaused_External()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsPaused_External()"
  },
  {
    "label": "PullPhysicsStateForEachDirtyProxy_External()",
    "kind": "Method",
    "detail": "Function (bPaused_External = bShouldPause ; } template<TDispatcher> void)",
    "insertText": "PullPhysicsStateForEachDirtyProxy_External(TDispatcher& Dispatcher)"
  },
  {
    "label": "IsUsingAsyncResults()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsUsingAsyncResults()"
  },
  {
    "label": "SetMaxDeltaTime_External()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetMaxDeltaTime_External(float InMaxDeltaTime)"
  },
  {
    "label": "SetMinDeltaTime_External()",
    "kind": "Method",
    "detail": "Function (MMaxDeltaTime = InMaxDeltaTime ; } void)",
    "insertText": "SetMinDeltaTime_External(float InMinDeltaTime)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (MMinDeltaTime =)",
    "insertText": "Max(InMinDeltaTime, UE_SMALL_NUMBER)"
  },
  {
    "label": "GetMaxDeltaTime_External()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GetMaxDeltaTime_External()"
  },
  {
    "label": "GetMaxSubSteps_External()",
    "kind": "Method",
    "detail": "Function (MMaxSubSteps = InMaxSubSteps ; } int32)",
    "insertText": "GetMaxSubSteps_External()"
  },
  {
    "label": "GetSolverSubstep_External()",
    "kind": "Method",
    "detail": "Function (bSolverSubstep_External = bInSubstepExternal ; } bool)",
    "insertText": "GetSolverSubstep_External()"
  },
  {
    "label": "GetExternalTime_External()",
    "kind": "Method",
    "detail": "Function (const FReal ExternalTime = MarshallingManager .)",
    "insertText": "GetExternalTime_External()"
  },
  {
    "label": "SetSolverTime()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetSolverTime(const FReal InTime)"
  },
  {
    "label": "SetAsyncInterpolationMultiplier()",
    "kind": "Method",
    "detail": "Function (AsyncBlockMode = InAsyncBlockMode ; } void)",
    "insertText": "SetAsyncInterpolationMultiplier(FRealSingle InAsyncInterpolationMultiplier)"
  },
  {
    "label": "GetAsyncInterpolationMultiplier()",
    "kind": "Method",
    "detail": "Function (AsyncMultiplier = InAsyncInterpolationMultiplier ; } float)",
    "insertText": "GetAsyncInterpolationMultiplier()"
  },
  {
    "label": "CVarDebugNetworkPhysicsPrediction()",
    "kind": "Method",
    "detail": "Function (int32 DebugNetworkPhysicsPrediction = 0 ; FAutoConsoleVariableRef)",
    "insertText": "CVarDebugNetworkPhysicsPrediction(TEXT(\"np2.DebugNetworkPhysicsPrediction\"), DebugNetworkPhysicsPrediction, TEXT(\"Debugs network physics prediction\"))"
  },
  {
    "label": "GetModule()",
    "kind": "Method",
    "detail": "Function (const bool NetworkPhysicsEnabled =)",
    "insertText": "GetModule()->GetSettingsProvider().GetPhysicsPredictionEnabled()"
  },
  {
    "label": "GetModule()",
    "kind": "Method",
    "detail": "Function (const float PhysicsHistoryTimeLength =)",
    "insertText": "GetModule()->GetSettingsProvider().GetPhysicsHistoryTimeLength()"
  },
  {
    "label": "GetModule()",
    "kind": "Method",
    "detail": "Function (const int32 PhysicsHistoryCount =)",
    "insertText": "GetModule()->GetSettingsProvider().GetPhysicsHistoryCount()"
  },
  {
    "label": "GetModule()",
    "kind": "Method",
    "detail": "Function (const float ResimulationErrorThreshold =)",
    "insertText": "GetModule()->GetSettingsProvider().GetResimulationErrorPositionThreshold()"
  },
  {
    "label": "GetModule()",
    "kind": "Method",
    "detail": "Function (const bool ResimulationErrorPositionThresholdEnabled =)",
    "insertText": "GetModule()->GetSettingsProvider().GetResimulationErrorPositionThresholdEnabled()"
  },
  {
    "label": "GetModule()",
    "kind": "Method",
    "detail": "Function (const bool ResimulationErrorRotationThresholdEnabled =)",
    "insertText": "GetModule()->GetSettingsProvider().GetResimulationErrorRotationThresholdEnabled()"
  },
  {
    "label": "GetModule()",
    "kind": "Method",
    "detail": "Function (const float ResimulationErrorRotationThreshold =)",
    "insertText": "GetModule()->GetSettingsProvider().GetResimulationErrorRotationThreshold()"
  },
  {
    "label": "GetModule()",
    "kind": "Method",
    "detail": "Function (const bool ResimulationErrorLinearVelocityThresholdEnabled =)",
    "insertText": "GetModule()->GetSettingsProvider().GetResimulationErrorLinearVelocityThresholdEnabled()"
  },
  {
    "label": "GetModule()",
    "kind": "Method",
    "detail": "Function (const float ResimulationErrorLinearVelocityThreshold =)",
    "insertText": "GetModule()->GetSettingsProvider().GetResimulationErrorLinearVelocityThreshold()"
  },
  {
    "label": "GetModule()",
    "kind": "Method",
    "detail": "Function (const bool ResimulationErrorAngularVelocityThresholdEnabled =)",
    "insertText": "GetModule()->GetSettingsProvider().GetResimulationErrorAngularVelocityThresholdEnabled()"
  },
  {
    "label": "GetModule()",
    "kind": "Method",
    "detail": "Function (const float ResimulationErrorAngularVelocityThreshold =)",
    "insertText": "GetModule()->GetSettingsProvider().GetResimulationErrorAngularVelocityThreshold()"
  },
  {
    "label": "CVarNetworkPhysicsPredictionInterpLerp()",
    "kind": "Method",
    "detail": "Function (float NetworkPhysicsPredictionInterpLerp = 0 . 1 f ; FAutoConsoleVariableRef)",
    "insertText": "CVarNetworkPhysicsPredictionInterpLerp(TEXT(\"np2.NetworkPhysicsPredictionInterpLerp\"), NetworkPhysicsPredictionInterpLerp, TEXT(\"State lerp value in between the target state and the current one in case resim is disabled or if the pawn is not possessed (continuous correction)\"))"
  },
  {
    "label": "FPhysicsSolverBase()",
    "kind": "Method",
    "detail": "Function (bIsStandaloneSolver = bStandaloneSolver ; } protected : bool bIsStandaloneSolver = false ; EMultiBufferMode BufferMode ; EThreadingModeTemp ThreadingMode ;)",
    "insertText": "FPhysicsSolverBase(const EMultiBufferMode BufferingModeIn,const EThreadingModeTemp InThreadingMode,UObject* InOwner, FReal AsyncDt)"
  },
  {
    "label": "FPhysicsSolverBase()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FPhysicsSolverBase()"
  },
  {
    "label": "DestroySolver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestroySolver(FPhysicsSolverBase& InSolver)"
  },
  {
    "label": "FPhysicsSolverBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPhysicsSolverBase(const FPhysicsSolverBase& InCopy)"
  },
  {
    "label": "FPhysicsSolverBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPhysicsSolverBase(FPhysicsSolverBase&& InSteal)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FPhysicsSolverBase&)",
    "insertText": "operator(const FPhysicsSolverBase& InCopy)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FPhysicsSolverBase&)",
    "insertText": "operator(FPhysicsSolverBase&& InSteal)"
  },
  {
    "label": "PrepareAdvanceBy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrepareAdvanceBy(const FReal Dt)"
  },
  {
    "label": "AdvanceSolverBy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AdvanceSolverBy(const FSubStepInfo& SubStepInfo = FSubStepInfo())"
  },
  {
    "label": "PushPhysicsState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PushPhysicsState(const FReal Dt, const int32 NumSteps, const int32 NumExternalSteps)"
  },
  {
    "label": "ProcessPushedData_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ProcessPushedData_Internal(FPushPhysicsData& PushDataArray)"
  },
  {
    "label": "SetExternalTimestampConsumed_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetExternalTimestampConsumed_Internal(const int32 Timestamp)"
  },
  {
    "label": "OnDebugNameChanged()",
    "kind": "Method",
    "detail": "Function (# if CHAOS_DEBUG_NAME void)",
    "insertText": "OnDebugNameChanged()"
  },
  {
    "label": "FReal()",
    "kind": "Method",
    "detail": "Function (} FName DebugName ; # endif FChaosMarshallingManager MarshallingManager ; TUniquePtr<FChaosResultsManager> PullResultsManager ; TUniquePtr<FPendingSpatialDataQueue> PendingSpatialOperations_External ; TArray<ISimCallbackObject*> SimCallbackObjects ; TArray<ISimCallbackObject*> MidPhaseModifiers ; TArray<ISimCallbackObject*> CCDModifiers ; TArray<ISimCallbackObject*> StrainModifiers ; TArray<ISimCallbackObject*> ContactModifiers ; TArray<ISimCallbackObject*> RegistrationWatchers ; TArray<ISimCallbackObject*> UnregistrationWatchers ; TArray<ISimCallbackObject*> PhysicsObjectUnregistrationWatchers ; TUniquePtr<FRewindData> MRewindData ; TUniquePtr<IRewindCallback> MRewindCallback ; FPhysicsReplicationAsync* PhysicsReplication ; bool bUseCollisionResimCache ; FGraphEventRef PendingTasks ; bool bSolverHasFrozenGameThreadCallbacks = false ; bool bGameThreadFrozen = false ; FReal MLastDt =)",
    "insertText": "FReal(0)"
  },
  {
    "label": "RegisterSimCallbackObject_External()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "RegisterSimCallbackObject_External(ISimCallbackObject* SimCallbackObject)"
  },
  {
    "label": "SetSolver_External()",
    "kind": "Method",
    "detail": "Function (SimCallbackObject ->)",
    "insertText": "SetSolver_External(this)"
  },
  {
    "label": "RegisterSimCallbackObject_External()",
    "kind": "Method",
    "detail": "Function (MarshallingManager .)",
    "insertText": "RegisterSimCallbackObject_External(SimCallbackObject)"
  },
  {
    "label": "GetExternalDataLock_External()",
    "kind": "Method",
    "detail": "Function (} TAtomic<int32> NumPendingSolverAdvanceTasks ; bool bPaused_External ; const UObject* Owner = nullptr ; FRWLock SimMaterialLock ; TUniquePtr<FPhysSceneLock> ExternalDataLock_External ; FChaosSolversModule ; FPhysicsSolverProcessPushDataTask ; FPhysicsSolverAdvanceTask ; template<ELockType> struct TSolverSimMaterialScope ; bool bIsShuttingDown ; bool bSolverSubstep_External ; FReal AsyncDt ; FReal AccumulatedTime ; float MMaxDeltaTime ; float MMinDeltaTime ; int32 MMaxSubSteps ; int32 ExternalSteps ; TArray<FGeometryParticle*> UniqueIdxToGTParticles ; EAsyncBlockMode AsyncBlockMode ; float AsyncMultiplier ; public : FPhysSceneLock&)",
    "insertText": "GetExternalDataLock_External()"
  },
  {
    "label": "ClearGTParticle_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearGTParticle_External(FGeometryParticle& Particle)"
  },
  {
    "label": "SetStealAdvanceTasks_ForTesting()",
    "kind": "Method",
    "detail": "Function (# if ! UE_BUILD_SHIPPING private : bool bStealAdvanceTasksForTesting ; TArray<FAllSolverTasks> StolenSolverAdvanceTasks ; public : void)",
    "insertText": "SetStealAdvanceTasks_ForTesting(bool bInStealAdvanceTasksForTesting)"
  },
  {
    "label": "PopAndExecuteStolenAdvanceTask_ForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PopAndExecuteStolenAdvanceTask_ForTesting()"
  }
]