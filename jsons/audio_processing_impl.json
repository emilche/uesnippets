[
  {
    "label": "ApmDataDumper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ApmDataDumper"
  },
  {
    "label": "AudioConverter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AudioConverter"
  },
  {
    "label": "AudioProcessingImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AudioProcessingImpl"
  },
  {
    "label": "RuntimeSettingEnqueuer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RuntimeSettingEnqueuer"
  },
  {
    "label": "SubmoduleStates",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SubmoduleStates"
  },
  {
    "label": "Submodules",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Submodules"
  },
  {
    "label": "ApmFormatState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ApmFormatState"
  },
  {
    "label": "ApmConstants",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ApmConstants"
  },
  {
    "label": "ApmCaptureState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ApmCaptureState"
  },
  {
    "label": "ApmCaptureNonLockedState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ApmCaptureNonLockedState"
  },
  {
    "label": "ApmRenderState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ApmRenderState"
  },
  {
    "label": "ApmStatsReporter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ApmStatsReporter"
  },
  {
    "label": "RuntimeSettingQueueSize()",
    "kind": "Method",
    "detail": "Function (# ifndef MODULES_AUDIO_PROCESSING_AUDIO_PROCESSING_IMPL_H_ # define MODULES_AUDIO_PROCESSING_AUDIO_PROCESSING_IMPL_H_ # include<stdio . h> # include<atomic> # include<list> # include<memory> # include<string> # include<vector> # include \" absl / strings / string_view . h \" # include \" absl / types / optional . h \" # include \" api / array_view . h \" # include \" api / function_view . h \" # include \" modules / audio_processing / aec3 / echo_canceller3 . h \" # include \" modules / audio_processing / agc / agc_manager_direct . h \" # include \" modules / audio_processing / agc / gain_control . h \" # include \" modules / audio_processing / agc2 / input_volume_stats_reporter . h \" # include \" modules / audio_processing / audio_buffer . h \" # include \" modules / audio_processing / capture_levels_adjuster / capture_levels_adjuster . h \" # include \" modules / audio_processing / echo_control_mobile_impl . h \" # include \" modules / audio_processing / gain_control_impl . h \" # include \" modules / audio_processing / gain_controller2 . h \" # include \" modules / audio_processing / high_pass_filter . h \" # include \" modules / audio_processing / include / aec_dump . h \" # include \" modules / audio_processing / include / audio_frame_proxies . h \" # include \" modules / audio_processing / include / audio_processing . h \" # include \" modules / audio_processing / include / audio_processing_statistics . h \" # include \" modules / audio_processing / ns / noise_suppressor . h \" # include \" modules / audio_processing / optionally_built_submodule_creators . h \" # include \" modules / audio_processing / render_queue_item_verifier . h \" # include \" modules / audio_processing / rms_level . h \" # include \" modules / audio_processing / transient / transient_suppressor . h \" # include \" rtc_base / gtest_prod_util . h \" # include \" rtc_base / ignore_wundef . h \" # include \" rtc_base / swap_queue . h \" # include \" rtc_base / synchronization / mutex . h \" # include \" rtc_base / thread_annotations . h \" namespace webrtc { class ApmDataDumper ; class AudioConverter ; int)",
    "insertText": "RuntimeSettingQueueSize()"
  },
  {
    "label": "AudioProcessingImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AudioProcessingImpl(const AudioProcessing::Config& config, std::unique_ptr<CustomProcessing> capture_post_processor, std::unique_ptr<CustomProcessing> render_pre_processor, std::unique_ptr<EchoControlFactory> echo_control_factory, rtc::scoped_refptr<EchoDetector> echo_detector, std::unique_ptr<CustomAudioAnalyzer> capture_analyzer)"
  },
  {
    "label": "AudioProcessingImpl()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "AudioProcessingImpl()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "Initialize()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "Initialize(const ProcessingConfig& processing_config)"
  },
  {
    "label": "ApplyConfig()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyConfig(const AudioProcessing::Config& config)"
  },
  {
    "label": "CreateAndAttachAecDump()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CreateAndAttachAecDump(absl::string_view file_name, int64_t max_log_size_bytes, rtc::TaskQueue* worker_queue)"
  },
  {
    "label": "CreateAndAttachAecDump()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CreateAndAttachAecDump(FILE* handle, int64_t max_log_size_bytes, rtc::TaskQueue* worker_queue)"
  },
  {
    "label": "AttachAecDump()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AttachAecDump(std::unique_ptr<AecDump> aec_dump)"
  },
  {
    "label": "DetachAecDump()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DetachAecDump()"
  },
  {
    "label": "SetRuntimeSetting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetRuntimeSetting(RuntimeSetting setting)"
  },
  {
    "label": "PostRuntimeSetting()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "PostRuntimeSetting(RuntimeSetting setting)"
  },
  {
    "label": "ProcessStream()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "ProcessStream(const int16_t* const src, const StreamConfig& input_config, const StreamConfig& output_config, int16_t* const dest)"
  },
  {
    "label": "ProcessStream()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "ProcessStream(const float* const* src, const StreamConfig& input_config, const StreamConfig& output_config, float* const* dest)"
  },
  {
    "label": "GetLinearAecOutput()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetLinearAecOutput(rtc::ArrayView<std::array<float, 160>> linear_output)"
  },
  {
    "label": "set_output_will_be_muted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_output_will_be_muted(bool muted)"
  },
  {
    "label": "HandleCaptureOutputUsedSetting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleCaptureOutputUsedSetting(bool capture_output_used) RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "set_stream_delay_ms()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "set_stream_delay_ms(int delay)"
  },
  {
    "label": "set_stream_key_pressed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_stream_key_pressed(bool key_pressed)"
  },
  {
    "label": "set_stream_analog_level()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_stream_analog_level(int level)"
  },
  {
    "label": "recommended_stream_analog_level()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "recommended_stream_analog_level() const RTC_LOCKS_EXCLUDED(mutex_capture_)"
  },
  {
    "label": "ProcessReverseStream()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "ProcessReverseStream(const int16_t* const src, const StreamConfig& input_config, const StreamConfig& output_config, int16_t* const dest)"
  },
  {
    "label": "AnalyzeReverseStream()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "AnalyzeReverseStream(const float* const* data, const StreamConfig& reverse_config)"
  },
  {
    "label": "ProcessReverseStream()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "ProcessReverseStream(const float* const* src, const StreamConfig& input_config, const StreamConfig& output_config, float* const* dest)"
  },
  {
    "label": "proc_sample_rate_hz()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "proc_sample_rate_hz()"
  },
  {
    "label": "proc_split_sample_rate_hz()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "proc_split_sample_rate_hz()"
  },
  {
    "label": "num_input_channels()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "num_input_channels()"
  },
  {
    "label": "num_proc_channels()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "num_proc_channels()"
  },
  {
    "label": "num_output_channels()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "num_output_channels()"
  },
  {
    "label": "num_reverse_channels()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "num_reverse_channels()"
  },
  {
    "label": "stream_delay_ms()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "stream_delay_ms()"
  },
  {
    "label": "GetStatistics()",
    "kind": "Method",
    "detail": "Function (AudioProcessingStats)",
    "insertText": "GetStatistics(bool has_remote_tracks)"
  },
  {
    "label": "GetStatistics()",
    "kind": "Method",
    "detail": "Function (} AudioProcessingStats)",
    "insertText": "GetStatistics()"
  },
  {
    "label": "GetConfig()",
    "kind": "Method",
    "detail": "Function (} AudioProcessing::Config)",
    "insertText": "GetConfig()"
  },
  {
    "label": "InitializeLocked()",
    "kind": "Method",
    "detail": "Function (protected : void)",
    "insertText": "InitializeLocked() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_render_, mutex_capture_)"
  },
  {
    "label": "AssertLockedForTest()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AssertLockedForTest() RTC_ASSERT_EXCLUSIVE_LOCK(mutex_render_, mutex_capture_)"
  },
  {
    "label": "AssertHeld()",
    "kind": "Method",
    "detail": "Function (mutex_render_ .)",
    "insertText": "AssertHeld()"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(ApmConfiguration, DefaultBehavior)"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(ApmConfiguration, ValidConfigBehavior)"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(ApmConfiguration, InValidConfigBehavior)"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(ApmWithSubmodulesExcludedTest, ToggleTransientSuppressor)"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(ApmWithSubmodulesExcludedTest, ReinitializeTransientSuppressor)"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(ApmWithSubmodulesExcludedTest, BitexactWithDisabledModules)"
  },
  {
    "label": "set_stream_analog_level_locked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_stream_analog_level_locked(int level) RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "UpdateRecommendedInputVolumeLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateRecommendedInputVolumeLocked() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "OverrideSubmoduleCreationForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OverrideSubmoduleCreationForTesting(const ApmSubmoduleCreationOverrides& overrides)"
  },
  {
    "label": "RuntimeSettingEnqueuer()",
    "kind": "Method",
    "detail": "Function (class RuntimeSettingEnqueuer { public :)",
    "insertText": "RuntimeSettingEnqueuer(SwapQueue<RuntimeSetting>* runtime_settings)"
  },
  {
    "label": "RuntimeSettingEnqueuer()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "RuntimeSettingEnqueuer()"
  },
  {
    "label": "Enqueue()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Enqueue(RuntimeSetting setting)"
  },
  {
    "label": "SubmoduleStates()",
    "kind": "Method",
    "detail": "Function (private : SwapQueue<RuntimeSetting>& runtime_settings_ ; } ; const std::unique_ptr<ApmDataDumper> data_dumper_ ; std::atomic<int> instance_count_ ; const bool use_setup_specific_default_aec3_config_ ; const bool use_denormal_disabler_ ; const TransientSuppressor::VadMode transient_suppressor_vad_mode_ ; SwapQueue<RuntimeSetting> capture_runtime_settings_ ; SwapQueue<RuntimeSetting> render_runtime_settings_ ; RuntimeSettingEnqueuer capture_runtime_settings_enqueuer_ ; RuntimeSettingEnqueuer render_runtime_settings_enqueuer_ ; const std::unique_ptr<EchoControlFactory> echo_control_factory_ ; class SubmoduleStates { public :)",
    "insertText": "SubmoduleStates(bool capture_post_processor_enabled, bool render_pre_processor_enabled, bool capture_analyzer_enabled)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Update(bool high_pass_filter_enabled, bool mobile_echo_controller_enabled, bool noise_suppressor_enabled, bool adaptive_gain_controller_enabled, bool gain_controller2_enabled, bool voice_activity_detector_enabled, bool gain_adjustment_enabled, bool echo_controller_enabled, bool transient_suppressor_enabled)"
  },
  {
    "label": "CaptureMultiBandSubModulesActive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CaptureMultiBandSubModulesActive()"
  },
  {
    "label": "CaptureMultiBandProcessingPresent()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CaptureMultiBandProcessingPresent()"
  },
  {
    "label": "CaptureMultiBandProcessingActive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CaptureMultiBandProcessingActive(bool ec_processing_active)"
  },
  {
    "label": "CaptureFullBandProcessingActive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CaptureFullBandProcessingActive()"
  },
  {
    "label": "CaptureAnalyzerActive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CaptureAnalyzerActive()"
  },
  {
    "label": "RenderMultiBandSubModulesActive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RenderMultiBandSubModulesActive()"
  },
  {
    "label": "RenderFullBandProcessingActive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RenderFullBandProcessingActive()"
  },
  {
    "label": "RenderMultiBandProcessingActive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RenderMultiBandProcessingActive()"
  },
  {
    "label": "HighPassFilteringRequired()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HighPassFilteringRequired()"
  },
  {
    "label": "MaybeInitializeRender()",
    "kind": "Method",
    "detail": "Function (private : const bool capture_post_processor_enabled_ = false ; const bool render_pre_processor_enabled_ = false ; const bool capture_analyzer_enabled_ = false ; bool high_pass_filter_enabled_ = false ; bool mobile_echo_controller_enabled_ = false ; bool noise_suppressor_enabled_ = false ; bool adaptive_gain_controller_enabled_ = false ; bool voice_activity_detector_enabled_ = false ; bool gain_controller2_enabled_ = false ; bool gain_adjustment_enabled_ = false ; bool echo_controller_enabled_ = false ; bool transient_suppressor_enabled_ = false ; bool first_update_ = true ; } ; int)",
    "insertText": "MaybeInitializeRender(const ProcessingConfig& processing_config) RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_render_)"
  },
  {
    "label": "MaybeInitializeCapture()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "MaybeInitializeCapture(const StreamConfig& input_config, const StreamConfig& output_config)"
  },
  {
    "label": "UpdateActiveSubmoduleStates()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "UpdateActiveSubmoduleStates() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "InitializeLocked()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "InitializeLocked(const ProcessingConfig& config) RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_render_, mutex_capture_)"
  },
  {
    "label": "InitializeResidualEchoDetector()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeResidualEchoDetector() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_render_, mutex_capture_)"
  },
  {
    "label": "InitializeEchoController()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeEchoController() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_render_, mutex_capture_)"
  },
  {
    "label": "InitializeHighPassFilter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeHighPassFilter(bool forced_reset) RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "InitializeGainController1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeGainController1() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "InitializeTransientSuppressor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeTransientSuppressor() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "InitializeGainController2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeGainController2(bool config_has_changed) RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "InitializeVoiceActivityDetector()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeVoiceActivityDetector(bool config_has_changed) RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "InitializeNoiseSuppressor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeNoiseSuppressor() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "InitializeCaptureLevelsAdjuster()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeCaptureLevelsAdjuster() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "InitializePostProcessor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializePostProcessor() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "InitializeAnalyzer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeAnalyzer() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "InitializePreProcessor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializePreProcessor() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_render_)"
  },
  {
    "label": "proc_fullband_sample_rate_hz()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "proc_fullband_sample_rate_hz() const RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "HandleCaptureRuntimeSettings()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleCaptureRuntimeSettings() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "HandleRenderRuntimeSettings()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleRenderRuntimeSettings() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_render_)"
  },
  {
    "label": "EmptyQueuedRenderAudio()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EmptyQueuedRenderAudio() RTC_LOCKS_EXCLUDED(mutex_capture_)"
  },
  {
    "label": "EmptyQueuedRenderAudioLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EmptyQueuedRenderAudioLocked() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "AllocateRenderQueue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AllocateRenderQueue() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_render_, mutex_capture_)"
  },
  {
    "label": "QueueBandedRenderAudio()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "QueueBandedRenderAudio(AudioBuffer* audio) RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_render_)"
  },
  {
    "label": "QueueNonbandedRenderAudio()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "QueueNonbandedRenderAudio(AudioBuffer* audio) RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_render_)"
  },
  {
    "label": "ProcessCaptureStreamLocked()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "ProcessCaptureStreamLocked() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "AnalyzeReverseStreamLocked()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "AnalyzeReverseStreamLocked(const float* const* src, const StreamConfig& input_config, const StreamConfig& output_config) RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_render_)"
  },
  {
    "label": "ProcessRenderStreamLocked()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "ProcessRenderStreamLocked() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_render_)"
  },
  {
    "label": "WriteAecDumpConfigMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteAecDumpConfigMessage(bool forced) RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "RecordUnprocessedCaptureStream()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RecordUnprocessedCaptureStream(const float* const* capture_stream) RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "RecordUnprocessedCaptureStream()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RecordUnprocessedCaptureStream(const int16_t* const data, const StreamConfig& config) RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "RecordProcessedCaptureStream()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RecordProcessedCaptureStream(const float* const* processed_capture_stream) RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "RecordProcessedCaptureStream()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RecordProcessedCaptureStream(const int16_t* const data, const StreamConfig& config) RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "RecordAudioProcessingState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RecordAudioProcessingState() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "HandleOverrunInCaptureRuntimeSettingsQueue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleOverrunInCaptureRuntimeSettingsQueue() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_)"
  },
  {
    "label": "RTC_GUARDED_BY()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<AecDump> aec_dump_ ; InternalAPMConfig apm_config_for_aec_dump_)",
    "insertText": "RTC_GUARDED_BY(mutex_capture_)"
  },
  {
    "label": "RTC_ACQUIRED_BEFORE()",
    "kind": "Method",
    "detail": "Function (Mutex mutex_render_)",
    "insertText": "RTC_ACQUIRED_BEFORE(mutex_capture_)"
  },
  {
    "label": "Submodules()",
    "kind": "Method",
    "detail": "Function (SubmoduleStates submodule_states_ ; struct Submodules {)",
    "insertText": "Submodules(std::unique_ptr<CustomProcessing> capture_post_processor, std::unique_ptr<CustomProcessing> render_pre_processor, rtc::scoped_refptr<EchoDetector> echo_detector, std::unique_ptr<CustomAudioAnalyzer> capture_analyzer) : echo_detector(std::move(echo_detector)), capture_post_processor(std::move(capture_post_processor)), render_pre_processor(std::move(render_pre_processor)), capture_analyzer(std::move(capture_analyzer))"
  },
  {
    "label": "ApmFormatState()",
    "kind": "Method",
    "detail": "Function (} const rtc::scoped_refptr<EchoDetector> echo_detector ; const std::unique_ptr<CustomProcessing> capture_post_processor ; const std::unique_ptr<CustomProcessing> render_pre_processor ; const std::unique_ptr<CustomAudioAnalyzer> capture_analyzer ; std::unique_ptr<AgcManagerDirect> agc_manager ; std::unique_ptr<GainControlImpl> gain_control ; std::unique_ptr<GainController2> gain_controller2 ; std::unique_ptr<VoiceActivityDetectorWrapper> voice_activity_detector ; std::unique_ptr<HighPassFilter> high_pass_filter ; std::unique_ptr<EchoControl> echo_controller ; std::unique_ptr<EchoControlMobileImpl> echo_control_mobile ; std::unique_ptr<NoiseSuppressor> noise_suppressor ; std::unique_ptr<TransientSuppressor> transient_suppressor ; std::unique_ptr<CaptureLevelsAdjuster> capture_levels_adjuster ; } submodules_ ; struct ApmFormatState {)",
    "insertText": "ApmFormatState() : api_format({{{kSampleRate16kHz, 1}, {kSampleRate16kHz, 1}, {kSampleRate16kHz, 1}, {kSampleRate16kHz, 1}}}), render_processing_format(kSampleRate16kHz, 1)"
  },
  {
    "label": "ApmConstants()",
    "kind": "Method",
    "detail": "Function (} ProcessingConfig api_format ; StreamConfig render_processing_format ; } formats_ ; const struct ApmConstants {)",
    "insertText": "ApmConstants(bool multi_channel_render_support, bool multi_channel_capture_support, bool enforce_split_band_hpf, bool minimize_processing_for_unused_output, bool transient_suppressor_forced_off) : multi_channel_render_support(multi_channel_render_support), multi_channel_capture_support(multi_channel_capture_support), enforce_split_band_hpf(enforce_split_band_hpf), minimize_processing_for_unused_output( minimize_processing_for_unused_output), transient_suppressor_forced_off(transient_suppressor_forced_off)"
  },
  {
    "label": "ApmCaptureState()",
    "kind": "Method",
    "detail": "Function (} bool multi_channel_render_support ; bool multi_channel_capture_support ; bool enforce_split_band_hpf ; bool minimize_processing_for_unused_output ; bool transient_suppressor_forced_off ; } constants_ ; struct ApmCaptureState {)",
    "insertText": "ApmCaptureState()"
  },
  {
    "label": "ApmCaptureNonLockedState()",
    "kind": "Method",
    "detail": "Function (struct ApmCaptureNonLockedState {)",
    "insertText": "ApmCaptureNonLockedState() : capture_processing_format(kSampleRate16kHz), split_rate(kSampleRate16kHz), stream_delay_ms(0)"
  },
  {
    "label": "ApmRenderState()",
    "kind": "Method",
    "detail": "Function (} StreamConfig capture_processing_format ; int split_rate ; int stream_delay_ms ; bool echo_controller_enabled = false ; } capture_nonlocked_ ; struct ApmRenderState {)",
    "insertText": "ApmRenderState()"
  },
  {
    "label": "RTC_GUARDED_BY()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<AudioConverter> render_converter ; std::unique_ptr<AudioBuffer> render_audio ; } render_)",
    "insertText": "RTC_GUARDED_BY(mutex_render_)"
  },
  {
    "label": "ApmStatsReporter()",
    "kind": "Method",
    "detail": "Function (class ApmStatsReporter { public :)",
    "insertText": "ApmStatsReporter()"
  },
  {
    "label": "UpdateStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateStatistics(const AudioProcessingStats& new_stats)"
  },
  {
    "label": "RTC_GUARDED_BY()",
    "kind": "Method",
    "detail": "Function (private : Mutex mutex_stats_ ; AudioProcessingStats cached_stats_)",
    "insertText": "RTC_GUARDED_BY(mutex_stats_)"
  },
  {
    "label": "RTC_GUARDED_BY()",
    "kind": "Method",
    "detail": "Function (size_t agc_render_queue_element_max_size_)",
    "insertText": "RTC_GUARDED_BY(mutex_render_) RTC_GUARDED_BY(mutex_capture_)"
  }
]