[
  {
    "label": "FSoundQualityInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSoundQualityInfo"
  },
  {
    "label": "FStreamedAudioChunkSeekTable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FStreamedAudioChunkSeekTable"
  },
  {
    "label": "ICompressedAudioInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ICompressedAudioInfo"
  },
  {
    "label": "FDecodeResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDecodeResult"
  },
  {
    "label": "IStreamedCompressedInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IStreamedCompressedInfo"
  },
  {
    "label": "IAudioInfoFactory",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IAudioInfoFactory"
  },
  {
    "label": "FCapabilities",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCapabilities"
  },
  {
    "label": "IAudioInfoFactoryRegistry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IAudioInfoFactoryRegistry"
  },
  {
    "label": "FSimpleAudioInfoFactory",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSimpleAudioInfoFactory"
  },
  {
    "label": "FAsyncAudioDecompressWorker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAsyncAudioDecompressWorker"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "FAsyncRealtimeAudioTaskWorker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAsyncRealtimeAudioTaskWorker"
  },
  {
    "label": "FAsyncRealtimeAudioTaskProxy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAsyncRealtimeAudioTaskProxy"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Stats / Stats . h \" # include \" Async / AsyncWork . h \" # include \" Sound / SoundWave . h \" # include \" Misc / ScopeLock . h \" # include \" HAL / LowLevelMemTracker . h \" # include \" ContentStreaming . h \" int32 MONO_PCM_BUFFER_SAMPLES = 4 8 0 0 ; uint32 MONO_PCM_SAMPLE_SIZE =)",
    "insertText": "sizeof(int16)"
  },
  {
    "label": "ICompressedAudioInfo()",
    "kind": "Method",
    "detail": "Function (uint32 MONO_PCM_BUFFER_SIZE = MONO_PCM_BUFFER_SAMPLES* MONO_PCM_SAMPLE_SIZE ; struct FSoundQualityInfo ; class FStreamedAudioChunkSeekTable ; class ICompressedAudioInfo { public :)",
    "insertText": "ICompressedAudioInfo()"
  },
  {
    "label": "ReadCompressedInfo()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ReadCompressedInfo(const uint8* InSrcBufferData, uint32 InSrcBufferDataSize, struct FSoundQualityInfo* QualityInfo)"
  },
  {
    "label": "ReadCompressedData()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ReadCompressedData(uint8* Destination, bool bLooping, uint32 BufferSize)"
  },
  {
    "label": "SeekToTime()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SeekToTime(const float SeekTime)"
  },
  {
    "label": "SeekToFrame()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SeekToFrame(const uint32 Frame)"
  },
  {
    "label": "ExpandFile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpandFile(uint8* DstBuffer, struct FSoundQualityInfo* QualityInfo)"
  },
  {
    "label": "EnableHalfRate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnableHalfRate(bool HalfRate)"
  },
  {
    "label": "GetSourceBufferSize()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetSourceBufferSize()"
  },
  {
    "label": "UsesVorbisChannelOrdering()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "UsesVorbisChannelOrdering()"
  },
  {
    "label": "GetStreamBufferSize()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetStreamBufferSize()"
  },
  {
    "label": "IsStreamedCompressedInfo()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsStreamedCompressedInfo()"
  },
  {
    "label": "StreamCompressedInfo()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "StreamCompressedInfo(const FSoundWaveProxyPtr& Wave, struct FSoundQualityInfo* QualityInfo)"
  },
  {
    "label": "HasError()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasError()"
  },
  {
    "label": "StreamCompressedInfoInternal()",
    "kind": "Method",
    "detail": "Function (protected : bool)",
    "insertText": "StreamCompressedInfoInternal(const FSoundWaveProxyPtr& InWaveProxy, struct FSoundQualityInfo* QualityInfo)"
  },
  {
    "label": "StreamCompressedData()",
    "kind": "Method",
    "detail": "Function (public : bool)",
    "insertText": "StreamCompressedData(uint8* Destination, bool bLooping, uint32 BufferSize, int32& OutNumBytesStreamed)"
  },
  {
    "label": "GetCurrentChunkIndex()",
    "kind": "Method",
    "detail": "Function (OutNumBytesStreamed = - 1 ; return false ; } int32)",
    "insertText": "GetCurrentChunkIndex()"
  },
  {
    "label": "IStreamedCompressedInfo()",
    "kind": "Method",
    "detail": "Function (} } ; class IStreamedCompressedInfo : public ICompressedAudioInfo { public :)",
    "insertText": "IStreamedCompressedInfo()"
  },
  {
    "label": "ReadCompressedInfo()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ReadCompressedInfo(const uint8* InSrcBufferData, uint32 InSrcBufferDataSize, FSoundQualityInfo* QualityInfo)"
  },
  {
    "label": "SeekToFrame()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SeekToFrame(const uint32 SeekFrame)"
  },
  {
    "label": "CreateDecoder()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CreateDecoder()"
  },
  {
    "label": "Decode()",
    "kind": "Method",
    "detail": "Function (FDecodeResult)",
    "insertText": "Decode(const uint8* CompressedData, const int32 CompressedDataSize, uint8* OutPCMData, const int32 OutputPCMDataSize)"
  },
  {
    "label": "PrepareToLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrepareToLoop()"
  },
  {
    "label": "GetFrameSize()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetFrameSize()"
  },
  {
    "label": "GetMaxFrameSizeSamples()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetMaxFrameSizeSamples()"
  },
  {
    "label": "GetStreamSeekBlockIndex()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetStreamSeekBlockIndex()"
  },
  {
    "label": "DecompressToPCMBuffer()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "DecompressToPCMBuffer(uint16 FrameSize)"
  },
  {
    "label": "IncrementCurrentSampleCount()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "IncrementCurrentSampleCount(uint32 NewSamples)"
  },
  {
    "label": "WriteFromDecodedPCM()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "WriteFromDecodedPCM(uint8* Destination, uint32 BufferSize)"
  },
  {
    "label": "ZeroBuffer()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "ZeroBuffer(uint8* Destination, uint32 BufferSize)"
  },
  {
    "label": "GetLoadedChunk()",
    "kind": "Method",
    "detail": "Function (const uint8*)",
    "insertText": "GetLoadedChunk(const FSoundWaveProxyPtr& InSoundWave, uint32 ChunkIndex, uint32& OutChunkSize)"
  },
  {
    "label": "GetCurrentSeekTable()",
    "kind": "Method",
    "detail": "Function (const FStreamedAudioChunkSeekTable&)",
    "insertText": "GetCurrentSeekTable()"
  },
  {
    "label": "IAudioInfoFactory()",
    "kind": "Method",
    "detail": "Function (bool bIsStreaming ; const uint8* SrcBufferData ; uint32 SrcBufferDataSize ; uint32 SrcBufferOffset ; uint32 AudioDataOffset ; uint32 AudioDataChunkIndex ; uint32 TrueSampleCount ; uint32 CurrentSampleCount ; uint8 NumChannels ; uint32 MaxFrameSizeSamples ; uint32 SampleStride ; TArray<uint8> LastDecodedPCM ; uint32 LastPCMByteSize ; uint32 LastPCMOffset ; bool bStoringEndOfFile ; int32 CurrentChunkIndex ; int32 PrintChunkFailMessageCount = 0 ; uint64 StartTimeInCycles = 0 ; uint32 SrcBufferPadding ; FAudioChunkHandle CurCompressedChunkHandle ; TPimplPtr<FStreamedAudioChunkSeekTable> CurrentChunkSeekTable ; std::atomic<int32> StreamSeekBlockIndex ; int32 StreamSeekBlockOffset ; uint32 StreamSeekToAudioFrames = INDEX_NONE ; } ; struct IAudioInfoFactory { ~)",
    "insertText": "IAudioInfoFactory()"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (ICompressedAudioInfo*)",
    "insertText": "Create()"
  },
  {
    "label": "IsSeekingSupported()",
    "kind": "Method",
    "detail": "Function (struct FCapabilities { bool bSupportsSeeking = true ; bool bSupportsSeekableStreaming = true ; } ; bool)",
    "insertText": "IsSeekingSupported(const bool bIsStreaming)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} ; struct IAudioInfoFactoryRegistry { IAudioInfoFactoryRegistry&)",
    "insertText": "Get()"
  },
  {
    "label": "IAudioInfoFactoryRegistry()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "IAudioInfoFactoryRegistry()"
  },
  {
    "label": "Register()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Register(IAudioInfoFactory*, FName)"
  },
  {
    "label": "Unregister()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unregister(IAudioInfoFactory*, FName)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (IAudioInfoFactory*)",
    "insertText": "Find(FName InName)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (ICompressedAudioInfo*)",
    "insertText": "Create(FName InName)"
  },
  {
    "label": "FSimpleAudioInfoFactory()",
    "kind": "Method",
    "detail": "Function (} return nullptr ; } } ; class FSimpleAudioInfoFactory : public IAudioInfoFactory { public :)",
    "insertText": "FSimpleAudioInfoFactory(const TFunction<ICompressedAudioInfo*()>& InLambda, const FName& InFormatName, const FCapabilities InCaps = {}) : CreateLambda(InLambda), FormatName(InFormatName), Capabilities(InCaps)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Get().Register(this, FormatName)"
  },
  {
    "label": "FSimpleAudioInfoFactory()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FSimpleAudioInfoFactory()"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Get().Unregister(this, FormatName)"
  },
  {
    "label": "FAsyncAudioDecompressWorker()",
    "kind": "Method",
    "detail": "Function (FName FormatName ; FCapabilities Capabilities ; } ; class FAsyncAudioDecompressWorker : public FNonAbandonableTask { protected : USoundWave* Wave ; ICompressedAudioInfo* AudioInfo ; int32 NumPrecacheFrames ; public :)",
    "insertText": "FAsyncAudioDecompressWorker(USoundWave* InWave, int32 InNumPrecacheFrames, FAudioDevice* InAudioDevice = nullptr)"
  },
  {
    "label": "DoWork()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DoWork()"
  },
  {
    "label": "FAsyncRealtimeAudioTaskWorker()",
    "kind": "Method",
    "detail": "Function (} } ; typedef FAsyncTask<FAsyncAudioDecompressWorker> FAsyncAudioDecompress ; enum class ERealtimeAudioTaskType : uint8 { CompressedInfo,Decompress,Procedural } ; template<class T> class FAsyncRealtimeAudioTaskWorker : public FNonAbandonableTask { protected : T* AudioBuffer ; USoundWave* WaveData ; uint8* AudioData ; int32 NumPrecacheFrames ; int32 MaxSamples ; int32 BytesWritten ; ERealtimeAudioTaskType TaskType ; uint32 bSkipFirstBuffer : 1 ; uint32 bLoopingMode : 1 ; uint32 bLooped : 1 ; public :)",
    "insertText": "FAsyncRealtimeAudioTaskWorker(T* InAudioBuffer, USoundWave* InWaveData) : AudioBuffer(InAudioBuffer) , WaveData(InWaveData) , AudioData(nullptr) , NumPrecacheFrames(0) , MaxSamples(0) , BytesWritten(0) , TaskType(ERealtimeAudioTaskType::CompressedInfo) , bSkipFirstBuffer(false) , bLoopingMode(false) , bLooped(false)"
  },
  {
    "label": "FAsyncRealtimeAudioTaskWorker()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FAsyncRealtimeAudioTaskWorker(T* InAudioBuffer, uint8* InAudioData, int32 InNumPrecacheFrames, bool bInLoopingMode, bool bInSkipFirstBuffer) : AudioBuffer(InAudioBuffer) , AudioData(InAudioData) , NumPrecacheFrames(InNumPrecacheFrames) , TaskType(ERealtimeAudioTaskType::Decompress) , bSkipFirstBuffer(bInSkipFirstBuffer) , bLoopingMode(bInLoopingMode) , bLooped(false)"
  },
  {
    "label": "FAsyncRealtimeAudioTaskWorker()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FAsyncRealtimeAudioTaskWorker(USoundWave* InWaveData, uint8* InAudioData, int32 InMaxSamples) : WaveData(InWaveData) , AudioData(InAudioData) , NumPrecacheFrames(0) , MaxSamples(InMaxSamples) , BytesWritten(0) , TaskType(ERealtimeAudioTaskType::Procedural)"
  },
  {
    "label": "LLM_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LLM_SCOPE(ELLMTag::AudioMisc)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case ERealtimeAudioTaskType::Decompress :)",
    "insertText": "if(bSkipFirstBuffer)"
  },
  {
    "label": "ReadCompressedData()",
    "kind": "Method",
    "detail": "Function (# if PLATFORM_ANDROID AudioBuffer ->)",
    "insertText": "ReadCompressedData((uint8*)AudioData, NumPrecacheFrames, bLoopingMode)"
  },
  {
    "label": "ReadCompressedData()",
    "kind": "Method",
    "detail": "Function (# endif } bLooped = AudioBuffer ->)",
    "insertText": "ReadCompressedData((uint8*)AudioData, MONO_PCM_BUFFER_SAMPLES, bLoopingMode)"
  },
  {
    "label": "GeneratePCMData()",
    "kind": "Method",
    "detail": "Function (break ; case ERealtimeAudioTaskType::Procedural : BytesWritten = WaveData ->)",
    "insertText": "GeneratePCMData((uint8*)AudioData, MaxSamples)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (break ; default :)",
    "insertText": "check(false)"
  },
  {
    "label": "GetStatId()",
    "kind": "Method",
    "detail": "Function (} } TStatId)",
    "insertText": "GetStatId()"
  },
  {
    "label": "RETURN_QUICK_DECLARE_CYCLE_STAT()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "RETURN_QUICK_DECLARE_CYCLE_STAT(FAsyncRealtimeAudioDecompressWorker, STATGROUP_ThreadPoolAsyncTasks)"
  },
  {
    "label": "GetTaskType()",
    "kind": "Method",
    "detail": "Function (} } ERealtimeAudioTaskType)",
    "insertText": "GetTaskType()"
  },
  {
    "label": "FAsyncRealtimeAudioTaskProxy()",
    "kind": "Method",
    "detail": "Function (template<class T> class FAsyncRealtimeAudioTaskProxy { public :)",
    "insertText": "FAsyncRealtimeAudioTaskProxy(T* InAudioBuffer, USoundWave* InWaveData)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Task = new FAsyncTask<FAsyncRealtimeAudioTaskWorker<)",
    "insertText": "T(InAudioBuffer, InWaveData)"
  },
  {
    "label": "FAsyncRealtimeAudioTaskProxy()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FAsyncRealtimeAudioTaskProxy(T* InAudioBuffer, uint8* InAudioData, int32 InNumFramesToDecode, bool bInLoopingMode, bool bInSkipFirstBuffer)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Task = new FAsyncTask<FAsyncRealtimeAudioTaskWorker<)",
    "insertText": "T(InAudioBuffer, InAudioData, InNumFramesToDecode, bInLoopingMode, bInSkipFirstBuffer)"
  },
  {
    "label": "FAsyncRealtimeAudioTaskProxy()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FAsyncRealtimeAudioTaskProxy(USoundWave* InWaveData, uint8* InAudioData, int32 InMaxSamples)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Task = new FAsyncTask<FAsyncRealtimeAudioTaskWorker<)",
    "insertText": "T(InWaveData, InAudioData, InMaxSamples)"
  },
  {
    "label": "FAsyncRealtimeAudioTaskProxy()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FAsyncRealtimeAudioTaskProxy()"
  },
  {
    "label": "IsDone()",
    "kind": "Method",
    "detail": "Function (delete Task ; } bool)",
    "insertText": "IsDone()"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (FScopeLock)",
    "insertText": "Lock(&CritSect)"
  },
  {
    "label": "EnsureCompletion()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "EnsureCompletion(bool bDoWorkOnThisThreadIfNotStarted = true)"
  },
  {
    "label": "Cancel()",
    "kind": "Method",
    "detail": "Function (Task ->)",
    "insertText": "Cancel()"
  },
  {
    "label": "EnsureCompletion()",
    "kind": "Method",
    "detail": "Function (} Task ->)",
    "insertText": "EnsureCompletion(bDoWorkOnThisThreadIfNotStarted)"
  },
  {
    "label": "StartBackgroundTask()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "StartBackgroundTask()"
  },
  {
    "label": "ShouldUseBackgroundPoolFor_FAsyncRealtimeAudioTask()",
    "kind": "Method",
    "detail": "Function (const bool bUseBackground =)",
    "insertText": "ShouldUseBackgroundPoolFor_FAsyncRealtimeAudioTask() && (Task->GetTask().GetTaskType() != ERealtimeAudioTaskType::Procedural)"
  },
  {
    "label": "StartBackgroundTask()",
    "kind": "Method",
    "detail": "Function (Task ->)",
    "insertText": "StartBackgroundTask(bUseBackground ? GBackgroundPriorityThreadPool : GThreadPool)"
  },
  {
    "label": "GetTask()",
    "kind": "Method",
    "detail": "Function (} FAsyncRealtimeAudioTaskWorker<T>&)",
    "insertText": "GetTask()"
  }
]