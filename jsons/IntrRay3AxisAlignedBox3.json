[
  {
    "label": "TIntrRay3AxisAlignedBox3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TIntrRay3AxisAlignedBox3"
  },
  {
    "label": "TestIntersection()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" BoxTypes . h \" # include \" VectorUtil . h \" namespace UE { namespace Geometry { using namespace UE::Math ; template<RealType> class TIntrRay3AxisAlignedBox3 { public : bool)",
    "insertText": "TestIntersection(const TRay<RealType>& Ray, const TAxisAlignedBox3<RealType>& Box, RealType ExpandExtents = 0)"
  },
  {
    "label": "Zero()",
    "kind": "Method",
    "detail": "Function (TVector<RealType> WdU = TVector<RealType)",
    "insertText": "Zero()"
  },
  {
    "label": "Center()",
    "kind": "Method",
    "detail": "Function (RealType RHS ; TVector<RealType> diff = Ray . Origin - Box .)",
    "insertText": "Center()"
  },
  {
    "label": "Extents()",
    "kind": "Method",
    "detail": "Function (TVector<RealType> extent = Box .)",
    "insertText": "Extents()"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (WdU . X = Ray . Direction . X ; AWdU . X =)",
    "insertText": "Abs(WdU.X)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (DdU . X = diff . X ; ADdU . X =)",
    "insertText": "Abs(DdU.X)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (DdU . Y = diff . Y ; ADdU . Y =)",
    "insertText": "Abs(DdU.Y)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (DdU . Z = diff . Z ; ADdU . Z =)",
    "insertText": "Abs(DdU.Z)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (AWxDdU . X =)",
    "insertText": "Abs(WxD.X)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (RHS = extent . Y* AWdU . Z + extent . Z* AWdU . Y ;)",
    "insertText": "if(AWxDdU.X > RHS)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (RHS = extent . X* AWdU . Z + extent . Z* AWdU . X ;)",
    "insertText": "if(AWxDdU.Y > RHS)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (RHS = extent . X* AWdU . Y + extent . Y* AWdU . X ;)",
    "insertText": "if(AWxDdU.Z > RHS)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (RealType RayParam0 = 0 . 0 ; RealType RayParam1 = TNumericLimits<RealType)",
    "insertText": "Max()"
  },
  {
    "label": "DoClipping()",
    "kind": "Method",
    "detail": "Function (EIntersectionType Type = EIntersectionType::Empty ;)",
    "insertText": "DoClipping(RayParam0, RayParam1, Ray.Origin, Ray.Direction, Box, true, Quantity, Point0, Point1, Type)"
  },
  {
    "label": "Clip()",
    "kind": "Method",
    "detail": "Function (RealType saveT0 = t0,saveT1 = t1 ; bool notAllClipped =)",
    "insertText": "Clip(+RayDirection.X, -BOrigin.X - extent.X, t0, t1) && Clip(-RayDirection.X, +BOrigin.X - extent.X, t0, t1) && Clip(+RayDirection.Y, -BOrigin.Y - extent.Y, t0, t1) && Clip(-RayDirection.Y, +BOrigin.Y - extent.Y, t0, t1) && Clip(+RayDirection.Z, -BOrigin.Z - extent.Z, t0, t1) && Clip(-RayDirection.Z, +BOrigin.Z - extent.Z, t0, t1)"
  },
  {
    "label": "Clip()",
    "kind": "Method",
    "detail": "Function (intrType = EIntersectionType::Segment ; quantity = 2 ; Point0 = RayOrigin + t0* RayDirection ; Point1 = RayOrigin + t1* RayDirection ; } else { intrType = EIntersectionType::Point ; quantity = 1 ; Point0 = RayOrigin + t0* RayDirection ; } } else { quantity = 0 ; intrType = EIntersectionType::Empty ; } return intrType ! = EIntersectionType::Empty ; } bool)",
    "insertText": "Clip(RealType denom, RealType numer, RealType& t0, RealType& t1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (t0 = numer / denom ; } return true ; } else)",
    "insertText": "if(denom < (RealType)0)"
  },
  {
    "label": "numer()",
    "kind": "Method",
    "detail": "Function (t1 = numer / denom ; } return true ; } else { return)",
    "insertText": "numer(RealType)"
  }
]