[
  {
    "label": "SluMatrixMapHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SluMatrixMapHelper"
  },
  {
    "label": "SluMatrix",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SluMatrix"
  },
  {
    "label": "SuperLUBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SuperLUBase"
  },
  {
    "label": "SuperLU",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SuperLU"
  },
  {
    "label": "SuperILU",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SuperILU"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_SUPERLUSUPPORT_H # define EIGEN_SUPERLUSUPPORT_H namespace Eigen { # if)",
    "insertText": "defined(SUPERLU_MAJOR_VERSION) && (SUPERLU_MAJOR_VERSION >= 5) #define DECL_GSSVX(PREFIX,FLOATTYPE,KEYTYPE)"
  },
  {
    "label": "gssvx()",
    "kind": "Method",
    "detail": "Function (\\ void PREFIX # #)",
    "insertText": "gssvx(superlu_options_t *, SuperMatrix *, int *, int *, int *, \\ char *, FLOATTYPE *, FLOATTYPE *, SuperMatrix *, SuperMatrix *, \\ void *, int, SuperMatrix *, SuperMatrix *, \\ FLOATTYPE *, FLOATTYPE *, FLOATTYPE *, FLOATTYPE *, \\ GlobalLU_t *, mem_usage_t *, SuperLUStat_t *, int *)"
  },
  {
    "label": "SuperLU_gssvx()",
    "kind": "Method",
    "detail": "Function (\\ } \\ float)",
    "insertText": "SuperLU_gssvx(superlu_options_t *options, SuperMatrix *A, \\ int *perm_c, int *perm_r, int *etree, char *equed, \\ FLOATTYPE *R, FLOATTYPE *C, SuperMatrix *L, \\ SuperMatrix *U, void *work, int lwork, \\ SuperMatrix *B, SuperMatrix *X, \\ FLOATTYPE *recip_pivot_growth, \\ FLOATTYPE *rcond, FLOATTYPE *ferr, FLOATTYPE *berr, \\ SuperLUStat_t *stats, int *info, KEYTYPE)"
  },
  {
    "label": "gssvx()",
    "kind": "Method",
    "detail": "Function (\\ mem_usage_t mem_usage ; \\ GlobalLU_t gLU ; \\ PREFIX # #)",
    "insertText": "gssvx(options, A, perm_c, perm_r, etree, equed, R, C, L, \\ U, work, lwork, B, X, recip_pivot_growth, rcond, \\ ferr, berr, &gLU, &mem_usage, stats, info)"
  },
  {
    "label": "DECL_GSSVX()",
    "kind": "Method",
    "detail": "Function (\\ return mem_usage . for_lu ; \\ } # else # define)",
    "insertText": "DECL_GSSVX(PREFIX,FLOATTYPE,KEYTYPE)"
  },
  {
    "label": "gssvx()",
    "kind": "Method",
    "detail": "Function (\\ void PREFIX # #)",
    "insertText": "gssvx(superlu_options_t *, SuperMatrix *, int *, int *, int *, \\ char *, FLOATTYPE *, FLOATTYPE *, SuperMatrix *, SuperMatrix *, \\ void *, int, SuperMatrix *, SuperMatrix *, \\ FLOATTYPE *, FLOATTYPE *, FLOATTYPE *, FLOATTYPE *, \\ mem_usage_t *, SuperLUStat_t *, int *)"
  },
  {
    "label": "gssvx()",
    "kind": "Method",
    "detail": "Function (\\ mem_usage_t mem_usage ; \\ PREFIX # #)",
    "insertText": "gssvx(options, A, perm_c, perm_r, etree, equed, R, C, L, \\ U, work, lwork, B, X, recip_pivot_growth, rcond, \\ ferr, berr, &mem_usage, stats, info)"
  },
  {
    "label": "DECL_GSSVX()",
    "kind": "Method",
    "detail": "Function (\\ return mem_usage . for_lu ; \\ } # endif)",
    "insertText": "DECL_GSSVX(s,float,float) DECL_GSSVX(c,float,std::complex<float>) DECL_GSSVX(d,double,double) DECL_GSSVX(z,double,std::complex<double>) #ifdef MILU_ALPHA #define EIGEN_SUPERLU_HAS_ILU #endif #ifdef EIGEN_SUPERLU_HAS_ILU #define DECL_GSISX(PREFIX,FLOATTYPE,KEYTYPE)"
  },
  {
    "label": "gsisx()",
    "kind": "Method",
    "detail": "Function (\\ void PREFIX # #)",
    "insertText": "gsisx(superlu_options_t *, SuperMatrix *, int *, int *, int *, \\ char *, FLOATTYPE *, FLOATTYPE *, SuperMatrix *, SuperMatrix *, \\ void *, int, SuperMatrix *, SuperMatrix *, FLOATTYPE *, FLOATTYPE *, \\ mem_usage_t *, SuperLUStat_t *, int *)"
  },
  {
    "label": "SuperLU_gsisx()",
    "kind": "Method",
    "detail": "Function (\\ } \\ float)",
    "insertText": "SuperLU_gsisx(superlu_options_t *options, SuperMatrix *A, \\ int *perm_c, int *perm_r, int *etree, char *equed, \\ FLOATTYPE *R, FLOATTYPE *C, SuperMatrix *L, \\ SuperMatrix *U, void *work, int lwork, \\ SuperMatrix *B, SuperMatrix *X, \\ FLOATTYPE *recip_pivot_growth, \\ FLOATTYPE *rcond, \\ SuperLUStat_t *stats, int *info, KEYTYPE)"
  },
  {
    "label": "gsisx()",
    "kind": "Method",
    "detail": "Function (\\ mem_usage_t mem_usage ; \\ PREFIX # #)",
    "insertText": "gsisx(options, A, perm_c, perm_r, etree, equed, R, C, L, \\ U, work, lwork, B, X, recip_pivot_growth, rcond, \\ &mem_usage, stats, info)"
  },
  {
    "label": "DECL_GSISX()",
    "kind": "Method",
    "detail": "Function (\\ return mem_usage . for_lu ; \\ })",
    "insertText": "DECL_GSISX(s,float,float) DECL_GSISX(c,float,std::complex<float>) DECL_GSISX(d,double,double) DECL_GSISX(z,double,std::complex<double>)"
  },
  {
    "label": "SluMatrix()",
    "kind": "Method",
    "detail": "Function (struct SluMatrix : SuperMatrix {)",
    "insertText": "SluMatrix()"
  },
  {
    "label": "SluMatrix()",
    "kind": "Method",
    "detail": "Function (Store =& storage ; })",
    "insertText": "SluMatrix(const SluMatrix& other) : SuperMatrix(other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Store =& storage ; storage = other . storage ; } SluMatrix&)",
    "insertText": "operator(const SluMatrix& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(static_cast<const SuperMatrix&>(other))"
  },
  {
    "label": "setStorageType()",
    "kind": "Method",
    "detail": "Function (Store =& storage ; storage = other . storage ; return* this ; } struct { union { int nnz ; int lda ; } ; void* values ; int* innerInd ; int* outerInd ; } storage ; void)",
    "insertText": "setStorageType(Stype_t t)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Stype = t ;)",
    "insertText": "if(t==SLU_NC || t==SLU_NR || t==SLU_DN)"
  },
  {
    "label": "setScalarType()",
    "kind": "Method",
    "detail": "Function (Store = 0 ; } } template<Scalar> void)",
    "insertText": "setScalarType()"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (} } template<MatrixType> SluMatrix)",
    "insertText": "Map(MatrixBase<MatrixType>& _mat)"
  },
  {
    "label": "mat()",
    "kind": "Method",
    "detail": "Function (MatrixType&)",
    "insertText": "mat(_mat.derived())"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(((MatrixType::Flags&RowMajorBit)!=RowMajorBit) && \"row-major dense matrices are not supported by SuperLU\")"
  },
  {
    "label": "setStorageType()",
    "kind": "Method",
    "detail": "Function (SluMatrix res ; res .)",
    "insertText": "setStorageType(SLU_DN)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (res . setScalarType<)",
    "insertText": "Scalar()"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (res . Mtype = SLU_GE ; res . nrow = internal::convert_index<)",
    "insertText": "int(mat.rows())"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (res . ncol = internal::convert_index<)",
    "insertText": "int(mat.cols())"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (res . storage . lda = internal::convert_index<)",
    "insertText": "int(MatrixType::IsVectorAtCompileTime ? mat.size() : mat.outerStride())"
  },
  {
    "label": "values()",
    "kind": "Method",
    "detail": "Function (res . storage .)",
    "insertText": "values(void*)(mat.data())"
  },
  {
    "label": "mat()",
    "kind": "Method",
    "detail": "Function (MatrixType&)",
    "insertText": "mat(a_mat.derived())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (SluMatrix res ;)",
    "insertText": "if((MatrixType::Flags&RowMajorBit)==RowMajorBit)"
  },
  {
    "label": "setStorageType()",
    "kind": "Method",
    "detail": "Function (res .)",
    "insertText": "setStorageType(SLU_NR)"
  },
  {
    "label": "setStorageType()",
    "kind": "Method",
    "detail": "Function (} else { res .)",
    "insertText": "setStorageType(SLU_NC)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} res . Mtype = SLU_GE ; res . storage . nnz = internal::convert_index<)",
    "insertText": "int(mat.nonZeros())"
  },
  {
    "label": "valuePtr()",
    "kind": "Method",
    "detail": "Function (res . storage . values = mat .)",
    "insertText": "valuePtr()"
  },
  {
    "label": "innerIndexPtr()",
    "kind": "Method",
    "detail": "Function (res . storage . innerInd = mat .)",
    "insertText": "innerIndexPtr()"
  },
  {
    "label": "outerIndexPtr()",
    "kind": "Method",
    "detail": "Function (res . storage . outerInd = mat .)",
    "insertText": "outerIndexPtr()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(((int(MatrixType::Flags) & int(SelfAdjoint))==0) && \"SelfAdjoint matrix shape not supported by SuperLU\")"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(((Options&RowMajor)!=RowMajor) && \"row-major dense matrices is not supported by SuperLU\")"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (res . Mtype = SLU_GE ; res . nrow = mat .)",
    "insertText": "rows()"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (res . ncol = mat .)",
    "insertText": "cols()"
  },
  {
    "label": "outerStride()",
    "kind": "Method",
    "detail": "Function (res . storage . lda = mat .)",
    "insertText": "outerStride()"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (res . storage . values = mat .)",
    "insertText": "data()"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<Derived> struct SluMatrixMapHelper<SparseMatrixBase<Derived>> { typedef Derived MatrixType ; void)",
    "insertText": "run(MatrixType& mat, SluMatrix& res)"
  },
  {
    "label": "nonZeros()",
    "kind": "Method",
    "detail": "Function (} res . Mtype = SLU_GE ; res . storage . nnz = mat .)",
    "insertText": "nonZeros()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(((MatrixType::Flags & SelfAdjoint)==0) && \"SelfAdjoint matrix shape not supported by SuperLU\")"
  },
  {
    "label": "asSluMatrix()",
    "kind": "Method",
    "detail": "Function (} } ; namespace internal { template<MatrixType> SluMatrix)",
    "insertText": "asSluMatrix(MatrixType& mat)"
  },
  {
    "label": "map_superlu()",
    "kind": "Method",
    "detail": "Function (} template<Scalar,int Flags,Index> MappedSparseMatrix<Scalar,Flags,Index>)",
    "insertText": "map_superlu(SluMatrix& sluMat)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(((Flags&RowMajor)==RowMajor && sluMat.Stype == SLU_NR) || ((Flags&ColMajor)==ColMajor && sluMat.Stype == SLU_NC))"
  },
  {
    "label": "outerSize()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "outerSize(Flags&RowMajor)"
  },
  {
    "label": "SuperLUBase()",
    "kind": "Method",
    "detail": "Function (} } template<_MatrixType,Derived> class SuperLUBase : public SparseSolverBase<Derived> { protected : typedef SparseSolverBase<Derived> Base ; using Base::derived ; using Base::m_isInitialized ; public : typedef _MatrixType MatrixType ; typedef MatrixType::Scalar Scalar ; typedef MatrixType::RealScalar RealScalar ; typedef MatrixType::StorageIndex StorageIndex ; typedef Matrix<Scalar,Dynamic,1> Vector ; typedef Matrix<int,1,MatrixType::ColsAtCompileTime> IntRowVectorType ; typedef Matrix<int,MatrixType::RowsAtCompileTime,1> IntColVectorType ; typedef Map<PermutationMatrix<Dynamic,Dynamic,int>> PermutationMap ; typedef SparseMatrix<Scalar> LUMatrixType ; enum { ColsAtCompileTime = MatrixType::ColsAtCompileTime,MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime } ; public :)",
    "insertText": "SuperLUBase()"
  },
  {
    "label": "clearFactors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clearFactors()"
  },
  {
    "label": "options()",
    "kind": "Method",
    "detail": "Function (} superlu_options_t&)",
    "insertText": "options()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_isInitialized && \"Decomposition is not initialized.\")"
  },
  {
    "label": "derived()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "derived().analyzePattern(matrix)"
  },
  {
    "label": "derived()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "derived().factorize(matrix)"
  },
  {
    "label": "analyzePattern()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "analyzePattern(const MatrixType&)"
  },
  {
    "label": "dumpMemory()",
    "kind": "Method",
    "detail": "Function (m_isInitialized = true ; m_info = Success ; m_analysisIsOk = true ; m_factorizationIsOk = false ; } template<Stream> void)",
    "insertText": "dumpMemory(Stream&)"
  },
  {
    "label": "initFactorization()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "initFactorization(const MatrixType& a)"
  },
  {
    "label": "set_default_options()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_default_options(&this->m_sluOptions)"
  },
  {
    "label": "asSluMatrix()",
    "kind": "Method",
    "detail": "Function (m_matrix = a ; m_sluA =)",
    "insertText": "asSluMatrix(m_matrix)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_p .)",
    "insertText": "resize(size)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (m_sluB . Mtype = SLU_GE ; m_sluB . storage . values = 0 ; m_sluB . nrow = 0 ; m_sluB . ncol = 0 ; m_sluB . storage . lda = internal::convert_index<)",
    "insertText": "int(size)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (m_sluX = m_sluB ; m_extractedDataAreDirty = true ; } void)",
    "insertText": "init()"
  },
  {
    "label": "extractData()",
    "kind": "Method",
    "detail": "Function (m_info = InvalidInput ; m_isInitialized = false ; m_sluL . Store = 0 ; m_sluU . Store = 0 ; } void)",
    "insertText": "extractData()"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (m_sluL . Store = 0 ; m_sluU . Store = 0 ;)",
    "insertText": "memset(&m_sluL,0,sizeof m_sluL)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(&m_sluU,0,sizeof m_sluU)"
  },
  {
    "label": "SuperLUBase()",
    "kind": "Method",
    "detail": "Function (} LUMatrixType m_l ; LUMatrixType m_u ; IntColVectorType m_p ; IntRowVectorType m_q ; LUMatrixType m_matrix ; SluMatrix m_sluA ; SuperMatrix m_sluL,m_sluU ; SluMatrix m_sluB,m_sluX ; SuperLUStat_t m_sluStat ; superlu_options_t m_sluOptions ; std::vector<int> m_sluEtree ; Matrix<RealScalar,Dynamic,1> m_sluRscale,m_sluCscale ; Matrix<RealScalar,Dynamic,1> m_sluFerr,m_sluBerr ; char m_sluEqued ; ComputationInfo m_info ; int m_factorizationIsOk ; int m_analysisIsOk ; bool m_extractedDataAreDirty ; private :)",
    "insertText": "SuperLUBase(SuperLUBase&)"
  },
  {
    "label": "SuperLU()",
    "kind": "Method",
    "detail": "Function (} } ; template<_MatrixType> class SuperLU : public SuperLUBase<_MatrixType,SuperLU<_MatrixType>> { public : typedef SuperLUBase<_MatrixType,SuperLU> Base ; typedef _MatrixType MatrixType ; typedef Base::Scalar Scalar ; typedef Base::RealScalar RealScalar ; typedef Base::StorageIndex StorageIndex ; typedef Base::IntRowVectorType IntRowVectorType ; typedef Base::IntColVectorType IntColVectorType ; typedef Base::PermutationMap PermutationMap ; typedef Base::LUMatrixType LUMatrixType ; typedef TriangularView<LUMatrixType,Lower | UnitDiag> LMatrixType ; typedef TriangularView<LUMatrixType,Upper> UMatrixType ; public : using Base::_solve_impl ;)",
    "insertText": "SuperLU() : Base()"
  },
  {
    "label": "SuperLU()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SuperLU(const MatrixType& matrix) : Base()"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute(matrix)"
  },
  {
    "label": "SuperLU()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "SuperLU()"
  },
  {
    "label": "analyzePattern()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "analyzePattern(const MatrixType& matrix)"
  },
  {
    "label": "analyzePattern()",
    "kind": "Method",
    "detail": "Function (m_info = InvalidInput ; m_isInitialized = false ;)",
    "insertText": "analyzePattern(matrix)"
  },
  {
    "label": "factorize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "factorize(const MatrixType& matrix)"
  },
  {
    "label": "_solve_impl()",
    "kind": "Method",
    "detail": "Function (template<Rhs,Dest> void)",
    "insertText": "_solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest)"
  },
  {
    "label": "matrixL()",
    "kind": "Method",
    "detail": "Function (const LMatrixType&)",
    "insertText": "matrixL()"
  },
  {
    "label": "SuperLU()",
    "kind": "Method",
    "detail": "Function (m_sluOptions . PrintStat = NO ; m_sluOptions . ConditionNumber = NO ; m_sluOptions . Trans = NOTRANS ; m_sluOptions . ColPerm = COLAMD ; } private :)",
    "insertText": "SuperLU(SuperLU&)"
  },
  {
    "label": "factorize()",
    "kind": "Method",
    "detail": "Function (} } ; template<MatrixType> void SuperLU<MatrixType)",
    "insertText": "factorize(const MatrixType& a)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_analysisIsOk && \"You must first call analyzePattern()\")"
  },
  {
    "label": "initFactorization()",
    "kind": "Method",
    "detail": "Function (m_info = InvalidInput ; return ; } this ->)",
    "insertText": "initFactorization(a)"
  },
  {
    "label": "StatInit()",
    "kind": "Method",
    "detail": "Function (m_sluOptions . ColPerm = COLAMD ; int info = 0 ; RealScalar recip_pivot_growth,rcond ; RealScalar ferr,berr ;)",
    "insertText": "StatInit(&m_sluStat)"
  },
  {
    "label": "SuperLU_gssvx()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SuperLU_gssvx(&m_sluOptions, &m_sluA, m_q.data(), m_p.data(), &m_sluEtree[0], &m_sluEqued, &m_sluRscale[0], &m_sluCscale[0], &m_sluL, &m_sluU, NULL, 0, &m_sluB, &m_sluX, &recip_pivot_growth, &rcond, &ferr, &berr, &m_sluStat, &info, Scalar())"
  },
  {
    "label": "StatFree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StatFree(&m_sluStat)"
  },
  {
    "label": "_solve_impl()",
    "kind": "Method",
    "detail": "Function (m_extractedDataAreDirty = true ; m_info = info = = 0 ? Success : NumericalIssue ; m_factorizationIsOk = true ; } template<MatrixType> template<Rhs,Dest> void SuperLU<MatrixType)",
    "insertText": "_solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_factorizationIsOk && \"The decomposition is not in a valid state for solving, you must first call either compute() or analyzePattern()/factorize()\")"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_matrix.rows()==b.rows())"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_sluOptions . Trans = NOTRANS ; m_sluOptions . Fact = FACTORED ; m_sluOptions . IterRefine = NOREFINE ; m_sluFerr .)",
    "insertText": "resize(rhsCols)"
  },
  {
    "label": "b_ref()",
    "kind": "Method",
    "detail": "Function (Ref<const Matrix<Rhs::Scalar,Dynamic,Dynamic,ColMajor>>)",
    "insertText": "b_ref(b)"
  },
  {
    "label": "x_ref()",
    "kind": "Method",
    "detail": "Function (Ref<const Matrix<Dest::Scalar,Dynamic,Dynamic,ColMajor>>)",
    "insertText": "x_ref(x)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (m_sluB =)",
    "insertText": "Map(b_ref.const_cast_derived())"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (m_sluX =)",
    "insertText": "Map(x_ref.const_cast_derived())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Rhs::PlainObject b_cpy ;)",
    "insertText": "if(m_sluEqued!='N')"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (b_cpy = b ; m_sluB =)",
    "insertText": "Map(b_cpy.const_cast_derived())"
  },
  {
    "label": "SuperLU_gssvx()",
    "kind": "Method",
    "detail": "Function (int info = 0 ; RealScalar recip_pivot_growth,rcond ;)",
    "insertText": "SuperLU_gssvx(&m_sluOptions, &m_sluA, m_q.data(), m_p.data(), &m_sluEtree[0], &m_sluEqued, &m_sluRscale[0], &m_sluCscale[0], &m_sluL, &m_sluU, NULL, 0, &m_sluB, &m_sluX, &recip_pivot_growth, &rcond, &m_sluFerr[0], &m_sluBerr[0], &m_sluStat, &info, Scalar())"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_factorizationIsOk && \"The decomposition is not in a valid state for extracting factors, you must first call either compute() or analyzePattern()/factorize()\")"
  },
  {
    "label": "SCformat()",
    "kind": "Method",
    "detail": "Function (int upper ; int fsupc,istart,nsupr ; int lastl = 0,lastu = 0 ; SCformat* Lstore = static_cast<)",
    "insertText": "SCformat(m_sluL.Store)"
  },
  {
    "label": "NCformat()",
    "kind": "Method",
    "detail": "Function (NCformat* Ustore = static_cast<)",
    "insertText": "NCformat(m_sluU.Store)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_l .)",
    "insertText": "resize(size,size)"
  },
  {
    "label": "resizeNonZeros()",
    "kind": "Method",
    "detail": "Function (m_l .)",
    "insertText": "resizeNonZeros(Lstore->nnz)"
  },
  {
    "label": "resizeNonZeros()",
    "kind": "Method",
    "detail": "Function (m_u .)",
    "insertText": "resizeNonZeros(Ustore->nnz)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Ucol [ 0 ] = 0 ; Ucol [ 0 ] = 0 ;)",
    "insertText": "for(int k = 0; k <= Lstore->nsuper; ++k)"
  },
  {
    "label": "L_FST_SUPC()",
    "kind": "Method",
    "detail": "Function (fsupc =)",
    "insertText": "L_FST_SUPC(k)"
  },
  {
    "label": "L_SUB_START()",
    "kind": "Method",
    "detail": "Function (istart =)",
    "insertText": "L_SUB_START(fsupc)"
  },
  {
    "label": "L_SUB_START()",
    "kind": "Method",
    "detail": "Function (nsupr =)",
    "insertText": "L_SUB_START(fsupc+1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (upper = 1 ;)",
    "insertText": "for(int j = fsupc; j < L_FST_SUPC(k+1); ++j)"
  },
  {
    "label": "SNptr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SNptr((Scalar*)Lstore->nzval)[L_NZ_START(j)"
  },
  {
    "label": "lastu()",
    "kind": "Method",
    "detail": "Function (Uval [)",
    "insertText": "lastu((Scalar*)Ustore->nzval)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int i = 0; i < upper; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Uval [ lastu ] = SNptr [ i ] ;)",
    "insertText": "if(Uval[lastu] != 0.0) Urow[lastu++] = L_SUB(istart+i)"
  },
  {
    "label": "L_SUB()",
    "kind": "Method",
    "detail": "Function (} Ucol [ j + 1 ] = lastu ; Lval [ lastl ] = 1 . 0 ; Lrow [ lastl + + ] =)",
    "insertText": "L_SUB(istart + upper - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Lval [ lastl ] = SNptr [ i ] ;)",
    "insertText": "if(Lval[lastl] != 0.0) Lrow[lastl++] = L_SUB(istart+i)"
  },
  {
    "label": "resizeNonZeros()",
    "kind": "Method",
    "detail": "Function (} Lcol [ j + 1 ] = lastl ; + + upper ; } } m_l .)",
    "insertText": "resizeNonZeros(lastl)"
  },
  {
    "label": "resizeNonZeros()",
    "kind": "Method",
    "detail": "Function (m_u .)",
    "insertText": "resizeNonZeros(lastu)"
  },
  {
    "label": "determinant()",
    "kind": "Method",
    "detail": "Function (m_extractedDataAreDirty = false ; } } template<MatrixType> SuperLU<MatrixType>::Scalar SuperLU<MatrixType)",
    "insertText": "determinant()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_factorizationIsOk && \"The decomposition is not in a valid state for computing the determinant, you must first call either compute() or analyzePattern()/factorize()\")"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (Scalar det =)",
    "insertText": "Scalar(1)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_u.innerIndexPtr()[lastId]<=j)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(PermutationMap(m_p.data(),m_p.size()).determinant()*PermutationMap(m_q.data(),m_q.size()).determinant()<0)"
  },
  {
    "label": "SuperILU()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SuperILU(const MatrixType& matrix) : Base()"
  },
  {
    "label": "SuperILU()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "SuperILU()"
  },
  {
    "label": "ilu_set_default_options()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ilu_set_default_options(&m_sluOptions)"
  },
  {
    "label": "dummy_precision()",
    "kind": "Method",
    "detail": "Function (m_sluOptions . PrintStat = NO ; m_sluOptions . ConditionNumber = NO ; m_sluOptions . Trans = NOTRANS ; m_sluOptions . ColPerm = MMD_AT_PLUS_A ; m_sluOptions . ILU_MILU = SILU ; m_sluOptions . ILU_DropRule = DROP_BASIC ; m_sluOptions . ILU_DropTol = NumTraits<Scalar)",
    "insertText": "dummy_precision()"
  },
  {
    "label": "SuperILU()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "SuperILU(SuperILU&)"
  },
  {
    "label": "SuperLU_gsisx()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SuperLU_gsisx(&m_sluOptions, &m_sluA, m_q.data(), m_p.data(), &m_sluEtree[0], &m_sluEqued, &m_sluRscale[0], &m_sluCscale[0], &m_sluL, &m_sluU, NULL, 0, &m_sluB, &m_sluX, &recip_pivot_growth, &rcond, &m_sluStat, &info, Scalar())"
  }
]