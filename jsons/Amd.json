[
  {
    "label": "amd_flip()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_SPARSE_AMD_H # define EIGEN_SPARSE_AMD_H namespace Eigen { namespace internal { template<T> T)",
    "insertText": "amd_flip(const T& i)"
  },
  {
    "label": "amd_marked()",
    "kind": "Method",
    "detail": "Function (} template<T0,T1> bool)",
    "insertText": "amd_marked(const T0* w, const T1& j)"
  },
  {
    "label": "cs_wclear()",
    "kind": "Method",
    "detail": "Function (} template<StorageIndex> StorageIndex)",
    "insertText": "cs_wclear(StorageIndex mark, StorageIndex lemax, StorageIndex *w, StorageIndex n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (StorageIndex k ;)",
    "insertText": "if(mark < 2 || (mark + lemax < 0))"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (mark = 2 ; })",
    "insertText": "return(mark)"
  },
  {
    "label": "cs_tdfs()",
    "kind": "Method",
    "detail": "Function (} template<StorageIndex> StorageIndex)",
    "insertText": "cs_tdfs(StorageIndex j, StorageIndex k, StorageIndex *head, const StorageIndex *next, StorageIndex *post, StorageIndex *stack)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (StorageIndex i,p,top = 0 ;)",
    "insertText": "if(!head || !next || !post || !stack) return (-1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (stack [ 0 ] = j ;)",
    "insertText": "while(top >= 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (p = stack [ top ] ; i = head [ p ] ;)",
    "insertText": "if(i == -1)"
  },
  {
    "label": "minimum_degree_ordering()",
    "kind": "Method",
    "detail": "Function (top - - ; post [ k + + ] = p ; } else { head [ p ] = next [ i ] ; stack [ + + top ] = i ; } } return k ; } template<Scalar,StorageIndex> void)",
    "insertText": "minimum_degree_ordering(SparseMatrix<Scalar,ColMajor,StorageIndex>& C, PermutationMatrix<Dynamic,Dynamic,StorageIndex>& perm)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (using std::sqrt ; StorageIndex d,dk,dext,lemax = 0,e,elenk,eln,i,j,k,k1,k2,k3,jlast,ln,dense,nzmax,mindeg = 0,nvi,nvj,nvk,mark,wnvi,ok,nel = 0,p,p1,p2,p3,p4,pj,pk,pk1,pk2,pn,q,t,h ; StorageIndex n =)",
    "insertText": "StorageIndex(C.cols())"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (dense = std::max<)",
    "insertText": "StorageIndex(16, StorageIndex(10 * sqrt(double(n))))"
  },
  {
    "label": "dense()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dense(std::min)(n-2, dense)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (StorageIndex cnz =)",
    "insertText": "StorageIndex(C.nonZeros())"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (perm .)",
    "insertText": "resize(n+1)"
  },
  {
    "label": "resizeNonZeros()",
    "kind": "Method",
    "detail": "Function (t = cnz + cnz / 5 + 2* n ; C .)",
    "insertText": "resizeNonZeros(t)"
  },
  {
    "label": "ei_declare_aligned_stack_constructed_variable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ei_declare_aligned_stack_constructed_variable(StorageIndex,W,8*(n+1),0)"
  },
  {
    "label": "W()",
    "kind": "Method",
    "detail": "Function (StorageIndex* len = W ; StorageIndex* nv =)",
    "insertText": "W(n+1)"
  },
  {
    "label": "indices()",
    "kind": "Method",
    "detail": "Function (StorageIndex* last = perm .)",
    "insertText": "indices().data()"
  },
  {
    "label": "outerIndexPtr()",
    "kind": "Method",
    "detail": "Function (StorageIndex* Cp = C .)",
    "insertText": "outerIndexPtr()"
  },
  {
    "label": "innerIndexPtr()",
    "kind": "Method",
    "detail": "Function (StorageIndex* Ci = C .)",
    "insertText": "innerIndexPtr()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (len [ n ] = 0 ; nzmax = t ;)",
    "insertText": "for(i = 0; i <= n; i++)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (head [ i ] = - 1 ; last [ i ] = - 1 ; next [ i ] = - 1 ; hhead [ i ] = - 1 ; nv [ i ] = 1 ; w [ i ] = 1 ; elen [ i ] = 0 ; degree [ i ] = len [ i ] ; } mark = internal::cs_wclear<)",
    "insertText": "StorageIndex(0, 0, w, n)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool has_diag = false ;)",
    "insertText": "for(p = Cp[i]; p<Cp[i+1]; ++p) if(Ci[p]==i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (has_diag = true ; break ; } d = degree [ i ] ;)",
    "insertText": "if(d == 1 && has_diag)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (elen [ i ] = - 2 ; nel + + ; Cp [ i ] = - 1 ; w [ i ] = 0 ; } else)",
    "insertText": "if(d > dense || !has_diag)"
  },
  {
    "label": "amd_flip()",
    "kind": "Method",
    "detail": "Function (nv [ i ] = 0 ; elen [ i ] = - 1 ; nel + + ; Cp [ i ] =)",
    "insertText": "amd_flip(n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (nv [ n ] + + ; } else {)",
    "insertText": "if(head[d] != -1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (next [ i ] = head [ d ] ; head [ d ] = i ; } } elen [ n ] = - 2 ; Cp [ n ] = - 1 ; w [ n ] = 0 ;)",
    "insertText": "while(nel < n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(next[k] != -1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (head [ mindeg ] = next [ k ] ; elenk = elen [ k ] ; nvk = nv [ k ] ; nel + = nvk ;)",
    "insertText": "if(elenk > 0 && cnz + mindeg >= nzmax)"
  },
  {
    "label": "amd_flip()",
    "kind": "Method",
    "detail": "Function (Cp [ j ] = Ci [ p ] ; Ci [ p ] =)",
    "insertText": "amd_flip(j)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(q = 0, p = 0; p < cnz;)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Ci [ q ] = Cp [ j ] ; Cp [ j ] = q + + ;)",
    "insertText": "for(k3 = 0; k3 < len[j]-1; k3++)"
  },
  {
    "label": "pk1()",
    "kind": "Method",
    "detail": "Function (} } cnz = q ; } dk = 0 ; nv [ k ] = - nvk ; p = Cp [ k ] ;)",
    "insertText": "pk1(elenk == 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (pk2 = pk1 ;)",
    "insertText": "for(k1 = 1; k1 <= elenk + 1; k1++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (e = k ; pj = p ; ln = len [ k ] - elenk ; } else { e = Ci [ p + + ] ; pj = Cp [ e ] ; ln = len [ e ] ; })",
    "insertText": "for(k2 = 1; k2 <= ln; k2++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (i = Ci [ pj + + ] ;)",
    "insertText": "if((nvi = nv[i]) <= 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (dk + = nvi ; nv [ i ] = - nvi ; Ci [ pk2 + + ] = i ;)",
    "insertText": "if(next[i] != -1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (next [ last [ i ] ] = next [ i ] ; } else { head [ degree [ i ] ] = next [ i ] ; } })",
    "insertText": "if(e != k)"
  },
  {
    "label": "amd_flip()",
    "kind": "Method",
    "detail": "Function (Cp [ e ] =)",
    "insertText": "amd_flip(k)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (w [ e ] = 0 ; } })",
    "insertText": "if(elenk != 0)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (degree [ k ] = dk ; Cp [ k ] = pk1 ; len [ k ] = pk2 - pk1 ; elen [ k ] = - 2 ; mark = internal::cs_wclear<)",
    "insertText": "StorageIndex(mark, lemax, w, n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (i = Ci [ pk ] ;)",
    "insertText": "if((eln = elen[i]) <= 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (nvi = - nv [ i ] ; wnvi = mark - nvi ;)",
    "insertText": "for(p = Cp[i]; p <= Cp[i] + eln - 1; p++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (e = Ci [ p ] ;)",
    "insertText": "if(w[e] >= mark)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (w [ e ] - = nvi ; } else)",
    "insertText": "if(w[e] != 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (w [ e ] = degree [ e ] + wnvi ; } } })",
    "insertText": "for(pk = pk1; pk < pk2; pk++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (i = Ci [ pk ] ; p1 = Cp [ i ] ; p2 = p1 + elen [ i ] - 1 ; pn = p1 ;)",
    "insertText": "for(h = 0, d = 0, p = p1; p <= p2; p++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (dext = w [ e ] - mark ;)",
    "insertText": "if(dext > 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (w [ e ] = 0 ; } } } elen [ i ] = pn - p1 + 1 ; p3 = pn ; p4 = p1 + len [ i ] ;)",
    "insertText": "for(p = p2 + 1; p < p4; p++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (j = Ci [ p ] ;)",
    "insertText": "if((nvj = nv[j]) <= 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (d + = nvj ; Ci [ pn + + ] = j ; h + = j ; })",
    "insertText": "if(d == 0)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (nvi = - nv [ i ] ; dk - = nvi ; nvk + = nvi ; nel + = nvi ; nv [ i ] = 0 ; elen [ i ] = - 1 ; } else { degree [ i ] = std::min<)",
    "insertText": "StorageIndex(degree[i], d)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (Ci [ pn ] = Ci [ p3 ] ; Ci [ p3 ] = Ci [ p1 ] ; Ci [ p1 ] = k ; len [ i ] = pn - p1 + 1 ; h % = n ; next [ i ] = hhead [ h ] ; hhead [ h ] = i ; last [ i ] = h ; } } degree [ k ] = dk ; lemax = std::max<)",
    "insertText": "StorageIndex(lemax, dk)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (mark = internal::cs_wclear<)",
    "insertText": "StorageIndex(mark+lemax, lemax, w, n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (i = Ci [ pk ] ;)",
    "insertText": "if(nv[i] >= 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (h = last [ i ] ; i = hhead [ h ] ; hhead [ h ] = - 1 ;)",
    "insertText": "for(; i != -1 && next[i] != -1; i = next[i], mark++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (ln = len [ i ] ; eln = elen [ i ] ;)",
    "insertText": "for(p = Cp[i]+1; p <= Cp[i] + ln-1; p++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (jlast = i ;)",
    "insertText": "for(j = next[i]; j != -1;)"
  },
  {
    "label": "ok()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ok(len[j] == ln) && (elen[j] == eln)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ok)"
  },
  {
    "label": "amd_flip()",
    "kind": "Method",
    "detail": "Function (Cp [ j ] =)",
    "insertText": "amd_flip(i)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (nv [ i ] + = nv [ j ] ; nv [ j ] = 0 ; elen [ j ] = - 1 ; j = next [ j ] ; next [ jlast ] = j ; } else { jlast = j ; j = next [ j ] ; } } } })",
    "insertText": "for(p = pk1, pk = pk1; pk < pk2; pk++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (i = Ci [ pk ] ;)",
    "insertText": "if((nvi = -nv[i]) <= 0)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (nv [ i ] = nvi ; d = degree [ i ] + dk - nvi ; d = std::min<)",
    "insertText": "StorageIndex(d, n - nel - nvi)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (next [ i ] = head [ d ] ; last [ i ] = - 1 ; head [ d ] = i ; mindeg = std::min<)",
    "insertText": "StorageIndex(mindeg, d)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (degree [ i ] = d ; Ci [ p + + ] = i ; } nv [ k ] = nvk ;)",
    "insertText": "if((len[k] = p-pk1) == 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(i = 0; i < n; i++) Cp[i] = amd_flip (Cp[i])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (next [ j ] = head [ Cp [ j ] ] ; head [ Cp [ j ] ] = j ; })",
    "insertText": "for(e = n; e >= 0; e--)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (next [ e ] = head [ Cp [ e ] ] ; head [ Cp [ e ] ] = e ; } })",
    "insertText": "for(k = 0, i = 0; i <= n; i++)"
  },
  {
    "label": "indices()",
    "kind": "Method",
    "detail": "Function (} perm .)",
    "insertText": "indices().conservativeResize(n)"
  }
]