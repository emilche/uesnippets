[
  {
    "label": "ListRecTy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ListRecTy"
  },
  {
    "label": "MultiClass",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MultiClass"
  },
  {
    "label": "Record",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Record"
  },
  {
    "label": "RecordVal",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RecordVal"
  },
  {
    "label": "RecordKeeper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RecordKeeper"
  },
  {
    "label": "RecTy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RecTy"
  },
  {
    "label": "RecTyKind",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "RecTyKind"
  },
  {
    "label": "BitRecTy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BitRecTy"
  },
  {
    "label": "BitsRecTy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BitsRecTy"
  },
  {
    "label": "IntRecTy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IntRecTy"
  },
  {
    "label": "StringRecTy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StringRecTy"
  },
  {
    "label": "DagRecTy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DagRecTy"
  },
  {
    "label": "RecordRecTy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RecordRecTy"
  },
  {
    "label": "Init",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Init"
  },
  {
    "label": "InitKind",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "InitKind"
  },
  {
    "label": "TypedInit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TypedInit"
  },
  {
    "label": "UnsetInit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UnsetInit"
  },
  {
    "label": "BitInit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BitInit"
  },
  {
    "label": "BitsInit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BitsInit"
  },
  {
    "label": "IntInit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IntInit"
  },
  {
    "label": "StringInit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StringInit"
  },
  {
    "label": "ListInit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ListInit"
  },
  {
    "label": "OpInit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OpInit"
  },
  {
    "label": "UnOpInit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UnOpInit"
  },
  {
    "label": "UnaryOp",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "UnaryOp"
  },
  {
    "label": "BinOpInit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BinOpInit"
  },
  {
    "label": "BinaryOp",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "BinaryOp"
  },
  {
    "label": "TernOpInit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TernOpInit"
  },
  {
    "label": "TernaryOp",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "TernaryOp"
  },
  {
    "label": "VarInit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VarInit"
  },
  {
    "label": "VarBitInit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VarBitInit"
  },
  {
    "label": "VarListElementInit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VarListElementInit"
  },
  {
    "label": "DefInit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DefInit"
  },
  {
    "label": "FieldInit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FieldInit"
  },
  {
    "label": "DagInit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DagInit"
  },
  {
    "label": "LessRecord",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LessRecord"
  },
  {
    "label": "LessRecordByID",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LessRecordByID"
  },
  {
    "label": "LessRecordFieldName",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LessRecordFieldName"
  },
  {
    "label": "LessRecordRegister",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LessRecordRegister"
  },
  {
    "label": "RecordParts",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RecordParts"
  },
  {
    "label": "getRecTyKind()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_TABLEGEN_RECORD_H # define LLVM_TABLEGEN_RECORD_H # include \" llvm / ADT / ArrayRef . h \" # include \" llvm / ADT / FoldingSet . h \" # include \" llvm / ADT / PointerIntPair . h \" # include \" llvm / Support / Casting . h \" # include \" llvm / Support / DataTypes . h \" # include \" llvm / Support / ErrorHandling . h \" # include \" llvm / Support / SMLoc . h \" # include \" llvm / Support / raw_ostream . h \" # include<map> namespace llvm { class ListRecTy ; struct MultiClass ; class Record ; class RecordVal ; class RecordKeeper ; class RecTy { public : enum RecTyKind { BitRecTyKind,BitsRecTyKind,IntRecTyKind,StringRecTyKind,ListRecTyKind,DagRecTyKind,RecordRecTyKind } ; private : RecTyKind Kind ; std::unique_ptr<ListRecTy> ListTy ; public : RecTyKind)",
    "insertText": "getRecTyKind()"
  },
  {
    "label": "RecTy()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "RecTy()"
  },
  {
    "label": "getAsString()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "getAsString()"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print(raw_ostream &OS)"
  },
  {
    "label": "dump()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "dump()"
  },
  {
    "label": "typeIsConvertibleTo()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "typeIsConvertibleTo(const RecTy *RHS)"
  },
  {
    "label": "getListTy()",
    "kind": "Method",
    "detail": "Function (ListRecTy*)",
    "insertText": "getListTy()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; raw_ostream&)",
    "insertText": "operator(raw_ostream &OS, const RecTy &Ty)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (Ty .)",
    "insertText": "print(OS)"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "classof(const RecTy *RT)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} BitRecTy*)",
    "insertText": "get()"
  },
  {
    "label": "BitsRecTy()",
    "kind": "Method",
    "detail": "Function (} ; class BitsRecTy : public RecTy { unsigned Size ;)",
    "insertText": "BitsRecTy(unsigned Sz) : RecTy(BitsRecTyKind), Size(Sz)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} BitsRecTy*)",
    "insertText": "get(unsigned Sz)"
  },
  {
    "label": "getNumBits()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getNumBits()"
  },
  {
    "label": "IntRecTy()",
    "kind": "Method",
    "detail": "Function (} ; class IntRecTy : public RecTy { IntRecTy Shared ;)",
    "insertText": "IntRecTy() : RecTy(IntRecTyKind)"
  },
  {
    "label": "StringRecTy()",
    "kind": "Method",
    "detail": "Function (} ; class StringRecTy : public RecTy { StringRecTy Shared ;)",
    "insertText": "StringRecTy() : RecTy(StringRecTyKind)"
  },
  {
    "label": "ListRecTy()",
    "kind": "Method",
    "detail": "Function (} ; class ListRecTy : public RecTy { RecTy* Ty ;)",
    "insertText": "ListRecTy(RecTy *T) : RecTy(ListRecTyKind), Ty(T)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} ListRecTy*)",
    "insertText": "get(RecTy *T)"
  },
  {
    "label": "getElementType()",
    "kind": "Method",
    "detail": "Function (} RecTy*)",
    "insertText": "getElementType()"
  },
  {
    "label": "DagRecTy()",
    "kind": "Method",
    "detail": "Function (} ; class DagRecTy : public RecTy { DagRecTy Shared ;)",
    "insertText": "DagRecTy() : RecTy(DagRecTyKind)"
  },
  {
    "label": "RecordRecTy()",
    "kind": "Method",
    "detail": "Function (} ; class RecordRecTy : public RecTy { Record* Rec ;)",
    "insertText": "RecordRecTy(Record *R) : RecTy(RecordRecTyKind), Rec(R)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} RecordRecTy*)",
    "insertText": "get(Record *R)"
  },
  {
    "label": "getRecord()",
    "kind": "Method",
    "detail": "Function (Record*)",
    "insertText": "getRecord()"
  },
  {
    "label": "resolveTypes()",
    "kind": "Method",
    "detail": "Function (} ; RecTy*)",
    "insertText": "resolveTypes(RecTy *T1, RecTy *T2)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (class Init { protected : enum InitKind { IK_BitInit,IK_FirstTypedInit,IK_BitsInit,IK_DagInit,IK_DefInit,IK_FieldInit,IK_IntInit,IK_ListInit,IK_FirstOpInit,IK_BinOpInit,IK_TernOpInit,IK_UnOpInit,IK_LastOpInit,IK_StringInit,IK_VarInit,IK_VarListElementInit,IK_LastTypedInit,IK_UnsetInit,IK_VarBitInit } ; private : const InitKind Kind ;)",
    "insertText": "Init(const Init &)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Init&)",
    "insertText": "operator(const Init &)"
  },
  {
    "label": "anchor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "anchor()"
  },
  {
    "label": "getKind()",
    "kind": "Method",
    "detail": "Function (public : InitKind)",
    "insertText": "getKind()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} public : ~)",
    "insertText": "Init()"
  },
  {
    "label": "isComplete()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isComplete()"
  },
  {
    "label": "getAsUnquotedString()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "getAsUnquotedString()"
  },
  {
    "label": "convertInitializerTo()",
    "kind": "Method",
    "detail": "Function (Init*)",
    "insertText": "convertInitializerTo(RecTy *Ty)"
  },
  {
    "label": "convertInitializerBitRange()",
    "kind": "Method",
    "detail": "Function (Init*)",
    "insertText": "convertInitializerBitRange(const std::vector<unsigned> &Bits)"
  },
  {
    "label": "getBit()",
    "kind": "Method",
    "detail": "Function (} Init*)",
    "insertText": "getBit(unsigned Bit)"
  },
  {
    "label": "getBitVar()",
    "kind": "Method",
    "detail": "Function (Init*)",
    "insertText": "getBitVar()"
  },
  {
    "label": "getBitNum()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getBitNum()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TypedInit&)",
    "insertText": "operator(const TypedInit &Other)"
  },
  {
    "label": "TypedInit()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "TypedInit(InitKind K, RecTy *T) : Init(K), Ty(T)"
  },
  {
    "label": "TypedInit()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TypedInit()"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "classof(const Init *I)"
  },
  {
    "label": "getType()",
    "kind": "Method",
    "detail": "Function (} RecTy*)",
    "insertText": "getType()"
  },
  {
    "label": "convertInitListSlice()",
    "kind": "Method",
    "detail": "Function (Init*)",
    "insertText": "convertInitListSlice(const std::vector<unsigned> &Elements)"
  },
  {
    "label": "getFieldType()",
    "kind": "Method",
    "detail": "Function (RecTy*)",
    "insertText": "getFieldType(const std::string &FieldName)"
  },
  {
    "label": "resolveListElementReference()",
    "kind": "Method",
    "detail": "Function (Init*)",
    "insertText": "resolveListElementReference(Record &R, const RecordVal *RV, unsigned Elt)"
  },
  {
    "label": "UnsetInit()",
    "kind": "Method",
    "detail": "Function (} ; class UnsetInit : public Init {)",
    "insertText": "UnsetInit() : Init(IK_UnsetInit)"
  },
  {
    "label": "UnsetInit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UnsetInit(const UnsetInit &)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (UnsetInit&)",
    "insertText": "operator(const UnsetInit &Other)"
  },
  {
    "label": "BitInit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "BitInit(const BitInit &Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (BitInit&)",
    "insertText": "operator(BitInit &Other)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} BitInit*)",
    "insertText": "get(bool V)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "getValue()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Bit < 1 && \"Bit index out of range!\")"
  },
  {
    "label": "BitsInit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "BitsInit(const BitsInit &Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (BitsInit&)",
    "insertText": "operator(const BitsInit &Other)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} BitsInit*)",
    "insertText": "get(ArrayRef<Init *> Range)"
  },
  {
    "label": "Profile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Profile(FoldingSetNodeID &ID)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Illegal element reference off bits<n>\")"
  },
  {
    "label": "resolveReferences()",
    "kind": "Method",
    "detail": "Function (} Init*)",
    "insertText": "resolveReferences(Record &R, const RecordVal *RV)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Bit < Bits.size() && \"Bit index out of range!\")"
  },
  {
    "label": "IntInit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "IntInit(const IntInit &Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IntInit&)",
    "insertText": "operator(const IntInit &Other)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} IntInit*)",
    "insertText": "get(int64_t V)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Illegal element reference off int\")"
  },
  {
    "label": "StringInit()",
    "kind": "Method",
    "detail": "Function (} } ; class StringInit : public TypedInit { std::string Value ;)",
    "insertText": "StringInit(const std::string &V) : TypedInit(IK_StringInit, StringRecTy::get()), Value(V)"
  },
  {
    "label": "StringInit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "StringInit(const StringInit &Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (StringInit&)",
    "insertText": "operator(const StringInit &Other)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} StringInit*)",
    "insertText": "get(StringRef)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Illegal element reference off string\")"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Illegal bit reference off string\")"
  },
  {
    "label": "ListInit()",
    "kind": "Method",
    "detail": "Function (} } ; class ListInit : public TypedInit,public FoldingSetNode { std::vector<Init*> Values ; public : typedef std::vector<Init*>::const_iterator const_iterator ; private :)",
    "insertText": "ListInit(ArrayRef<Init *> Range, RecTy *EltTy) : TypedInit(IK_ListInit, ListRecTy::get(EltTy)), Values(Range.begin(), Range.end())"
  },
  {
    "label": "ListInit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ListInit(const ListInit &Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ListInit&)",
    "insertText": "operator(const ListInit &Other)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} ListInit*)",
    "insertText": "get(ArrayRef<Init *> Range, RecTy *EltTy)"
  },
  {
    "label": "getElement()",
    "kind": "Method",
    "detail": "Function (Init*)",
    "insertText": "getElement(unsigned i)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i < Values.size() && \"List element index out of range!\")"
  },
  {
    "label": "getValues()",
    "kind": "Method",
    "detail": "Function (ArrayRef<Init*>)",
    "insertText": "getValues()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "end()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "size()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Illegal bit reference off list\")"
  },
  {
    "label": "OpInit()",
    "kind": "Method",
    "detail": "Function (} } ; class OpInit : public TypedInit {)",
    "insertText": "OpInit(const OpInit &Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (OpInit&)",
    "insertText": "operator(OpInit &Other)"
  },
  {
    "label": "OpInit()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "OpInit(InitKind K, RecTy *Type) : TypedInit(K, Type)"
  },
  {
    "label": "clone()",
    "kind": "Method",
    "detail": "Function (} OpInit*)",
    "insertText": "clone(std::vector<Init *> &Operands)"
  },
  {
    "label": "getNumOperands()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getNumOperands()"
  },
  {
    "label": "getOperand()",
    "kind": "Method",
    "detail": "Function (Init*)",
    "insertText": "getOperand(unsigned i)"
  },
  {
    "label": "Fold()",
    "kind": "Method",
    "detail": "Function (Init*)",
    "insertText": "Fold(Record *CurRec, MultiClass *CurMultiClass)"
  },
  {
    "label": "UnOpInit()",
    "kind": "Method",
    "detail": "Function (} ; class UnOpInit : public OpInit { public : enum UnaryOp { CAST,HEAD,TAIL,EMPTY } ; private : UnaryOp Opc ; Init* LHS ;)",
    "insertText": "UnOpInit(UnaryOp opc, Init *lhs, RecTy *Type) : OpInit(IK_UnOpInit, Type), Opc(opc), LHS(lhs)"
  },
  {
    "label": "UnOpInit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UnOpInit(const UnOpInit &Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (UnOpInit&)",
    "insertText": "operator(const UnOpInit &Other)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} UnOpInit*)",
    "insertText": "get(UnaryOp opc, Init *lhs, RecTy *Type)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Operands.size() == 1 && \"Wrong number of operands for unary operation\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i == 0 && \"Invalid operand id for unary operator\")"
  },
  {
    "label": "getOpcode()",
    "kind": "Method",
    "detail": "Function (} UnaryOp)",
    "insertText": "getOpcode()"
  },
  {
    "label": "BinOpInit()",
    "kind": "Method",
    "detail": "Function (} ; class BinOpInit : public OpInit { public : enum BinaryOp { ADD,AND,SHL,SRA,SRL,LISTCONCAT,STRCONCAT,CONCAT,EQ } ; private : BinaryOp Opc ; Init* LHS,* RHS ;)",
    "insertText": "BinOpInit(BinaryOp opc, Init *lhs, Init *rhs, RecTy *Type) : OpInit(IK_BinOpInit, Type), Opc(opc), LHS(lhs), RHS(rhs)"
  },
  {
    "label": "BinOpInit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "BinOpInit(const BinOpInit &Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (BinOpInit&)",
    "insertText": "operator(const BinOpInit &Other)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} BinOpInit*)",
    "insertText": "get(BinaryOp opc, Init *lhs, Init *rhs, RecTy *Type)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Operands.size() == 2 && \"Wrong number of operands for binary operation\")"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (default :)",
    "insertText": "llvm_unreachable(\"Invalid operand id for binary operator\")"
  },
  {
    "label": "TernOpInit()",
    "kind": "Method",
    "detail": "Function (} ; class TernOpInit : public OpInit { public : enum TernaryOp { SUBST,FOREACH,IF } ; private : TernaryOp Opc ; Init* LHS,* MHS,* RHS ;)",
    "insertText": "TernOpInit(TernaryOp opc, Init *lhs, Init *mhs, Init *rhs, RecTy *Type) : OpInit(IK_TernOpInit, Type), Opc(opc), LHS(lhs), MHS(mhs), RHS(rhs)"
  },
  {
    "label": "TernOpInit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TernOpInit(const TernOpInit &Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TernOpInit&)",
    "insertText": "operator(const TernOpInit &Other)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} TernOpInit*)",
    "insertText": "get(TernaryOp opc, Init *lhs, Init *mhs, Init *rhs, RecTy *Type)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Operands.size() == 3 && \"Wrong number of operands for ternary operation\")"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (default :)",
    "insertText": "llvm_unreachable(\"Invalid operand id for ternary operator\")"
  },
  {
    "label": "VarInit()",
    "kind": "Method",
    "detail": "Function (} ; class VarInit : public TypedInit { Init* VarName ;)",
    "insertText": "VarInit(const std::string &VN, RecTy *T) : TypedInit(IK_VarInit, T), VarName(StringInit::get(VN))"
  },
  {
    "label": "VarInit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VarInit(Init *VN, RecTy *T) : TypedInit(IK_VarInit, T), VarName(VN)"
  },
  {
    "label": "VarInit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VarInit(const VarInit &Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (VarInit&)",
    "insertText": "operator(const VarInit &Other)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} VarInit*)",
    "insertText": "get(const std::string &VN, RecTy *T)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (VarInit*)",
    "insertText": "get(Init *VN, RecTy *T)"
  },
  {
    "label": "getName()",
    "kind": "Method",
    "detail": "Function (const std::string&)",
    "insertText": "getName()"
  },
  {
    "label": "getNameInit()",
    "kind": "Method",
    "detail": "Function (Init*)",
    "insertText": "getNameInit()"
  },
  {
    "label": "getFieldInit()",
    "kind": "Method",
    "detail": "Function (Init*)",
    "insertText": "getFieldInit(Record &R, const RecordVal *RV, const std::string &FieldName)"
  },
  {
    "label": "VarBitInit()",
    "kind": "Method",
    "detail": "Function (} } ; class VarBitInit : public Init { TypedInit* TI ; unsigned Bit ;)",
    "insertText": "VarBitInit(TypedInit *T, unsigned B) : Init(IK_VarBitInit), TI(T), Bit(B)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(T->getType() && (isa<IntRecTy>(T->getType()) || (isa<BitsRecTy>(T->getType()) && cast<BitsRecTy>(T->getType())->getNumBits() > B)) && \"Illegal VarBitInit expression!\")"
  },
  {
    "label": "VarBitInit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VarBitInit(const VarBitInit &Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (VarBitInit&)",
    "insertText": "operator(const VarBitInit &Other)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} VarBitInit*)",
    "insertText": "get(TypedInit *T, unsigned B)"
  },
  {
    "label": "getBit()",
    "kind": "Method",
    "detail": "Function (Init*)",
    "insertText": "getBit(unsigned B)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(B < 1 && \"Bit index out of range!\")"
  },
  {
    "label": "VarListElementInit()",
    "kind": "Method",
    "detail": "Function (} } ; class VarListElementInit : public TypedInit { TypedInit* TI ; unsigned Element ;)",
    "insertText": "VarListElementInit(TypedInit *T, unsigned E) : TypedInit(IK_VarListElementInit, cast<ListRecTy>(T->getType())->getElementType()), TI(T), Element(E)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(T->getType() && isa<ListRecTy>(T->getType()) && \"Illegal VarBitInit expression!\")"
  },
  {
    "label": "VarListElementInit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VarListElementInit(const VarListElementInit &Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(const VarListElementInit &Other)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} VarListElementInit*)",
    "insertText": "get(TypedInit *T, unsigned E)"
  },
  {
    "label": "getVariable()",
    "kind": "Method",
    "detail": "Function (TypedInit*)",
    "insertText": "getVariable()"
  },
  {
    "label": "DefInit()",
    "kind": "Method",
    "detail": "Function (} ; class DefInit : public TypedInit { Record* Def ;)",
    "insertText": "DefInit(Record *D, RecordRecTy *T) : TypedInit(IK_DefInit, T), Def(D)"
  },
  {
    "label": "DefInit()",
    "kind": "Method",
    "detail": "Function (} class Record ;)",
    "insertText": "DefInit(const DefInit &Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (DefInit&)",
    "insertText": "operator(const DefInit &Other)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} DefInit*)",
    "insertText": "get(Record*)"
  },
  {
    "label": "getDef()",
    "kind": "Method",
    "detail": "Function (Record*)",
    "insertText": "getDef()"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Illegal bit reference off def\")"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Illegal element reference off def\")"
  },
  {
    "label": "FieldInit()",
    "kind": "Method",
    "detail": "Function (} } ; class FieldInit : public TypedInit { Init* Rec ; std::string FieldName ;)",
    "insertText": "FieldInit(Init *R, const std::string &FN) : TypedInit(IK_FieldInit, R->getFieldType(FN)), Rec(R), FieldName(FN)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(getType() && \"FieldInit with non-record type!\")"
  },
  {
    "label": "FieldInit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FieldInit(const FieldInit &Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FieldInit&)",
    "insertText": "operator(const FieldInit &Other)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} FieldInit*)",
    "insertText": "get(Init *R, const std::string &FN)"
  },
  {
    "label": "DagInit()",
    "kind": "Method",
    "detail": "Function (} } ; class DagInit : public TypedInit,public FoldingSetNode { Init* Val ; std::string ValName ; std::vector<Init*> Args ; std::vector<std::string> ArgNames ;)",
    "insertText": "DagInit(Init *V, const std::string &VN, ArrayRef<Init *> ArgRange, ArrayRef<std::string> NameRange) : TypedInit(IK_DagInit, DagRecTy::get()), Val(V), ValName(VN), Args(ArgRange.begin(), ArgRange.end()), ArgNames(NameRange.begin(), NameRange.end())"
  },
  {
    "label": "DagInit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "DagInit(const DagInit &Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (DagInit&)",
    "insertText": "operator(const DagInit &Other)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} DagInit*)",
    "insertText": "get(Init *V, const std::string &VN, ArrayRef<Init *> ArgRange, ArrayRef<std::string> NameRange)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (DagInit*)",
    "insertText": "get(Init *V, const std::string &VN, const std::vector< std::pair<Init*, std::string> > &args)"
  },
  {
    "label": "getOperator()",
    "kind": "Method",
    "detail": "Function (Init*)",
    "insertText": "getOperator()"
  },
  {
    "label": "getArg()",
    "kind": "Method",
    "detail": "Function (} Init*)",
    "insertText": "getArg(unsigned Num)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Num < Args.size() && \"Arg number out of range!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Num < ArgNames.size() && \"Arg number out of range!\")"
  },
  {
    "label": "arg_begin()",
    "kind": "Method",
    "detail": "Function (typedef std::vector<Init*>::const_iterator const_arg_iterator ; typedef std::vector<std::string>::const_iterator const_name_iterator ; const_arg_iterator)",
    "insertText": "arg_begin()"
  },
  {
    "label": "arg_end()",
    "kind": "Method",
    "detail": "Function (} const_arg_iterator)",
    "insertText": "arg_end()"
  },
  {
    "label": "arg_size()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "arg_size()"
  },
  {
    "label": "arg_empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "arg_empty()"
  },
  {
    "label": "name_begin()",
    "kind": "Method",
    "detail": "Function (} const_name_iterator)",
    "insertText": "name_begin()"
  },
  {
    "label": "name_end()",
    "kind": "Method",
    "detail": "Function (} const_name_iterator)",
    "insertText": "name_end()"
  },
  {
    "label": "name_size()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "name_size()"
  },
  {
    "label": "name_empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "name_empty()"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Illegal bit reference off dag\")"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Illegal element reference off dag\")"
  },
  {
    "label": "RecordVal()",
    "kind": "Method",
    "detail": "Function (} } ; class RecordVal { PointerIntPair<Init*,1,bool> NameAndPrefix ; RecTy* Ty ; Init* Value ; public :)",
    "insertText": "RecordVal(Init *N, RecTy *T, bool P)"
  },
  {
    "label": "RecordVal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RecordVal(const std::string &N, RecTy *T, bool P)"
  },
  {
    "label": "getNameInitAsString()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "getNameInitAsString()"
  },
  {
    "label": "getPrefix()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "getPrefix()"
  },
  {
    "label": "convertInitializerTo()",
    "kind": "Method",
    "detail": "Function (Value = V ->)",
    "insertText": "convertInitializerTo(Ty)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print(raw_ostream &OS, bool PrintSem = true)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; raw_ostream&)",
    "insertText": "operator(raw_ostream &OS, const RecordVal &RV)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (RV .)",
    "insertText": "print(OS << \" \")"
  },
  {
    "label": "checkName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "checkName()"
  },
  {
    "label": "Record()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "Record(Init *N, ArrayRef<SMLoc> locs, RecordKeeper &records, bool Anonymous = false) : ID(LastID++), Name(N), Locs(locs.begin(), locs.end()), TrackedRecords(records), IsAnonymous(Anonymous), ResolveFirst(false)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init()"
  },
  {
    "label": "Record()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Record(const std::string &N, ArrayRef<SMLoc> locs, RecordKeeper &records, bool Anonymous = false) : Record(StringInit::get(N), locs, records, Anonymous)"
  },
  {
    "label": "Record()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Record(const Record &O) : ID(LastID++), Name(O.Name), Locs(O.Locs), TemplateArgs(O.TemplateArgs), Values(O.Values), SuperClasses(O.SuperClasses), SuperClassRanges(O.SuperClassRanges), TrackedRecords(O.TrackedRecords), IsAnonymous(O.IsAnonymous), ResolveFirst(O.ResolveFirst)"
  },
  {
    "label": "getNewUID()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getNewUID()"
  },
  {
    "label": "setName()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setName(Init *Name)"
  },
  {
    "label": "setName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setName(const std::string &Name)"
  },
  {
    "label": "getLoc()",
    "kind": "Method",
    "detail": "Function (ArrayRef<SMLoc>)",
    "insertText": "getLoc()"
  },
  {
    "label": "getTemplateArgs()",
    "kind": "Method",
    "detail": "Function (ArrayRef<Init*>)",
    "insertText": "getTemplateArgs()"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (} const RecordVal*)",
    "insertText": "getValue(const Init *Name)"
  },
  {
    "label": "addTemplateArg()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addTemplateArg(Init *Name)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!isTemplateArg(Name) && \"Template arg already defined!\")"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (TemplateArgs .)",
    "insertText": "push_back(Name)"
  },
  {
    "label": "addTemplateArg()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addTemplateArg(StringRef Name)"
  },
  {
    "label": "addTemplateArg()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addTemplateArg(StringInit::get(Name))"
  },
  {
    "label": "addValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addValue(const RecordVal &RV)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(getValue(RV.getNameInit()) == nullptr && \"Value already added!\")"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Values .)",
    "insertText": "push_back(RV)"
  },
  {
    "label": "removeValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "removeValue(Init *Name)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (Values .)",
    "insertText": "erase(Values.begin()+i)"
  },
  {
    "label": "removeValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "removeValue(StringRef Name)"
  },
  {
    "label": "removeValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "removeValue(StringInit::get(Name))"
  },
  {
    "label": "isSubClassOf()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isSubClassOf(const Record *R)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!isSubClassOf(R) && \"Already subclassing record!\")"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (SuperClasses .)",
    "insertText": "push_back(R)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (SuperClassRanges .)",
    "insertText": "push_back(Range)"
  },
  {
    "label": "resolveReferences()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resolveReferences()"
  },
  {
    "label": "resolveReferencesTo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resolveReferencesTo(nullptr)"
  },
  {
    "label": "resolveReferencesTo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resolveReferencesTo(const RecordVal *RV)"
  },
  {
    "label": "getRecords()",
    "kind": "Method",
    "detail": "Function (RecordKeeper&)",
    "insertText": "getRecords()"
  },
  {
    "label": "getValueInit()",
    "kind": "Method",
    "detail": "Function (Init*)",
    "insertText": "getValueInit(StringRef FieldName)"
  },
  {
    "label": "isValueUnset()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isValueUnset(StringRef FieldName)"
  },
  {
    "label": "getValueAsString()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "getValueAsString(StringRef FieldName)"
  },
  {
    "label": "getValueAsBitsInit()",
    "kind": "Method",
    "detail": "Function (BitsInit*)",
    "insertText": "getValueAsBitsInit(StringRef FieldName)"
  },
  {
    "label": "getValueAsListInit()",
    "kind": "Method",
    "detail": "Function (ListInit*)",
    "insertText": "getValueAsListInit(StringRef FieldName)"
  },
  {
    "label": "getValueAsListOfDefs()",
    "kind": "Method",
    "detail": "Function (std::vector<Record*>)",
    "insertText": "getValueAsListOfDefs(StringRef FieldName)"
  },
  {
    "label": "getValueAsListOfInts()",
    "kind": "Method",
    "detail": "Function (std::vector<int64_t>)",
    "insertText": "getValueAsListOfInts(StringRef FieldName)"
  },
  {
    "label": "getValueAsListOfStrings()",
    "kind": "Method",
    "detail": "Function (std::vector<std::string>)",
    "insertText": "getValueAsListOfStrings(StringRef FieldName)"
  },
  {
    "label": "getValueAsDef()",
    "kind": "Method",
    "detail": "Function (Record*)",
    "insertText": "getValueAsDef(StringRef FieldName)"
  },
  {
    "label": "getValueAsBit()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "getValueAsBit(StringRef FieldName)"
  },
  {
    "label": "getValueAsBitOrUnset()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "getValueAsBitOrUnset(StringRef FieldName, bool &Unset)"
  },
  {
    "label": "getValueAsInt()",
    "kind": "Method",
    "detail": "Function (int64_t)",
    "insertText": "getValueAsInt(StringRef FieldName)"
  },
  {
    "label": "getValueAsDag()",
    "kind": "Method",
    "detail": "Function (DagInit*)",
    "insertText": "getValueAsDag(StringRef FieldName)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; raw_ostream&)",
    "insertText": "operator(raw_ostream &OS, const Record &R)"
  },
  {
    "label": "MultiClass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MultiClass(const std::string &Name, SMLoc Loc, RecordKeeper &Records) : Rec(Name, Loc, Records)"
  },
  {
    "label": "getClasses()",
    "kind": "Method",
    "detail": "Function (} } ; class RecordKeeper { typedef std::map<std::string,std::unique_ptr<Record>> RecordMap ; RecordMap Classes,Defs ; public : const RecordMap&)",
    "insertText": "getClasses()"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (auto I = Classes .)",
    "insertText": "find(Name)"
  },
  {
    "label": "getDef()",
    "kind": "Method",
    "detail": "Function (} Record*)",
    "insertText": "getDef(const std::string &Name)"
  },
  {
    "label": "addClass()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addClass(std::unique_ptr<Record> R)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (bool Ins = Classes .)",
    "insertText": "insert(std::make_pair(R->getName(), std::move(R)))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Ins && \"Class already exists\")"
  },
  {
    "label": "addDef()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addDef(std::unique_ptr<Record> R)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Ins && \"Record already exists\")"
  },
  {
    "label": "getAllDerivedDefinitions()",
    "kind": "Method",
    "detail": "Function (} std::vector<Record*>)",
    "insertText": "getAllDerivedDefinitions(const std::string &ClassName)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; struct LessRecord { bool)",
    "insertText": "operator()(const Record *Rec1, const Record *Rec2)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; struct LessRecordByID { bool)",
    "insertText": "operator()(const Record *LHS, const Record *RHS)"
  },
  {
    "label": "ascii_isdigit()",
    "kind": "Method",
    "detail": "Function (} } ; struct LessRecordRegister { bool)",
    "insertText": "ascii_isdigit(char x)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (size_t Len = 0 ; const char* Start = Rec .)",
    "insertText": "data()"
  },
  {
    "label": "ascii_isdigit()",
    "kind": "Method",
    "detail": "Function (const char* Curr = Start ; bool isDigitPart =)",
    "insertText": "ascii_isdigit(Curr[0])"
  },
  {
    "label": "ascii_isdigit()",
    "kind": "Method",
    "detail": "Function (bool isDigit =)",
    "insertText": "ascii_isdigit(Curr[I])"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Parts .)",
    "insertText": "push_back(std::make_pair(isDigitPart, StringRef(Start, Len)))"
  },
  {
    "label": "getPart()",
    "kind": "Method",
    "detail": "Function (} std::pair<bool,StringRef>)",
    "insertText": "getPart(size_t i)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i < Parts.size() && \"Invalid idx!\")"
  },
  {
    "label": "LHSParts()",
    "kind": "Method",
    "detail": "Function (RecordParts)",
    "insertText": "LHSParts(StringRef(Rec1->getName()))"
  },
  {
    "label": "RHSParts()",
    "kind": "Method",
    "detail": "Function (RecordParts)",
    "insertText": "RHSParts(StringRef(Rec2->getName()))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(LHSNumParts && RHSNumParts && \"Expected at least one part!\")"
  },
  {
    "label": "getPart()",
    "kind": "Method",
    "detail": "Function (std::pair<bool,StringRef> LHSPart = LHSParts .)",
    "insertText": "getPart(I)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(LHSPart.first == false && RHSPart.first == false && \"Expected both parts to be alpha.\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(size_t I = 1, E = LHSNumParts; I < E; I+=2)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(LHSPart.first == true && RHSPart.first == true && \"Expected both parts to be numeric.\")"
  },
  {
    "label": "getAsInteger()",
    "kind": "Method",
    "detail": "Function (unsigned LHSVal,RHSVal ; bool LHSFailed = LHSPart . second .)",
    "insertText": "getAsInteger(10, LHSVal)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!LHSFailed && \"Unable to convert LHS to integer.\")"
  },
  {
    "label": "getAsInteger()",
    "kind": "Method",
    "detail": "Function (bool RHSFailed = RHSPart . second .)",
    "insertText": "getAsInteger(10, RHSVal)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!RHSFailed && \"Unable to convert RHS to integer.\")"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return LHSNumParts<RHSNumParts ; } } ; raw_ostream&)",
    "insertText": "operator(raw_ostream &OS, const RecordKeeper &RK)"
  },
  {
    "label": "QualifyName()",
    "kind": "Method",
    "detail": "Function (Init*)",
    "insertText": "QualifyName(Record &CurRec, MultiClass *CurMultiClass, Init *Name, const std::string &Scoper)"
  },
  {
    "label": "QualifyName()",
    "kind": "Method",
    "detail": "Function (Init*)",
    "insertText": "QualifyName(Record &CurRec, MultiClass *CurMultiClass, const std::string &Name, const std::string &Scoper)"
  }
]