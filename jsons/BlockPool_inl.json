[
  {
    "label": "CBlockPool()",
    "kind": "Method",
    "detail": "Function (template<bool bUseCustomAllocator> ST_INLINE CBlockPool<bUseCustomAllocator)",
    "insertText": "CBlockPool(size_t uiBlockSize, size_t uiNum) : m_pData(NULL), m_pFreeLocations(NULL), m_uiSize(0), m_uiCurrent(0), m_uiBlockSize(uiBlockSize)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(uiNum)"
  },
  {
    "label": "CBlockPool()",
    "kind": "Method",
    "detail": "Function (} template<bool bUseCustomAllocator> ST_INLINE CBlockPool<bUseCustomAllocator>::~)",
    "insertText": "CBlockPool(void)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} template<bool bUseCustomAllocator> ST_INLINE void CBlockPool<bUseCustomAllocator)",
    "insertText": "clear(bool bForce)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (# ifndef SPEEDTREE_NO_ALLOCATORS bUseCustomAllocator ? st_delete_array<)",
    "insertText": "char(m_pData)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (# ifndef SPEEDTREE_NO_ALLOCATORS bUseCustomAllocator ? st_delete_array<)",
    "insertText": "size_t(m_pFreeLocations)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (m_pData = NULL ; m_pFreeLocations = NULL ; m_uiSize = 0 ; m_uiCurrent = 0 ; } template<bool bUseCustomAllocator> ST_INLINE size_t CBlockPool<bUseCustomAllocator)",
    "insertText": "size(void)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(uiSize > m_uiSize)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (char* pNewData = # ifndef SPEEDTREE_NO_ALLOCATORS bUseCustomAllocator ? st_new_array<)",
    "insertText": "char(uiSize * m_uiBlockSize + 4, \"CBlockPool\")"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (size_t* pNewFreeLocations = # ifndef SPEEDTREE_NO_ALLOCATORS bUseCustomAllocator ? st_new_array<)",
    "insertText": "size_t(uiSize, \"CBlockPool\")"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(pNewData, m_pData, m_uiSize * m_uiBlockSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(m_pFreeLocations != NULL)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(size_t i = m_uiSize; i < uiSize; ++i)"
  },
  {
    "label": "GrabBlock()",
    "kind": "Method",
    "detail": "Function (m_pData = pNewData ; m_pFreeLocations = pNewFreeLocations ; m_uiSize = uiSize ; } template<bool bUseCustomAllocator> ST_INLINE CBlockPool<bUseCustomAllocator>::CReference CBlockPool<bUseCustomAllocator)",
    "insertText": "GrabBlock(void)"
  },
  {
    "label": "ReleaseBlock()",
    "kind": "Method",
    "detail": "Function (} template<bool bUseCustomAllocator> ST_INLINE void CBlockPool<bUseCustomAllocator)",
    "insertText": "ReleaseBlock(CReference& cRef)"
  },
  {
    "label": "m_uiCurrent()",
    "kind": "Method",
    "detail": "Function (m_pFreeLocations [)",
    "insertText": "m_uiCurrent(size_t)"
  },
  {
    "label": "ResolveBlock()",
    "kind": "Method",
    "detail": "Function (cRef = NULL ; } template<bool bUseCustomAllocator> ST_INLINE void* CBlockPool<bUseCustomAllocator)",
    "insertText": "ResolveBlock(const CReference& cRef)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((size_t)cRef < (m_uiSize * m_uiBlockSize + 4))"
  }
]