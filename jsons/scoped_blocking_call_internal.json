[
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "OnlyObservedThreadsTag",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OnlyObservedThreadsTag"
  },
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "ScopedMonitoredCall",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScopedMonitoredCall"
  },
  {
    "label": "base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "base"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_THREADING_SCOPED_BLOCKING_CALL_INTERNAL_H_ # define BASE_THREADING_SCOPED_BLOCKING_CALL_INTERNAL_H_ # include \" base / base_export . h \" # include \" base / callback_forward . h \" # include \" base / debug / activity_tracker . h \" # include \" base / memory / raw_ptr . h \" # include \" base / memory / ref_counted . h \" # include \" base / synchronization / lock . h \" # include \" base / thread_annotations . h \" # include \" base / time / time . h \" # include \" base / types / strong_alias . h \" # include \" third_party / abseil - cpp / absl / types / optional . h \" namespace base { enum class BlockingType ; using IOJankReportingCallback = RepeatingCallback<)",
    "insertText": "void(int, int)"
  },
  {
    "label": "EnableIOJankMonitoringForProcess()",
    "kind": "Method",
    "detail": "Function (using OnlyObservedThreadsForTest = StrongAlias<class OnlyObservedThreadsTag,bool> ; void BASE_EXPORT)",
    "insertText": "EnableIOJankMonitoringForProcess(IOJankReportingCallback, OnlyObservedThreadsForTest)"
  },
  {
    "label": "BlockingObserver()",
    "kind": "Method",
    "detail": "Function (namespace internal { class BASE_EXPORT BlockingObserver { public : ~)",
    "insertText": "BlockingObserver()"
  },
  {
    "label": "BlockingStarted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BlockingStarted(BlockingType blocking_type)"
  },
  {
    "label": "BlockingTypeUpgraded()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BlockingTypeUpgraded()"
  },
  {
    "label": "BlockingEnded()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BlockingEnded()"
  },
  {
    "label": "SetBlockingObserverForCurrentThread()",
    "kind": "Method",
    "detail": "Function (} ; BASE_EXPORT void)",
    "insertText": "SetBlockingObserverForCurrentThread(BlockingObserver* blocking_observer)"
  },
  {
    "label": "ClearBlockingObserverForCurrentThread()",
    "kind": "Method",
    "detail": "Function (BASE_EXPORT void)",
    "insertText": "ClearBlockingObserverForCurrentThread()"
  },
  {
    "label": "IOJankMonitoringWindow()",
    "kind": "Method",
    "detail": "Function (class BASE_EXPORT IOJankMonitoringWindow : public RefCountedThreadSafe<IOJankMonitoringWindow> { public :)",
    "insertText": "IOJankMonitoringWindow(TimeTicks start_time)"
  },
  {
    "label": "IOJankMonitoringWindow()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IOJankMonitoringWindow(const IOJankMonitoringWindow&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IOJankMonitoringWindow&)",
    "insertText": "operator(const IOJankMonitoringWindow&)"
  },
  {
    "label": "CancelMonitoringForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CancelMonitoringForTesting()"
  },
  {
    "label": "ScopedMonitoredCall()",
    "kind": "Method",
    "detail": "Function (class ScopedMonitoredCall { public :)",
    "insertText": "ScopedMonitoredCall()"
  },
  {
    "label": "ScopedMonitoredCall()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ScopedMonitoredCall(const ScopedMonitoredCall&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ScopedMonitoredCall&)",
    "insertText": "operator(const ScopedMonitoredCall&)"
  },
  {
    "label": "Cancel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Cancel()"
  },
  {
    "label": "Seconds()",
    "kind": "Method",
    "detail": "Function (private : TimeTicks call_start_ ; scoped_refptr<IOJankMonitoringWindow> assigned_jank_window_ ; } ; TimeDelta kIOJankInterval =)",
    "insertText": "Seconds(1)"
  },
  {
    "label": "Minutes()",
    "kind": "Method",
    "detail": "Function (TimeDelta kMonitoringWindow =)",
    "insertText": "Minutes(1)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (TimeDelta kTimeDiscrepancyTimeout = kIOJankInterval* 1 0 ; int kNumIntervals = kMonitoringWindow / kIOJankInterval ;)",
    "insertText": "static_assert((kMonitoringWindow % kIOJankInterval).is_zero(), \"\")"
  },
  {
    "label": "MonitorNextJankWindowIfNecessary()",
    "kind": "Method",
    "detail": "Function (scoped_refptr<IOJankMonitoringWindow>)",
    "insertText": "MonitorNextJankWindowIfNecessary(TimeTicks recent_now)"
  },
  {
    "label": "IOJankMonitoringWindow()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "IOJankMonitoringWindow()"
  },
  {
    "label": "OnBlockingCallCompleted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnBlockingCallCompleted(TimeTicks call_start, TimeTicks call_end)"
  },
  {
    "label": "AddJank()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddJank(int local_jank_start_index, int num_janky_intervals)"
  },
  {
    "label": "current_jank_window_lock()",
    "kind": "Method",
    "detail": "Function (Lock&)",
    "insertText": "current_jank_window_lock()"
  },
  {
    "label": "current_jank_window_storage()",
    "kind": "Method",
    "detail": "Function (scoped_refptr<IOJankMonitoringWindow>&)",
    "insertText": "current_jank_window_storage() EXCLUSIVE_LOCKS_REQUIRED(current_jank_window_lock())"
  },
  {
    "label": "reporting_callback_storage()",
    "kind": "Method",
    "detail": "Function (IOJankReportingCallback&)",
    "insertText": "reporting_callback_storage() EXCLUSIVE_LOCKS_REQUIRED(current_jank_window_lock())"
  },
  {
    "label": "GUARDED_BY()",
    "kind": "Method",
    "detail": "Function (Lock intervals_lock_ ; size_t intervals_jank_count_ [ kNumIntervals ])",
    "insertText": "GUARDED_BY(intervals_lock_)"
  },
  {
    "label": "UncheckedScopedBlockingCall()",
    "kind": "Method",
    "detail": "Function (} ; const TimeTicks start_time_ ; scoped_refptr<IOJankMonitoringWindow> next_ ; bool canceled_ = false ; } ; class BASE_EXPORT UncheckedScopedBlockingCall { public : enum class BlockingCallType { kRegular,kBaseSyncPrimitives,} ;)",
    "insertText": "UncheckedScopedBlockingCall(const Location& from_here, BlockingType blocking_type, BlockingCallType blocking_call_type)"
  },
  {
    "label": "UncheckedScopedBlockingCall()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UncheckedScopedBlockingCall(const UncheckedScopedBlockingCall&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (UncheckedScopedBlockingCall&)",
    "insertText": "operator(const UncheckedScopedBlockingCall&)"
  },
  {
    "label": "UncheckedScopedBlockingCall()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "UncheckedScopedBlockingCall()"
  }
]