[
  {
    "label": "S16ToFloat()",
    "kind": "Method",
    "detail": "Function (# ifndef COMMON_AUDIO_INCLUDE_AUDIO_UTIL_H_ # define COMMON_AUDIO_INCLUDE_AUDIO_UTIL_H_ # include<stdint . h> # include<algorithm> # include<cmath> # include<cstring> # include<limits> # include \" rtc_base / checks . h \" namespace webrtc { typedef std::numeric_limits<int16_t> limits_int16 ; float)",
    "insertText": "S16ToFloat(int16_t v)"
  },
  {
    "label": "FloatS16ToS16()",
    "kind": "Method",
    "detail": "Function (float kScaling = 1 . f / 3 2 7 6 8 . f ; return v* kScaling ; } int16_t)",
    "insertText": "FloatS16ToS16(float v)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (v =)",
    "insertText": "min(v, 32767.f)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (v =)",
    "insertText": "max(v, -32768.f)"
  },
  {
    "label": "FloatToS16()",
    "kind": "Method",
    "detail": "Function (} int16_t)",
    "insertText": "FloatToS16(float v)"
  },
  {
    "label": "FloatToFloatS16()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "FloatToFloatS16(float v)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (v =)",
    "insertText": "min(v, 1.f)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (v =)",
    "insertText": "max(v, -1.f)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (v =)",
    "insertText": "min(v, 32768.f)"
  },
  {
    "label": "FloatToS16()",
    "kind": "Method",
    "detail": "Function (float kScaling = 1 . f / 3 2 7 6 8 . f ; return v* kScaling ; } void)",
    "insertText": "FloatToS16(const float* src, size_t size, int16_t* dest)"
  },
  {
    "label": "S16ToFloat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "S16ToFloat(const int16_t* src, size_t size, float* dest)"
  },
  {
    "label": "S16ToFloatS16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "S16ToFloatS16(const int16_t* src, size_t size, float* dest)"
  },
  {
    "label": "FloatS16ToS16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FloatS16ToS16(const float* src, size_t size, int16_t* dest)"
  },
  {
    "label": "FloatToFloatS16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FloatToFloatS16(const float* src, size_t size, float* dest)"
  },
  {
    "label": "FloatS16ToFloat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FloatS16ToFloat(const float* src, size_t size, float* dest)"
  },
  {
    "label": "DbToRatio()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "DbToRatio(float v)"
  },
  {
    "label": "DbfsToFloatS16()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "DbfsToFloatS16(float v)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (float kMaximumAbsFloatS16 = -)",
    "insertText": "min()"
  },
  {
    "label": "FloatS16ToDbfs()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "FloatS16ToDbfs(float v)"
  },
  {
    "label": "RTC_DCHECK_GE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_GE(v, 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (float kMinDbfs = - 9 0 . 3 0 8 9 9 8 6 9 9 1 9 4 3 6 f ;)",
    "insertText": "if(v <= 1.0f)"
  },
  {
    "label": "CopyAudioIfNeeded()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "CopyAudioIfNeeded(const T* const* src, int num_frames, int num_channels, T* const* dest)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copy(src[i], src[i] + num_frames, dest[i])"
  },
  {
    "label": "Deinterleave()",
    "kind": "Method",
    "detail": "Function (} } } template<T> void)",
    "insertText": "Deinterleave(const T* interleaved, size_t samples_per_channel, size_t num_channels, T* const* deinterleaved)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (T* channel = deinterleaved [ i ] ; size_t interleaved_idx = i ;)",
    "insertText": "for(size_t j = 0; j < samples_per_channel; ++j)"
  },
  {
    "label": "Interleave()",
    "kind": "Method",
    "detail": "Function (channel [ j ] = interleaved [ interleaved_idx ] ; interleaved_idx + = num_channels ; } } } template<T> void)",
    "insertText": "Interleave(const T* const* deinterleaved, size_t samples_per_channel, size_t num_channels, T* interleaved)"
  },
  {
    "label": "UpmixMonoToInterleaved()",
    "kind": "Method",
    "detail": "Function (interleaved [ interleaved_idx ] = channel [ j ] ; interleaved_idx + = num_channels ; } } } template<T> void)",
    "insertText": "UpmixMonoToInterleaved(const T* mono, int num_frames, int num_channels, T* interleaved)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int interleaved_idx = 0 ;)",
    "insertText": "for(int i = 0; i < num_frames; ++i)"
  },
  {
    "label": "DownmixToMono()",
    "kind": "Method",
    "detail": "Function (interleaved [ interleaved_idx + + ] = mono [ i ] ; } } } template<T,Intermediate> void)",
    "insertText": "DownmixToMono(const T* const* input_channels, size_t num_frames, int num_channels, T* out)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Intermediate value = input_channels [ 0 ] [ i ] ;)",
    "insertText": "for(int j = 1; j < num_channels; ++j)"
  },
  {
    "label": "DownmixInterleavedToMonoImpl()",
    "kind": "Method",
    "detail": "Function (value + = input_channels [ j ] [ i ] ; } out [ i ] = value / num_channels ; } } template<T,Intermediate> void)",
    "insertText": "DownmixInterleavedToMonoImpl(const T* interleaved, size_t num_frames, int num_channels, T* deinterleaved)"
  },
  {
    "label": "RTC_DCHECK_GT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_GT(num_channels, 0)"
  },
  {
    "label": "RTC_DCHECK_GT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_GT(num_frames, 0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const T* const end = interleaved + num_frames* num_channels ;)",
    "insertText": "while(interleaved < end)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const T* const frame_end = interleaved + num_channels ; Intermediate value =* interleaved + + ;)",
    "insertText": "while(interleaved < frame_end)"
  },
  {
    "label": "DownmixInterleavedToMono()",
    "kind": "Method",
    "detail": "Function (value + =* interleaved + + ; }* deinterleaved + + = value / num_channels ; } } template<T> void)",
    "insertText": "DownmixInterleavedToMono(const T* interleaved, size_t num_frames, int num_channels, T* deinterleaved)"
  },
  {
    "label": "int16_t()",
    "kind": "Method",
    "detail": "Function (template<> void DownmixInterleavedToMono<)",
    "insertText": "int16_t(const int16_t* interleaved, size_t num_frames, int num_channels, int16_t* deinterleaved)"
  }
]