[
  {
    "label": "FRenderTransform",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRenderTransform"
  },
  {
    "label": "FRenderBounds",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRenderBounds"
  },
  {
    "label": "FCompressedTransform",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCompressedTransform"
  },
  {
    "label": "FRenderTransform()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Math / Box . h \" # include \" Math / BoxSphereBounds . h \" # include \" Math / Float32 . h \" # include \" Math / Matrix . h \" # include \" Math / NumericLimits . h \" # include \" Math / UnrealMathSSE . h \" # include \" Math / Vector . h \" # include \" Math / Vector2D . h \" # include \" Math / VectorRegister . h \" # include \" Serialization / Archive . h \" # include \" Serialization / MemoryLayout . h \" # include \" Serialization / StructuredArchiveAdapters . h \" struct FRenderTransform { FVector3f TransformRows [ 3 ] ; FVector3f Origin ; public :)",
    "insertText": "FRenderTransform()"
  },
  {
    "label": "FRenderTransform()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRenderTransform(FRenderTransform&&)"
  },
  {
    "label": "FRenderTransform()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRenderTransform(const FRenderTransform&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FRenderTransform&)",
    "insertText": "operator(FRenderTransform&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FRenderTransform&)",
    "insertText": "operator(const FRenderTransform&)"
  },
  {
    "label": "FRenderTransform()",
    "kind": "Method",
    "detail": "Function (TransformRows [ 0 ] = InXAxis ; TransformRows [ 1 ] = InYAxis ; TransformRows [ 2 ] = InZAxis ; Origin = InOrigin ; })",
    "insertText": "FRenderTransform(const FMatrix44f& M)"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (TransformRows [ 0 ] =)",
    "insertText": "FVector3f(M.M[0][0], M.M[0][1], M.M[0][2])"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (TransformRows [ 1 ] =)",
    "insertText": "FVector3f(M.M[1][0], M.M[1][1], M.M[1][2])"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (TransformRows [ 2 ] =)",
    "insertText": "FVector3f(M.M[2][0], M.M[2][1], M.M[2][2])"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (Origin =)",
    "insertText": "FVector3f(M.M[3][0], M.M[3][1], M.M[3][2])"
  },
  {
    "label": "FRenderTransform()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FRenderTransform(const FMatrix44d& M)"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (TransformRows [ 0 ] =)",
    "insertText": "FVector3f((float)M.M[0][0], (float)M.M[0][1], (float)M.M[0][2])"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (TransformRows [ 1 ] =)",
    "insertText": "FVector3f((float)M.M[1][0], (float)M.M[1][1], (float)M.M[1][2])"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (TransformRows [ 2 ] =)",
    "insertText": "FVector3f((float)M.M[2][0], (float)M.M[2][1], (float)M.M[2][2])"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (Origin =)",
    "insertText": "FVector3f((float)M.M[3][0], (float)M.M[3][1], (float)M.M[3][2])"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FRenderTransform&)",
    "insertText": "operator(const FMatrix44f& From)"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (TransformRows [ 0 ] =)",
    "insertText": "FVector3f(From.M[0][0], From.M[0][1], From.M[0][2])"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (TransformRows [ 1 ] =)",
    "insertText": "FVector3f(From.M[1][0], From.M[1][1], From.M[1][2])"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (TransformRows [ 2 ] =)",
    "insertText": "FVector3f(From.M[2][0], From.M[2][1], From.M[2][2])"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (Origin =)",
    "insertText": "FVector3f(From.M[3][0], From.M[3][1], From.M[3][2])"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (TransformRows [ 0 ] =)",
    "insertText": "FVector3f((float)From.M[0][0], (float)From.M[0][1], (float)From.M[0][2])"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (TransformRows [ 1 ] =)",
    "insertText": "FVector3f((float)From.M[1][0], (float)From.M[1][1], (float)From.M[1][2])"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (TransformRows [ 2 ] =)",
    "insertText": "FVector3f((float)From.M[2][0], (float)From.M[2][1], (float)From.M[2][2])"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (Origin =)",
    "insertText": "FVector3f((float)From.M[3][0], (float)From.M[3][1], (float)From.M[3][2])"
  },
  {
    "label": "ToMatrix44f()",
    "kind": "Method",
    "detail": "Function (} FMatrix44f)",
    "insertText": "ToMatrix44f()"
  },
  {
    "label": "VectorSet_W0()",
    "kind": "Method",
    "detail": "Function (FMatrix44f Matrix ; # if PLATFORM_ENABLE_VECTORINTRINSICS VectorRegister4Float Row0 =)",
    "insertText": "VectorSet_W0(VectorLoad(&TransformRows[0].X))"
  },
  {
    "label": "VectorSet_W0()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Row1 =)",
    "insertText": "VectorSet_W0(VectorLoad(&TransformRows[1].X))"
  },
  {
    "label": "VectorSet_W0()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Row2 =)",
    "insertText": "VectorSet_W0(VectorLoad(&TransformRows[2].X))"
  },
  {
    "label": "MakeVectorRegisterFloat()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Row3 =)",
    "insertText": "MakeVectorRegisterFloat(Origin.X, Origin.Y, Origin.Z, 1.0f)"
  },
  {
    "label": "VectorStore()",
    "kind": "Method",
    "detail": "Function (float* RESTRICT Dest =& Matrix . M [ 0 ] [ 0 ] ;)",
    "insertText": "VectorStore(Row0, &Dest[0])"
  },
  {
    "label": "VectorStore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStore(Row1, &Dest[4])"
  },
  {
    "label": "VectorStore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStore(Row2, &Dest[8])"
  },
  {
    "label": "VectorStore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStore(Row3, &Dest[12])"
  },
  {
    "label": "ToMatrix()",
    "kind": "Method",
    "detail": "Function (# else Matrix . M [ 0 ] [ 0 ] = TransformRows [ 0 ] . X ; Matrix . M [ 0 ] [ 1 ] = TransformRows [ 0 ] . Y ; Matrix . M [ 0 ] [ 2 ] = TransformRows [ 0 ] . Z ; Matrix . M [ 0 ] [ 3 ] = 0 . 0 f ; Matrix . M [ 1 ] [ 0 ] = TransformRows [ 1 ] . X ; Matrix . M [ 1 ] [ 1 ] = TransformRows [ 1 ] . Y ; Matrix . M [ 1 ] [ 2 ] = TransformRows [ 1 ] . Z ; Matrix . M [ 1 ] [ 3 ] = 0 . 0 f ; Matrix . M [ 2 ] [ 0 ] = TransformRows [ 2 ] . X ; Matrix . M [ 2 ] [ 1 ] = TransformRows [ 2 ] . Y ; Matrix . M [ 2 ] [ 2 ] = TransformRows [ 2 ] . Z ; Matrix . M [ 2 ] [ 3 ] = 0 . 0 f ; Matrix . M [ 3 ] [ 0 ] = Origin . X ; Matrix . M [ 3 ] [ 1 ] = Origin . Y ; Matrix . M [ 3 ] [ 2 ] = Origin . Z ; Matrix . M [ 3 ] [ 3 ] = 1 . 0 f ; # endif return Matrix ; } FMatrix)",
    "insertText": "ToMatrix()"
  },
  {
    "label": "To3x4MatrixTranspose()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "To3x4MatrixTranspose(float* Result)"
  },
  {
    "label": "VectorLoad()",
    "kind": "Method",
    "detail": "Function (float* RESTRICT Dest = Result ; # if PLATFORM_ENABLE_VECTORINTRINSICS VectorRegister4Float InRow0 =)",
    "insertText": "VectorLoad(&TransformRows[0].X)"
  },
  {
    "label": "VectorLoad()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float InRow1 =)",
    "insertText": "VectorLoad(&TransformRows[1].X)"
  },
  {
    "label": "VectorLoad()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float InRow2 =)",
    "insertText": "VectorLoad(&TransformRows[2].X)"
  },
  {
    "label": "MakeVectorRegisterFloat()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float InRow3 =)",
    "insertText": "MakeVectorRegisterFloat(Origin.X, Origin.Y, Origin.Z, 0.0f)"
  },
  {
    "label": "VectorCombineLow()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Temp0 =)",
    "insertText": "VectorCombineLow(InRow0, InRow1)"
  },
  {
    "label": "VectorCombineLow()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Temp1 =)",
    "insertText": "VectorCombineLow(InRow2, InRow3)"
  },
  {
    "label": "VectorCombineHigh()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Temp2 =)",
    "insertText": "VectorCombineHigh(InRow0, InRow1)"
  },
  {
    "label": "VectorCombineHigh()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Temp3 =)",
    "insertText": "VectorCombineHigh(InRow2, InRow3)"
  },
  {
    "label": "VectorDeinterleave()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Row0,Row1,Row2,Row3 ;)",
    "insertText": "VectorDeinterleave(Row0, Row1, Temp0, Temp1)"
  },
  {
    "label": "VectorDeinterleave()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorDeinterleave(Row2, Row3, Temp2, Temp3)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# else Dest [ 0 ] = TransformRows [ 0 ] . X ; Dest [ 1 ] = TransformRows [ 1 ] . X ; Dest [ 2 ] = TransformRows [ 2 ] . X ; Dest [ 3 ] = Origin . X ; Dest [ 4 ] = TransformRows [ 0 ] . Y ; Dest [ 5 ] = TransformRows [ 1 ] . Y ; Dest [ 6 ] = TransformRows [ 2 ] . Y ; Dest [ 7 ] = Origin . Y ; Dest [ 8 ] = TransformRows [ 0 ] . Z ; Dest [ 9 ] = TransformRows [ 1 ] . Z ; Dest [ 1 0 ] = TransformRows [ 2 ] . Z ; Dest [ 1 1 ] = Origin . Z ; # endif } FRenderTransform)",
    "insertText": "operator(const FRenderTransform& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FRenderTransform)",
    "insertText": "operator(const FMatrix44f& Other)"
  },
  {
    "label": "RotDeterminant()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "RotDeterminant()"
  },
  {
    "label": "Inverse()",
    "kind": "Method",
    "detail": "Function (} FRenderTransform)",
    "insertText": "Inverse()"
  },
  {
    "label": "InverseFast()",
    "kind": "Method",
    "detail": "Function (} FRenderTransform)",
    "insertText": "InverseFast()"
  },
  {
    "label": "GetScale()",
    "kind": "Method",
    "detail": "Function (} FVector3f)",
    "insertText": "GetScale()"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (FVector3f Scale ; Scale . X = TransformRows [ 0 ] .)",
    "insertText": "Size()"
  },
  {
    "label": "Orthogonalize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Orthogonalize()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FVector3f X = TransformRows [ 0 ] ; FVector3f Y = TransformRows [ 1 ] ; FVector3f Z = TransformRows [ 2 ] ;)",
    "insertText": "if(X.IsZero() || Y.IsZero())"
  },
  {
    "label": "Z()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Z(Z | X) / (X | X)"
  },
  {
    "label": "Z()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Z(Z | Y) / (Y | Y)"
  },
  {
    "label": "SetIdentity()",
    "kind": "Method",
    "detail": "Function (TransformRows [ 0 ] = X ; TransformRows [ 1 ] = Y ; TransformRows [ 2 ] = Z ; } void)",
    "insertText": "SetIdentity()"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (TransformRows [ 0 ] =)",
    "insertText": "FVector3f(1.0f, 0.0f, 0.0f)"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (TransformRows [ 1 ] =)",
    "insertText": "FVector3f(0.0f, 1.0f, 0.0f)"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (TransformRows [ 2 ] =)",
    "insertText": "FVector3f(0.0f, 0.0f, 1.0f)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Origin = FVector3f::ZeroVector ; } FArchive&)",
    "insertText": "operator(FArchive& Ar, FRenderTransform& T)"
  },
  {
    "label": "FRenderBounds()",
    "kind": "Method",
    "detail": "Function (Ar<<T . TransformRows [ 0 ] . X<<T . TransformRows [ 0 ] . Y<<T . TransformRows [ 0 ] . Z ; Ar<<T . TransformRows [ 1 ] . X<<T . TransformRows [ 1 ] . Y<<T . TransformRows [ 1 ] . Z ; Ar<<T . TransformRows [ 2 ] . X<<T . TransformRows [ 2 ] . Y<<T . TransformRows [ 2 ] . Z ; Ar<<T . Origin . X<<T . Origin . Y<<T . Origin . Z ; return Ar ; } FRenderTransform Identity ; } ; struct FRenderBounds { FVector3f Min ; FVector3f Max ; public :)",
    "insertText": "FRenderBounds() : Min( MAX_flt, MAX_flt, MAX_flt) , Max(-MAX_flt, -MAX_flt, -MAX_flt)"
  },
  {
    "label": "FRenderBounds()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FRenderBounds(const FVector3f& InMin, const FVector3f& InMax) : Min(InMin) , Max(InMax)"
  },
  {
    "label": "FRenderBounds()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FRenderBounds(const FBox& Box)"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (Min =)",
    "insertText": "FVector3f(Box.Min)"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (Max =)",
    "insertText": "FVector3f(Box.Max)"
  },
  {
    "label": "FRenderBounds()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FRenderBounds(const FBoxSphereBounds& Bounds)"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (Min =)",
    "insertText": "FVector3f(Bounds.Origin - Bounds.BoxExtent)"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (Max =)",
    "insertText": "FVector3f(Bounds.Origin + Bounds.BoxExtent)"
  },
  {
    "label": "ToBox()",
    "kind": "Method",
    "detail": "Function (} FBox)",
    "insertText": "ToBox()"
  },
  {
    "label": "ToBoxSphereBounds()",
    "kind": "Method",
    "detail": "Function (} FBoxSphereBounds)",
    "insertText": "ToBoxSphereBounds()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FRenderBounds&)",
    "insertText": "operator(const FVector3f& Other)"
  },
  {
    "label": "VectorLoadFloat3()",
    "kind": "Method",
    "detail": "Function (const VectorRegister VecOther =)",
    "insertText": "VectorLoadFloat3(&Other.X)"
  },
  {
    "label": "VectorStoreFloat3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreFloat3(VectorMin(VectorLoadFloat3(&Min.X), VecOther), &Min)"
  },
  {
    "label": "VectorStoreFloat3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreFloat3(VectorMax(VectorLoadFloat3(&Max.X), VecOther), &Max)"
  },
  {
    "label": "VectorStoreFloat3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreFloat3(VectorMin(VectorLoadFloat3(&Min), VectorLoadFloat3(&Other.Min)), &Min)"
  },
  {
    "label": "VectorStoreFloat3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreFloat3(VectorMax(VectorLoadFloat3(&Max), VectorLoadFloat3(&Other.Max)), &Max)"
  },
  {
    "label": "Equals()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Equals(const FRenderBounds& Other, float Tolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "GetMin()",
    "kind": "Method",
    "detail": "Function (} const FVector3f&)",
    "insertText": "GetMin()"
  },
  {
    "label": "GetExtent()",
    "kind": "Method",
    "detail": "Function (} FVector3f)",
    "insertText": "GetExtent()"
  },
  {
    "label": "GetSurfaceArea()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GetSurfaceArea()"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (FVector3f Size = Max - Min ; return 0 . 5)",
    "insertText": "f(Size.X * Size.Y + Size.X * Size.Z + Size.Y * Size.Z)"
  },
  {
    "label": "TransformBy()",
    "kind": "Method",
    "detail": "Function (} FRenderBounds)",
    "insertText": "TransformBy(const FMatrix44f& M)"
  },
  {
    "label": "TransformBy()",
    "kind": "Method",
    "detail": "Function (FRenderBounds)",
    "insertText": "TransformBy(const FMatrix44d& M)"
  },
  {
    "label": "TransformBy()",
    "kind": "Method",
    "detail": "Function (FRenderBounds)",
    "insertText": "TransformBy(const FRenderTransform& T)"
  },
  {
    "label": "AxisDistances()",
    "kind": "Method",
    "detail": "Function (FVector3f)",
    "insertText": "AxisDistances(Point - GetCenter()).GetAbs() - GetExtent()"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (AxisDistances =)",
    "insertText": "Max(AxisDistances, FVector3f(0.0f, 0.0f, 0.0f))"
  },
  {
    "label": "GetHemiOrthoBasis()",
    "kind": "Method",
    "detail": "Function (Ar<<B . Min ; Ar<<B . Max ; return Ar ; } } ; void)",
    "insertText": "GetHemiOrthoBasis(FVector3f& BasisX, FVector3f& BasisY, const FVector3f& BasisZ)"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (float A = 1 . 0)",
    "insertText": "f(1.0f + BasisZ.Z)"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (float B = - BasisZ . X* BasisZ . Y* A ; BasisX =)",
    "insertText": "FVector3f(1.0f - BasisZ.X * BasisZ.X * A, B, -BasisZ.X)"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (BasisY =)",
    "insertText": "FVector3f(B, 1.0f - BasisZ.Y * BasisZ.Y * A, -BasisZ.Y)"
  },
  {
    "label": "UnitVectorToHemiOctahedron()",
    "kind": "Method",
    "detail": "Function (} FVector2f)",
    "insertText": "UnitVectorToHemiOctahedron(const FVector3f& N)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (float Sum =)",
    "insertText": "Abs(N.X ) + FMath::Abs( N.Y ) + FMath::Abs( N.Z)"
  },
  {
    "label": "HemiOctahedronToUnitVector()",
    "kind": "Method",
    "detail": "Function (} FVector3f)",
    "insertText": "HemiOctahedronToUnitVector(const FVector2f& Oct)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (FVector3f N ; N . X = Oct . X + Oct . Y ; N . Y = Oct . X - Oct . Y ; N . Z = 2 . 0 f -)",
    "insertText": "Abs(N.X ) - FMath::Abs( N.Y)"
  },
  {
    "label": "ExpBias()",
    "kind": "Method",
    "detail": "Function (} struct FCompressedTransform { uint32 ExpBits = 8 ; uint32)",
    "insertText": "ExpBias(1 << (ExpBits - 1))"
  },
  {
    "label": "SignMantissaMask()",
    "kind": "Method",
    "detail": "Function (uint32 SignMantissaBits = 1 6 ; uint32)",
    "insertText": "SignMantissaMask(1 << SignMantissaBits)"
  },
  {
    "label": "FCompressedTransform()",
    "kind": "Method",
    "detail": "Function (uint32 MantissaBits = SignMantissaBits - 1 ; FVector3f Translation ; uint16 Rotation [ 4 ] ; uint16 Scale_SharedExp [ 4 ] ;)",
    "insertText": "FCompressedTransform()"
  },
  {
    "label": "FCompressedTransform()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FCompressedTransform(const FRenderTransform& In)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Translation = In . Origin ; FVector3f Scale ; FVector3f Axis [ 3 ] ;)",
    "insertText": "for(int i = 0; i < 3; i++)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (Axis [)",
    "insertText": "i(Scale[i] != 0.f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} {)",
    "insertText": "if(Axis[2].Z < 0.0f)"
  },
  {
    "label": "UnitVectorToHemiOctahedron()",
    "kind": "Method",
    "detail": "Function (Axis [ 2 ]* = - 1 . 0 f ; Scale [ 2 ]* = - 1 . 0 f ; } FVector2f OctZ =)",
    "insertText": "UnitVectorToHemiOctahedron(Axis[2])"
  },
  {
    "label": "GetHemiOrthoBasis()",
    "kind": "Method",
    "detail": "Function (FVector3f BasisX,BasisY ;)",
    "insertText": "GetHemiOrthoBasis(BasisX, BasisY, Axis[2])"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (float X = Axis [ 0 ] | BasisX ; float Y = Axis [ 0 ] | BasisY ; float aX =)",
    "insertText": "Abs(X)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (float aY =)",
    "insertText": "Abs(Y)"
  },
  {
    "label": "Scale()",
    "kind": "Method",
    "detail": "Function (bool bSpinIsX = aX<aY ; float Spin0 = bSpinIsX ? X : Y ; float Spin1 = bSpinIsX ? Y : X ; float Sign1 = Spin1<0 . 0 f ? - 1 . 0 f : 1 . 0 f ; Scale [ 0 ]* = Sign1 ; Spin0* = Sign1 ; FVector3f GeneratedY = Axis [ 2 ] ^ Axis [ 0 ] ;)",
    "insertText": "Scale(Axis[1] | GeneratedY)"
  },
  {
    "label": "uint16()",
    "kind": "Method",
    "detail": "Function (# if 1 Rotation [ 0 ] = static_cast<)",
    "insertText": "uint16(FMath::RoundToInt( OctZ.X * 32767.0f ) + 32768)"
  },
  {
    "label": "uint16()",
    "kind": "Method",
    "detail": "Function (Rotation [ 1 ] = static_cast<)",
    "insertText": "uint16(FMath::RoundToInt( OctZ.Y * 32767.0f ) + 32768)"
  },
  {
    "label": "uint16()",
    "kind": "Method",
    "detail": "Function (Rotation [ 2 ] = static_cast<)",
    "insertText": "uint16(FMath::RoundToInt( Spin0 * 16383.0f * 1.41421356f ))"
  },
  {
    "label": "Rotation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Rotation(Rotation[2] + 16384)"
  },
  {
    "label": "bSpinIsX()",
    "kind": "Method",
    "detail": "Function (Rotation [ 2 ] | =)",
    "insertText": "bSpinIsX(1 << 15)"
  },
  {
    "label": "Rotation()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "Rotation(FMath::RoundToInt( OctZ.X * 32767.0f ) + 32768)"
  },
  {
    "label": "Rotation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Rotation(FMath::RoundToInt( OctZ.Y * 32767.0f ) + 32768)"
  },
  {
    "label": "RoundToInt()",
    "kind": "Method",
    "detail": "Function (Rotation [ 1 ] =)",
    "insertText": "RoundToInt(Spin0 * 16383.0f * 1.41421356f)"
  },
  {
    "label": "Rotation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Rotation(Rotation[1] + 16384)"
  },
  {
    "label": "GetAbsMax()",
    "kind": "Method",
    "detail": "Function (# endif } { FFloat32 MaxComponent = Scale .)",
    "insertText": "GetAbsMax()"
  },
  {
    "label": "SharedExp()",
    "kind": "Method",
    "detail": "Function (uint16)",
    "insertText": "SharedExp(uint16)"
  },
  {
    "label": "ExpScale()",
    "kind": "Method",
    "detail": "Function (FFloat32)",
    "insertText": "ExpScale(1.0f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ExpScale . Components . Exponent = 1 2 7 + ExpBias + MantissaBits - SharedExp ;)",
    "insertText": "if(FMath::RoundToInt( MaxComponent.FloatValue * ExpScale.FloatValue ) == (1 << MantissaBits))"
  },
  {
    "label": "Scale_SharedExp()",
    "kind": "Method",
    "detail": "Function (SharedExp + + ; ExpScale . FloatValue* = 0 . 5 f ; } # if 0)",
    "insertText": "Scale_SharedExp(uint64)SharedExp << ( SignMantissaBits * 3)"
  },
  {
    "label": "RoundToInt()",
    "kind": "Method",
    "detail": "Function (uint32 Mantissa =)",
    "insertText": "RoundToInt(Scale[i] * ExpScale.FloatValue ) + (1 << MantissaBits)"
  },
  {
    "label": "Scale_SharedExp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Scale_SharedExp(uint64)Mantissa << ( SignMantissaBits * i)"
  },
  {
    "label": "uint16()",
    "kind": "Method",
    "detail": "Function (Scale_SharedExp [ i ] = static_cast<)",
    "insertText": "uint16(FMath::RoundToInt( Scale[i] * ExpScale.FloatValue ) + (1 << MantissaBits))"
  },
  {
    "label": "ToRenderTransform()",
    "kind": "Method",
    "detail": "Function (} # endif } } FRenderTransform)",
    "insertText": "ToRenderTransform()"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (FRenderTransform Out ; Out . Origin = Translation ; { FVector2f OctZ ; float Spin0 ; OctZ . X =)",
    "insertText": "float((int32)Rotation[0] - 32768 ) * (1.0f / 32767.0f)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (OctZ . Y =)",
    "insertText": "float((int32)Rotation[1] - 32768 ) * (1.0f / 32767.0f)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (Spin0 =)",
    "insertText": "float((int32)( Rotation[2] & 0x7fff ) - 16384 ) * (0.70710678f / 16383.0f)"
  },
  {
    "label": "HemiOctahedronToUnitVector()",
    "kind": "Method",
    "detail": "Function (bool bSpinIsX = Rotation [ 2 ]> 0 x7fff ; Out . TransformRows [ 2 ] =)",
    "insertText": "HemiOctahedronToUnitVector(OctZ)"
  },
  {
    "label": "GetHemiOrthoBasis()",
    "kind": "Method",
    "detail": "Function (FVector3f BasisX,BasisY ;)",
    "insertText": "GetHemiOrthoBasis(BasisX, BasisY, Out.TransformRows[2])"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (float Spin1 =)",
    "insertText": "Sqrt(1.0f - Spin0 * Spin0)"
  },
  {
    "label": "Mantissa()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Mantissa(Scale_SharedExp >> ( SignMantissaBits * i ))"
  },
  {
    "label": "Mantissa()",
    "kind": "Method",
    "detail": "Function (float Scale =)",
    "insertText": "Mantissa(1 << MantissaBits)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (float Scale = static_cast<)",
    "insertText": "float(int32(Scale_SharedExp[i]) - (1 << MantissaBits))"
  }
]