[
  {
    "label": "FAnimSingleNodeInstanceProxy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimSingleNodeInstanceProxy"
  },
  {
    "label": "UMirrorDataTable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UMirrorDataTable"
  },
  {
    "label": "FAnimNode_SingleNode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimNode_SingleNode"
  },
  {
    "label": "UBlendSpace",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UBlendSpace"
  },
  {
    "label": "USTRUCT()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" UObject / ObjectMacros . h \" # include \" Animation / AnimTypes . h \" # include \" Animation / AnimationAsset . h \" # include \" Animation / AnimInstanceProxy . h \" # include \" Animation / AnimNodeBase . h \" # include \" AnimSingleNodeInstanceProxy . generated . h \" struct FAnimSingleNodeInstanceProxy ; class UMirrorDataTable ;)",
    "insertText": "USTRUCT(BlueprintInternalUseOnly)"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (struct FAnimSingleNodeInstanceProxy ;)",
    "insertText": "GENERATED_BODY() UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Links)"
  },
  {
    "label": "Evaluate_AnyThread()",
    "kind": "Method",
    "detail": "Function (FName ActiveMontageSlot ; void)",
    "insertText": "Evaluate_AnyThread(FPoseContext& Output)"
  },
  {
    "label": "Update_AnyThread()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Update_AnyThread(const FAnimationUpdateContext& Context)"
  },
  {
    "label": "USTRUCT()",
    "kind": "Method",
    "detail": "Function (private : FAnimSingleNodeInstanceProxy* Proxy ; } ;)",
    "insertText": "USTRUCT()"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (struct FAnimNode_SingleNode ;)",
    "insertText": "GENERATED_BODY() public: FAnimSingleNodeInstanceProxy()"
  },
  {
    "label": "FAnimSingleNodeInstanceProxy()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR bCanProcessAdditiveAnimations = false ; bIgnoreRootLock = false ; bIgnoreRootMotion = false ; # endif })",
    "insertText": "FAnimSingleNodeInstanceProxy(UAnimInstance* InAnimInstance) : FAnimInstanceProxy(InAnimInstance) , CurrentAsset(nullptr) , MirrorDataTable(nullptr) , BlendSpacePosition(0.0f, 0.0f, 0.0f) , CurrentTime(0.0f) , DeltaTimeRecord() #if WITH_EDITORONLY_DATA , PreviewPoseCurrentTime(0.0f) #endif , PlayRate(1.f) , bLooping(true) , bPlaying(true) , bReverse(false)"
  },
  {
    "label": "FAnimSingleNodeInstanceProxy()",
    "kind": "Method",
    "detail": "Function (SingleNode . Proxy = this ; # if WITH_EDITOR bCanProcessAdditiveAnimations = false ; bIgnoreRootLock = false ; bIgnoreRootMotion = false ; # endif } ~)",
    "insertText": "FAnimSingleNodeInstanceProxy()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Initialize(UAnimInstance* InAnimInstance)"
  },
  {
    "label": "Evaluate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Evaluate(FPoseContext& Output)"
  },
  {
    "label": "UpdateAnimationNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateAnimationNode(const FAnimationUpdateContext& InContext)"
  },
  {
    "label": "PostUpdate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PostUpdate(UAnimInstance* InAnimInstance)"
  },
  {
    "label": "PreUpdate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PreUpdate(UAnimInstance* InAnimInstance, float DeltaSeconds)"
  },
  {
    "label": "InitializeObjects()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeObjects(UAnimInstance* InAnimInstance)"
  },
  {
    "label": "ClearObjects()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearObjects()"
  },
  {
    "label": "SetPlaying()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetPlaying(bool bIsPlaying)"
  },
  {
    "label": "IsPlaying()",
    "kind": "Method",
    "detail": "Function (bPlaying = bIsPlaying ; } bool)",
    "insertText": "IsPlaying()"
  },
  {
    "label": "IsLooping()",
    "kind": "Method",
    "detail": "Function (bLooping = bIsLooping ; } bool)",
    "insertText": "IsLooping()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (WeightInfo .)",
    "insertText": "Reset()"
  },
  {
    "label": "SetAnimationAsset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetAnimationAsset(UAnimationAsset* NewAsset, USkeletalMeshComponent* MeshComponent, bool bIsLooping, float InPlayRate)"
  },
  {
    "label": "UpdateBlendspaceSamples()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateBlendspaceSamples(FVector InBlendInput)"
  },
  {
    "label": "SetCurrentTime()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCurrentTime(float InCurrentTime)"
  },
  {
    "label": "GetCurrentTime()",
    "kind": "Method",
    "detail": "Function (} CurrentTime = InCurrentTime ; } float)",
    "insertText": "GetCurrentTime()"
  },
  {
    "label": "GetFilterLastOutput()",
    "kind": "Method",
    "detail": "Function (PlayRate = InPlayRate ; } FVector)",
    "insertText": "GetFilterLastOutput()"
  },
  {
    "label": "SetReverse()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetReverse(bool bInReverse)"
  },
  {
    "label": "SetBlendSpacePosition()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetBlendSpacePosition(const FVector& InPosition)"
  },
  {
    "label": "GetBlendSpaceState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetBlendSpaceState(FVector& OutPosition, FVector& OutFilteredPosition)"
  },
  {
    "label": "GetBlendSpaceLength()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetBlendSpaceLength()"
  },
  {
    "label": "CanProcessAdditiveAnimations()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR bool)",
    "insertText": "CanProcessAdditiveAnimations()"
  },
  {
    "label": "GetMirrorDataTable()",
    "kind": "Method",
    "detail": "Function (const UMirrorDataTable*)",
    "insertText": "GetMirrorDataTable()"
  },
  {
    "label": "PropagatePreviewCurve()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITORONLY_DATA void)",
    "insertText": "PropagatePreviewCurve(FPoseContext& Output)"
  },
  {
    "label": "SetPreviewCurveOverride()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "SetPreviewCurveOverride(const FName& PoseName, float Value, bool bRemoveIfZero)"
  },
  {
    "label": "UpdateMontageWeightForSlot()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateMontageWeightForSlot(const FName CurrentSlotNodeName, float InGlobalNodeWeight)"
  },
  {
    "label": "SetMontagePreviewSlot()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMontagePreviewSlot(FName PreviewSlot)"
  },
  {
    "label": "InternalBlendSpaceEvaluatePose()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "InternalBlendSpaceEvaluatePose(class UBlendSpace* BlendSpace, TArray<FBlendSampleData>& BlendSampleDataCache, FPoseContext& OutContext)"
  }
]