[
  {
    "label": "split_ordered_list",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "split_ordered_list"
  },
  {
    "label": "concurrent_unordered_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "concurrent_unordered_base"
  },
  {
    "label": "concurrent_skip_list",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "concurrent_skip_list"
  },
  {
    "label": "node_handle_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "node_handle_base"
  },
  {
    "label": "node_handle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "node_handle"
  },
  {
    "label": "tbb",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "tbb"
  },
  {
    "label": "node_handle_base()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_node_handle_H # define __TBB_node_handle_H # include \" _allocator_traits . h \" # include \" . . / tbb_config . h \" namespace tbb { namespace interface5 { namespace internal { template<T,Allocator> class split_ordered_list ; template<Traits> class concurrent_unordered_base ; } } namespace interface10 { namespace internal { template<Traits> class concurrent_skip_list ; } } namespace internal { template<Value,Node,Allocator> class node_handle_base { public : typedef Allocator allocator_type ; protected : typedef Node node ; typedef tbb::internal::allocator_traits<allocator_type> traits_type ; public :)",
    "insertText": "node_handle_base() : my_node(NULL), my_allocator()"
  },
  {
    "label": "node_handle_base()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "node_handle_base(node_handle_base&& nh) : my_node(nh.my_node), my_allocator(std::move(nh.my_allocator))"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (nh . my_node = NULL ; } bool)",
    "insertText": "empty()"
  },
  {
    "label": "internal_destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_destroy()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} node_handle_base&)",
    "insertText": "operator(node_handle_base&& nh)"
  },
  {
    "label": "allocator_move_assignment()",
    "kind": "Method",
    "detail": "Function (my_node = nh . my_node ; typedef traits_type::propagate_on_container_move_assignment pocma_type ; tbb::)",
    "insertText": "allocator_move_assignment(my_allocator, nh.my_allocator, pocma_type())"
  },
  {
    "label": "deactivate()",
    "kind": "Method",
    "detail": "Function (nh .)",
    "insertText": "deactivate()"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(my_node, nh.my_node)"
  },
  {
    "label": "allocator_swap()",
    "kind": "Method",
    "detail": "Function (typedef traits_type::propagate_on_container_swap pocs_type ; tbb::)",
    "insertText": "allocator_swap(my_allocator, nh.my_allocator, pocs_type())"
  },
  {
    "label": "get_allocator()",
    "kind": "Method",
    "detail": "Function (} allocator_type)",
    "insertText": "get_allocator()"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy(my_allocator, my_node->storage())"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (tbb::internal::allocator_rebind<allocator_type,node>::type node_allocator ; node_allocator .)",
    "insertText": "deallocate(my_node, 1)"
  },
  {
    "label": "node_handle()",
    "kind": "Method",
    "detail": "Function (my_node = NULL ; } node* my_node ; allocator_type my_allocator ; } ; template<Key,Value,Node,Allocator> class node_handle : public node_handle_base<Value,Node,Allocator> { typedef node_handle_base<Value,Node,Allocator> base_type ; public : typedef Key key_type ; typedef Value::second_type mapped_type ; typedef base_type::allocator_type allocator_type ;)",
    "insertText": "node_handle() : base_type()"
  },
  {
    "label": "key()",
    "kind": "Method",
    "detail": "Function (} key_type&)",
    "insertText": "key()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(!this->empty(), \"Cannot get key from the empty node_type object\")"
  },
  {
    "label": "mapped()",
    "kind": "Method",
    "detail": "Function (} mapped_type&)",
    "insertText": "mapped()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(!this->empty(), \"Cannot get mapped value from the empty node_type object\")"
  },
  {
    "label": "node_handle()",
    "kind": "Method",
    "detail": "Function (} private : template<T,A> class tbb::interface5::internal::split_ordered_list ; template<Traits> class tbb::interface5::internal::concurrent_unordered_base ; template<Traits> class tbb::interface10::internal::concurrent_skip_list ;)",
    "insertText": "node_handle(typename base_type::node* n) : base_type(n)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} value_type&)",
    "insertText": "value()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(!this->empty(), \"Cannot get value from the empty node_type object\")"
  }
]