[
  {
    "label": "NodeChain",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NodeChain"
  },
  {
    "label": "SameRootConfig",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SameRootConfig"
  },
  {
    "label": "RootNodeCopyHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RootNodeCopyHelper"
  },
  {
    "label": "RootNodeCombineHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RootNodeCombineHelper"
  },
  {
    "label": "RootNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RootNode"
  },
  {
    "label": "ValueConverter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValueConverter"
  },
  {
    "label": "SameConfiguration",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SameConfiguration"
  },
  {
    "label": "Tile",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Tile"
  },
  {
    "label": "NodeStruct",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NodeStruct"
  },
  {
    "label": "NullPred",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NullPred"
  },
  {
    "label": "ValueOnPred",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValueOnPred"
  },
  {
    "label": "ValueOffPred",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValueOffPred"
  },
  {
    "label": "ValueAllPred",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValueAllPred"
  },
  {
    "label": "ChildOnPred",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ChildOnPred"
  },
  {
    "label": "ChildOffPred",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ChildOffPred"
  },
  {
    "label": "BaseIter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BaseIter"
  },
  {
    "label": "ChildIter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ChildIter"
  },
  {
    "label": "ValueIter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueIter"
  },
  {
    "label": "DenseIter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DenseIter"
  },
  {
    "label": "Local",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Local"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_TREE_ROOTNODE_HAS_BEEN_INCLUDED # define OPENVDB_TREE_ROOTNODE_HAS_BEEN_INCLUDED # include<openvdb / Exceptions . h> # include<openvdb / Types . h> # include<openvdb / io / Compression . h> # include<openvdb / math / Math . h> # include<openvdb / math / BBox . h> # include<openvdb / util / NodeMasks . h> # include<openvdb / version . h> # include<tbb / parallel_for . h> # include<map> # include<set> # include<sstream> # include<vector> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace tree { template<HeadType,int HeadLevel> struct NodeChain ; template<,> struct SameRootConfig ; template<,,bool> struct RootNodeCopyHelper ; template<,,,bool> struct RootNodeCombineHelper ; template<ChildType> class RootNode { public : using ChildNodeType = ChildType ; using LeafNodeType = ChildType::LeafNodeType ; using ValueType = ChildType::ValueType ; using BuildType = ChildType::BuildType ; const Index LEVEL = 1 + ChildType::LEVEL ; using NodeChainType = NodeChain<RootNode,LEVEL>::Type ;)",
    "insertText": "static_assert(NodeChainType::Size == LEVEL + 1, \"wrong number of entries in RootNode node chain\")"
  },
  {
    "label": "RootNode()",
    "kind": "Method",
    "detail": "Function (template<OtherValueType> struct ValueConverter { using Type = RootNode<ChildType::template ValueConverter<OtherValueType>::Type> ; } ; template<OtherNodeType> struct SameConfiguration { const bool value = SameRootConfig<ChildNodeType,OtherNodeType>::value ; } ;)",
    "insertText": "RootNode()"
  },
  {
    "label": "RootNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RootNode(const ValueType& background)"
  },
  {
    "label": "RootNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RootNode(const RootNode& other)"
  },
  {
    "label": "RootNode()",
    "kind": "Method",
    "detail": "Function (* this = other ; } template<OtherChildType>)",
    "insertText": "RootNode(const RootNode<OtherChildType>& other)"
  },
  {
    "label": "RootNode()",
    "kind": "Method",
    "detail": "Function (* this = other ; } template<OtherChildType>)",
    "insertText": "RootNode(const RootNode<OtherChildType>& other, const ValueType& background, const ValueType& foreground, TopologyCopy)"
  },
  {
    "label": "RootNode()",
    "kind": "Method",
    "detail": "Function (template<OtherChildType>)",
    "insertText": "RootNode(const RootNode<OtherChildType>& other, const ValueType& background, TopologyCopy)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (RootNode&)",
    "insertText": "operator(const RootNode& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<OtherChildType> RootNode&)",
    "insertText": "operator(const RootNode<OtherChildType>& other)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "clear()"
  },
  {
    "label": "Tile()",
    "kind": "Method",
    "detail": "Function (} private : struct Tile {)",
    "insertText": "Tile(): value(zeroVal<ValueType>()), active(false)"
  },
  {
    "label": "Tile()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Tile(const ValueType& v, bool b): value(v), active(b)"
  },
  {
    "label": "NodeStruct()",
    "kind": "Method",
    "detail": "Function (} ValueType value ; bool active ; } ; struct NodeStruct { ChildType* child ; Tile tile ;)",
    "insertText": "NodeStruct(): child(nullptr)"
  },
  {
    "label": "NodeStruct()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "NodeStruct(ChildType& c): child(&c)"
  },
  {
    "label": "NodeStruct()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "NodeStruct(const Tile& t): child(nullptr), tile(t)"
  },
  {
    "label": "NodeStruct()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "NodeStruct(const NodeStruct&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (NodeStruct&)",
    "insertText": "operator(const NodeStruct&)"
  },
  {
    "label": "NodeStruct()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "NodeStruct()"
  },
  {
    "label": "isChild()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isChild()"
  },
  {
    "label": "isTileOn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isTileOn()"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set(ChildType& c)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (delete child ; child =& c ; } void)",
    "insertText": "set(const Tile& t)"
  },
  {
    "label": "steal()",
    "kind": "Method",
    "detail": "Function (delete child ; child = nullptr ; tile = t ; } ChildType&)",
    "insertText": "steal(const Tile& t)"
  },
  {
    "label": "setTile()",
    "kind": "Method",
    "detail": "Function (ChildType* c = child ; child = nullptr ; tile = t ; return* c ; } } ; using MapType = std::map<Coord,NodeStruct> ; using MapIter = MapType::iterator ; using MapCIter = MapType::const_iterator ; using CoordSet = std::set<Coord> ; using CoordSetIter = CoordSet::iterator ; using CoordSetCIter = CoordSet::const_iterator ; void)",
    "insertText": "setTile(const MapIter& i, const Tile& t)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (i -> second .)",
    "insertText": "set(t)"
  },
  {
    "label": "setChild()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setChild(const MapIter& i, ChildType& c)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (i -> second .)",
    "insertText": "set(c)"
  },
  {
    "label": "getTile()",
    "kind": "Method",
    "detail": "Function (} Tile&)",
    "insertText": "getTile(const MapIter& i)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (} const ChildType&)",
    "insertText": "getChild(const MapCIter& i)"
  },
  {
    "label": "stealChild()",
    "kind": "Method",
    "detail": "Function (} ChildType&)",
    "insertText": "stealChild(const MapIter& i, const Tile& t)"
  },
  {
    "label": "stealChild()",
    "kind": "Method",
    "detail": "Function (} const ChildType&)",
    "insertText": "stealChild(const MapCIter& i,const Tile& t)"
  },
  {
    "label": "isChild()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isChild(const MapCIter& i)"
  },
  {
    "label": "isChild()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isChild(const MapIter& i)"
  },
  {
    "label": "isTile()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isTile(const MapCIter& i)"
  },
  {
    "label": "isTile()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isTile(const MapIter& i)"
  },
  {
    "label": "isTileOff()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isTileOff(const MapCIter& i)"
  },
  {
    "label": "isTileOff()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isTileOff(const MapIter& i)"
  },
  {
    "label": "isTileOn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isTileOn(const MapCIter& i)"
  },
  {
    "label": "isTileOn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isTileOn(const MapIter& i)"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (} struct NullPred { bool)",
    "insertText": "test(const MapIter&)"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "test(const MapCIter& i)"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (} } ; struct ValueOffPred { bool)",
    "insertText": "test(const MapIter& i)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<_RootNodeT,_MapIterT,FilterPredT> class BaseIter { public : using RootNodeT = _RootNodeT ; using MapIterT = _MapIterT ; bool)",
    "insertText": "operator(const BaseIter& other)"
  },
  {
    "label": "getParentNode()",
    "kind": "Method",
    "detail": "Function (} RootNodeT*)",
    "insertText": "getParentNode()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(mParentNode)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "increment()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "increment()"
  },
  {
    "label": "skip()",
    "kind": "Method",
    "detail": "Function (+ + mIter ; } this ->)",
    "insertText": "skip()"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "next()"
  },
  {
    "label": "increment()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "increment(Index n)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (} } Index)",
    "insertText": "pos()"
  },
  {
    "label": "isValueOn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueOn()"
  },
  {
    "label": "isValueOff()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueOff()"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOn(bool on = true)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (mIter -> second . tile . active = on ; } void)",
    "insertText": "setValueOff()"
  },
  {
    "label": "getCoord()",
    "kind": "Method",
    "detail": "Function (mIter -> second . tile . active = false ; } Coord)",
    "insertText": "getCoord()"
  },
  {
    "label": "BaseIter()",
    "kind": "Method",
    "detail": "Function (} protected :)",
    "insertText": "BaseIter(): mParentNode(nullptr)"
  },
  {
    "label": "BaseIter()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "BaseIter(RootNodeT& parent, const MapIterT& iter): mParentNode(&parent), mIter(iter)"
  },
  {
    "label": "ChildIter()",
    "kind": "Method",
    "detail": "Function (} RootNodeT* mParentNode ; MapIterT mIter ; } ; template<RootNodeT,MapIterT,FilterPredT,ChildNodeT> class ChildIter : public BaseIter<RootNodeT,MapIterT,FilterPredT> { public : using BaseT = BaseIter<RootNodeT,MapIterT,FilterPredT> ; using NodeType = RootNodeT ; using ValueType = NodeType ; using ChildNodeType = ChildNodeT ; using NonConstNodeType = std::remove_const<NodeType>::type ; using NonConstValueType = std::remove_const<ValueType>::type ; using NonConstChildNodeType = std::remove_const<ChildNodeType>::type ; using BaseT::mIter ;)",
    "insertText": "ChildIter()"
  },
  {
    "label": "ChildIter()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ChildIter(RootNodeT& parent, const MapIterT& iter): BaseT(parent, iter)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ChildIter&)",
    "insertText": "operator()"
  },
  {
    "label": "ValueIter()",
    "kind": "Method",
    "detail": "Function (} } ; template<RootNodeT,MapIterT,FilterPredT,ValueT> class ValueIter : public BaseIter<RootNodeT,MapIterT,FilterPredT> { public : using BaseT = BaseIter<RootNodeT,MapIterT,FilterPredT> ; using NodeType = RootNodeT ; using ValueType = ValueT ; using NonConstNodeType = std::remove_const<NodeType>::type ; using NonConstValueType = std::remove_const<ValueT>::type ; using BaseT::mIter ;)",
    "insertText": "ValueIter()"
  },
  {
    "label": "ValueIter()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ValueIter(RootNodeT& parent, const MapIterT& iter): BaseT(parent, iter)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValue(const ValueT& v)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(isTile(mIter))"
  },
  {
    "label": "getTile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getTile(mIter)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp> void)",
    "insertText": "modifyValue(const ModifyOp& op)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(getTile(mIter).value)"
  },
  {
    "label": "DenseIter()",
    "kind": "Method",
    "detail": "Function (} } ; template<RootNodeT,MapIterT,ChildNodeT,ValueT> class DenseIter : public BaseIter<RootNodeT,MapIterT,NullPred> { public : using BaseT = BaseIter<RootNodeT,MapIterT,NullPred> ; using NodeType = RootNodeT ; using ValueType = ValueT ; using ChildNodeType = ChildNodeT ; using NonConstNodeType = std::remove_const<NodeType>::type ; using NonConstValueType = std::remove_const<ValueT>::type ; using NonConstChildNodeType = std::remove_const<ChildNodeT>::type ; using BaseT::mIter ;)",
    "insertText": "DenseIter()"
  },
  {
    "label": "DenseIter()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "DenseIter(RootNodeT& parent, const MapIterT& iter): BaseT(parent, iter)"
  },
  {
    "label": "probeChild()",
    "kind": "Method",
    "detail": "Function (} ChildNodeT*)",
    "insertText": "probeChild(NonConstValueType& value)"
  },
  {
    "label": "probeChild()",
    "kind": "Method",
    "detail": "Function (child = this ->)",
    "insertText": "probeChild(value)"
  },
  {
    "label": "setChild()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setChild(ChildNodeT& c)"
  },
  {
    "label": "setChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setChild(mIter, c)"
  },
  {
    "label": "setChild()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setChild(ChildNodeT* c)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(c != nullptr)"
  },
  {
    "label": "setChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setChild(mIter, *c)"
  },
  {
    "label": "cbeginChildOn()",
    "kind": "Method",
    "detail": "Function (} } ; public : using ChildOnIter = ChildIter<RootNode,MapIter,ChildOnPred,ChildType> ; using ChildOnCIter = ChildIter<const RootNode,MapCIter,ChildOnPred,const ChildType> ; using ChildOffIter = ValueIter<RootNode,MapIter,ChildOffPred,const ValueType> ; using ChildOffCIter = ValueIter<const RootNode,MapCIter,ChildOffPred,ValueType> ; using ChildAllIter = DenseIter<RootNode,MapIter,ChildType,ValueType> ; using ChildAllCIter = DenseIter<const RootNode,MapCIter,const ChildType,const ValueType> ; using ValueOnIter = ValueIter<RootNode,MapIter,ValueOnPred,ValueType> ; using ValueOnCIter = ValueIter<const RootNode,MapCIter,ValueOnPred,const ValueType> ; using ValueOffIter = ValueIter<RootNode,MapIter,ValueOffPred,ValueType> ; using ValueOffCIter = ValueIter<const RootNode,MapCIter,ValueOffPred,const ValueType> ; using ValueAllIter = ValueIter<RootNode,MapIter,ValueAllPred,ValueType> ; using ValueAllCIter = ValueIter<const RootNode,MapCIter,ValueAllPred,const ValueType> ; ChildOnCIter)",
    "insertText": "cbeginChildOn()"
  },
  {
    "label": "cbeginChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "cbeginChildOff()"
  },
  {
    "label": "cbeginChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "cbeginChildAll()"
  },
  {
    "label": "beginChildOn()",
    "kind": "Method",
    "detail": "Function (} ChildOnCIter)",
    "insertText": "beginChildOn()"
  },
  {
    "label": "beginChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "beginChildOff()"
  },
  {
    "label": "beginChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "beginChildAll()"
  },
  {
    "label": "cbeginValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnCIter)",
    "insertText": "cbeginValueOn()"
  },
  {
    "label": "cbeginValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "cbeginValueOff()"
  },
  {
    "label": "cbeginValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "cbeginValueAll()"
  },
  {
    "label": "beginValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnCIter)",
    "insertText": "beginValueOn()"
  },
  {
    "label": "beginValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "beginValueOff()"
  },
  {
    "label": "beginValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "beginValueAll()"
  },
  {
    "label": "memUsage()",
    "kind": "Method",
    "detail": "Function (} Index64)",
    "insertText": "memUsage()"
  },
  {
    "label": "evalActiveBoundingBox()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalActiveBoundingBox(CoordBBox& bbox, bool visitVoxels = true)"
  },
  {
    "label": "getNodeBoundingBox()",
    "kind": "Method",
    "detail": "Function (CoordBBox)",
    "insertText": "getNodeBoundingBox()"
  },
  {
    "label": "setBackground()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setBackground(const ValueType& value, bool updateChildNodes)"
  },
  {
    "label": "background()",
    "kind": "Method",
    "detail": "Function (const ValueType&)",
    "insertText": "background()"
  },
  {
    "label": "isBackgroundTile()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isBackgroundTile(const MapIter&)"
  },
  {
    "label": "isBackgroundTile()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isBackgroundTile(const MapCIter&)"
  },
  {
    "label": "numBackgroundTiles()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "numBackgroundTiles()"
  },
  {
    "label": "eraseBackgroundTiles()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "eraseBackgroundTiles()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "empty()"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "expand(const Coord& xyz)"
  },
  {
    "label": "getLevel()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "getLevel()"
  },
  {
    "label": "getChildDim()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "getChildDim()"
  },
  {
    "label": "getWidth()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "getWidth()"
  },
  {
    "label": "getHeight()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "getHeight()"
  },
  {
    "label": "getDepth()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "getDepth()"
  },
  {
    "label": "getMinIndex()",
    "kind": "Method",
    "detail": "Function (} Coord)",
    "insertText": "getMinIndex()"
  },
  {
    "label": "getMaxIndex()",
    "kind": "Method",
    "detail": "Function (Coord)",
    "insertText": "getMaxIndex()"
  },
  {
    "label": "getIndexRange()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getIndexRange(CoordBBox& bbox)"
  },
  {
    "label": "hasSameTopology()",
    "kind": "Method",
    "detail": "Function (template<OtherChildType> bool)",
    "insertText": "hasSameTopology(const RootNode<OtherChildType>& other)"
  },
  {
    "label": "hasSameConfiguration()",
    "kind": "Method",
    "detail": "Function (template<OtherChildType> bool)",
    "insertText": "hasSameConfiguration(const RootNode<OtherChildType>& other)"
  },
  {
    "label": "hasCompatibleValueType()",
    "kind": "Method",
    "detail": "Function (template<OtherChildType> bool)",
    "insertText": "hasCompatibleValueType(const RootNode<OtherChildType>& other)"
  },
  {
    "label": "leafCount()",
    "kind": "Method",
    "detail": "Function (Index32)",
    "insertText": "leafCount()"
  },
  {
    "label": "nonLeafCount()",
    "kind": "Method",
    "detail": "Function (Index32)",
    "insertText": "nonLeafCount()"
  },
  {
    "label": "childCount()",
    "kind": "Method",
    "detail": "Function (Index32)",
    "insertText": "childCount()"
  },
  {
    "label": "onVoxelCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "onVoxelCount()"
  },
  {
    "label": "offVoxelCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "offVoxelCount()"
  },
  {
    "label": "onLeafVoxelCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "onLeafVoxelCount()"
  },
  {
    "label": "offLeafVoxelCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "offLeafVoxelCount()"
  },
  {
    "label": "onTileCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "onTileCount()"
  },
  {
    "label": "nodeCount()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nodeCount(std::vector<Index32> &vec)"
  },
  {
    "label": "isValueOn()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isValueOn(const Coord& xyz)"
  },
  {
    "label": "hasActiveTiles()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasActiveTiles()"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const ValueType&)",
    "insertText": "getValue(const Coord& xyz)"
  },
  {
    "label": "probeValue()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "probeValue(const Coord& xyz, ValueType& value)"
  },
  {
    "label": "getValueDepth()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "getValueDepth(const Coord& xyz)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setActiveState(const Coord& xyz, bool on)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOnly(const Coord& xyz, const ValueType& value)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOn(const Coord& xyz, const ValueType& value)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOff(const Coord& xyz)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOff(const Coord& xyz, const ValueType& value)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (template<ModifyOp> void)",
    "insertText": "modifyValue(const Coord& xyz, const ModifyOp& op)"
  },
  {
    "label": "modifyValueAndActiveState()",
    "kind": "Method",
    "detail": "Function (template<ModifyOp> void)",
    "insertText": "modifyValueAndActiveState(const Coord& xyz, const ModifyOp& op)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(const CoordBBox& bbox, const ValueType& value, bool active = true)"
  },
  {
    "label": "sparseFill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sparseFill(const CoordBBox& bbox, const ValueType& value, bool active = true)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "fill(bbox, value, active)"
  },
  {
    "label": "denseFill()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "denseFill(const CoordBBox& bbox, const ValueType& value, bool active = true)"
  },
  {
    "label": "voxelizeActiveTiles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "voxelizeActiveTiles(bool threaded = true)"
  },
  {
    "label": "copyToDense()",
    "kind": "Method",
    "detail": "Function (template<DenseT> void)",
    "insertText": "copyToDense(const CoordBBox& bbox, DenseT& dense)"
  },
  {
    "label": "writeTopology()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "writeTopology(std::ostream&, bool toHalf = false)"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "readTopology(std::istream&, bool fromHalf = false)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeBuffers(std::ostream&, bool toHalf = false)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(std::istream&, bool fromHalf = false)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(std::istream&, const CoordBBox&, bool fromHalf = false)"
  },
  {
    "label": "getValueAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> const ValueType&)",
    "insertText": "getValueAndCache(const Coord& xyz, AccessorT&)"
  },
  {
    "label": "isValueOnAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> bool)",
    "insertText": "isValueOnAndCache(const Coord& xyz, AccessorT&)"
  },
  {
    "label": "setValueAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> void)",
    "insertText": "setValueAndCache(const Coord& xyz, const ValueType& value, AccessorT&)"
  },
  {
    "label": "setValueOnlyAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> void)",
    "insertText": "setValueOnlyAndCache(const Coord& xyz, const ValueType& value, AccessorT&)"
  },
  {
    "label": "modifyValueAndCache()",
    "kind": "Method",
    "detail": "Function (template<ModifyOp,AccessorT> void)",
    "insertText": "modifyValueAndCache(const Coord& xyz, const ModifyOp& op, AccessorT&)"
  },
  {
    "label": "modifyValueAndActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (template<ModifyOp,AccessorT> void)",
    "insertText": "modifyValueAndActiveStateAndCache(const Coord& xyz, const ModifyOp& op, AccessorT&)"
  },
  {
    "label": "setValueOffAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> void)",
    "insertText": "setValueOffAndCache(const Coord& xyz, const ValueType& value, AccessorT&)"
  },
  {
    "label": "setActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> void)",
    "insertText": "setActiveStateAndCache(const Coord& xyz, bool on, AccessorT&)"
  },
  {
    "label": "probeValueAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> bool)",
    "insertText": "probeValueAndCache(const Coord& xyz, ValueType& value, AccessorT&)"
  },
  {
    "label": "getValueDepthAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> int)",
    "insertText": "getValueDepthAndCache(const Coord& xyz, AccessorT&)"
  },
  {
    "label": "clip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clip(const CoordBBox&)"
  },
  {
    "label": "prune()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "prune(const ValueType& tolerance = zeroVal<ValueType>())"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addLeaf(LeafNodeType* leaf)"
  },
  {
    "label": "addLeafAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> void)",
    "insertText": "addLeafAndCache(LeafNodeType* leaf, AccessorT&)"
  },
  {
    "label": "stealNode()",
    "kind": "Method",
    "detail": "Function (template<NodeT> NodeT*)",
    "insertText": "stealNode(const Coord& xyz, const ValueType& value, bool state)"
  },
  {
    "label": "addChild()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "addChild(ChildType* child)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addTile(const Coord& xyz, const ValueType& value, bool state)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addTile(Index level, const Coord& xyz, const ValueType& value, bool state)"
  },
  {
    "label": "addTileAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> void)",
    "insertText": "addTileAndCache(Index level, const Coord& xyz, const ValueType&, bool state, AccessorT&)"
  },
  {
    "label": "touchLeaf()",
    "kind": "Method",
    "detail": "Function (LeafNodeType*)",
    "insertText": "touchLeaf(const Coord& xyz)"
  },
  {
    "label": "touchLeafAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> LeafNodeType*)",
    "insertText": "touchLeafAndCache(const Coord& xyz, AccessorT& acc)"
  },
  {
    "label": "probeNode()",
    "kind": "Method",
    "detail": "Function (template<NodeT> NodeT*)",
    "insertText": "probeNode(const Coord& xyz)"
  },
  {
    "label": "probeConstNode()",
    "kind": "Method",
    "detail": "Function (template<NodeT> const NodeT*)",
    "insertText": "probeConstNode(const Coord& xyz)"
  },
  {
    "label": "probeNodeAndCache()",
    "kind": "Method",
    "detail": "Function (template<NodeT,AccessorT> NodeT*)",
    "insertText": "probeNodeAndCache(const Coord& xyz, AccessorT& acc)"
  },
  {
    "label": "probeConstNodeAndCache()",
    "kind": "Method",
    "detail": "Function (template<NodeT,AccessorT> const NodeT*)",
    "insertText": "probeConstNodeAndCache(const Coord& xyz, AccessorT& acc)"
  },
  {
    "label": "probeLeaf()",
    "kind": "Method",
    "detail": "Function (LeafNodeType*)",
    "insertText": "probeLeaf(const Coord& xyz)"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (const LeafNodeType*)",
    "insertText": "probeConstLeaf(const Coord& xyz)"
  },
  {
    "label": "probeLeafAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> LeafNodeType*)",
    "insertText": "probeLeafAndCache(const Coord& xyz, AccessorT& acc)"
  },
  {
    "label": "probeConstLeafAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> const LeafNodeType*)",
    "insertText": "probeConstLeafAndCache(const Coord& xyz, AccessorT& acc)"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (template<ArrayT> void)",
    "insertText": "getNodes(ArrayT& array)"
  },
  {
    "label": "stealNodes()",
    "kind": "Method",
    "detail": "Function (template<ArrayT> void)",
    "insertText": "stealNodes(ArrayT& array, const ValueType& value, bool state)"
  },
  {
    "label": "stealNodes()",
    "kind": "Method",
    "detail": "Function (template<ArrayT> void)",
    "insertText": "stealNodes(ArrayT& array)"
  },
  {
    "label": "stealNodes()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "stealNodes(array, mBackground, false)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (} template<MergePolicy Policy> void)",
    "insertText": "merge(RootNode& other)"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (template<OtherChildType> void)",
    "insertText": "topologyUnion(const RootNode<OtherChildType>& other, const bool preserveTiles = false)"
  },
  {
    "label": "topologyIntersection()",
    "kind": "Method",
    "detail": "Function (template<OtherChildType> void)",
    "insertText": "topologyIntersection(const RootNode<OtherChildType>& other)"
  },
  {
    "label": "topologyDifference()",
    "kind": "Method",
    "detail": "Function (template<OtherChildType> void)",
    "insertText": "topologyDifference(const RootNode<OtherChildType>& other)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (template<CombineOp> void)",
    "insertText": "combine(RootNode& other, CombineOp&, bool prune = false)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (template<CombineOp,OtherRootNode> void)",
    "insertText": "combine2(const RootNode& other0, const OtherRootNode& other1, CombineOp& op, bool prune = false)"
  },
  {
    "label": "visitActiveBBox()",
    "kind": "Method",
    "detail": "Function (template<BBoxOp> void)",
    "insertText": "visitActiveBBox(BBoxOp&)"
  },
  {
    "label": "visit()",
    "kind": "Method",
    "detail": "Function (template<VisitorOp> void)",
    "insertText": "visit(VisitorOp&)"
  },
  {
    "label": "visit2()",
    "kind": "Method",
    "detail": "Function (template<OtherRootNodeType,VisitorOp> void)",
    "insertText": "visit2(OtherRootNodeType& other, VisitorOp&)"
  },
  {
    "label": "initTable()",
    "kind": "Method",
    "detail": "Function (private : template<> class RootNode ; template<,,bool> struct RootNodeCopyHelper ; template<,,,bool> struct RootNodeCombineHelper ; void)",
    "insertText": "initTable()"
  },
  {
    "label": "resetTable()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resetTable(MapType& table)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (mTable .)",
    "insertText": "swap(table)"
  },
  {
    "label": "resetTable()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resetTable(const MapType&)"
  },
  {
    "label": "getChildCount()",
    "kind": "Method",
    "detail": "Function (} # if OPENVDB_ABI_VERSION_NUMBER<8 Index)",
    "insertText": "getChildCount()"
  },
  {
    "label": "getTileCount()",
    "kind": "Method",
    "detail": "Function (# endif Index)",
    "insertText": "getTileCount()"
  },
  {
    "label": "getActiveTileCount()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "getActiveTileCount()"
  },
  {
    "label": "getInactiveTileCount()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "getInactiveTileCount()"
  },
  {
    "label": "coordToKey()",
    "kind": "Method",
    "detail": "Function (Coord)",
    "insertText": "coordToKey(const Coord& xyz)"
  },
  {
    "label": "insertKeys()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "insertKeys(CoordSet&)"
  },
  {
    "label": "hasKey()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasKey(const Coord& key)"
  },
  {
    "label": "findKey()",
    "kind": "Method",
    "detail": "Function (} MapIter)",
    "insertText": "findKey(const Coord& key)"
  },
  {
    "label": "findCoord()",
    "kind": "Method",
    "detail": "Function (} MapIter)",
    "insertText": "findCoord(const Coord& xyz)"
  },
  {
    "label": "findOrAddCoord()",
    "kind": "Method",
    "detail": "Function (} MapIter)",
    "insertText": "findOrAddCoord(const Coord& xyz)"
  },
  {
    "label": "enforceSameConfiguration()",
    "kind": "Method",
    "detail": "Function (template<OtherChildType> void)",
    "insertText": "enforceSameConfiguration(const RootNode<OtherChildType>& other)"
  },
  {
    "label": "enforceCompatibleValueTypes()",
    "kind": "Method",
    "detail": "Function (template<OtherChildType> void)",
    "insertText": "enforceCompatibleValueTypes(const RootNode<OtherChildType>& other)"
  },
  {
    "label": "doCombine2()",
    "kind": "Method",
    "detail": "Function (template<CombineOp,OtherRootNode> void)",
    "insertText": "doCombine2(const RootNode&, const OtherRootNode&, CombineOp&, bool prune)"
  },
  {
    "label": "doVisit()",
    "kind": "Method",
    "detail": "Function (template<RootNodeT,VisitorOp,ChildAllIterT> void)",
    "insertText": "doVisit(RootNodeT&, VisitorOp&)"
  },
  {
    "label": "doVisit2()",
    "kind": "Method",
    "detail": "Function (template<RootNodeT,OtherRootNodeT,VisitorOp,ChildAllIterT,OtherChildAllIterT> void)",
    "insertText": "doVisit2(RootNodeT&, OtherRootNodeT&, VisitorOp&)"
  },
  {
    "label": "RootNode()",
    "kind": "Method",
    "detail": "Function (MapType mTable ; ValueType mBackground ; } ; template<HeadT,int HeadLevel> struct NodeChain { using SubtreeT = NodeChain<HeadT::ChildNodeType,HeadLevel - 1>::Type ; using Type = SubtreeT::template Append<HeadT> ; } ; template<HeadT> struct NodeChain<HeadT,1> { using Type = TypeList<HeadT::ChildNodeType,HeadT> ; } ; template<ChildT1,NodeT2> struct SameRootConfig { const bool value = false ; } ; template<ChildT1,ChildT2> struct SameRootConfig<ChildT1,RootNode<ChildT2>> { const bool value = ChildT1::template SameConfiguration<ChildT2>::value ; } ; template<ChildT> RootNode<ChildT)",
    "insertText": "RootNode(): mBackground(zeroVal<ValueType>())"
  },
  {
    "label": "RootNode()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> RootNode<ChildT)",
    "insertText": "RootNode(const ValueType& background): mBackground(background)"
  },
  {
    "label": "RootNode()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> template<OtherChildType> RootNode<ChildT)",
    "insertText": "RootNode(const RootNode<OtherChildType>& other, const ValueType& backgd, const ValueType& foregd, TopologyCopy): mBackground(backgd)"
  },
  {
    "label": "enforceSameConfiguration()",
    "kind": "Method",
    "detail": "Function (using OtherRootT = RootNode<OtherChildType> ;)",
    "insertText": "enforceSameConfiguration(other)"
  },
  {
    "label": "bgTile()",
    "kind": "Method",
    "detail": "Function (const Tile)",
    "insertText": "bgTile(backgd, false), fgTile(foregd, true)"
  },
  {
    "label": "isTile()",
    "kind": "Method",
    "detail": "Function (mTable [ i -> first ] =)",
    "insertText": "isTile(i) ? NodeStruct(OtherRootT::isTileOn(i) ? fgTile : bgTile) : NodeStruct(*(new ChildT(OtherRootT::getChild(i), backgd, foregd, TopologyCopy())))"
  },
  {
    "label": "RootNode()",
    "kind": "Method",
    "detail": "Function (} } template<ChildT> template<OtherChildType> RootNode<ChildT)",
    "insertText": "RootNode(const RootNode<OtherChildType>& other, const ValueType& backgd, TopologyCopy): mBackground(backgd)"
  },
  {
    "label": "bgTile()",
    "kind": "Method",
    "detail": "Function (const Tile)",
    "insertText": "bgTile(backgd, false), fgTile(backgd, true)"
  },
  {
    "label": "isTile()",
    "kind": "Method",
    "detail": "Function (mTable [ i -> first ] =)",
    "insertText": "isTile(i) ? NodeStruct(OtherRootT::isTileOn(i) ? fgTile : bgTile) : NodeStruct(*(new ChildT(OtherRootT::getChild(i), backgd, TopologyCopy())))"
  },
  {
    "label": "copyWithValueConversion()",
    "kind": "Method",
    "detail": "Function (} } template<RootT,OtherRootT,bool Compatible = false> struct RootNodeCopyHelper { void)",
    "insertText": "copyWithValueConversion(RootT& self, const OtherRootT& other)"
  },
  {
    "label": "enforceCompatibleValueTypes()",
    "kind": "Method",
    "detail": "Function (self .)",
    "insertText": "enforceCompatibleValueTypes(other)"
  },
  {
    "label": "OtherRootT()",
    "kind": "Method",
    "detail": "Function (std::ostringstream ostr ; # if VDB_WITH_EPIC_EXTENSIONS ostr<<\" cannot convert a \"<<typeNameAsString<)",
    "insertText": "OtherRootT() << \" to a \" << typeNameAsString<RootT>()"
  },
  {
    "label": "typeid()",
    "kind": "Method",
    "detail": "Function (# else ostr<<\" cannot convert a \"<<)",
    "insertText": "typeid(OtherRootT).name() << \" to a \" << typeid(RootT).name()"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "OPENVDB_THROW(TypeError, ostr.str())"
  },
  {
    "label": "convertValue()",
    "kind": "Method",
    "detail": "Function (using ValueT = RootT::ValueType ; using ChildT = RootT::ChildNodeType ; using NodeStruct = RootT::NodeStruct ; using Tile = RootT::Tile ; using OtherValueT = OtherRootT::ValueType ; using OtherMapCIter = OtherRootT::MapCIter ; using OtherTile = OtherRootT::Tile ; struct Local { ValueT)",
    "insertText": "convertValue(const OtherValueT& val)"
  },
  {
    "label": "convertValue()",
    "kind": "Method",
    "detail": "Function (} } ; self . mBackground =)",
    "insertText": "convertValue(other.mBackground)"
  },
  {
    "label": "getTile()",
    "kind": "Method",
    "detail": "Function (const OtherTile& otherTile = other .)",
    "insertText": "getTile(i)"
  },
  {
    "label": "NodeStruct()",
    "kind": "Method",
    "detail": "Function (self . mTable [ i -> first ] =)",
    "insertText": "NodeStruct(Tile(Local::convertValue(otherTile.value), otherTile.active))"
  },
  {
    "label": "NodeStruct()",
    "kind": "Method",
    "detail": "Function (} else { self . mTable [ i -> first ] =)",
    "insertText": "NodeStruct(*(new ChildT(other.getChild(i))))"
  },
  {
    "label": "isTile()",
    "kind": "Method",
    "detail": "Function (mTable [ i -> first ] =)",
    "insertText": "isTile(i) ? NodeStruct(getTile(i)) : NodeStruct(*(new ChildT(getChild(i))))"
  },
  {
    "label": "compatible()",
    "kind": "Method",
    "detail": "Function (using OtherRootT = RootNode<OtherChildType> ; using OtherValueT = OtherRootT::ValueType ; const bool)",
    "insertText": "compatible(SameConfiguration<OtherRootT>::value && CanConvertType< OtherValueT, ValueType>::value)"
  },
  {
    "label": "copyWithValueConversion()",
    "kind": "Method",
    "detail": "Function (RootNodeCopyHelper<RootNode,OtherRootT,compatible)",
    "insertText": "copyWithValueConversion(*this, other)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ChildT* child = iter -> second . child ;)",
    "insertText": "if(child)"
  },
  {
    "label": "resetBackground()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "resetBackground(mBackground, background)"
  },
  {
    "label": "getTile()",
    "kind": "Method",
    "detail": "Function (} else { Tile& tile =)",
    "insertText": "getTile(iter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (tile . value = background ; } else)",
    "insertText": "if(math::isApproxEqual(tile.value, math::negative(mBackground)))"
  },
  {
    "label": "negative()",
    "kind": "Method",
    "detail": "Function (tile . value =)",
    "insertText": "negative(background)"
  },
  {
    "label": "isBackgroundTile()",
    "kind": "Method",
    "detail": "Function (} } } } mBackground = background ; } template<ChildT> bool RootNode<ChildT)",
    "insertText": "isBackgroundTile(const Tile& tile)"
  },
  {
    "label": "isBackgroundTile()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> bool RootNode<ChildT)",
    "insertText": "isBackgroundTile(const MapIter& iter)"
  },
  {
    "label": "isBackgroundTile()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> bool RootNode<ChildT)",
    "insertText": "isBackgroundTile(const MapCIter& iter)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t count = 0 ;)",
    "insertText": "for(MapCIter i = mTable.begin(), e = mTable.end(); i != e; ++i)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(std::set<Coord>::iterator i = keysToErase.begin(), e = keysToErase.end(); i != e; ++i)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (mTable .)",
    "insertText": "erase(*i)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} return keysToErase .)",
    "insertText": "size()"
  },
  {
    "label": "insertKeys()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> void RootNode<ChildT)",
    "insertText": "insertKeys(CoordSet& keys)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (keys .)",
    "insertText": "insert(i->first)"
  },
  {
    "label": "coordToKey()",
    "kind": "Method",
    "detail": "Function (const Coord key =)",
    "insertText": "coordToKey(xyz)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (std::pair<MapIter,bool> result = mTable .)",
    "insertText": "insert(typename MapType::value_type(key, NodeStruct(Tile(mBackground, false))))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (dims .)",
    "insertText": "push_back(0)"
  },
  {
    "label": "getNodeLog2Dims()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getNodeLog2Dims(dims)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "min() = this->getMinIndex()"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "max() = this->getMaxIndex()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using OtherRootT = RootNode<OtherChildType> ; using OtherMapT = OtherRootT::MapType ; using OtherIterT = OtherRootT::MapIter ; using OtherCIterT = OtherRootT::MapCIter ;)",
    "insertText": "if(!hasSameConfiguration(other))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (OtherMapT copyOfOtherTable = other . mTable ;)",
    "insertText": "for(MapCIter thisIter = mTable.begin(); thisIter != mTable.end(); ++thisIter)"
  },
  {
    "label": "findKey()",
    "kind": "Method",
    "detail": "Function (OtherCIterT otherIter = other .)",
    "insertText": "findKey(thisIter->first)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(OtherRootT::isChild(otherIter))"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} copyOfOtherTable .)",
    "insertText": "erase(otherIter->first)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(OtherIterT i = copyOfOtherTable.begin(), e = copyOfOtherTable.end(); i != e; ++i)"
  },
  {
    "label": "hasSameConfiguration()",
    "kind": "Method",
    "detail": "Function (} return true ; } template<ChildT> template<OtherChildType> bool RootNode<ChildT)",
    "insertText": "hasSameConfiguration(const RootNode<OtherChildType>&)"
  },
  {
    "label": "getNodeLog2Dims()",
    "kind": "Method",
    "detail": "Function (std::vector<Index> thisDims,otherDims ;)",
    "insertText": "getNodeLog2Dims(thisDims)"
  },
  {
    "label": "getNodeLog2Dims()",
    "kind": "Method",
    "detail": "Function (RootNode<OtherChildType)",
    "insertText": "getNodeLog2Dims(otherDims)"
  },
  {
    "label": "enforceSameConfiguration()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> template<OtherChildType> void RootNode<ChildT)",
    "insertText": "enforceSameConfiguration(const RootNode<OtherChildType>&)"
  },
  {
    "label": "configurations()",
    "kind": "Method",
    "detail": "Function (std::ostringstream ostr ; ostr<<\" grids have incompatible)",
    "insertText": "configurations(\" << thisDims[0]; for (size_t i = 1, N = thisDims.size(); i < N; ++i) ostr << \" x \" << thisDims[i]; ostr << \" vs. \" << otherDims[0]; for (size_t i = 1, N = otherDims.size(); i < N; ++i) ostr << \" x \" << otherDims[i]; ostr << \")"
  },
  {
    "label": "hasCompatibleValueType()",
    "kind": "Method",
    "detail": "Function (} } template<ChildT> template<OtherChildType> bool RootNode<ChildT)",
    "insertText": "hasCompatibleValueType(const RootNode<OtherChildType>&)"
  },
  {
    "label": "enforceCompatibleValueTypes()",
    "kind": "Method",
    "detail": "Function (using OtherValueType = OtherChildType::ValueType ; return CanConvertType<OtherValueType,ValueType>::value ; } template<ChildT> template<OtherChildType> void RootNode<ChildT)",
    "insertText": "enforceCompatibleValueTypes(const RootNode<OtherChildType>&)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using OtherValueType = OtherChildType::ValueType ;)",
    "insertText": "if(!CanConvertType< OtherValueType, ValueType>::value)"
  },
  {
    "label": "OtherValueType()",
    "kind": "Method",
    "detail": "Function (std::ostringstream ostr ; ostr<<\" values of type \"<<typeNameAsString<)",
    "insertText": "OtherValueType() << \" cannot be converted to type \" << typeNameAsString<ValueType>()"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (Index64 sum =)",
    "insertText": "sizeof(*this)"
  },
  {
    "label": "evalActiveBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> void RootNode<ChildT)",
    "insertText": "evalActiveBoundingBox(CoordBBox& bbox, bool visitVoxels)"
  },
  {
    "label": "evalActiveBoundingBox()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "evalActiveBoundingBox(bbox, visitVoxels)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(isTileOn(iter))"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "expand(iter->first, ChildT::DIM)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index32 sum = 1 ;)",
    "insertText": "if(ChildT::LEVEL != 0)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (sum + =)",
    "insertText": "getChild(i).onVoxelCount()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(isTileOn(i))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (sum + =)",
    "insertText": "getChild(i).offVoxelCount()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(isTileOff(i) && !this->isBackgroundTile(i))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (sum + =)",
    "insertText": "getChild(i).onTileCount()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(vec.size() > LEVEL)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (+ + sum ;)",
    "insertText": "getChild(i).nodeCount(vec)"
  },
  {
    "label": "findCoord()",
    "kind": "Method",
    "detail": "Function (MapCIter iter = this ->)",
    "insertText": "findCoord(xyz)"
  },
  {
    "label": "isValueOnAndCache()",
    "kind": "Method",
    "detail": "Function (} return false ; } template<ChildT> template<AccessorT> bool RootNode<ChildT)",
    "insertText": "isValueOnAndCache(const Coord& xyz, AccessorT& acc)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (acc .)",
    "insertText": "insert(xyz, &getChild(iter))"
  },
  {
    "label": "getValueAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> template<AccessorT> const ChildT::ValueType& RootNode<ChildT)",
    "insertText": "getValueAndCache(const Coord& xyz, AccessorT& acc)"
  },
  {
    "label": "getValueDepthAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> template<AccessorT> int RootNode<ChildT)",
    "insertText": "getValueDepthAndCache(const Coord& xyz, AccessorT& acc)"
  },
  {
    "label": "setChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setChild(iter, *new ChildT(xyz, getTile(iter).value, true))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "getChild(iter).setValueOff(xyz)"
  },
  {
    "label": "ChildT()",
    "kind": "Method",
    "detail": "Function (child = new)",
    "insertText": "ChildT(xyz, mBackground)"
  },
  {
    "label": "coordToKey()",
    "kind": "Method",
    "detail": "Function (mTable [ this ->)",
    "insertText": "coordToKey(xyz)] = NodeStruct(*child)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { } } else)",
    "insertText": "if(isChild(iter))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (child =&)",
    "insertText": "getChild(iter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(on != getTile(iter).active)"
  },
  {
    "label": "ChildT()",
    "kind": "Method",
    "detail": "Function (child = new)",
    "insertText": "ChildT(xyz, getTile(iter).value, !on)"
  },
  {
    "label": "setChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setChild(iter, *child)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(child) child->setActiveState(xyz, on)"
  },
  {
    "label": "setActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> template<AccessorT> void RootNode<ChildT)",
    "insertText": "setActiveStateAndCache(const Coord& xyz, bool on, AccessorT& acc)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (acc .)",
    "insertText": "insert(xyz, child)"
  },
  {
    "label": "setActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "setActiveStateAndCache(xyz, on, acc)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(isTileOn(iter) || !math::isExactlyEqual(getTile(iter).value, value))"
  },
  {
    "label": "ChildT()",
    "kind": "Method",
    "detail": "Function (child = new)",
    "insertText": "ChildT(xyz, getTile(iter).value, isTileOn(iter))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(child) child->setValueOff(xyz, value)"
  },
  {
    "label": "setValueOffAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> template<AccessorT> void RootNode<ChildT)",
    "insertText": "setValueOffAndCache(const Coord& xyz, const ValueType& value, AccessorT& acc)"
  },
  {
    "label": "setValueOffAndCache()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "setValueOffAndCache(xyz, value, acc)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(isTileOff(iter) || !math::isExactlyEqual(getTile(iter).value, value))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(child) child->setValueOn(xyz, value)"
  },
  {
    "label": "setValueAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> template<AccessorT> void RootNode<ChildT)",
    "insertText": "setValueAndCache(const Coord& xyz, const ValueType& value, AccessorT& acc)"
  },
  {
    "label": "setValueAndCache()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "setValueAndCache(xyz, value, acc)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(!math::isExactlyEqual(getTile(iter).value, value))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(child) child->setValueOnly(xyz, value)"
  },
  {
    "label": "setValueOnlyAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> template<AccessorT> void RootNode<ChildT)",
    "insertText": "setValueOnlyAndCache(const Coord& xyz, const ValueType& value, AccessorT& acc)"
  },
  {
    "label": "setValueOnlyAndCache()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "setValueOnlyAndCache(xyz, value, acc)"
  },
  {
    "label": "isTileOff()",
    "kind": "Method",
    "detail": "Function (} else { bool createChild =)",
    "insertText": "isTileOff(iter)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (ValueType modifiedVal = tileVal ;)",
    "insertText": "op(modifiedVal)"
  },
  {
    "label": "isExactlyEqual()",
    "kind": "Method",
    "detail": "Function (createChild = !)",
    "insertText": "isExactlyEqual(tileVal, modifiedVal)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(createChild)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(child) child->modifyValue(xyz, op)"
  },
  {
    "label": "modifyValueAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> template<ModifyOp,AccessorT> void RootNode<ChildT)",
    "insertText": "modifyValueAndCache(const Coord& xyz, const ModifyOp& op, AccessorT& acc)"
  },
  {
    "label": "modifyValueAndCache()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "modifyValueAndCache(xyz, op, acc)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (bool modifiedState = tile . active ; ValueType modifiedVal = tile . value ;)",
    "insertText": "op(modifiedVal, modifiedState)"
  },
  {
    "label": "ChildT()",
    "kind": "Method",
    "detail": "Function (child = new)",
    "insertText": "ChildT(xyz, tile.value, tile.active)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(child) child->modifyValueAndActiveState(xyz, op)"
  },
  {
    "label": "modifyValueAndActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> template<ModifyOp,AccessorT> void RootNode<ChildT)",
    "insertText": "modifyValueAndActiveStateAndCache(const Coord& xyz, const ModifyOp& op, AccessorT& acc)"
  },
  {
    "label": "modifyValueAndActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "modifyValueAndActiveStateAndCache(xyz, op, acc)"
  },
  {
    "label": "probeValueAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> template<AccessorT> bool RootNode<ChildT)",
    "insertText": "probeValueAndCache(const Coord& xyz, ValueType& value, AccessorT& acc)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> void RootNode<ChildT)",
    "insertText": "fill(const CoordBBox& bbox, const ValueType& value, bool active)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Coord xyz,tileMax ;)",
    "insertText": "for(int x = bbox.min().x(); x <= bbox.max().x(); x = tileMax.x() + 1)"
  },
  {
    "label": "setX()",
    "kind": "Method",
    "detail": "Function (xyz .)",
    "insertText": "setX(x)"
  },
  {
    "label": "setY()",
    "kind": "Method",
    "detail": "Function (xyz .)",
    "insertText": "setY(y)"
  },
  {
    "label": "setZ()",
    "kind": "Method",
    "detail": "Function (xyz .)",
    "insertText": "setZ(z)"
  },
  {
    "label": "offsetBy()",
    "kind": "Method",
    "detail": "Function (tileMax = tileMin .)",
    "insertText": "offsetBy(ChildT::DIM - 1)"
  },
  {
    "label": "findKey()",
    "kind": "Method",
    "detail": "Function (ChildT* child = nullptr ; MapIter iter = this ->)",
    "insertText": "findKey(tileMin)"
  },
  {
    "label": "NodeStruct()",
    "kind": "Method",
    "detail": "Function (mTable [ tileMin ] =)",
    "insertText": "NodeStruct(*child)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(isTile(iter))"
  },
  {
    "label": "minComponent()",
    "kind": "Method",
    "detail": "Function (const Coord tmp =)",
    "insertText": "minComponent(bbox.max(), tileMax)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "fill(CoordBBox(xyz, tmp), value, active)"
  },
  {
    "label": "findOrAddCoord()",
    "kind": "Method",
    "detail": "Function (} } else { MapIter iter = this ->)",
    "insertText": "findOrAddCoord(tileMin)"
  },
  {
    "label": "setTile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setTile(iter, Tile(value, active))"
  },
  {
    "label": "denseFill()",
    "kind": "Method",
    "detail": "Function (} } } } } template<ChildT> void RootNode<ChildT)",
    "insertText": "denseFill(const CoordBBox& bbox, const ValueType& value, bool active)"
  },
  {
    "label": "sparseFill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sparseFill(bbox, value, active)"
  },
  {
    "label": "voxelizeActiveTiles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "voxelizeActiveTiles(true)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "getChild(iter).denseFill(bbox, value, active)"
  },
  {
    "label": "voxelizeActiveTiles()",
    "kind": "Method",
    "detail": "Function (} } } } template<ChildT> void RootNode<ChildT)",
    "insertText": "voxelizeActiveTiles(bool threaded)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ChildT* child = i -> second . child ;)",
    "insertText": "if(child == nullptr)"
  },
  {
    "label": "voxelizeActiveTiles()",
    "kind": "Method",
    "detail": "Function (i -> second . child = child ; } child ->)",
    "insertText": "voxelizeActiveTiles(threaded)"
  },
  {
    "label": "xStride()",
    "kind": "Method",
    "detail": "Function (using DenseValueType = DenseT::ValueType ; const size_t xStride = dense .)",
    "insertText": "xStride(), yStride = dense.yStride(), zStride = dense.zStride()"
  },
  {
    "label": "bbox()",
    "kind": "Method",
    "detail": "Function (const Coord& min = dense .)",
    "insertText": "bbox().min()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (CoordBBox nodeBBox ;)",
    "insertText": "for(Coord xyz = bbox.min(); xyz[0] <= bbox.max()[0]; xyz[0] = nodeBBox.max()[0] + 1)"
  },
  {
    "label": "createCube()",
    "kind": "Method",
    "detail": "Function (nodeBBox =)",
    "insertText": "createCube(coordToKey(xyz), ChildT::DIM)"
  },
  {
    "label": "sub()",
    "kind": "Method",
    "detail": "Function (CoordBBox)",
    "insertText": "sub(xyz, Coord::minComponent(bbox.max(), nodeBBox.max()))"
  },
  {
    "label": "findKey()",
    "kind": "Method",
    "detail": "Function (MapCIter iter = this ->)",
    "insertText": "findKey(nodeBBox.min())"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getChild(iter).copyToDense(sub, dense)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} else { const ValueType value = iter = = mTable .)",
    "insertText": "end() ? mBackground : getTile(iter)"
  },
  {
    "label": "translate()",
    "kind": "Method",
    "detail": "Function (sub .)",
    "insertText": "translate(-min)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (DenseValueType* a0 = dense .)",
    "insertText": "data() + zStride*sub.min()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (DenseValueType* a1 = a0 + x* xStride ;)",
    "insertText": "for(Int32 y=sub.min()[1], ey=sub.max()[1]+1; y<ey; ++y)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (DenseValueType* a2 = a1 + y* yStride ;)",
    "insertText": "for(Int32 z=sub.min()[2], ez=sub.max()[2]+1; z<ez; ++z, a2 += zStride)"
  },
  {
    "label": "DenseValueType()",
    "kind": "Method",
    "detail": "Function (* a2 =)",
    "insertText": "DenseValueType(value)"
  },
  {
    "label": "writeTopology()",
    "kind": "Method",
    "detail": "Function (} } } } } } } } template<ChildT> bool RootNode<ChildT)",
    "insertText": "writeTopology(std::ostream& os, bool toHalf)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&mBackground), sizeof(ValueType))"
  },
  {
    "label": "truncateRealToHalf()",
    "kind": "Method",
    "detail": "Function (} else { ValueType truncatedVal =)",
    "insertText": "truncateRealToHalf(mBackground)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&truncatedVal), sizeof(ValueType))"
  },
  {
    "label": "setGridBackgroundValuePtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "setGridBackgroundValuePtr(os, &mBackground)"
  },
  {
    "label": "getTileCount()",
    "kind": "Method",
    "detail": "Function (const Index numTiles = this ->)",
    "insertText": "getTileCount(), numChildren = this->childCount()"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&numTiles), sizeof(Index))"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&numChildren), sizeof(Index))"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(i->first.asPointer()), 3 * sizeof(Int32))"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&getTile(i).value), sizeof(ValueType))"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&getTile(i).active), sizeof(bool))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getChild(i).writeTopology(os, toHalf)"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (} return true ; } template<ChildT> bool RootNode<ChildT)",
    "insertText": "readTopology(std::istream& is, bool fromHalf)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(&mBackground), sizeof(ValueType))"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (ValueType inside ; is .)",
    "insertText": "read(reinterpret_cast<char*>(&inside), sizeof(ValueType))"
  },
  {
    "label": "setGridBackgroundValuePtr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setGridBackgroundValuePtr(is, &mBackground)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (Coord rangeMin,rangeMax ; is .)",
    "insertText": "read(reinterpret_cast<char*>(rangeMin.asPointer()), 3 * sizeof(Int32))"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(rangeMax.asPointer()), 3 * sizeof(Int32))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index tableSize = 0,log2Dim [ 4 ] = { 0,0,0,0 } ; Int32 offset [ 3 ] ;)",
    "insertText": "for(int i = 0; i < 3; ++i)"
  },
  {
    "label": "FindHighestOn()",
    "kind": "Method",
    "detail": "Function (offset [ i ] = rangeMin [ i ]>> ChildT::TOTAL ; rangeMin [ i ] = offset [ i ]<<ChildT::TOTAL ; log2Dim [ i ] = 1 +)",
    "insertText": "FindHighestOn((rangeMax[i] >> ChildT::TOTAL) - offset[i])"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (tableSize + = log2Dim [ i ] ; rangeMax [)",
    "insertText": "i(((1 << log2Dim[i]) + offset[i]) << ChildT::TOTAL)"
  },
  {
    "label": "childMask()",
    "kind": "Method",
    "detail": "Function (} log2Dim [ 3 ] = log2Dim [ 1 ] + log2Dim [ 2 ] ; tableSize = 1 U<<tableSize ; util::RootNodeMask)",
    "insertText": "childMask(tableSize), valueMask(tableSize)"
  },
  {
    "label": "load()",
    "kind": "Method",
    "detail": "Function (childMask .)",
    "insertText": "load(is)"
  },
  {
    "label": "origin()",
    "kind": "Method",
    "detail": "Function (Index n = i ; Coord origin ;)",
    "insertText": "origin(n >> log2Dim[3])"
  },
  {
    "label": "n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "n(1U << log2Dim[3])"
  },
  {
    "label": "origin()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "origin(n >> log2Dim[2])"
  },
  {
    "label": "origin()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "origin(n & ((1U << log2Dim[2]) - 1))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (origin<<= ChildT::TOTAL ;)",
    "insertText": "if(childMask.isOn(i))"
  },
  {
    "label": "ChildT()",
    "kind": "Method",
    "detail": "Function (ChildT* child = new)",
    "insertText": "ChildT(PartialCreate(), origin, mBackground)"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "readTopology(is)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (} else { ValueType value ; is .)",
    "insertText": "read(reinterpret_cast<char*>(&value), sizeof(ValueType))"
  },
  {
    "label": "NodeStruct()",
    "kind": "Method",
    "detail": "Function (mTable [ origin ] =)",
    "insertText": "NodeStruct(Tile(value, valueMask.isOn(i)))"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (Index numTiles = 0,numChildren = 0 ; is .)",
    "insertText": "read(reinterpret_cast<char*>(&numTiles), sizeof(Index))"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(&numChildren), sizeof(Index))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Int32 vec [ 3 ] ; ValueType value ; bool active ;)",
    "insertText": "for(Index n = 0; n < numTiles; ++n)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(vec), 3 * sizeof(Int32))"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(&active), sizeof(bool))"
  },
  {
    "label": "Coord()",
    "kind": "Method",
    "detail": "Function (mTable [)",
    "insertText": "Coord(vec)] = NodeStruct(Tile(value, active))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(Index n = 0; n < numChildren; ++n)"
  },
  {
    "label": "origin()",
    "kind": "Method",
    "detail": "Function (Coord)",
    "insertText": "origin(vec)"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "readTopology(is, fromHalf)"
  },
  {
    "label": "Coord()",
    "kind": "Method",
    "detail": "Function (mTable [)",
    "insertText": "Coord(vec)] = NodeStruct(*child)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (} return true ; } template<ChildT> void RootNode<ChildT)",
    "insertText": "writeBuffers(std::ostream& os, bool toHalf)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (} } template<ChildT> void RootNode<ChildT)",
    "insertText": "readBuffers(std::istream& is, bool fromHalf)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (} } template<ChildT> void RootNode<ChildT)",
    "insertText": "readBuffers(std::istream& is, const CoordBBox& clipBBox, bool fromHalf)"
  },
  {
    "label": "bgTile()",
    "kind": "Method",
    "detail": "Function (const Tile)",
    "insertText": "bgTile(mBackground, false)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (ChildT& child =)",
    "insertText": "getChild(i)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (child .)",
    "insertText": "readBuffers(is, clipBBox, fromHalf)"
  },
  {
    "label": "clip()",
    "kind": "Method",
    "detail": "Function (} } this ->)",
    "insertText": "clip(clipBBox)"
  },
  {
    "label": "clip()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> void RootNode<ChildT)",
    "insertText": "clip(const CoordBBox& clipBBox)"
  },
  {
    "label": "copyOfTable()",
    "kind": "Method",
    "detail": "Function (MapType)",
    "insertText": "copyOfTable(mTable)"
  },
  {
    "label": "tileBBox()",
    "kind": "Method",
    "detail": "Function (const Coord& xyz = i -> first ; CoordBBox)",
    "insertText": "tileBBox(xyz, xyz.offsetBy(ChildT::DIM - 1))"
  },
  {
    "label": "setTile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setTile(this->findCoord(xyz), bgTile)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (mTable .)",
    "insertText": "erase(xyz)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(!clipBBox.isInside(tileBBox))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getChild(i).clip(clipBBox, mBackground)"
  },
  {
    "label": "intersect()",
    "kind": "Method",
    "detail": "Function (} else { tileBBox .)",
    "insertText": "intersect(clipBBox)"
  },
  {
    "label": "sparseFill()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "sparseFill(tileBBox, origTile.value, origTile.active)"
  },
  {
    "label": "prune()",
    "kind": "Method",
    "detail": "Function (} } else { } } this ->)",
    "insertText": "prune()"
  },
  {
    "label": "prune()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> void RootNode<ChildT)",
    "insertText": "prune(const ValueType& tolerance)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (bool state = false ; ValueType value = zeroVal<)",
    "insertText": "ValueType()"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "getChild(i).prune(tolerance)"
  },
  {
    "label": "setTile()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setTile(i, Tile(value, state))"
  },
  {
    "label": "origin()",
    "kind": "Method",
    "detail": "Function (ChildT* child = nullptr ; const Coord& xyz = leaf ->)",
    "insertText": "origin()"
  },
  {
    "label": "ChildT()",
    "kind": "Method",
    "detail": "Function (child = new)",
    "insertText": "ChildT(xyz, mBackground, false)"
  },
  {
    "label": "ChildT()",
    "kind": "Method",
    "detail": "Function (} else { child = reinterpret_cast<)",
    "insertText": "ChildT(leaf)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "if(ChildT::LEVEL>0)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (} child ->)",
    "insertText": "addLeaf(leaf)"
  },
  {
    "label": "addLeafAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> template<AccessorT> void RootNode<ChildT)",
    "insertText": "addLeafAndCache(LeafNodeType* leaf, AccessorT& acc)"
  },
  {
    "label": "addLeafAndCache()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "addLeafAndCache(leaf, acc)"
  },
  {
    "label": "addChild()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> bool RootNode<ChildT)",
    "insertText": "addChild(ChildT* child)"
  },
  {
    "label": "coordToKey()",
    "kind": "Method",
    "detail": "Function (mTable [ this ->)",
    "insertText": "coordToKey(xyz)] = NodeStruct(Tile(value, state))"
  },
  {
    "label": "setTile()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "setTile(iter, Tile(value, state))"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "addTile(level, xyz, value, state)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getChild(iter).addTile(level, xyz, value, state)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "if(LEVEL > level)"
  },
  {
    "label": "addTileAndCache()",
    "kind": "Method",
    "detail": "Function (} } } } template<ChildT> template<AccessorT> void RootNode<ChildT)",
    "insertText": "addTileAndCache(Index level, const Coord& xyz, const ValueType& value, bool state, AccessorT& acc)"
  },
  {
    "label": "addTileAndCache()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "addTileAndCache(level, xyz, value, state, acc)"
  },
  {
    "label": "touchLeaf()",
    "kind": "Method",
    "detail": "Function (} return child ->)",
    "insertText": "touchLeaf(xyz)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (using NodePtr = ArrayT::value_type ;)",
    "insertText": "static_assert(std::is_pointer<NodePtr>::value, \"argument to getNodes() must be a pointer array\")"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (using NodeType = std::remove_pointer<NodePtr>::type ; using NonConstNodeType = std::remove_const<NodeType>::type ;)",
    "insertText": "static_assert(NodeChainType::template Contains<NonConstNodeType>, \"can't extract non-const nodes from a const tree\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (using ArrayChildT = std::conditional<std::is_const<NodeType>::value,const ChildT,ChildT>::type ;)",
    "insertText": "for(MapIter iter=mTable.begin(); iter!=mTable.end(); ++iter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN)",
    "insertText": "if(std::is_same<NodePtr, ArrayChildT*>::value)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (array .)",
    "insertText": "push_back(reinterpret_cast<NodePtr>(iter->second.child))"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (} else { child ->)",
    "insertText": "getNodes(array)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (using NodeType = std::remove_pointer<NodePtr>::type ;)",
    "insertText": "static_assert(std::is_const<NodeType>::value, \"argument to getNodes() must be an array of const node pointers\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN)",
    "insertText": "if(std::is_same<NodePtr, const ChildT*>::value)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (using NodePtr = ArrayT::value_type ;)",
    "insertText": "static_assert(std::is_pointer<NodePtr>::value, \"argument to stealNodes() must be a pointer array\")"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (array .)",
    "insertText": "push_back(reinterpret_cast<NodePtr>(&stealChild(iter, Tile(value, state))))"
  },
  {
    "label": "stealNodes()",
    "kind": "Method",
    "detail": "Function (} else { child ->)",
    "insertText": "stealNodes(array, value, state)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN)",
    "insertText": "switch(Policy)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (default : case MERGE_ACTIVE_STATES :)",
    "insertText": "for(MapIter i = other.mTable.begin(), e = other.mTable.end(); i != e; ++i)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (MapIter j = mTable .)",
    "insertText": "find(i->first)"
  },
  {
    "label": "stealChild()",
    "kind": "Method",
    "detail": "Function (ChildNodeType& child =)",
    "insertText": "stealChild(i, Tile(other.mBackground, false))"
  },
  {
    "label": "resetBackground()",
    "kind": "Method",
    "detail": "Function (child .)",
    "insertText": "resetBackground(other.mBackground, mBackground)"
  },
  {
    "label": "NodeStruct()",
    "kind": "Method",
    "detail": "Function (mTable [ i -> first ] =)",
    "insertText": "NodeStruct(child)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(isTile(j))"
  },
  {
    "label": "setChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setChild(j, child)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "getChild(j).template merge<MERGE_ACTIVE_STATES>(getChild(i), other.mBackground, mBackground)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(other.isTileOn(i))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mTable [ i -> first ] = i -> second ; } else)",
    "insertText": "if(!isTileOn(j))"
  },
  {
    "label": "setTile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setTile(j, Tile(other.getTile(i).value, true))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "getChild(j).template merge<MERGE_NODES>( getChild(i), other.mBackground, mBackground)"
  },
  {
    "label": "getTile()",
    "kind": "Method",
    "detail": "Function (const Tile tile =)",
    "insertText": "getTile(j)"
  },
  {
    "label": "MERGE_ACTIVE_STATES_AND_NODES()",
    "kind": "Method",
    "detail": "Function (child . template merge<)",
    "insertText": "MERGE_ACTIVE_STATES_AND_NODES(tile.value, tile.active)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "getChild(j).template merge<MERGE_ACTIVE_STATES_AND_NODES>(getChild(i), other.mBackground, mBackground)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mTable [ i -> first ] = i -> second ; } else)",
    "insertText": "if(isTileOff(j))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(isChild(j))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getChild(j).template merge<MERGE_ACTIVE_STATES_AND_NODES>( tile.value, tile.active)"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_END } template<ChildT> template<OtherChildType> void RootNode<ChildT)",
    "insertText": "topologyUnion(const RootNode<OtherChildType>& other, const bool preserveTiles)"
  },
  {
    "label": "NodeStruct()",
    "kind": "Method",
    "detail": "Function (mTable [ i -> first ] =)",
    "insertText": "NodeStruct(*(new ChildT(other.getChild(i), mBackground, TopologyCopy())))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(this->isChild(j))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "getChild(j).topologyUnion(other.getChild(i), preserveTiles)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(!preserveTiles || this->isTileOff(j))"
  },
  {
    "label": "ChildT()",
    "kind": "Method",
    "detail": "Function (ChildT* child = new)",
    "insertText": "ChildT(other.getChild(i), this->getTile(j).value, TopologyCopy())"
  },
  {
    "label": "setChild()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setChild(j, *child)"
  },
  {
    "label": "NodeStruct()",
    "kind": "Method",
    "detail": "Function (mTable [ i -> first ] =)",
    "insertText": "NodeStruct(Tile(mBackground, true))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "getChild(j).setValuesOn()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(this->isTileOff(j))"
  },
  {
    "label": "setTile()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setTile(j, Tile(this->getTile(j).value, true))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::set<Coord> tmp ;)",
    "insertText": "for(MapIter i = mTable.begin(), e = mTable.end(); i != e; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(other.isChild(j))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "getChild(i).topologyIntersection(other.getChild(j), mBackground)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(this->isTileOn(i))"
  },
  {
    "label": "setTile()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setTile(i, Tile(this->getTile(i).value, false))"
  },
  {
    "label": "ChildT()",
    "kind": "Method",
    "detail": "Function (ChildT* child = new)",
    "insertText": "ChildT(other.getChild(j), this->getTile(i).value, TopologyCopy())"
  },
  {
    "label": "setChild()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setChild(i, *child)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "for(std::set<Coord>::iterator i = tmp.begin(), e = tmp.end(); i != e; ++i)"
  },
  {
    "label": "findCoord()",
    "kind": "Method",
    "detail": "Function (MapIter it = this ->)",
    "insertText": "findCoord(*i)"
  },
  {
    "label": "setTile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setTile(it, Tile())"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (mTable .)",
    "insertText": "erase(it)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "getChild(j).topologyDifference(other.getChild(i), mBackground)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(this->isTileOn(j))"
  },
  {
    "label": "ChildT()",
    "kind": "Method",
    "detail": "Function (ChildT* child = new)",
    "insertText": "ChildT(j->first, this->getTile(j).value, true)"
  },
  {
    "label": "topologyDifference()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "topologyDifference(other.getChild(i), mBackground)"
  },
  {
    "label": "setTile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setTile(j, Tile())"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (mTable .)",
    "insertText": "erase(j)"
  },
  {
    "label": "setTile()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setTile(j, Tile(this->getTile(j).value, false))"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (} } } } template<ChildT> template<CombineOp> void RootNode<ChildT)",
    "insertText": "combine(RootNode& other, CombineOp& op, bool prune)"
  },
  {
    "label": "insertKeys()",
    "kind": "Method",
    "detail": "Function (CombineArgs<ValueType> args ; CoordSet keys ; this ->)",
    "insertText": "insertKeys(keys)"
  },
  {
    "label": "findOrAddCoord()",
    "kind": "Method",
    "detail": "Function (MapIter iter =)",
    "insertText": "findOrAddCoord(*i), otherIter = other.findOrAddCoord(*i)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(args.setARef(getTile(iter).value) .setAIsActive(isTileOn(iter)) .setBRef(getTile(otherIter).value) .setBIsActive(isTileOn(otherIter)))"
  },
  {
    "label": "setTile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setTile(iter, Tile(args.result(), args.resultIsActive()))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(isChild(iter) && isTile(otherIter))"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (child .)",
    "insertText": "combine(getTile(otherIter).value, isTileOn(otherIter), op)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(isTile(iter) && isChild(otherIter))"
  },
  {
    "label": "swappedOp()",
    "kind": "Method",
    "detail": "Function (SwappedCombineOp<ValueType,CombineOp>)",
    "insertText": "swappedOp(op)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (ChildT& child =)",
    "insertText": "getChild(otherIter)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (child .)",
    "insertText": "combine(getTile(iter).value, isTileOn(iter), swappedOp)"
  },
  {
    "label": "setChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setChild(iter, stealChild(otherIter, Tile()))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (} else { ChildT& child =)",
    "insertText": "getChild(iter), &otherChild = getChild(otherIter)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (child .)",
    "insertText": "combine(otherChild, op)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(prune && isChild(iter)) getChild(iter).prune()"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "op(args.setARef(mBackground).setBRef(other.mBackground))"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (mBackground = args .)",
    "insertText": "result()"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (} template<CombineOp,RootT,OtherRootT,bool Compatible = false> struct RootNodeCombineHelper { void)",
    "insertText": "combine2(RootT& self, const RootT&, const OtherRootT& other1, CombineOp&, bool)"
  },
  {
    "label": "enforceSameConfiguration()",
    "kind": "Method",
    "detail": "Function (self .)",
    "insertText": "enforceSameConfiguration(other1)"
  },
  {
    "label": "enforceCompatibleValueTypes()",
    "kind": "Method",
    "detail": "Function (self .)",
    "insertText": "enforceCompatibleValueTypes(other1)"
  },
  {
    "label": "OtherRootT()",
    "kind": "Method",
    "detail": "Function (std::ostringstream ostr ; # if VDB_WITH_EPIC_EXTENSIONS ostr<<\" cannot combine a \"<<typeNameAsString<)",
    "insertText": "OtherRootT() << \" into a \" << typeNameAsString<RootT>()"
  },
  {
    "label": "typeid()",
    "kind": "Method",
    "detail": "Function (# else ostr<<\" cannot combine a \"<<)",
    "insertText": "typeid(OtherRootT).name() << \" into a \" << typeid(RootT).name()"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (} } ; template<CombineOp,RootT,OtherRootT> struct RootNodeCombineHelper<CombineOp,RootT,OtherRootT,true> { void)",
    "insertText": "combine2(RootT& self, const RootT& other0, const OtherRootT& other1, CombineOp& op, bool prune)"
  },
  {
    "label": "doCombine2()",
    "kind": "Method",
    "detail": "Function (self .)",
    "insertText": "doCombine2(other0, other1, op, prune)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (} } ; template<ChildT> template<CombineOp,OtherRootNode> void RootNode<ChildT)",
    "insertText": "combine2(const RootNode& other0, const OtherRootNode& other1, CombineOp& op, bool prune)"
  },
  {
    "label": "compatible()",
    "kind": "Method",
    "detail": "Function (using OtherValueType = OtherRootNode::ValueType ; const bool)",
    "insertText": "compatible(SameConfiguration<OtherRootNode>::value && CanConvertType< OtherValueType, ValueType>::value)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (RootNodeCombineHelper<CombineOp,RootNode,OtherRootNode,compatible)",
    "insertText": "combine2(*this, other0, other1, op, prune)"
  },
  {
    "label": "doCombine2()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> template<CombineOp,OtherRootNode> void RootNode<ChildT)",
    "insertText": "doCombine2(const RootNode& other0, const OtherRootNode& other1, CombineOp& op, bool prune)"
  },
  {
    "label": "bg0()",
    "kind": "Method",
    "detail": "Function (const NodeStruct)",
    "insertText": "bg0(Tile(other0.mBackground, false))"
  },
  {
    "label": "bg1()",
    "kind": "Method",
    "detail": "Function (const OtherNodeStructT)",
    "insertText": "bg1(OtherTileT(other1.mBackground, false))"
  },
  {
    "label": "findOrAddCoord()",
    "kind": "Method",
    "detail": "Function (MapIter thisIter = this ->)",
    "insertText": "findOrAddCoord(*i)"
  },
  {
    "label": "findKey()",
    "kind": "Method",
    "detail": "Function (MapCIter iter0 = other0 .)",
    "insertText": "findKey(*i)"
  },
  {
    "label": "ns0()",
    "kind": "Method",
    "detail": "Function (second : bg0)",
    "insertText": "ns0(iter0 != other0.mTable.end())"
  },
  {
    "label": "ns1()",
    "kind": "Method",
    "detail": "Function (second : bg1)",
    "insertText": "ns1(iter1 != other1.mTable.end())"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(args.setARef(ns0.tile.value) .setAIsActive(ns0.isTileOn()) .setBRef(ns1.tile.value) .setBIsActive(ns1.isTileOn()))"
  },
  {
    "label": "setTile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setTile(thisIter, Tile(args.result(), args.resultIsActive()))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(!isChild(thisIter))"
  },
  {
    "label": "isChild()",
    "kind": "Method",
    "detail": "Function (const Coord& childOrigin = ns0 .)",
    "insertText": "isChild() ? ns0.child->origin() : ns1.child->origin()"
  },
  {
    "label": "setChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setChild(thisIter, *(new ChildT(childOrigin, getTile(thisIter).value)))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (} ChildT& child =)",
    "insertText": "getChild(thisIter)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (child .)",
    "insertText": "combine2(ns0.tile.value, *ns1.child, ns0.isTileOn(), op)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(ns1.isTile())"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (child .)",
    "insertText": "combine2(*ns0.child, ns1.tile.value, ns1.isTileOn(), op)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (} else { child .)",
    "insertText": "combine2(*ns0.child, *ns1.child, op)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(prune && isChild(thisIter)) getChild(thisIter).prune()"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "op(args.setARef(other0.mBackground).setBRef(other1.mBackground))"
  },
  {
    "label": "visitActiveBBox()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> template<BBoxOp> void RootNode<ChildT)",
    "insertText": "visitActiveBBox(BBoxOp& op)"
  },
  {
    "label": "LEVEL()",
    "kind": "Method",
    "detail": "Function (const bool descent = op . template descent<)",
    "insertText": "LEVEL()"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "getChild(i).visitActiveBBox(op)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} else { op . template)",
    "insertText": "operator()<LEVEL>(CoordBBox::createCube(i->first, ChildT::DIM))"
  },
  {
    "label": "visit()",
    "kind": "Method",
    "detail": "Function (} } } template<ChildT> template<VisitorOp> void RootNode<ChildT)",
    "insertText": "visit(VisitorOp& op)"
  },
  {
    "label": "doVisit()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> template<RootNodeT,VisitorOp,ChildAllIterT> void RootNode<ChildT)",
    "insertText": "doVisit(RootNodeT& self, VisitorOp& op)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (RootNodeT::ValueType val ;)",
    "insertText": "for(ChildAllIterT iter = self.beginChildAll(); iter; ++iter)"
  },
  {
    "label": "visit()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "visit(op)"
  },
  {
    "label": "visit2()",
    "kind": "Method",
    "detail": "Function (} } } template<ChildT> template<OtherRootNodeType,VisitorOp> void RootNode<ChildT)",
    "insertText": "visit2(OtherRootNodeType& other, VisitorOp& op)"
  },
  {
    "label": "doVisit2()",
    "kind": "Method",
    "detail": "Function (} template<ChildT> template<RootNodeT,OtherRootNodeT,VisitorOp,ChildAllIterT,OtherChildAllIterT> void RootNode<ChildT)",
    "insertText": "doVisit2(RootNodeT& self, OtherRootNodeT& other, VisitorOp& op)"
  },
  {
    "label": "copyOfSelf()",
    "kind": "Method",
    "detail": "Function (RootNodeT::ValueType val ; OtherRootNodeT::ValueType otherVal ; RootNodeT)",
    "insertText": "copyOfSelf(self.mBackground)"
  },
  {
    "label": "copyOfOther()",
    "kind": "Method",
    "detail": "Function (copyOfSelf . mTable = self . mTable ; OtherRootNodeT)",
    "insertText": "copyOfOther(other.mBackground)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (const size_t skipBranch = static_cast<)",
    "insertText": "size_t(op(iter, otherIter))"
  },
  {
    "label": "child()",
    "kind": "Method",
    "detail": "Function (ChildAllIterT::ChildNodeType*)",
    "insertText": "child(skipBranch & 1U) ? nullptr : iter.probeChild(val)"
  },
  {
    "label": "otherChild()",
    "kind": "Method",
    "detail": "Function (OtherChildAllIterT::ChildNodeType*)",
    "insertText": "otherChild(skipBranch & 2U) ? nullptr : otherIter.probeChild(otherVal)"
  },
  {
    "label": "visit2Node()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "visit2Node(*otherChild, op)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(child != nullptr)"
  },
  {
    "label": "visit2()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "visit2(otherIter, op)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(otherChild != nullptr)"
  },
  {
    "label": "visit2()",
    "kind": "Method",
    "detail": "Function (otherChild ->)",
    "insertText": "visit2(iter, op, true)"
  },
  {
    "label": "resetTable()",
    "kind": "Method",
    "detail": "Function (self .)",
    "insertText": "resetTable(copyOfSelf.mTable)"
  },
  {
    "label": "resetTable()",
    "kind": "Method",
    "detail": "Function (other .)",
    "insertText": "resetTable(copyOfOther.mTable)"
  }
]