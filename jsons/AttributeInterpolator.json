[
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "TAttributeInterpolator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TAttributeInterpolator"
  },
  {
    "label": "TAnimatedAttribute",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TAnimatedAttribute"
  },
  {
    "label": "TEasingAttributeInterpolator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TEasingAttributeInterpolator"
  },
  {
    "label": "FSettings",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSettings"
  },
  {
    "label": "TArriveAttributeInterpolator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TArriveAttributeInterpolator"
  },
  {
    "label": "TVerletAttributeInterpolator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TVerletAttributeInterpolator"
  },
  {
    "label": "DECLARE_MULTICAST_DELEGATE_OneParam()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Math / UnrealMathUtility . h \" enum class EAttributeInterpolatorType : uint8 { Easing,Arrive,Verlet } ; template<NumericType> class TAttributeInterpolator { public :)",
    "insertText": "DECLARE_MULTICAST_DELEGATE_OneParam(FInterpolatorEvent, TOptional<NumericType>)"
  },
  {
    "label": "TAttributeInterpolator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TAttributeInterpolator() : bEnabled(true) , Tolerance(0.001f)"
  },
  {
    "label": "TAttributeInterpolator()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TAttributeInterpolator()"
  },
  {
    "label": "Equals()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Equals(const NumericType& InA, const NumericType& InB, double InTolerance = 0.001)"
  },
  {
    "label": "IsTypeOf()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsTypeOf(EAttributeInterpolatorType InType)"
  },
  {
    "label": "IdenticalTo()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IdenticalTo(const TAttributeInterpolator* InOther)"
  },
  {
    "label": "IsSet()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSet()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset()"
  },
  {
    "label": "Stop()",
    "kind": "Method",
    "detail": "Function (const bool bFireStopEvent =)",
    "insertText": "Stop()"
  },
  {
    "label": "Broadcast()",
    "kind": "Method",
    "detail": "Function (InterpolationStopped .)",
    "insertText": "Broadcast(TOptional<NumericType>())"
  },
  {
    "label": "IsEnabled()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "IsEnabled()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bEnabled = InEnabled ;)",
    "insertText": "if(DesiredValue.IsSet())"
  },
  {
    "label": "SetValueAndStop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetValueAndStop(DesiredValue.GetValue())"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "SetValue(const NumericType& InValue)"
  },
  {
    "label": "SetValueAndStop()",
    "kind": "Method",
    "detail": "Function (} DesiredValue = InValue ; } else {)",
    "insertText": "SetValueAndStop(InValue)"
  },
  {
    "label": "SetValueAndStop()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetValueAndStop(const NumericType& InValue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (LastValue = DesiredValue = InValue ;)",
    "insertText": "if(bFireStopEvent)"
  },
  {
    "label": "Broadcast()",
    "kind": "Method",
    "detail": "Function (InterpolationStopped .)",
    "insertText": "Broadcast(InValue)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} } const NumericType&)",
    "insertText": "Get()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(InterpolatedValue.IsSet())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(LastValue.IsSet())"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (} return DesiredValue .)",
    "insertText": "GetValue()"
  },
  {
    "label": "Tick()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Tick(float InDeltaTime)"
  },
  {
    "label": "IsSet()",
    "kind": "Method",
    "detail": "Function (const NumericType& CurrentValue = InterpolatedValue .)",
    "insertText": "IsSet() ? InterpolatedValue.GetValue() : DesiredValue.GetValue()"
  },
  {
    "label": "SetValueAndStop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetValueAndStop(LastValue.GetValue())"
  },
  {
    "label": "DelayLeft()",
    "kind": "Method",
    "detail": "Function (InDeltaTime = -)",
    "insertText": "DelayLeft(void)PlayIfStopped()"
  },
  {
    "label": "Interpolate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Interpolate()"
  },
  {
    "label": "GetOverAllDeltaTime()",
    "kind": "Method",
    "detail": "Function (} } double)",
    "insertText": "GetOverAllDeltaTime()"
  },
  {
    "label": "SetDelayOneShot()",
    "kind": "Method",
    "detail": "Function (} } return 0 . 0 f ; } void)",
    "insertText": "SetDelayOneShot(float InDelay)"
  },
  {
    "label": "SetTolerance()",
    "kind": "Method",
    "detail": "Function (Delay = InDelay ; } void)",
    "insertText": "SetTolerance(float InTolerance)"
  },
  {
    "label": "OnInterpolationStarted()",
    "kind": "Method",
    "detail": "Function (Tolerance = InTolerance ; } FInterpolatorEvent&)",
    "insertText": "OnInterpolationStarted()"
  },
  {
    "label": "IsPlaying()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsPlaying()"
  },
  {
    "label": "Start()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Start()"
  },
  {
    "label": "PlayIfStopped()",
    "kind": "Method",
    "detail": "Function (InterpolatedValue = LastValue ; OverallDeltaTime = 0 . f ; return true ; } bool)",
    "insertText": "PlayIfStopped()"
  },
  {
    "label": "Equals()",
    "kind": "Method",
    "detail": "Function (} bool bEnabled ; float Tolerance ; TOptional<float> Delay ; TOptional<float> OverallDeltaTime ; TOptional<NumericType> InterpolatedValue ; TOptional<NumericType> LastValue ; TOptional<NumericType> DesiredValue ; FInterpolatorEvent InterpolationStarted ; FInterpolatorEvent InterpolationStopped ; template<> class TAnimatedAttribute ; } ; template<> bool TAttributeInterpolator<float)",
    "insertText": "Equals(const float& InA, const float& InB, double InTolerance)"
  },
  {
    "label": "Equals()",
    "kind": "Method",
    "detail": "Function (} template<> bool TAttributeInterpolator<double)",
    "insertText": "Equals(const double& InA, const double& InB, double InTolerance)"
  },
  {
    "label": "EaseInterpolatorRatio()",
    "kind": "Method",
    "detail": "Function (} enum class EEasingInterpolatorType : uint8 { Linear,QuadraticEaseIn,QuadraticEaseOut,QuadraticEaseInOut,CubicEaseIn,CubicEaseOut,CubicEaseInOut,QuarticEaseIn,QuarticEaseOut,QuarticEaseInOut,QuinticEaseIn,QuinticEaseOut,QuinticEaseInOut,SineEaseIn,SineEaseOut,SineEaseInOut,CircularEaseIn,CircularEaseOut,CircularEaseInOut,ExponentialEaseIn,ExponentialEaseOut,ExponentialEaseInOut,ElasticEaseIn,ElasticEaseOut,ElasticEaseInOut,BackEaseIn,BackEaseOut,BackEaseInOut,BounceEaseIn,BounceEaseOut,BounceEaseInOut } ; float)",
    "insertText": "EaseInterpolatorRatio(EEasingInterpolatorType InEasingType, float InRatio)"
  },
  {
    "label": "FSettings()",
    "kind": "Method",
    "detail": "Function (template<NumericType> class TEasingAttributeInterpolator ; template<NumericType> class TEasingAttributeInterpolator : public TAttributeInterpolator<NumericType> { private : typedef TAttributeInterpolator<NumericType> Super ; public : struct FSettings { typedef TEasingAttributeInterpolator<NumericType> InterpolatorType ;)",
    "insertText": "FSettings(EEasingInterpolatorType InEasingType, float InDuration) : EasingType(InEasingType) , Duration(InDuration)"
  },
  {
    "label": "TEasingAttributeInterpolator()",
    "kind": "Method",
    "detail": "Function (} EEasingInterpolatorType EasingType ; float Duration ; } ;)",
    "insertText": "TEasingAttributeInterpolator(const FSettings& InSettings) : Super() , Settings(InSettings)"
  },
  {
    "label": "DeltaTime()",
    "kind": "Method",
    "detail": "Function (const float)",
    "insertText": "DeltaTime(float)Super::GetOverAllDeltaTime()"
  },
  {
    "label": "SetValueAndStop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetValueAndStop(Super::DesiredValue.GetValue())"
  },
  {
    "label": "EaseInterpolatorRatio()",
    "kind": "Method",
    "detail": "Function (const float EasedRatio =)",
    "insertText": "EaseInterpolatorRatio(Settings.EasingType, Ratio)"
  },
  {
    "label": "NumericType()",
    "kind": "Method",
    "detail": "Function (Super::InterpolatedValue = FMath::Lerp<)",
    "insertText": "NumericType(Super::LastValue.GetValue(), Super::DesiredValue.GetValue(), EasedRatio)"
  },
  {
    "label": "FSettings()",
    "kind": "Method",
    "detail": "Function (} FSettings Settings ; } ; template<NumericType> class TArriveAttributeInterpolator : public TAttributeInterpolator<NumericType> { private : typedef TAttributeInterpolator<NumericType> Super ; public : struct FSettings { typedef TArriveAttributeInterpolator<NumericType> InterpolatorType ;)",
    "insertText": "FSettings(int32 InIterations, float InStrength) : Iterations(InIterations) , Strength(InStrength)"
  },
  {
    "label": "TArriveAttributeInterpolator()",
    "kind": "Method",
    "detail": "Function (} int32 Iterations ; float Strength ; } ;)",
    "insertText": "TArriveAttributeInterpolator(const FSettings& InSettings) : Super() , Settings(InSettings) , LastDeltaTime(0)"
  },
  {
    "label": "Restart()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Restart()"
  },
  {
    "label": "OverallDeltaTime()",
    "kind": "Method",
    "detail": "Function (const float)",
    "insertText": "OverallDeltaTime(float)Super::GetOverAllDeltaTime()"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (const float LocalDeltaTime = OverallDeltaTime - LastDeltaTime ; const float Blend = FMath::Max<)",
    "insertText": "float(Settings.Strength, 0)"
  },
  {
    "label": "NumericType()",
    "kind": "Method",
    "detail": "Function (Super::InterpolatedValue = FMath::Lerp<)",
    "insertText": "NumericType(Super::InterpolatedValue.IsSet() ? Super::InterpolatedValue.GetValue() : Super::LastValue.GetValue(), Super::DesiredValue.GetValue(), Blend)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} LastDeltaTime = OverallDeltaTime ;)",
    "insertText": "if(Super::Equals(Super::DesiredValue.GetValue(), Super::InterpolatedValue.GetValue(), Super::Tolerance))"
  },
  {
    "label": "FSettings()",
    "kind": "Method",
    "detail": "Function (} } FSettings Settings ; float LastDeltaTime ; } ; template<NumericType> class TVerletAttributeInterpolator : public TAttributeInterpolator<NumericType> { private : typedef TAttributeInterpolator<NumericType> Super ; public : struct FSettings { typedef TVerletAttributeInterpolator<NumericType> InterpolatorType ;)",
    "insertText": "FSettings(float InBlend, float InStrength, float InDamping) : Blend(InBlend) , Strength(InStrength) , Damping(InDamping)"
  },
  {
    "label": "TVerletAttributeInterpolator()",
    "kind": "Method",
    "detail": "Function (} float Blend ; float Strength ; float Damping ; } ;)",
    "insertText": "TVerletAttributeInterpolator(const FSettings& InSettings) : Super() , Settings(InSettings) , LastDeltaTime(0)"
  },
  {
    "label": "NumericType()",
    "kind": "Method",
    "detail": "Function (LastDeltaTime = 0 . 0 ; Velocity =)",
    "insertText": "NumericType(0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Super::LastValue = Super::InterpolatedValue = PreviousValue ; })",
    "insertText": "if(PreviousVelocity.IsSet())"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (const float LocalDeltaTime = OverallDeltaTime - LastDeltaTime ; const float U = FMath::Clamp<)",
    "insertText": "float(FMath::Max<float>(Settings.Blend, 0) * 8.f * LocalDeltaTime, 0, 1)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (const float ScaleDown = FMath::Clamp<)",
    "insertText": "float(1.f - Settings.Damping, 0.f, 1.f)"
  },
  {
    "label": "IsSet()",
    "kind": "Method",
    "detail": "Function (const NumericType PreviousValue = Super::InterpolatedValue .)",
    "insertText": "IsSet() ? Super::InterpolatedValue.GetValue() : Super::LastValue.GetValue()"
  },
  {
    "label": "Force()",
    "kind": "Method",
    "detail": "Function (const NumericType)",
    "insertText": "Force(Super::DesiredValue.GetValue() - PreviousValue)"
  },
  {
    "label": "NumericType()",
    "kind": "Method",
    "detail": "Function (Velocity = FMath::Lerp<)",
    "insertText": "NumericType(PreviousVelocity, Force, U)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (LastDeltaTime = OverallDeltaTime ;)",
    "insertText": "if(Super::Equals(Super::DesiredValue.GetValue(), Super::InterpolatedValue.GetValue(), Super::Tolerance) && Super::Equals(Velocity.GetValue(), NumericType(0), Super::Tolerance))"
  }
]