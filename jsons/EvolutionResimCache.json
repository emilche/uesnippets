[
  {
    "label": "FCollisionResimCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCollisionResimCache"
  },
  {
    "label": "FEvolutionResimCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FEvolutionResimCache"
  },
  {
    "label": "FWeakConstraintPair",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FWeakConstraintPair"
  },
  {
    "label": "FPBDSolveCache",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPBDSolveCache"
  },
  {
    "label": "FEvolutionResimCache()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" ResimCacheBase . h \" # include \" Templates / UniquePtr . h \" # include \" Chaos / Collision / PBDCollisionConstraint . h \" # include \" Chaos / ParticleHandle . h \" namespace Chaos { class FCollisionResimCache ; class FEvolutionResimCache : public IResimCacheBase { public :)",
    "insertText": "FEvolutionResimCache()"
  },
  {
    "label": "ResetCache()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetCache()"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const int32 CurrentSize = ParticleToCachedSolve .)",
    "insertText": "Num()"
  },
  {
    "label": "CeilToInt()",
    "kind": "Method",
    "detail": "Function (const int32 SizeLeniency =)",
    "insertText": "CeilToInt(0.1f * static_cast<float>(CurrentSize))"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (ParticleCacheAllocationSize =)",
    "insertText": "Max(CurrentSize, ParticleCacheAllocationSize)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (const int32 ReallocationLimit =)",
    "insertText": "Max(ParticleCacheAllocationSize - (SizeLeniency * 2), 0)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (const int32 PreferredSize = CurrentSize + SizeLeniency ; ParticleToCachedSolve .)",
    "insertText": "Empty(PreferredSize)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (ParticleCacheAllocationSize = PreferredSize ; } else { ParticleToCachedSolve .)",
    "insertText": "Reset()"
  },
  {
    "label": "SaveParticlePostSolve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SaveParticlePostSolve(const FPBDRigidParticleHandle& Particle)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (FPBDSolveCache& Cache = ParticleToCachedSolve .)",
    "insertText": "FindOrAdd(Particle.UniqueIdx())"
  },
  {
    "label": "GetP()",
    "kind": "Method",
    "detail": "Function (Cache . P = Particle .)",
    "insertText": "GetP()"
  },
  {
    "label": "GetQ()",
    "kind": "Method",
    "detail": "Function (Cache . Q = Particle .)",
    "insertText": "GetQ()"
  },
  {
    "label": "GetV()",
    "kind": "Method",
    "detail": "Function (Cache . V = Particle .)",
    "insertText": "GetV()"
  },
  {
    "label": "GetW()",
    "kind": "Method",
    "detail": "Function (Cache . W = Particle .)",
    "insertText": "GetW()"
  },
  {
    "label": "ReloadParticlePostSolve()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ReloadParticlePostSolve(FPBDRigidParticleHandle& Particle)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (const FPBDSolveCache* Cache = ParticleToCachedSolve .)",
    "insertText": "Find(Particle.UniqueIdx())"
  },
  {
    "label": "SetP()",
    "kind": "Method",
    "detail": "Function (Particle .)",
    "insertText": "SetP(Cache->P)"
  },
  {
    "label": "SetQ()",
    "kind": "Method",
    "detail": "Function (Particle .)",
    "insertText": "SetQ(Cache->Q)"
  },
  {
    "label": "SetV()",
    "kind": "Method",
    "detail": "Function (Particle .)",
    "insertText": "SetV(Cache->V)"
  },
  {
    "label": "SetW()",
    "kind": "Method",
    "detail": "Function (Particle .)",
    "insertText": "SetW(Cache->W)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (SavedConstraints .)",
    "insertText": "Reset(CollisionsArray.Num())"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (SavedConstraints .)",
    "insertText": "Emplace(FPBDCollisionConstraint::MakeCopy(*Collision))"
  },
  {
    "label": "SaveArrayHelper()",
    "kind": "Method",
    "detail": "Function (} auto)",
    "insertText": "SaveArrayHelper(auto& Constraints,auto& WeakPairs)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (WeakPairs .)",
    "insertText": "Empty(Constraints.Num())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (WeakPairs .)",
    "insertText": "Add(FWeakConstraintPair{Constraint.GetParticle0()->WeakParticleHandle(),Constraint.GetParticle1()->WeakParticleHandle()})"
  },
  {
    "label": "GetParticle0()",
    "kind": "Method",
    "detail": "Function (auto* A = Constraint .)",
    "insertText": "GetParticle0()"
  },
  {
    "label": "GetParticle1()",
    "kind": "Method",
    "detail": "Function (auto* B = Constraint .)",
    "insertText": "GetParticle1()"
  },
  {
    "label": "MarkSoftIfDesync()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MarkSoftIfDesync(*A,*B)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "check(Constraints.Num() == WeakPairs.Num())"
  },
  {
    "label": "SaveArrayHelper()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "SaveArrayHelper(SavedConstraints,WeakSinglePointConstraints)"
  },
  {
    "label": "GetAndSanitizeConstraints()",
    "kind": "Method",
    "detail": "Function (} const TArray<FPBDCollisionConstraint>&)",
    "insertText": "GetAndSanitizeConstraints()"
  },
  {
    "label": "CleanupArrayHelper()",
    "kind": "Method",
    "detail": "Function (auto)",
    "insertText": "CleanupArrayHelper(auto& Constraints,auto& WeakPairs)"
  },
  {
    "label": "GetHandleUnsafe()",
    "kind": "Method",
    "detail": "Function (FPBDCollisionConstraint& Constraint = Constraints [ Idx ] ; FWeakConstraintPair& WeakPair = WeakPairs [ Idx ] ; TGeometryParticleHandle<FReal,3>* A = WeakPair . A .)",
    "insertText": "GetHandleUnsafe()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bValidConstraint = A ! = nullptr&& B ! = nullptr ;)",
    "insertText": "if(bValidConstraint)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!bValidConstraint)"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (Constraints .)",
    "insertText": "RemoveAtSwap(Idx)"
  },
  {
    "label": "CleanupArrayHelper()",
    "kind": "Method",
    "detail": "Function (} } } ;)",
    "insertText": "CleanupArrayHelper(SavedConstraints,WeakSinglePointConstraints)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(B.SyncState() != ESyncState::HardDesync)"
  }
]