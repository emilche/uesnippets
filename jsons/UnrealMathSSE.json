[
  {
    "label": "VectorRegisterConstInit",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VectorRegisterConstInit"
  },
  {
    "label": "alignas",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "alignas"
  },
  {
    "label": "PLATFORM_ENABLE_VECTORINTRINSICS_NEON()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" HAL / Platform . h \" # include \" HAL / PlatformMath . h \" # include \" Math / MathFwd . h \" # include \" Math / UnrealMathUtility . h \" # if ! WITH_DIRECTXMATH&& !)",
    "insertText": "PLATFORM_ENABLE_VECTORINTRINSICS_NEON(defined(__cplusplus_cli) && !PLATFORM_HOLOLENS)"
  },
  {
    "label": "UE_PLATFORM_MATH_USE_AVX_2()",
    "kind": "Method",
    "detail": "Function (} ; # include<emmintrin . h> # ifndef UE_PLATFORM_MATH_USE_SSE4_1 # define UE_PLATFORM_MATH_USE_SSE4_1 PLATFORM_ALWAYS_HAS_SSE4_1 # endif # ifndef UE_PLATFORM_MATH_USE_AVX # define UE_PLATFORM_MATH_USE_AVX PLATFORM_ALWAYS_HAS_AVX # endif # ifndef UE_PLATFORM_MATH_USE_AVX_2 # define)",
    "insertText": "UE_PLATFORM_MATH_USE_AVX_2(PLATFORM_ALWAYS_HAS_AVX_2 && UE_PLATFORM_MATH_USE_AVX) #endif #ifndef UE_PLATFORM_MATH_USE_FMA3 #define UE_PLATFORM_MATH_USE_FMA3 PLATFORM_ALWAYS_HAS_FMA3 #endif #ifndef UE_PLATFORM_MATH_USE_SVML #if defined(_MSC_VER) && !defined(__clang__) #define UE_PLATFORM_MATH_USE_SVML (_MSC_VER >= 1920) #else #define UE_PLATFORM_MATH_USE_SVML 0 #endif #endif #ifndef UE_PLATFORM_MATH_USE_SVML_AVX #define UE_PLATFORM_MATH_USE_SVML_AVX (UE_PLATFORM_MATH_USE_SVML && UE_PLATFORM_MATH_USE_AVX)"
  },
  {
    "label": "sin_ps()",
    "kind": "Method",
    "detail": "Function (typedef __m128i VectorRegister4Int ; typedef __m128i VectorRegister2Int64 ; typedef __m128d VectorRegister2Double ; typedef struct { VectorRegister4Float val [ 4 ] ; } VectorRegister4x4Float ; namespace SSE { VectorRegister4Float)",
    "insertText": "sin_ps(VectorRegister4Float x)"
  },
  {
    "label": "cos_ps()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float)",
    "insertText": "cos_ps(VectorRegister4Float x)"
  },
  {
    "label": "sincos_ps()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sincos_ps(VectorRegister4Float x, VectorRegister4Float* s, VectorRegister4Float* c)"
  },
  {
    "label": "log_ps()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float)",
    "insertText": "log_ps(VectorRegister4Float x)"
  },
  {
    "label": "exp_ps()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float)",
    "insertText": "exp_ps(VectorRegister4Float x)"
  },
  {
    "label": "tan_ps()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float)",
    "insertText": "tan_ps(VectorRegister4Float x)"
  },
  {
    "label": "cot_ps()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float)",
    "insertText": "cot_ps(VectorRegister4Float x)"
  },
  {
    "label": "atan_ps()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float)",
    "insertText": "atan_ps(VectorRegister4Float x)"
  },
  {
    "label": "atan2_ps()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float)",
    "insertText": "atan2_ps(VectorRegister4Float y, VectorRegister4Float x)"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (} ; struct)",
    "insertText": "alignas(UE_SSE_DOUBLE_ALIGNMENT)"
  },
  {
    "label": "GetXY()",
    "kind": "Method",
    "detail": "Function (# if ! UE_PLATFORM_MATH_USE_AVX VectorRegister2Double XY ; VectorRegister2Double ZW ; VectorRegister2Double)",
    "insertText": "GetXY()"
  },
  {
    "label": "GetZW()",
    "kind": "Method",
    "detail": "Function (} VectorRegister2Double)",
    "insertText": "GetZW()"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (} # endif)",
    "insertText": "VectorRegister4Double()"
  },
  {
    "label": "_mm256_setr_m128d()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_AVX XYZW =)",
    "insertText": "_mm256_setr_m128d(InXY, InZW)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (# else XY = InXY ; ZW = InZW ; # endif })",
    "insertText": "VectorRegister4Double(VectorRegister2Double InXY, VectorRegister2Double InZW, VectorRegisterConstInit) : XY(InXY) , ZW(InZW)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VectorRegister4Double(const VectorRegister4Float& FloatVector)"
  },
  {
    "label": "_mm_cvtps_pd()",
    "kind": "Method",
    "detail": "Function (# if ! UE_PLATFORM_MATH_USE_AVX XY =)",
    "insertText": "_mm_cvtps_pd(FloatVector)"
  },
  {
    "label": "_mm_cvtps_pd()",
    "kind": "Method",
    "detail": "Function (ZW =)",
    "insertText": "_mm_cvtps_pd(_mm_movehl_ps(FloatVector, FloatVector))"
  },
  {
    "label": "_mm256_cvtps_pd()",
    "kind": "Method",
    "detail": "Function (# else XYZW =)",
    "insertText": "_mm256_cvtps_pd(FloatVector)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double&)",
    "insertText": "operator(const VectorRegister4Float& FloatVector)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (# endif return* this ; } # if UE_PLATFORM_MATH_USE_AVX)",
    "insertText": "VectorRegister4Double(const __m256d& Register)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (XYZW = Register ; } VectorRegister4Double&)",
    "insertText": "operator(const __m256d& Register)"
  },
  {
    "label": "__m256d()",
    "kind": "Method",
    "detail": "Function (XYZW = Register ; return* this ; } operator)",
    "insertText": "__m256d()"
  },
  {
    "label": "VectorLoadAligned()",
    "kind": "Method",
    "detail": "Function (typedef VectorRegister4Int VectorRegisterInt ; VectorRegister4Float)",
    "insertText": "VectorLoadAligned(const float* Ptr)"
  },
  {
    "label": "VectorLoadAligned()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double)",
    "insertText": "VectorLoadAligned(const double* Ptr)"
  },
  {
    "label": "VectorStoreAligned()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreAligned(const VectorRegister4Float& Vec, float* Ptr)"
  },
  {
    "label": "VectorStoreAligned()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreAligned(const VectorRegister4Double& Vec, double* Dst)"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (struct)",
    "insertText": "alignas(UE_SSE_FLOAT_ALIGNMENT)"
  },
  {
    "label": "AlignedFloat4()",
    "kind": "Method",
    "detail": "Function (float V [ 4 ] ;)",
    "insertText": "AlignedFloat4(const VectorRegister4Float& Vec)"
  },
  {
    "label": "VectorStoreAligned()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreAligned(Vec, V)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "operator(int32 Index)"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (} } ; struct)",
    "insertText": "alignas(alignof(VectorRegister4Double))"
  },
  {
    "label": "DECLARE_VECTOR_REGISTER()",
    "kind": "Method",
    "detail": "Function (} } ; typedef AlignedDouble4 AlignedRegister4 ; # define)",
    "insertText": "DECLARE_VECTOR_REGISTER(X, Y, Z, W) MakeVectorRegister(X, Y, Z, W) #define SHUFFLEMASK(A0,A1,B2,B3) ( (A0) | ((A1)<<2) | ((B2)<<4) | ((B3)<<6) ) #define SHUFFLEMASK2(A0,A1) ((A0) | ((A1)<<1)) FORCEINLINE VectorRegister2Double MakeVectorRegister2Double(double X, double Y)"
  },
  {
    "label": "MakeVectorRegister2DoubleMask()",
    "kind": "Method",
    "detail": "Function (} VectorRegister2Double)",
    "insertText": "MakeVectorRegister2DoubleMask(uint64 X, uint64 Y)"
  },
  {
    "label": "_mm_set_epi64x()",
    "kind": "Method",
    "detail": "Function (union { VectorRegister2Double Vd ; __m128i Vi ; } Result ; Result . Vi =)",
    "insertText": "_mm_set_epi64x(Y, X)"
  },
  {
    "label": "_mm_setr_epi32()",
    "kind": "Method",
    "detail": "Function (union { VectorRegister4Float v ; VectorRegister4Int i ; } Tmp ; Tmp . i =)",
    "insertText": "_mm_setr_epi32(X, Y, Z, W)"
  },
  {
    "label": "MakeVectorRegister()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "MakeVectorRegister(uint32 X, uint32 Y, uint32 Z, uint32 W)"
  },
  {
    "label": "MakeVectorRegisterFloatMask()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "MakeVectorRegisterFloatMask(uint32 X, uint32 Y, uint32 Z, uint32 W)"
  },
  {
    "label": "MakeVectorRegisterDoubleMask()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "MakeVectorRegisterDoubleMask(uint64 X, uint64 Y, uint64 Z, uint64 W)"
  },
  {
    "label": "MakeVectorRegisterFloat()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "MakeVectorRegisterFloat(float X, float Y, float Z, float W)"
  },
  {
    "label": "MakeVectorRegisterDouble()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "MakeVectorRegisterDouble(double X, double Y, double Z, double W)"
  },
  {
    "label": "_mm_setr_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_setr_pd(X, Y)"
  },
  {
    "label": "_mm_setr_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_setr_pd(Z, W)"
  },
  {
    "label": "_mm256_setr_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_setr_pd(X, Y, Z, W)"
  },
  {
    "label": "MakeVectorRegister()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "MakeVectorRegister(float X, float Y, float Z, float W)"
  },
  {
    "label": "MakeVectorRegister()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "MakeVectorRegister(double X, double Y, double Z, double W)"
  },
  {
    "label": "MakeVectorRegisterDouble()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "MakeVectorRegisterDouble(const VectorRegister2Double& XY, const VectorRegister2Double& ZW)"
  },
  {
    "label": "MakeVectorRegisterDouble()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "MakeVectorRegisterDouble(const VectorRegister4Float& From)"
  },
  {
    "label": "MakeVectorRegisterFloatFromDouble()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "MakeVectorRegisterFloatFromDouble(const VectorRegister4Double& Vec4d)"
  },
  {
    "label": "_mm_movelh_ps()",
    "kind": "Method",
    "detail": "Function (# if ! UE_PLATFORM_MATH_USE_AVX return)",
    "insertText": "_mm_movelh_ps(_mm_cvtpd_ps(Vec4d.XY), _mm_cvtpd_ps(Vec4d.ZW))"
  },
  {
    "label": "_mm256_cvtpd_ps()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "_mm256_cvtpd_ps(Vec4d)"
  },
  {
    "label": "MakeVectorRegisterInt()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Int)",
    "insertText": "MakeVectorRegisterInt(int32 X, int32 Y, int32 Z, int32 W)"
  },
  {
    "label": "MakeVectorRegisterInt64()",
    "kind": "Method",
    "detail": "Function (} VectorRegister2Int64)",
    "insertText": "MakeVectorRegisterInt64(int64 X, int64 Y)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} PRAGMA_DISABLE_UNSAFE_TYPECAST_WARNINGS # if)",
    "insertText": "defined(PRAGMA_DISABLE_MISSING_BRACES_WARNINGS) PRAGMA_DISABLE_MISSING_BRACES_WARNINGS #endif FORCEINLINE constexpr VectorRegister4Int MakeVectorRegisterIntConstant(int32 X, int32 Y, int32 Z, int32 W)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if ! PLATFORM_LITTLE_ENDIAN # error Big - endian unimplemented # elif)",
    "insertText": "defined(_MSC_VER) && !defined(__clang__)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "char(X >> 0), static_cast<char>(X >> 8), static_cast<char>(X >> 16), static_cast<char>(X >> 24), static_cast<char>(Y >> 0), static_cast<char>(Y >> 8), static_cast<char>(Y >> 16), static_cast<char>(Y >> 24), static_cast<char>(Z >> 0), static_cast<char>(Z >> 8), static_cast<char>(Z >> 16), static_cast<char>(Z >> 24), static_cast<char>(W >> 0), static_cast<char>(W >> 8), static_cast<char>(W >> 16), static_cast<char>(W >> 24)"
  },
  {
    "label": "uint64()",
    "kind": "Method",
    "detail": "Function (# else uint64 XY =)",
    "insertText": "uint64(uint32(X)) | (uint64(uint32(Y)) << 32)"
  },
  {
    "label": "uint64()",
    "kind": "Method",
    "detail": "Function (uint64 ZW =)",
    "insertText": "uint64(uint32(Z)) | (uint64(uint32(W)) << 32)"
  },
  {
    "label": "MakeVectorRegisterFloatConstant()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "MakeVectorRegisterFloatConstant(float X, float Y, float Z, float W)"
  },
  {
    "label": "VectorZeroDouble()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorZeroDouble(void)"
  },
  {
    "label": "_mm_setzero_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_setzero_pd()"
  },
  {
    "label": "_mm256_setzero_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_setzero_pd()"
  },
  {
    "label": "VectorOneFloat()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorOneFloat(void)"
  },
  {
    "label": "VectorGetComponentImpl()",
    "kind": "Method",
    "detail": "Function (} template<> float)",
    "insertText": "VectorGetComponentImpl(const VectorRegister4Float& Vec)"
  },
  {
    "label": "VectorGetComponentImpl()",
    "kind": "Method",
    "detail": "Function (} template<uint32 ComponentIndex> double)",
    "insertText": "VectorGetComponentImpl(const VectorRegister4Double& Vec)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (# if ! UE_PLATFORM_MATH_USE_AVX)",
    "insertText": "return(((double*)&(Vec.XY))[ComponentIndex])"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "return(((double*)&(Vec.XYZW))[ComponentIndex])"
  },
  {
    "label": "VectorGetComponent()",
    "kind": "Method",
    "detail": "Function (} # endif # define)",
    "insertText": "VectorGetComponent(Vec, ComponentIndex) VectorGetComponentImpl<ComponentIndex>(Vec) FORCEINLINE float VectorGetComponentDynamic(const VectorRegister4Float& Vec, uint32 ComponentIndex)"
  },
  {
    "label": "VectorGetComponentDynamic()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "VectorGetComponentDynamic(const VectorRegister4Double& Vec, uint32 ComponentIndex)"
  },
  {
    "label": "VectorLoad()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorLoad(const float* Ptr)"
  },
  {
    "label": "VectorLoad()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorLoad(const double* Ptr)"
  },
  {
    "label": "_mm_loadu_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_loadu_pd((double*)(Ptr))"
  },
  {
    "label": "_mm_loadu_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_loadu_pd((double*)(Ptr + 2))"
  },
  {
    "label": "_mm256_loadu_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_loadu_pd((double*)Ptr)"
  },
  {
    "label": "VectorLoad16()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4x4Float)",
    "insertText": "VectorLoad16(const float* Ptr)"
  },
  {
    "label": "VectorLoad()",
    "kind": "Method",
    "detail": "Function (VectorRegister4x4Float Result ; Result . val [ 0 ] =)",
    "insertText": "VectorLoad(Ptr)"
  },
  {
    "label": "VectorLoad()",
    "kind": "Method",
    "detail": "Function (Result . val [ 1 ] =)",
    "insertText": "VectorLoad(Ptr + 4)"
  },
  {
    "label": "VectorLoad()",
    "kind": "Method",
    "detail": "Function (Result . val [ 2 ] =)",
    "insertText": "VectorLoad(Ptr + 8)"
  },
  {
    "label": "VectorLoad()",
    "kind": "Method",
    "detail": "Function (Result . val [ 3 ] =)",
    "insertText": "VectorLoad(Ptr + 12)"
  },
  {
    "label": "_mm_load_sd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_load_sd((double*)(Ptr+2))"
  },
  {
    "label": "VectorLoadFloat3_W1()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorLoadFloat3_W1(const double* Ptr)"
  },
  {
    "label": "MakeVectorRegister2Double()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "MakeVectorRegister2Double(Ptr[2], 1.0)"
  },
  {
    "label": "_mm256_blend_pd()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "_mm256_blend_pd(Result, VectorOneDouble(), 0b1000)"
  },
  {
    "label": "_mm_load_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_load_pd((const double*)(Ptr))"
  },
  {
    "label": "_mm_load_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_load_pd((const double*)(Ptr + 2))"
  },
  {
    "label": "_mm256_loadu_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_loadu_pd(Ptr)"
  },
  {
    "label": "VectorLoadFloat1()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorLoadFloat1(const float* Ptr)"
  },
  {
    "label": "_mm_load1_ps()",
    "kind": "Method",
    "detail": "Function (# if ! UE_PLATFORM_MATH_USE_AVX return)",
    "insertText": "_mm_load1_ps(Ptr)"
  },
  {
    "label": "_mm_broadcast_ss()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "_mm_broadcast_ss(Ptr)"
  },
  {
    "label": "VectorLoadDouble1()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorLoadDouble1(const double* Ptr)"
  },
  {
    "label": "_mm_load1_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_load1_pd(Ptr)"
  },
  {
    "label": "_mm256_broadcast_sd()",
    "kind": "Method",
    "detail": "Function (Result . ZW = Result . XY ; # else Result =)",
    "insertText": "_mm256_broadcast_sd(Ptr)"
  },
  {
    "label": "VectorLoad64Bits()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4i)",
    "insertText": "VectorLoad64Bits(const VectorRegister4i *Ptr)"
  },
  {
    "label": "VectorLoadFloat2()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "VectorLoadFloat2(const float* Ptr)"
  },
  {
    "label": "VectorLoadFloat2()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorLoadFloat2(const double* Ptr)"
  },
  {
    "label": "_mm_loadu_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_loadu_pd(Ptr)"
  },
  {
    "label": "_mm256_set_m128d()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "_mm256_set_m128d(Temp, Temp)"
  },
  {
    "label": "VectorLoadTwoPairsFloat()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorLoadTwoPairsFloat(const float* Ptr1, const float* Ptr2)"
  },
  {
    "label": "_mm_castpd_ps()",
    "kind": "Method",
    "detail": "Function (__m128 Ret =)",
    "insertText": "_mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(Ptr1)))"
  },
  {
    "label": "_mm_loadh_pi()",
    "kind": "Method",
    "detail": "Function (Ret =)",
    "insertText": "_mm_loadh_pi(Ret, (__m64 const*)(Ptr2))"
  },
  {
    "label": "_mm_loadu_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_loadu_pd(Ptr1)"
  },
  {
    "label": "_mm_loadu_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_loadu_pd(Ptr2)"
  },
  {
    "label": "_mm256_loadu2_m128d()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_loadu2_m128d(Ptr2, Ptr1)"
  },
  {
    "label": "VectorSetFloat1()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorSetFloat1(float F)"
  },
  {
    "label": "VectorSetFloat1()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorSetFloat1(double D)"
  },
  {
    "label": "_mm_set1_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_set1_pd(D)"
  },
  {
    "label": "_mm256_set1_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW = Result . XY ; # else Result =)",
    "insertText": "_mm256_set1_pd(D)"
  },
  {
    "label": "VectorStore()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } void)",
    "insertText": "VectorStore(const VectorRegister4Float& Vec, float* Ptr)"
  },
  {
    "label": "_mm_storeu_ps()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mm_storeu_ps(Ptr, Vec)"
  },
  {
    "label": "VectorStore()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VectorStore(const VectorRegister4Double& Vec, double* Dst)"
  },
  {
    "label": "_mm_storeu_pd()",
    "kind": "Method",
    "detail": "Function (# if ! UE_PLATFORM_MATH_USE_AVX)",
    "insertText": "_mm_storeu_pd(Dst, Vec.XY)"
  },
  {
    "label": "_mm_storeu_pd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mm_storeu_pd(Dst + 2, Vec.ZW)"
  },
  {
    "label": "_mm256_storeu_pd()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "_mm256_storeu_pd(Dst, Vec)"
  },
  {
    "label": "VectorStore16()",
    "kind": "Method",
    "detail": "Function (# endif } void)",
    "insertText": "VectorStore16(const VectorRegister4x4Float& Vec, float* Ptr)"
  },
  {
    "label": "VectorStore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStore(Vec.val[0], Ptr)"
  },
  {
    "label": "VectorStore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStore(Vec.val[1], Ptr + 4)"
  },
  {
    "label": "VectorStore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStore(Vec.val[2], Ptr + 8)"
  },
  {
    "label": "VectorStore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStore(Vec.val[3], Ptr + 12)"
  },
  {
    "label": "VectorStoreAligned()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VectorStoreAligned(const VectorRegister4Float& Vec, float* Dst)"
  },
  {
    "label": "_mm_store_ps()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mm_store_ps(Dst, Vec)"
  },
  {
    "label": "_mm_store_pd()",
    "kind": "Method",
    "detail": "Function (# if ! UE_PLATFORM_MATH_USE_AVX)",
    "insertText": "_mm_store_pd(Dst, Vec.XY)"
  },
  {
    "label": "_mm_store_pd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mm_store_pd(Dst + 2, Vec.ZW)"
  },
  {
    "label": "VectorStoreAlignedStreamed()",
    "kind": "Method",
    "detail": "Function (# endif } void)",
    "insertText": "VectorStoreAlignedStreamed(const VectorRegister4Float& Vec, float* Dst)"
  },
  {
    "label": "_mm_stream_ps()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mm_stream_ps(Dst, Vec)"
  },
  {
    "label": "VectorStoreAlignedStreamed()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VectorStoreAlignedStreamed(const VectorRegister4Double& Vec, double* Dst)"
  },
  {
    "label": "_mm_stream_pd()",
    "kind": "Method",
    "detail": "Function (# if ! UE_PLATFORM_MATH_USE_AVX)",
    "insertText": "_mm_stream_pd(Dst, Vec.XY)"
  },
  {
    "label": "_mm_stream_pd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mm_stream_pd(Dst + 2, Vec.ZW)"
  },
  {
    "label": "VectorStoreFloat3()",
    "kind": "Method",
    "detail": "Function (# endif } void)",
    "insertText": "VectorStoreFloat3(const VectorRegister4Float& Vec, float* Ptr)"
  },
  {
    "label": "_mm_storel_pi()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Tmp = Vec ;)",
    "insertText": "_mm_storel_pi((__m64*)(Ptr), Tmp)"
  },
  {
    "label": "_mm_store_ss()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mm_store_ss(&Ptr[2], _mm_movehl_ps(Tmp, Tmp))"
  },
  {
    "label": "VectorStoreFloat3()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VectorStoreFloat3(const VectorRegister4Double& Vec, double* Dst)"
  },
  {
    "label": "_mm_store_sd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mm_store_sd(Dst + 2, Vec.ZW)"
  },
  {
    "label": "VectorStoreFloat1()",
    "kind": "Method",
    "detail": "Function (# endif } void)",
    "insertText": "VectorStoreFloat1(const VectorRegister4Float& Vec, float* Ptr)"
  },
  {
    "label": "_mm_store_ss()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mm_store_ss(Ptr, Vec)"
  },
  {
    "label": "VectorStoreFloat1()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VectorStoreFloat1(const VectorRegister4Double& Vec, double* Dst)"
  },
  {
    "label": "_mm_store_sd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mm_store_sd(Dst, Vec.XY)"
  },
  {
    "label": "InLane0()",
    "kind": "Method",
    "detail": "Function (} namespace SSEPermuteHelpers { # define)",
    "insertText": "InLane0(Index0, Index1) ((Index0) <= 1 && (Index1) <= 1) #define InLane1(Index0, Index1) ((Index0) >= 2 && (Index1) >= 2) #define InSameLane(Index0, Index1) (InLane0(Index0, Index1) || InLane1(Index0, Index1)) #define OutOfLane(Index0, Index1) (!InSameLane(Index0, Index1)) template <int Index0, int Index1> FORCEINLINE VectorRegister2Double SelectVectorSwizzle2(const VectorRegister4Double& Vec)"
  },
  {
    "label": "_mm_shuffle_pd()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "_mm_shuffle_pd(Vec.GetXY(), Vec.GetZW(), SHUFFLEMASK2(Index0, Index1 - 2))"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} } else { if)",
    "insertText": "constexpr(Index1 <= 1)"
  },
  {
    "label": "_mm_shuffle_pd()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "_mm_shuffle_pd(Vec.GetZW(), Vec.GetZW(), SHUFFLEMASK2(Index0 - 2, Index1 - 2))"
  },
  {
    "label": "SelectVectorSwizzle2()",
    "kind": "Method",
    "detail": "Function (} } } template<> VectorRegister2Double)",
    "insertText": "SelectVectorSwizzle2(const VectorRegister4Double& Vec)"
  },
  {
    "label": "PERMUTE_LANE_MASK()",
    "kind": "Method",
    "detail": "Function (} # endif # if UE_PLATFORM_MATH_USE_AVX int)",
    "insertText": "PERMUTE_LANE_MASK(int A, int B)"
  },
  {
    "label": "PermuteLanes()",
    "kind": "Method",
    "detail": "Function (} template<int Lane0,int Lane1> VectorRegister4Double)",
    "insertText": "PermuteLanes(const VectorRegister4Double& Vec)"
  },
  {
    "label": "PERMUTE_MASK()",
    "kind": "Method",
    "detail": "Function (} # endif int)",
    "insertText": "PERMUTE_MASK(int A, int B, int C, int D)"
  },
  {
    "label": "SelectVectorSwizzle()",
    "kind": "Method",
    "detail": "Function (} template<int Index0,int Index1,int Index2,int Index3> VectorRegister4Double)",
    "insertText": "SelectVectorSwizzle(const VectorRegister4Double& Vec)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(InLane1(Index0, Index1) && InLane0(Index2, Index3))"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(InLane0(Index0, Index1) && InLane0(Index2, Index3))"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(InLane1(Index0, Index1) && InLane1(Index2, Index3))"
  },
  {
    "label": "_mm256_permute4x64_pd()",
    "kind": "Method",
    "detail": "Function (} else { # if UE_PLATFORM_MATH_USE_AVX_2 return)",
    "insertText": "_mm256_permute4x64_pd(Vec, SHUFFLEMASK(Index0, Index1, Index2, Index3))"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "VectorRegister4Double(SelectVectorSwizzle2<Index0, Index1>(Vec), SelectVectorSwizzle2<Index2, Index3>(Vec))"
  },
  {
    "label": "VectorSwizzleTemplate()",
    "kind": "Method",
    "detail": "Function (} # endif template<int Index0,int Index1,int Index2,int Index3> VectorRegister4Double)",
    "insertText": "VectorSwizzleTemplate(const VectorRegister4Double& Vec)"
  },
  {
    "label": "Index3()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_AVX return SelectVectorSwizzle<Index0,Index1,Index2,)",
    "insertText": "Index3(Vec)"
  },
  {
    "label": "VectorReplicateImpl4()",
    "kind": "Method",
    "detail": "Function (} template<int Index> VectorRegister4Double)",
    "insertText": "VectorReplicateImpl4(const VectorRegister4Double& Vec)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (VectorRegister2Double Temp = VectorReplicateImpl2<)",
    "insertText": "Index(Vec.GetXY())"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (} else { VectorRegister2Double Temp = VectorReplicateImpl2<)",
    "insertText": "Index(Vec.GetZW())"
  },
  {
    "label": "VectorReplicateTemplate()",
    "kind": "Method",
    "detail": "Function (} } template<int Index> VectorRegister4Double)",
    "insertText": "VectorReplicateTemplate(const VectorRegister4Double& Vec)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_AVX_2 return VectorSwizzleTemplate<Index,Index,Index,)",
    "insertText": "Index(Vec)"
  },
  {
    "label": "ShuffleLanes()",
    "kind": "Method",
    "detail": "Function (# endif } # if UE_PLATFORM_MATH_USE_AVX template<int Lane0,int Lane1> VectorRegister4Double)",
    "insertText": "ShuffleLanes(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "SelectVectorShuffle()",
    "kind": "Method",
    "detail": "Function (} # endif template<int Index0,int Index1,int Index2,int Index3> VectorRegister4Double)",
    "insertText": "SelectVectorShuffle(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "ShuffleLanes()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Double Blended =)",
    "insertText": "ShuffleLanes(Vec1, Vec2)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(InSameLane(Index0, Index1) && OutOfLane(Index2, Index3))"
  },
  {
    "label": "Index1()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Double Vec1_XY = VectorSwizzleTemplate<Index0,)",
    "insertText": "Index1(Vec1)"
  },
  {
    "label": "Index3()",
    "kind": "Method",
    "detail": "Function (const VectorRegister2Double Vec2_ZW = SelectVectorSwizzle2<Index2,)",
    "insertText": "Index3(Vec2)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(OutOfLane(Index0, Index1) && InSameLane(Index2, Index3))"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "VectorRegister4Double(SelectVectorSwizzle2<Index0, Index1>(Vec1), SelectVectorSwizzle2<Index2, Index3>(Vec2))"
  },
  {
    "label": "VectorShuffleTemplate()",
    "kind": "Method",
    "detail": "Function (} # endif template<int Index0,int Index1,int Index2,int Index3> VectorRegister4Double)",
    "insertText": "VectorShuffleTemplate(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "VectorSwizzleTemplate()",
    "kind": "Method",
    "detail": "Function (} template<int Index0,int Index1,int Index2,int Index3> VectorRegister4Float)",
    "insertText": "VectorSwizzleTemplate(const VectorRegister4Float& Vec)"
  },
  {
    "label": "_mm_shuffle_ps()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Result =)",
    "insertText": "_mm_shuffle_ps(Vec, Vec, SHUFFLEMASK(Index0, Index1, Index2, Index3))"
  },
  {
    "label": "VectorReplicateTemplate()",
    "kind": "Method",
    "detail": "Function (} # endif template<int Index> VectorRegister4Float)",
    "insertText": "VectorReplicateTemplate(const VectorRegister4Float& Vec)"
  },
  {
    "label": "VectorShuffleTemplate()",
    "kind": "Method",
    "detail": "Function (} template<int Index0,int Index1,int Index2,int Index3> VectorRegister4Float)",
    "insertText": "VectorShuffleTemplate(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (} # undef OutOfLane # undef InSameLane # undef InLane1 # undef InLane0 } # define)",
    "insertText": "VectorReplicate(Vec, ElementIndex ) SSEPermuteHelpers::VectorReplicateTemplate<ElementIndex>(Vec) #define VectorSwizzle( Vec, X, Y, Z, W ) SSEPermuteHelpers::VectorSwizzleTemplate<X,Y,Z,W>( Vec ) #define VectorShuffle( Vec1, Vec2, X, Y, Z, W ) SSEPermuteHelpers::VectorShuffleTemplate<X,Y,Z,W>( Vec1, Vec2 ) FORCEINLINE VectorRegister4Float VectorAbs(const VectorRegister4Float& Vec)"
  },
  {
    "label": "VectorAbs()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorAbs(const VectorRegister4Double& Vec)"
  },
  {
    "label": "MakeVectorRegister2DoubleMask()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX VectorRegister2Double DoubleSignMask2d =)",
    "insertText": "MakeVectorRegister2DoubleMask(~(uint64(1) << 63), ~(uint64(1) << 63))"
  },
  {
    "label": "_mm_and_pd()",
    "kind": "Method",
    "detail": "Function (Result . XY =)",
    "insertText": "_mm_and_pd(Vec.XY, DoubleSignMask2d)"
  },
  {
    "label": "_mm_and_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_and_pd(Vec.ZW, DoubleSignMask2d)"
  },
  {
    "label": "_mm256_and_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_and_pd(Vec, GlobalVectorConstants::DoubleSignMask())"
  },
  {
    "label": "VectorNegate()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorNegate(const VectorRegister4Float& Vec)"
  },
  {
    "label": "VectorNegate()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorNegate(const VectorRegister4Double& Vec)"
  },
  {
    "label": "_mm_sub_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_sub_pd(_mm_setzero_pd(), Vec.XY)"
  },
  {
    "label": "_mm_sub_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_sub_pd(_mm_setzero_pd(), Vec.ZW)"
  },
  {
    "label": "_mm256_sub_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_sub_pd(_mm256_setzero_pd(), Vec)"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorAdd(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorAdd(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "_mm_add_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_add_pd(Vec1.XY, Vec2.XY)"
  },
  {
    "label": "_mm_add_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_add_pd(Vec1.ZW, Vec2.ZW)"
  },
  {
    "label": "_mm256_add_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_add_pd(Vec1, Vec2)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorSubtract(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorSubtract(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "_mm_sub_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_sub_pd(Vec1.XY, Vec2.XY)"
  },
  {
    "label": "_mm_sub_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_sub_pd(Vec1.ZW, Vec2.ZW)"
  },
  {
    "label": "_mm256_sub_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_sub_pd(Vec1, Vec2)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorMultiply(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorMultiply(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "_mm_mul_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_mul_pd(Vec1.XY, Vec2.XY)"
  },
  {
    "label": "_mm_mul_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_mul_pd(Vec1.ZW, Vec2.ZW)"
  },
  {
    "label": "_mm256_mul_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_mul_pd(Vec1, Vec2)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorMultiplyAdd(const VectorRegister4Float& A, const VectorRegister4Float& B, const VectorRegister4Float& C)"
  },
  {
    "label": "_mm_fmadd_ps()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_FMA3 return)",
    "insertText": "_mm_fmadd_ps(A, B, C)"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "VectorAdd(VectorMultiply(A, B), C)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorMultiplyAdd(const VectorRegister4Double& A, const VectorRegister4Double& B, const VectorRegister4Double& C)"
  },
  {
    "label": "_mm256_fmadd_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_FMA3&& UE_PLATFORM_MATH_USE_AVX return)",
    "insertText": "_mm256_fmadd_pd(A, B, C)"
  },
  {
    "label": "_mm_fmadd_pd()",
    "kind": "Method",
    "detail": "Function (# elif UE_PLATFORM_MATH_USE_FMA3 VectorRegister4Double Result ; Result . XY =)",
    "insertText": "_mm_fmadd_pd(A.XY, B.XY, C.XY)"
  },
  {
    "label": "_mm_fmadd_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_fmadd_pd(A.ZW, B.ZW, C.ZW)"
  },
  {
    "label": "VectorNegateMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorNegateMultiplyAdd(const VectorRegister4Float& A, const VectorRegister4Float& B, const VectorRegister4Float& C)"
  },
  {
    "label": "_mm_fnmadd_ps()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_FMA3 return)",
    "insertText": "_mm_fnmadd_ps(A, B, C)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "VectorSubtract(C, VectorMultiply(A, B))"
  },
  {
    "label": "VectorNegateMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorNegateMultiplyAdd(const VectorRegister4Double& A, const VectorRegister4Double& B, const VectorRegister4Double& C)"
  },
  {
    "label": "_mm256_fnmadd_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_FMA3&& UE_PLATFORM_MATH_USE_AVX return)",
    "insertText": "_mm256_fnmadd_pd(A, B, C)"
  },
  {
    "label": "_mm_fnmadd_pd()",
    "kind": "Method",
    "detail": "Function (# elif UE_PLATFORM_MATH_USE_FMA3 VectorRegister4Double Result ; Result . XY =)",
    "insertText": "_mm_fnmadd_pd(A.XY, B.XY, C.XY)"
  },
  {
    "label": "_mm_fnmadd_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_fnmadd_pd(A.ZW, B.ZW, C.ZW)"
  },
  {
    "label": "VectorDivide()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorDivide(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorDivide()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorDivide(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "_mm_div_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_div_pd(Vec1.XY, Vec2.XY)"
  },
  {
    "label": "_mm_div_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_div_pd(Vec1.ZW, Vec2.ZW)"
  },
  {
    "label": "_mm256_div_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_div_pd(Vec1, Vec2)"
  },
  {
    "label": "InternalVectorDot3X()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } namespace SSEVectorHelperFuncs { VectorRegister4Float)",
    "insertText": "InternalVectorDot3X(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Prod =)",
    "insertText": "VectorMultiply(Vec1, Vec2)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Shuf =)",
    "insertText": "VectorSwizzle(Prod, 1, 1, 3, 3)"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Sum =)",
    "insertText": "VectorAdd(Prod, Shuf)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (Shuf =)",
    "insertText": "VectorSwizzle(Prod, 2, 3, 2, 3)"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (Sum =)",
    "insertText": "VectorAdd(Sum, Shuf)"
  },
  {
    "label": "_mm_fmadd_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_FMA3 A =)",
    "insertText": "_mm_fmadd_pd(Vec1.ZW, Vec2.ZW, T)"
  },
  {
    "label": "_mm_add_pd()",
    "kind": "Method",
    "detail": "Function (# else A =)",
    "insertText": "_mm_add_pd(_mm_mul_pd(Vec1.ZW, Vec2.ZW), T)"
  },
  {
    "label": "_mm_shuffle_pd()",
    "kind": "Method",
    "detail": "Function (# endif T =)",
    "insertText": "_mm_shuffle_pd(T, T, SHUFFLEMASK2(1, 0))"
  },
  {
    "label": "_mm_add_pd()",
    "kind": "Method",
    "detail": "Function (T =)",
    "insertText": "_mm_add_pd(A, T)"
  },
  {
    "label": "VectorDot3Scalar()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "VectorDot3Scalar(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "VectorGetComponent()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_AVX return)",
    "insertText": "VectorGetComponent(SSEVectorHelperFuncs::InternalVectorDot3X_Full(Vec1, Vec2), 0)"
  },
  {
    "label": "InternalVectorDot3X_Half()",
    "kind": "Method",
    "detail": "Function (# else VectorRegister2Double T =)",
    "insertText": "InternalVectorDot3X_Half(Vec1, Vec2)"
  },
  {
    "label": "VectorDot3()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorDot3(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorDot3()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorDot3(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_AVX return)",
    "insertText": "VectorReplicate(SSEVectorHelperFuncs::InternalVectorDot3X_Full(Vec1, Vec2), 0)"
  },
  {
    "label": "_mm_shuffle_pd()",
    "kind": "Method",
    "detail": "Function (T =)",
    "insertText": "_mm_shuffle_pd(T, T, SHUFFLEMASK2(0, 0))"
  },
  {
    "label": "VectorDot4()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorDot4(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (T =)",
    "insertText": "VectorSwizzle(R, 1, 0, 3, 2)"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (R =)",
    "insertText": "VectorAdd(R, T)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (T =)",
    "insertText": "VectorSwizzle(R, 2, 3, 0, 1)"
  },
  {
    "label": "VectorDot4()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorDot4(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "_mm_shuffle_pd()",
    "kind": "Method",
    "detail": "Function (# endif T =)",
    "insertText": "_mm_shuffle_pd(A, A, SHUFFLEMASK2(1, 0))"
  },
  {
    "label": "VectorCompareEQ()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorCompareEQ(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorCompareEQ()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorCompareEQ(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "_mm_cmpeq_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_cmpeq_pd(Vec1.XY, Vec2.XY)"
  },
  {
    "label": "_mm_cmpeq_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_cmpeq_pd(Vec1.ZW, Vec2.ZW)"
  },
  {
    "label": "_mm256_cmp_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_cmp_pd(Vec1, Vec2, _CMP_EQ_OQ)"
  },
  {
    "label": "VectorCompareNE()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorCompareNE(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorCompareNE()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorCompareNE(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "_mm_cmpneq_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_cmpneq_pd(Vec1.XY, Vec2.XY)"
  },
  {
    "label": "_mm_cmpneq_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_cmpneq_pd(Vec1.ZW, Vec2.ZW)"
  },
  {
    "label": "_mm256_cmp_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_cmp_pd(Vec1, Vec2, _CMP_NEQ_UQ)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorCompareGT(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorCompareGT(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "_mm_cmpgt_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_cmpgt_pd(Vec1.XY, Vec2.XY)"
  },
  {
    "label": "_mm_cmpgt_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_cmpgt_pd(Vec1.ZW, Vec2.ZW)"
  },
  {
    "label": "_mm256_cmp_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_cmp_pd(Vec1, Vec2, _CMP_GT_OQ)"
  },
  {
    "label": "VectorCompareGE()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorCompareGE(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorCompareGE()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorCompareGE(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "_mm_cmpge_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_cmpge_pd(Vec1.XY, Vec2.XY)"
  },
  {
    "label": "_mm_cmpge_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_cmpge_pd(Vec1.ZW, Vec2.ZW)"
  },
  {
    "label": "_mm256_cmp_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_cmp_pd(Vec1, Vec2, _CMP_GE_OQ)"
  },
  {
    "label": "VectorCompareLT()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorCompareLT(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorCompareLT()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorCompareLT(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "_mm_cmplt_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_cmplt_pd(Vec1.XY, Vec2.XY)"
  },
  {
    "label": "_mm_cmplt_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_cmplt_pd(Vec1.ZW, Vec2.ZW)"
  },
  {
    "label": "_mm256_cmp_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_cmp_pd(Vec1, Vec2, _CMP_LT_OQ)"
  },
  {
    "label": "VectorCompareLE()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorCompareLE(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorCompareLE()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorCompareLE(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "_mm_cmple_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_cmple_pd(Vec1.XY, Vec2.XY)"
  },
  {
    "label": "_mm_cmple_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_cmple_pd(Vec1.ZW, Vec2.ZW)"
  },
  {
    "label": "_mm256_cmp_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_cmp_pd(Vec1, Vec2, _CMP_LE_OQ)"
  },
  {
    "label": "VectorSelect()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorSelect(const VectorRegister4Float& Mask, const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorSelect()",
    "kind": "Method",
    "detail": "Function (} VectorRegister2Double)",
    "insertText": "VectorSelect(const VectorRegister2Double& Mask, const VectorRegister2Double& Vec1, const VectorRegister2Double& Vec2)"
  },
  {
    "label": "VectorSelect()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorSelect(const VectorRegister4Double& Mask, const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "VectorSelect()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "VectorSelect(Mask.XY, Vec1.XY, Vec2.XY)"
  },
  {
    "label": "VectorSelect()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "VectorSelect(Mask.ZW, Vec1.ZW, Vec2.ZW)"
  },
  {
    "label": "_mm256_or_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_or_pd(_mm256_and_pd(Mask, Vec1), _mm256_andnot_pd(Mask, Vec2))"
  },
  {
    "label": "VectorBitwiseOr()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorBitwiseOr(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorBitwiseOr()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorBitwiseOr(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "_mm_or_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_or_pd(Vec1.XY, Vec2.XY)"
  },
  {
    "label": "_mm_or_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_or_pd(Vec1.ZW, Vec2.ZW)"
  },
  {
    "label": "_mm256_or_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_or_pd(Vec1, Vec2)"
  },
  {
    "label": "VectorBitwiseAnd()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorBitwiseAnd(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorBitwiseAnd()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorBitwiseAnd(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "_mm_and_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_and_pd(Vec1.XY, Vec2.XY)"
  },
  {
    "label": "_mm_and_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_and_pd(Vec1.ZW, Vec2.ZW)"
  },
  {
    "label": "_mm256_and_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_and_pd(Vec1, Vec2)"
  },
  {
    "label": "VectorBitwiseXor()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorBitwiseXor(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorBitwiseXor()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorBitwiseXor(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "_mm_xor_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_xor_pd(Vec1.XY, Vec2.XY)"
  },
  {
    "label": "_mm_xor_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_xor_pd(Vec1.ZW, Vec2.ZW)"
  },
  {
    "label": "_mm256_xor_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_xor_pd(Vec1, Vec2)"
  },
  {
    "label": "VectorCross()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorCross(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float A =)",
    "insertText": "VectorSwizzle(Vec2, 1, 2, 0, 3)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float B =)",
    "insertText": "VectorSwizzle(Vec1, 1, 2, 0, 3)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (A =)",
    "insertText": "VectorMultiply(A, Vec1)"
  },
  {
    "label": "VectorNegateMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (A =)",
    "insertText": "VectorNegateMultiplyAdd(B, Vec2, A)"
  },
  {
    "label": "VectorCross()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorCross(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "VectorPow()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "VectorPow(const VectorRegister4Float& Base, const VectorRegister4Float& Exponent)"
  },
  {
    "label": "_mm_pow_ps()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "_mm_pow_ps(Base, Exponent)"
  },
  {
    "label": "exp_ps()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "exp_ps(_mm_mul_ps(SSE::log_ps(Base), Exponent))"
  },
  {
    "label": "VectorPow()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorPow(const VectorRegister4Double& Base, const VectorRegister4Double& Exponent)"
  },
  {
    "label": "_mm256_pow_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML_AVX return)",
    "insertText": "_mm256_pow_pd(Base, Exponent)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (# elif UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "VectorRegister4Double(_mm_pow_pd(Base.XY, Exponent.XY), _mm_pow_pd(Base.ZW, Exponent.ZW))"
  },
  {
    "label": "Values()",
    "kind": "Method",
    "detail": "Function (# else AlignedDouble4)",
    "insertText": "Values(Base)"
  },
  {
    "label": "Exponents()",
    "kind": "Method",
    "detail": "Function (AlignedDouble4)",
    "insertText": "Exponents(Exponent)"
  },
  {
    "label": "Pow()",
    "kind": "Method",
    "detail": "Function (Values [ 0 ] =)",
    "insertText": "Pow(Values[0], Exponents[0])"
  },
  {
    "label": "Pow()",
    "kind": "Method",
    "detail": "Function (Values [ 1 ] =)",
    "insertText": "Pow(Values[1], Exponents[1])"
  },
  {
    "label": "Pow()",
    "kind": "Method",
    "detail": "Function (Values [ 2 ] =)",
    "insertText": "Pow(Values[2], Exponents[2])"
  },
  {
    "label": "Pow()",
    "kind": "Method",
    "detail": "Function (Values [ 3 ] =)",
    "insertText": "Pow(Values[3], Exponents[3])"
  },
  {
    "label": "VectorSqrt()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorSqrt(const VectorRegister4Float& Vec)"
  },
  {
    "label": "VectorSqrt()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorSqrt(const VectorRegister4Double& Vec)"
  },
  {
    "label": "_mm256_sqrt_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_AVX return)",
    "insertText": "_mm256_sqrt_pd(Vec)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "VectorRegister4Double(_mm_sqrt_pd(Vec.XY), _mm_sqrt_pd(Vec.ZW))"
  },
  {
    "label": "VectorReciprocalSqrtEstimate()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorReciprocalSqrtEstimate(const VectorRegister4Float& Vec)"
  },
  {
    "label": "VectorReciprocalSqrt()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "VectorReciprocalSqrt(const VectorRegister4Float& Vec)"
  },
  {
    "label": "_mm_invsqrt_ps()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML&& 0 return)",
    "insertText": "_mm_invsqrt_ps(Vec)"
  },
  {
    "label": "VectorDivide()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "VectorDivide(GlobalVectorConstants::FloatOne, VectorSqrt(Vec))"
  },
  {
    "label": "VectorReciprocalSqrt()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorReciprocalSqrt(const VectorRegister4Double& Vec)"
  },
  {
    "label": "VectorDivide()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_AVX return)",
    "insertText": "VectorDivide(GlobalVectorConstants::DoubleOne, _mm256_sqrt_pd(Vec))"
  },
  {
    "label": "VectorDivide()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "VectorDivide(GlobalVectorConstants::DoubleOne, VectorRegister4Double(_mm_sqrt_pd(Vec.XY), _mm_sqrt_pd(Vec.ZW)))"
  },
  {
    "label": "VectorReciprocalSqrtEstimate()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorReciprocalSqrtEstimate(const VectorRegister4Double& Vec)"
  },
  {
    "label": "_mm256_invsqrt_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML_AVX return)",
    "insertText": "_mm256_invsqrt_pd(Vec)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (# elif UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "VectorRegister4Double(_mm_invsqrt_pd(Vec.XY), _mm_invsqrt_pd(Vec.ZW))"
  },
  {
    "label": "VectorReciprocalSqrt()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "VectorReciprocalSqrt(Vec)"
  },
  {
    "label": "VectorReciprocalLen()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorReciprocalLen(const VectorRegister4Float& Vector)"
  },
  {
    "label": "VectorReciprocalLen()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorReciprocalLen(const VectorRegister4Double& Vector)"
  },
  {
    "label": "VectorReciprocalLenEstimate()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "VectorReciprocalLenEstimate(const VectorRegister4Float& Vector)"
  },
  {
    "label": "VectorReciprocalLenEstimate()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorReciprocalLenEstimate(const VectorRegister4Double& Vector)"
  },
  {
    "label": "VectorReciprocalEstimate()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "VectorReciprocalEstimate(const VectorRegister4Float& Vec)"
  },
  {
    "label": "VectorReciprocal()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "VectorReciprocal(const VectorRegister4Float& Vec)"
  },
  {
    "label": "VectorReciprocal()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorReciprocal(const VectorRegister4Double& Vec)"
  },
  {
    "label": "VectorReciprocalEstimate()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorReciprocalEstimate(const VectorRegister4Double& Vec)"
  },
  {
    "label": "VectorMergeVecXYZ_VecW()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "VectorMergeVecXYZ_VecW(const VectorRegister4Float& VecXYZ, const VectorRegister4Float& VecW)"
  },
  {
    "label": "VectorMergeVecXYZ_VecW()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorMergeVecXYZ_VecW(const VectorRegister4Double& VecXYZ, const VectorRegister4Double& VecW)"
  },
  {
    "label": "VectorSet_W0()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "VectorSet_W0(const VectorRegister4Float& Vec)"
  },
  {
    "label": "VectorSet_W0()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorSet_W0(const VectorRegister4Double& Vec)"
  },
  {
    "label": "_mm_move_sd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY = Vec . XY ; Result . ZW =)",
    "insertText": "_mm_move_sd(_mm_setzero_pd(), Vec.ZW)"
  },
  {
    "label": "_mm256_blend_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_blend_pd(Vec, VectorZeroDouble(), 0b1000)"
  },
  {
    "label": "VectorSet_W1()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorSet_W1(const VectorRegister4Float& Vec)"
  },
  {
    "label": "VectorSet_W1()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorSet_W1(const VectorRegister4Double& Vec)"
  },
  {
    "label": "_mm_move_sd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY = Vec . XY ; Result . ZW =)",
    "insertText": "_mm_move_sd(GlobalVectorConstants::DoubleOne2d, Vec.ZW)"
  },
  {
    "label": "_mm256_blend_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_blend_pd(Vec, VectorOneDouble(), 0b1000)"
  },
  {
    "label": "VectorMatrixMultiply()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } void)",
    "insertText": "VectorMatrixMultiply(FMatrix44f* Result, const FMatrix44f* Matrix1, const FMatrix44f* Matrix2)"
  },
  {
    "label": "VectorMatrixMultiply()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorMatrixMultiply(FMatrix44d* Result, const FMatrix44d* Matrix1, const FMatrix44d* Matrix2)"
  },
  {
    "label": "VectorMatrixInverse()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "VectorMatrixInverse(FMatrix44f* DstMatrix, const FMatrix44f* SrcMatrix)"
  },
  {
    "label": "VectorTransformVector()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "VectorTransformVector(const VectorRegister4Float& VecP, const FMatrix44f* MatrixM)"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float*)",
    "insertText": "M(const VectorRegister4Float *)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float VTempX,VTempY,VTempZ,VTempW ; VTempX =)",
    "insertText": "VectorReplicate(VecP, 0)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (VTempY =)",
    "insertText": "VectorReplicate(VecP, 1)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (VTempZ =)",
    "insertText": "VectorReplicate(VecP, 2)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (VTempW =)",
    "insertText": "VectorReplicate(VecP, 3)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (VTempX =)",
    "insertText": "VectorMultiply(VTempX, M[0])"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (VTempX =)",
    "insertText": "VectorMultiplyAdd(VTempY, M[1], VTempX)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (VTempX =)",
    "insertText": "VectorMultiplyAdd(VTempZ, M[2], VTempX)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (VTempX =)",
    "insertText": "VectorMultiplyAdd(VTempW, M[3], VTempX)"
  },
  {
    "label": "MRows()",
    "kind": "Method",
    "detail": "Function (typedef double Double4x4 [ 4 ] [ 4 ] ; const Double4x4&)",
    "insertText": "MRows((const Double4x4*)MatrixM)"
  },
  {
    "label": "VectorLoad()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double M [ 4 ] ; M [ 0 ] =)",
    "insertText": "VectorLoad(MRows[0])"
  },
  {
    "label": "VectorLoad()",
    "kind": "Method",
    "detail": "Function (M [ 1 ] =)",
    "insertText": "VectorLoad(MRows[1])"
  },
  {
    "label": "VectorLoad()",
    "kind": "Method",
    "detail": "Function (M [ 2 ] =)",
    "insertText": "VectorLoad(MRows[2])"
  },
  {
    "label": "VectorLoad()",
    "kind": "Method",
    "detail": "Function (M [ 3 ] =)",
    "insertText": "VectorLoad(MRows[3])"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double VTempX,VTempY,VTempZ,VTempW ; VectorRegister4Double VecPDouble = VecP ; VTempX =)",
    "insertText": "VectorReplicate(VecPDouble, 0)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (VTempY =)",
    "insertText": "VectorReplicate(VecPDouble, 1)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (VTempZ =)",
    "insertText": "VectorReplicate(VecPDouble, 2)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (VTempW =)",
    "insertText": "VectorReplicate(VecPDouble, 3)"
  },
  {
    "label": "VectorTransformVector()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorTransformVector(const VectorRegister4Double& VecP, const FMatrix44d* MatrixM)"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float*)",
    "insertText": "M(const VectorRegister4Float*)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (VTempX =)",
    "insertText": "VectorMultiply(VTempX, VectorRegister4Double(M[0]))"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (VTempX =)",
    "insertText": "VectorMultiplyAdd(VTempY, VectorRegister4Double(M[1]), VTempX)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (VTempX =)",
    "insertText": "VectorMultiplyAdd(VTempZ, VectorRegister4Double(M[2]), VTempX)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (VTempX =)",
    "insertText": "VectorMultiplyAdd(VTempW, VectorRegister4Double(M[3]), VTempX)"
  },
  {
    "label": "VectorMin()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorMin(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "_mm_min_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_min_pd(Vec1.XY, Vec2.XY)"
  },
  {
    "label": "_mm_min_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_min_pd(Vec1.ZW, Vec2.ZW)"
  },
  {
    "label": "_mm256_min_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_min_pd(Vec1, Vec2)"
  },
  {
    "label": "VectorMax()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorMax(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorMax()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorMax(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "_mm_max_pd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_max_pd(Vec1.XY, Vec2.XY)"
  },
  {
    "label": "_mm_max_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_max_pd(Vec1.ZW, Vec2.ZW)"
  },
  {
    "label": "_mm256_max_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_max_pd(Vec1, Vec2)"
  },
  {
    "label": "VectorCombineHigh()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorCombineHigh(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorCombineHigh()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorCombineHigh(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "VectorCombineLow()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "VectorCombineLow(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorCombineLow()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorCombineLow(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "VectorDeinterleave()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VectorDeinterleave(VectorRegister4Float& RESTRICT OutEvens, VectorRegister4Float& RESTRICT OutOdds, const VectorRegister4Float& RESTRICT Lo, const VectorRegister4Float& RESTRICT Hi)"
  },
  {
    "label": "VectorShuffle()",
    "kind": "Method",
    "detail": "Function (OutEvens =)",
    "insertText": "VectorShuffle(Lo, Hi, 0, 2, 0, 2)"
  },
  {
    "label": "VectorShuffle()",
    "kind": "Method",
    "detail": "Function (OutOdds =)",
    "insertText": "VectorShuffle(Lo, Hi, 1, 3, 1, 3)"
  },
  {
    "label": "VectorDeinterleave()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VectorDeinterleave(VectorRegister4Double& RESTRICT OutEvens, VectorRegister4Double& RESTRICT OutOdds, const VectorRegister4Double& RESTRICT Lo, const VectorRegister4Double& RESTRICT Hi)"
  },
  {
    "label": "VectorMaskBits()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "VectorMaskBits(const VectorRegister4Float& VecMask)"
  },
  {
    "label": "VectorMaskBits()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "VectorMaskBits(const VectorRegister4Double& VecMask)"
  },
  {
    "label": "_mm_movemask_pd()",
    "kind": "Method",
    "detail": "Function (# if ! UE_PLATFORM_MATH_USE_AVX const int MaskXY =)",
    "insertText": "_mm_movemask_pd(VecMask.XY)"
  },
  {
    "label": "_mm_movemask_pd()",
    "kind": "Method",
    "detail": "Function (const int MaskZW =)",
    "insertText": "_mm_movemask_pd(VecMask.ZW)"
  },
  {
    "label": "_mm256_movemask_pd()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "_mm256_movemask_pd(VecMask)"
  },
  {
    "label": "VectorLoadByte4()",
    "kind": "Method",
    "detail": "Function (# endif } # define)",
    "insertText": "VectorLoadByte4(Ptr ) _mm_cvtepi32_ps(_mm_cvtepu8_epi32(_mm_cvtsi32_si128(*(int32*)Ptr))) FORCEINLINE VectorRegister4Float VectorLoadSignedByte4(const void* Ptr)"
  },
  {
    "label": "_mm_cvtepi8_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i Temp =)",
    "insertText": "_mm_cvtepi8_epi32(_mm_cvtsi32_si128(*(int32*)Ptr))"
  },
  {
    "label": "VectorLoadByte4Reverse()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "VectorLoadByte4Reverse(void* Ptr)"
  },
  {
    "label": "VectorLoadByte4()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Temp =)",
    "insertText": "VectorLoadByte4(Ptr)"
  },
  {
    "label": "VectorStoreByte4()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VectorStoreByte4(const VectorRegister4Float& Vec, void* Ptr)"
  },
  {
    "label": "_mm_cvttps_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i VecInt32 =)",
    "insertText": "_mm_cvttps_epi32(Vec)"
  },
  {
    "label": "_mm_packs_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i VecInt16 =)",
    "insertText": "_mm_packs_epi32(VecInt32, VecInt32)"
  },
  {
    "label": "_mm_packus_epi16()",
    "kind": "Method",
    "detail": "Function (__m128i VecUInt8 =)",
    "insertText": "_mm_packus_epi16(VecInt16, VecInt16)"
  },
  {
    "label": "VectorStoreSignedByte4()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VectorStoreSignedByte4(const VectorRegister4Float& Vec, void* Ptr)"
  },
  {
    "label": "_mm_packs_epi16()",
    "kind": "Method",
    "detail": "Function (__m128i VecInt8 =)",
    "insertText": "_mm_packs_epi16(VecInt16, VecInt16)"
  },
  {
    "label": "VectorLoadURGB10A2N()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "VectorLoadURGB10A2N(void* Ptr)"
  },
  {
    "label": "_mm_and_ps()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Tmp ; Tmp =)",
    "insertText": "_mm_and_ps(_mm_load_ps1((const float *)Ptr), MakeVectorRegisterFloat(0x3FFu, 0x3FFu << 10, 0x3FFu << 20, 0x3u << 30))"
  },
  {
    "label": "_mm_xor_ps()",
    "kind": "Method",
    "detail": "Function (Tmp =)",
    "insertText": "_mm_xor_ps(Tmp, MakeVectorRegister(0, 0, 0, 0x80000000))"
  },
  {
    "label": "_mm_cvtepi32_ps()",
    "kind": "Method",
    "detail": "Function (Tmp =)",
    "insertText": "_mm_cvtepi32_ps(*(const VectorRegister4Int*)&Tmp)"
  },
  {
    "label": "_mm_add_ps()",
    "kind": "Method",
    "detail": "Function (Tmp =)",
    "insertText": "_mm_add_ps(Tmp, MakeVectorRegister(0, 0, 0, 32768.0f*65536.0f))"
  },
  {
    "label": "_mm_mul_ps()",
    "kind": "Method",
    "detail": "Function (Tmp =)",
    "insertText": "_mm_mul_ps(Tmp, MakeVectorRegister(1.0f / 1023.0f, 1.0f / (1023.0f*1024.0f), 1.0f / (1023.0f*1024.0f*1024.0f), 1.0f / (3.0f*1024.0f*1024.0f*1024.0f)))"
  },
  {
    "label": "_mm_max_ps()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Tmp ; Tmp =)",
    "insertText": "_mm_max_ps(Vec, MakeVectorRegisterFloat(0.0f, 0.0f, 0.0f, 0.0f))"
  },
  {
    "label": "_mm_min_ps()",
    "kind": "Method",
    "detail": "Function (Tmp =)",
    "insertText": "_mm_min_ps(Tmp, MakeVectorRegisterFloat(1.0f, 1.0f, 1.0f, 1.0f))"
  },
  {
    "label": "_mm_mul_ps()",
    "kind": "Method",
    "detail": "Function (Tmp =)",
    "insertText": "_mm_mul_ps(Tmp, MakeVectorRegisterFloat(1023.0f, 1023.0f*1024.0f*0.5f, 1023.0f*1024.0f*1024.0f, 3.0f*1024.0f*1024.0f*1024.0f*0.5f))"
  },
  {
    "label": "_mm_cvttps_epi32()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Int TmpI ; TmpI =)",
    "insertText": "_mm_cvttps_epi32(Tmp)"
  },
  {
    "label": "_mm_and_si128()",
    "kind": "Method",
    "detail": "Function (TmpI =)",
    "insertText": "_mm_and_si128(TmpI, MakeVectorRegisterInt(0x3FFu, 0x3FFu << (10 - 1), 0x3FFu << 20, 0x3u << (30 - 1)))"
  },
  {
    "label": "_mm_shuffle_epi32()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Int TmpI2 ; TmpI2 =)",
    "insertText": "_mm_shuffle_epi32(TmpI, _MM_SHUFFLE(3, 2, 3, 2))"
  },
  {
    "label": "_mm_or_si128()",
    "kind": "Method",
    "detail": "Function (TmpI =)",
    "insertText": "_mm_or_si128(TmpI, TmpI2)"
  },
  {
    "label": "_mm_shuffle_epi32()",
    "kind": "Method",
    "detail": "Function (TmpI2 =)",
    "insertText": "_mm_shuffle_epi32(TmpI, _MM_SHUFFLE(1, 1, 1, 1))"
  },
  {
    "label": "_mm_add_epi32()",
    "kind": "Method",
    "detail": "Function (TmpI2 =)",
    "insertText": "_mm_add_epi32(TmpI2, TmpI2)"
  },
  {
    "label": "_mm_store_ss()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mm_store_ss((float *)Ptr, *(const VectorRegister4Float*)&TmpI)"
  },
  {
    "label": "VectorLoadURGBA16N()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "VectorLoadURGBA16N(Ptr ) _mm_cvtepi32_ps(_mm_cvtepu16_epi32(_mm_loadl_epi64((const __m128i*)Ptr))) FORCEINLINE VectorRegister4Float VectorLoadSRGBA16N(const void* Ptr)"
  },
  {
    "label": "_mm_cvtepi16_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i Temp =)",
    "insertText": "_mm_cvtepi16_epi32(_mm_loadl_epi64((const __m128i*)Ptr))"
  },
  {
    "label": "VectorStoreURGBA16N()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VectorStoreURGBA16N(const VectorRegister4Float& Vec, void* Ptr)"
  },
  {
    "label": "_mm_mul_ps()",
    "kind": "Method",
    "detail": "Function (Tmp =)",
    "insertText": "_mm_mul_ps(Tmp, MakeVectorRegisterFloat(65535.0f, 65535.0f, 65535.0f, 65535.0f))"
  },
  {
    "label": "_mm_cvtps_epi32()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Int TmpI =)",
    "insertText": "_mm_cvtps_epi32(Tmp)"
  },
  {
    "label": "_mm_storel_epi64()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mm_storel_epi64((__m128i*)Ptr, _mm_packus_epi32(TmpI, TmpI))"
  },
  {
    "label": "VectorAnyGreaterThan()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "VectorAnyGreaterThan(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorAnyGreaterThan()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "VectorAnyGreaterThan(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "VectorResetFloatRegisters()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "VectorResetFloatRegisters() #define VectorGetControlRegister() _mm_getcsr() #if PLATFORM_SUPPORTS_VECTOR_CONTROL_REGISTERS #define VectorSetControlRegister(ControlStatus) _mm_setcsr( ControlStatus ) #define VECTOR_ROUND_TOWARD_ZERO _MM_ROUND_TOWARD_ZERO #define VECTOR_DENORMALS_FLUSH_TO_ZERO _MM_FLUSH_ZERO_ON #else #define VectorSetControlRegister(...) #define VECTOR_ROUND_TOWARD_ZERO #define VECTOR_DENORMALS_FLUSH_TO_ZERO #endif FORCEINLINE VectorRegister4Float VectorQuaternionMultiply2( const VectorRegister4Float& Quat1, const VectorRegister4Float& Quat2)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Result =)",
    "insertText": "VectorMultiply(VectorReplicate(Quat1, 3), Quat2)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "VectorMultiplyAdd(VectorMultiply(VectorReplicate(Quat1, 0), VectorSwizzle(Quat2, 3, 2, 1, 0)), GlobalVectorConstants::QMULTI_SIGN_MASK0, Result)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "VectorMultiplyAdd(VectorMultiply(VectorReplicate(Quat1, 1), VectorSwizzle(Quat2, 2, 3, 0, 1)), GlobalVectorConstants::QMULTI_SIGN_MASK1, Result)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "VectorMultiplyAdd(VectorMultiply(VectorReplicate(Quat1, 2), VectorSwizzle(Quat2, 1, 0, 3, 2)), GlobalVectorConstants::QMULTI_SIGN_MASK2, Result)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "VectorMultiplyAdd(VectorMultiply(VectorReplicate(Quat1, 0), VectorSwizzle(Quat2, 3, 2, 1, 0)), GlobalVectorConstants::DOUBLE_QMULTI_SIGN_MASK0, Result)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "VectorMultiplyAdd(VectorMultiply(VectorReplicate(Quat1, 1), VectorSwizzle(Quat2, 2, 3, 0, 1)), GlobalVectorConstants::DOUBLE_QMULTI_SIGN_MASK1, Result)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "VectorMultiplyAdd(VectorMultiply(VectorReplicate(Quat1, 2), VectorSwizzle(Quat2, 1, 0, 3, 2)), GlobalVectorConstants::DOUBLE_QMULTI_SIGN_MASK2, Result)"
  },
  {
    "label": "VectorQuaternionMultiply2()",
    "kind": "Method",
    "detail": "Function (* Result =)",
    "insertText": "VectorQuaternionMultiply2(*Quat1, *Quat2)"
  },
  {
    "label": "VectorQuaternionMultiply()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VectorQuaternionMultiply(VectorRegister4Double* RESTRICT Result, const VectorRegister4Double* RESTRICT Quat1, const VectorRegister4Double* RESTRICT Quat2)"
  },
  {
    "label": "VectorContainsNaNOrInfinite()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "VectorContainsNaNOrInfinite(const VectorRegister4Float& Vec)"
  },
  {
    "label": "MakeVectorRegisterFloat()",
    "kind": "Method",
    "detail": "Function (union { float F ; uint32 U ; } InfUnion ; InfUnion . U = 0 x7F800000 ; const float Inf = InfUnion . F ; const VectorRegister4Float FloatInfinity =)",
    "insertText": "MakeVectorRegisterFloat(Inf, Inf, Inf, Inf)"
  },
  {
    "label": "VectorBitwiseAnd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float ExpTest =)",
    "insertText": "VectorBitwiseAnd(Vec, FloatInfinity)"
  },
  {
    "label": "VectorMaskBits()",
    "kind": "Method",
    "detail": "Function (bool IsFinite =)",
    "insertText": "VectorMaskBits(VectorCompareEQ(ExpTest, FloatInfinity))"
  },
  {
    "label": "MakeVectorRegisterDouble()",
    "kind": "Method",
    "detail": "Function (union { double D ; uint64 U ; } InfUnion ; InfUnion . U = 0 x7FF0000000000000 ; const double Inf = InfUnion . D ; const VectorRegister4Double DoubleInfinity =)",
    "insertText": "MakeVectorRegisterDouble(Inf, Inf, Inf, Inf)"
  },
  {
    "label": "VectorBitwiseAnd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double ExpTest =)",
    "insertText": "VectorBitwiseAnd(Vec, DoubleInfinity)"
  },
  {
    "label": "VectorMaskBits()",
    "kind": "Method",
    "detail": "Function (bool IsFinite =)",
    "insertText": "VectorMaskBits(VectorCompareEQ(ExpTest, DoubleInfinity))"
  },
  {
    "label": "TruncateVectorRegister2d()",
    "kind": "Method",
    "detail": "Function (} VectorRegister2Double)",
    "insertText": "TruncateVectorRegister2d(const VectorRegister2Double& V)"
  },
  {
    "label": "VectorTruncate()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorTruncate(const VectorRegister4Double& V)"
  },
  {
    "label": "TruncateVectorRegister2d()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "TruncateVectorRegister2d(V.XY)"
  },
  {
    "label": "TruncateVectorRegister2d()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "TruncateVectorRegister2d(V.ZW)"
  },
  {
    "label": "_mm256_round_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_round_pd(V, _MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)"
  },
  {
    "label": "VectorRound()",
    "kind": "Method",
    "detail": "Function (# endif return Result ; } VectorRegister4Float)",
    "insertText": "VectorRound(const VectorRegister4Float &Vec)"
  },
  {
    "label": "VectorRoundToIntHalfToEven()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Int)",
    "insertText": "VectorRoundToIntHalfToEven(const VectorRegister4Float& Vec)"
  },
  {
    "label": "VectorCeil()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "VectorCeil(const VectorRegister4Float& V)"
  },
  {
    "label": "VectorCeil()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorCeil(const VectorRegister4Double& V)"
  },
  {
    "label": "_mm256_round_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_AVX VectorRegister4Double Result ; Result =)",
    "insertText": "_mm256_round_pd(V, _MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)"
  },
  {
    "label": "_mm_ceil_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_ceil_pd(V.ZW)"
  },
  {
    "label": "VectorFloor()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorFloor(const VectorRegister4Double& V)"
  },
  {
    "label": "_mm256_round_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_AVX VectorRegister4Double Result ; Result =)",
    "insertText": "_mm256_round_pd(V, _MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)"
  },
  {
    "label": "_mm_floor_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_floor_pd(V.ZW)"
  },
  {
    "label": "VectorCompareLE()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float InvalidDivisorMask =)",
    "insertText": "VectorCompareLE(VectorAbs(Y), GlobalVectorConstants::SmallNumber)"
  },
  {
    "label": "_mm_fmod_ps()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML VectorRegister4Float Result =)",
    "insertText": "_mm_fmod_ps(X, Y)"
  },
  {
    "label": "XFloats()",
    "kind": "Method",
    "detail": "Function (# else AlignedFloat4)",
    "insertText": "XFloats(X), YFloats(Y)"
  },
  {
    "label": "fmodf()",
    "kind": "Method",
    "detail": "Function (XFloats [ 0 ] =)",
    "insertText": "fmodf(XFloats[0], YFloats[0])"
  },
  {
    "label": "fmodf()",
    "kind": "Method",
    "detail": "Function (XFloats [ 1 ] =)",
    "insertText": "fmodf(XFloats[1], YFloats[1])"
  },
  {
    "label": "fmodf()",
    "kind": "Method",
    "detail": "Function (XFloats [ 2 ] =)",
    "insertText": "fmodf(XFloats[2], YFloats[2])"
  },
  {
    "label": "fmodf()",
    "kind": "Method",
    "detail": "Function (XFloats [ 3 ] =)",
    "insertText": "fmodf(XFloats[3], YFloats[3])"
  },
  {
    "label": "ToVectorRegister()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Result = XFloats .)",
    "insertText": "ToVectorRegister()"
  },
  {
    "label": "VectorSelect()",
    "kind": "Method",
    "detail": "Function (# endif Result =)",
    "insertText": "VectorSelect(InvalidDivisorMask, GlobalVectorConstants::FloatZero, Result)"
  },
  {
    "label": "VectorCompareLE()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double InvalidDivisorMask =)",
    "insertText": "VectorCompareLE(VectorAbs(Y), GlobalVectorConstants::DoubleSmallNumber)"
  },
  {
    "label": "_mm256_fmod_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML_AVX VectorRegister4Double DoubleResult =)",
    "insertText": "_mm256_fmod_pd(X, Y)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (# elif UE_PLATFORM_MATH_USE_SVML VectorRegister4Double DoubleResult =)",
    "insertText": "VectorRegister4Double(_mm_fmod_pd(X.XY, Y.XY), _mm_fmod_pd(X.ZW, Y.ZW))"
  },
  {
    "label": "XDoubles()",
    "kind": "Method",
    "detail": "Function (# else AlignedDouble4)",
    "insertText": "XDoubles(X), YDoubles(Y)"
  },
  {
    "label": "fmod()",
    "kind": "Method",
    "detail": "Function (XDoubles [ 0 ] =)",
    "insertText": "fmod(XDoubles[0], YDoubles[0])"
  },
  {
    "label": "fmod()",
    "kind": "Method",
    "detail": "Function (XDoubles [ 1 ] =)",
    "insertText": "fmod(XDoubles[1], YDoubles[1])"
  },
  {
    "label": "fmod()",
    "kind": "Method",
    "detail": "Function (XDoubles [ 2 ] =)",
    "insertText": "fmod(XDoubles[2], YDoubles[2])"
  },
  {
    "label": "fmod()",
    "kind": "Method",
    "detail": "Function (XDoubles [ 3 ] =)",
    "insertText": "fmod(XDoubles[3], YDoubles[3])"
  },
  {
    "label": "VectorSelect()",
    "kind": "Method",
    "detail": "Function (# endif DoubleResult =)",
    "insertText": "VectorSelect(InvalidDivisorMask, GlobalVectorConstants::DoubleZero, DoubleResult)"
  },
  {
    "label": "VectorCompareGE()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Mask =)",
    "insertText": "VectorCompareGE(X, GlobalVectorConstants::FloatZero)"
  },
  {
    "label": "VectorSign()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorSign(const VectorRegister4Double& X)"
  },
  {
    "label": "VectorCompareGE()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Mask =)",
    "insertText": "VectorCompareGE(X, (GlobalVectorConstants::DoubleZero))"
  },
  {
    "label": "VectorStep()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "VectorStep(const VectorRegister4Float& X)"
  },
  {
    "label": "VectorStep()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Double)",
    "insertText": "VectorStep(const VectorRegister4Double& X)"
  },
  {
    "label": "VectorCompareGE()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Mask =)",
    "insertText": "VectorCompareGE(X, GlobalVectorConstants::DoubleZero)"
  },
  {
    "label": "VectorExp()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "VectorExp(const VectorRegister4Float& X)"
  },
  {
    "label": "_mm_exp_ps()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "_mm_exp_ps(X)"
  },
  {
    "label": "exp_ps()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "exp_ps(X)"
  },
  {
    "label": "VectorExp()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorExp(const VectorRegister4Double& X)"
  },
  {
    "label": "_mm256_exp_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML_AVX return)",
    "insertText": "_mm256_exp_pd(X)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (# elif UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "VectorRegister4Double(_mm_exp_pd(X.XY), _mm_exp_pd(X.ZW))"
  },
  {
    "label": "Doubles()",
    "kind": "Method",
    "detail": "Function (# else AlignedDouble4)",
    "insertText": "Doubles(X)"
  },
  {
    "label": "VectorExp2()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorExp2(const VectorRegister4Float& X)"
  },
  {
    "label": "_mm_exp2_ps()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "_mm_exp2_ps(X)"
  },
  {
    "label": "Floats()",
    "kind": "Method",
    "detail": "Function (# else AlignedFloat4)",
    "insertText": "Floats(X)"
  },
  {
    "label": "Exp2()",
    "kind": "Method",
    "detail": "Function (Floats [ 0 ] =)",
    "insertText": "Exp2(Floats[0])"
  },
  {
    "label": "Exp2()",
    "kind": "Method",
    "detail": "Function (Floats [ 1 ] =)",
    "insertText": "Exp2(Floats[1])"
  },
  {
    "label": "Exp2()",
    "kind": "Method",
    "detail": "Function (Floats [ 2 ] =)",
    "insertText": "Exp2(Floats[2])"
  },
  {
    "label": "Exp2()",
    "kind": "Method",
    "detail": "Function (Floats [ 3 ] =)",
    "insertText": "Exp2(Floats[3])"
  },
  {
    "label": "VectorExp2()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorExp2(const VectorRegister4Double& X)"
  },
  {
    "label": "_mm256_exp2_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML_AVX return)",
    "insertText": "_mm256_exp2_pd(X)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (# elif UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "VectorRegister4Double(_mm_exp2_pd(X.XY), _mm_exp2_pd(X.ZW))"
  },
  {
    "label": "VectorLog()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorLog(const VectorRegister4Float& X)"
  },
  {
    "label": "_mm_log_ps()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "_mm_log_ps(X)"
  },
  {
    "label": "log_ps()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "log_ps(X)"
  },
  {
    "label": "VectorLog()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorLog(const VectorRegister4Double& X)"
  },
  {
    "label": "_mm256_log_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML_AVX return)",
    "insertText": "_mm256_log_pd(X)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (# elif UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "VectorRegister4Double(_mm_log_pd(X.XY), _mm_log_pd(X.ZW))"
  },
  {
    "label": "VectorLog2()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorLog2(const VectorRegister4Float& X)"
  },
  {
    "label": "_mm_log2_ps()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "_mm_log2_ps(X)"
  },
  {
    "label": "Log2()",
    "kind": "Method",
    "detail": "Function (Floats [ 0 ] =)",
    "insertText": "Log2(Floats[0])"
  },
  {
    "label": "Log2()",
    "kind": "Method",
    "detail": "Function (Floats [ 1 ] =)",
    "insertText": "Log2(Floats[1])"
  },
  {
    "label": "Log2()",
    "kind": "Method",
    "detail": "Function (Floats [ 2 ] =)",
    "insertText": "Log2(Floats[2])"
  },
  {
    "label": "Log2()",
    "kind": "Method",
    "detail": "Function (Floats [ 3 ] =)",
    "insertText": "Log2(Floats[3])"
  },
  {
    "label": "VectorLog2()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorLog2(const VectorRegister4Double& X)"
  },
  {
    "label": "_mm256_log2_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML_AVX return)",
    "insertText": "_mm256_log2_pd(X)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (# elif UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "VectorRegister4Double(_mm_log2_pd(X.XY), _mm_log2_pd(X.ZW))"
  },
  {
    "label": "MakeVectorRegisterFloatConstant()",
    "kind": "Method",
    "detail": "Function (# endif } namespace VectorSinConstantsSSE { const float p = 0 . 2 2 5 f ; const float a = 7 . 5 8 9 4 6 6 0 9 f ; const float b = 1 . 6 3 3 8 4 3 4 2 f ; const VectorRegister4Float A =)",
    "insertText": "MakeVectorRegisterFloatConstant(a, a, a, a)"
  },
  {
    "label": "MakeVectorRegisterFloatConstant()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float B =)",
    "insertText": "MakeVectorRegisterFloatConstant(b, b, b, b)"
  },
  {
    "label": "VectorSin()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "VectorSin(const VectorRegister4Float& V)"
  },
  {
    "label": "_mm_sin_ps()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "_mm_sin_ps(V)"
  },
  {
    "label": "sin_ps()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "sin_ps(V)"
  },
  {
    "label": "VectorSin()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorSin(const VectorRegister4Double& V)"
  },
  {
    "label": "_mm256_sin_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML_AVX return)",
    "insertText": "_mm256_sin_pd(V)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (# elif UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "VectorRegister4Double(_mm_sin_pd(V.XY), _mm_sin_pd(V.ZW))"
  },
  {
    "label": "Doubles()",
    "kind": "Method",
    "detail": "Function (# else AlignedDouble4)",
    "insertText": "Doubles(V)"
  },
  {
    "label": "VectorCos()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorCos(const VectorRegister4Float& V)"
  },
  {
    "label": "_mm_cos_ps()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "_mm_cos_ps(V)"
  },
  {
    "label": "cos_ps()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "cos_ps(V)"
  },
  {
    "label": "VectorCos()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorCos(const VectorRegister4Double& V)"
  },
  {
    "label": "_mm256_cos_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML_AVX return)",
    "insertText": "_mm256_cos_pd(V)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (# elif UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "VectorRegister4Double(_mm_cos_pd(V.XY), _mm_cos_pd(V.ZW))"
  },
  {
    "label": "VectorSinCos()",
    "kind": "Method",
    "detail": "Function (# endif } void)",
    "insertText": "VectorSinCos(VectorRegister4Float* RESTRICT VSinAngles, VectorRegister4Float* RESTRICT VCosAngles, const VectorRegister4Float* RESTRICT VAngles)"
  },
  {
    "label": "_mm_sincos_ps()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML* VSinAngles =)",
    "insertText": "_mm_sincos_ps(VCosAngles, *VAngles)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (# else VectorRegister4Float Quotient =)",
    "insertText": "VectorMultiply(*VAngles, GlobalVectorConstants::OneOverTwoPi)"
  },
  {
    "label": "_mm_cvtepi32_ps()",
    "kind": "Method",
    "detail": "Function (Quotient =)",
    "insertText": "_mm_cvtepi32_ps(_mm_cvtps_epi32(Quotient))"
  },
  {
    "label": "VectorNegateMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float X =)",
    "insertText": "VectorNegateMultiplyAdd(GlobalVectorConstants::TwoPi, Quotient, *VAngles)"
  },
  {
    "label": "VectorBitwiseAnd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float sign =)",
    "insertText": "VectorBitwiseAnd(X, GlobalVectorConstants::SignBit())"
  },
  {
    "label": "VectorBitwiseOr()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float c =)",
    "insertText": "VectorBitwiseOr(GlobalVectorConstants::Pi, sign)"
  },
  {
    "label": "VectorAbs()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float absx =)",
    "insertText": "VectorAbs(X)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float rflx =)",
    "insertText": "VectorSubtract(c, X)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float comp =)",
    "insertText": "VectorCompareGT(absx, GlobalVectorConstants::PiByTwo)"
  },
  {
    "label": "VectorSelect()",
    "kind": "Method",
    "detail": "Function (X =)",
    "insertText": "VectorSelect(comp, rflx, X)"
  },
  {
    "label": "VectorSelect()",
    "kind": "Method",
    "detail": "Function (sign =)",
    "insertText": "VectorSelect(comp, GlobalVectorConstants::FloatMinusOne, GlobalVectorConstants::FloatOne)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float XSquared =)",
    "insertText": "VectorMultiply(X, X)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (/ 0 . f,0 . f ) ; VectorRegister4Float S ; S =)",
    "insertText": "VectorReplicate(SinCoeff1, 1)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (S =)",
    "insertText": "VectorMultiplyAdd(XSquared, S, VectorReplicate(SinCoeff1, 0))"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (S =)",
    "insertText": "VectorMultiplyAdd(XSquared, S, VectorReplicate(SinCoeff0, 3))"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (S =)",
    "insertText": "VectorMultiplyAdd(XSquared, S, VectorReplicate(SinCoeff0, 2))"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (S =)",
    "insertText": "VectorMultiplyAdd(XSquared, S, VectorReplicate(SinCoeff0, 1))"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (S =)",
    "insertText": "VectorMultiplyAdd(XSquared, S, VectorReplicate(SinCoeff0, 0))"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (* VSinAngles =)",
    "insertText": "VectorMultiply(S, X)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (/ 0 . f,0 . f ) ; VectorRegister4Float C ; C =)",
    "insertText": "VectorReplicate(CosCoeff1, 1)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (C =)",
    "insertText": "VectorMultiplyAdd(XSquared, C, VectorReplicate(CosCoeff1, 0))"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (C =)",
    "insertText": "VectorMultiplyAdd(XSquared, C, VectorReplicate(CosCoeff0, 3))"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (C =)",
    "insertText": "VectorMultiplyAdd(XSquared, C, VectorReplicate(CosCoeff0, 2))"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (C =)",
    "insertText": "VectorMultiplyAdd(XSquared, C, VectorReplicate(CosCoeff0, 1))"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (C =)",
    "insertText": "VectorMultiplyAdd(XSquared, C, VectorReplicate(CosCoeff0, 0))"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (* VCosAngles =)",
    "insertText": "VectorMultiply(C, sign)"
  },
  {
    "label": "VectorSinCos()",
    "kind": "Method",
    "detail": "Function (# endif } void)",
    "insertText": "VectorSinCos(VectorRegister4Double* RESTRICT VSinAngles, VectorRegister4Double* RESTRICT VCosAngles, const VectorRegister4Double* RESTRICT VAngles)"
  },
  {
    "label": "_mm256_sincos_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML_AVX VSinAngles -> XYZW =)",
    "insertText": "_mm256_sincos_pd(&(VCosAngles->XYZW), VAngles->XYZW)"
  },
  {
    "label": "_mm_sincos_pd()",
    "kind": "Method",
    "detail": "Function (# elif UE_PLATFORM_MATH_USE_SVML VSinAngles -> XY =)",
    "insertText": "_mm_sincos_pd(&(VCosAngles->XY), VAngles->XY)"
  },
  {
    "label": "_mm_sincos_pd()",
    "kind": "Method",
    "detail": "Function (VSinAngles -> ZW =)",
    "insertText": "_mm_sincos_pd(&(VCosAngles->ZW), VAngles->ZW)"
  },
  {
    "label": "VectorSin()",
    "kind": "Method",
    "detail": "Function (# else* VSinAngles =)",
    "insertText": "VectorSin(*VAngles)"
  },
  {
    "label": "VectorCos()",
    "kind": "Method",
    "detail": "Function (* VCosAngles =)",
    "insertText": "VectorCos(*VAngles)"
  },
  {
    "label": "VectorTan()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorTan(const VectorRegister4Float& X)"
  },
  {
    "label": "_mm_tan_ps()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "_mm_tan_ps(X)"
  },
  {
    "label": "Tan()",
    "kind": "Method",
    "detail": "Function (Floats [ 0 ] =)",
    "insertText": "Tan(Floats[0])"
  },
  {
    "label": "Tan()",
    "kind": "Method",
    "detail": "Function (Floats [ 1 ] =)",
    "insertText": "Tan(Floats[1])"
  },
  {
    "label": "Tan()",
    "kind": "Method",
    "detail": "Function (Floats [ 2 ] =)",
    "insertText": "Tan(Floats[2])"
  },
  {
    "label": "Tan()",
    "kind": "Method",
    "detail": "Function (Floats [ 3 ] =)",
    "insertText": "Tan(Floats[3])"
  },
  {
    "label": "VectorTan()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorTan(const VectorRegister4Double& X)"
  },
  {
    "label": "_mm256_tan_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML_AVX return)",
    "insertText": "_mm256_tan_pd(X)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (# elif UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "VectorRegister4Double(_mm_tan_pd(X.XY), _mm_tan_pd(X.ZW))"
  },
  {
    "label": "VectorASin()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorASin(const VectorRegister4Float& X)"
  },
  {
    "label": "_mm_asin_ps()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "_mm_asin_ps(X)"
  },
  {
    "label": "Asin()",
    "kind": "Method",
    "detail": "Function (Floats [ 0 ] =)",
    "insertText": "Asin(Floats[0])"
  },
  {
    "label": "Asin()",
    "kind": "Method",
    "detail": "Function (Floats [ 1 ] =)",
    "insertText": "Asin(Floats[1])"
  },
  {
    "label": "Asin()",
    "kind": "Method",
    "detail": "Function (Floats [ 2 ] =)",
    "insertText": "Asin(Floats[2])"
  },
  {
    "label": "Asin()",
    "kind": "Method",
    "detail": "Function (Floats [ 3 ] =)",
    "insertText": "Asin(Floats[3])"
  },
  {
    "label": "VectorASin()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorASin(const VectorRegister4Double& X)"
  },
  {
    "label": "_mm256_asin_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML_AVX return)",
    "insertText": "_mm256_asin_pd(X)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (# elif UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "VectorRegister4Double(_mm_asin_pd(X.XY), _mm_asin_pd(X.ZW))"
  },
  {
    "label": "VectorACos()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorACos(const VectorRegister4Float& X)"
  },
  {
    "label": "_mm_acos_ps()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "_mm_acos_ps(X)"
  },
  {
    "label": "Acos()",
    "kind": "Method",
    "detail": "Function (Floats [ 0 ] =)",
    "insertText": "Acos(Floats[0])"
  },
  {
    "label": "Acos()",
    "kind": "Method",
    "detail": "Function (Floats [ 1 ] =)",
    "insertText": "Acos(Floats[1])"
  },
  {
    "label": "Acos()",
    "kind": "Method",
    "detail": "Function (Floats [ 2 ] =)",
    "insertText": "Acos(Floats[2])"
  },
  {
    "label": "Acos()",
    "kind": "Method",
    "detail": "Function (Floats [ 3 ] =)",
    "insertText": "Acos(Floats[3])"
  },
  {
    "label": "VectorACos()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorACos(const VectorRegister4Double& X)"
  },
  {
    "label": "_mm256_acos_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML_AVX return)",
    "insertText": "_mm256_acos_pd(X)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (# elif UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "VectorRegister4Double(_mm_acos_pd(X.XY), _mm_acos_pd(X.ZW))"
  },
  {
    "label": "VectorATan()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorATan(const VectorRegister4Float& X)"
  },
  {
    "label": "_mm_atan_ps()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "_mm_atan_ps(X)"
  },
  {
    "label": "Atan()",
    "kind": "Method",
    "detail": "Function (Floats [ 0 ] =)",
    "insertText": "Atan(Floats[0])"
  },
  {
    "label": "Atan()",
    "kind": "Method",
    "detail": "Function (Floats [ 1 ] =)",
    "insertText": "Atan(Floats[1])"
  },
  {
    "label": "Atan()",
    "kind": "Method",
    "detail": "Function (Floats [ 2 ] =)",
    "insertText": "Atan(Floats[2])"
  },
  {
    "label": "Atan()",
    "kind": "Method",
    "detail": "Function (Floats [ 3 ] =)",
    "insertText": "Atan(Floats[3])"
  },
  {
    "label": "VectorATan()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorATan(const VectorRegister4Double& X)"
  },
  {
    "label": "_mm256_atan_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML_AVX return)",
    "insertText": "_mm256_atan_pd(X)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (# elif UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "VectorRegister4Double(_mm_atan_pd(X.XY), _mm_atan_pd(X.ZW))"
  },
  {
    "label": "VectorATan2()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorATan2(const VectorRegister4Float& Y, const VectorRegister4Float& X)"
  },
  {
    "label": "_mm_atan2_ps()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "_mm_atan2_ps(Y, X)"
  },
  {
    "label": "FloatsY()",
    "kind": "Method",
    "detail": "Function (# else AlignedFloat4)",
    "insertText": "FloatsY(Y)"
  },
  {
    "label": "FloatsX()",
    "kind": "Method",
    "detail": "Function (AlignedFloat4)",
    "insertText": "FloatsX(X)"
  },
  {
    "label": "Atan2()",
    "kind": "Method",
    "detail": "Function (FloatsY [ 0 ] =)",
    "insertText": "Atan2(FloatsY[0], FloatsX[0])"
  },
  {
    "label": "Atan2()",
    "kind": "Method",
    "detail": "Function (FloatsY [ 1 ] =)",
    "insertText": "Atan2(FloatsY[1], FloatsX[1])"
  },
  {
    "label": "Atan2()",
    "kind": "Method",
    "detail": "Function (FloatsY [ 2 ] =)",
    "insertText": "Atan2(FloatsY[2], FloatsX[2])"
  },
  {
    "label": "Atan2()",
    "kind": "Method",
    "detail": "Function (FloatsY [ 3 ] =)",
    "insertText": "Atan2(FloatsY[3], FloatsX[3])"
  },
  {
    "label": "VectorATan2()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorATan2(const VectorRegister4Double& Y, const VectorRegister4Double& X)"
  },
  {
    "label": "_mm256_atan2_pd()",
    "kind": "Method",
    "detail": "Function (# if UE_PLATFORM_MATH_USE_SVML_AVX return)",
    "insertText": "_mm256_atan2_pd(Y, X)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (# elif UE_PLATFORM_MATH_USE_SVML return)",
    "insertText": "VectorRegister4Double(_mm_atan2_pd(Y.XY, X.XY), _mm_atan2_pd(Y.ZW, X.ZW))"
  },
  {
    "label": "DoublesY()",
    "kind": "Method",
    "detail": "Function (# else AlignedDouble4)",
    "insertText": "DoublesY(Y)"
  },
  {
    "label": "DoublesX()",
    "kind": "Method",
    "detail": "Function (AlignedDouble4)",
    "insertText": "DoublesX(X)"
  },
  {
    "label": "VectorIntAnd()",
    "kind": "Method",
    "detail": "Function (# endif } # define)",
    "insertText": "VectorIntAnd(A, B) _mm_and_si128(A, B) #define VectorIntOr(A, B) _mm_or_si128(A, B) #define VectorIntXor(A, B) _mm_xor_si128(A, B) #define VectorIntAndNot(A, B) _mm_andnot_si128(A, B) #define VectorIntNot(A) _mm_xor_si128(A, GlobalVectorConstants::IntAllMask) #define VectorIntCompareEQ(A, B) _mm_cmpeq_epi32(A,B) #define VectorIntCompareNEQ(A, B) VectorIntNot(_mm_cmpeq_epi32(A,B)) #define VectorIntCompareGT(A, B) _mm_cmpgt_epi32(A,B) #define VectorIntCompareLT(A, B) _mm_cmplt_epi32(A,B) #define VectorIntCompareGE(A, B) VectorIntNot(VectorIntCompareLT(A,B)) #define VectorIntCompareLE(A, B) VectorIntNot(VectorIntCompareGT(A,B)) FORCEINLINE VectorRegister4Int VectorIntSelect(const VectorRegister4Int& Mask, const VectorRegister4Int& Vec1, const VectorRegister4Int& Vec2)"
  },
  {
    "label": "VectorIntAdd()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "VectorIntAdd(A, B) _mm_add_epi32(A, B) #define VectorIntSubtract(A, B) _mm_sub_epi32(A, B) FORCEINLINE VectorRegister4Int VectorIntMultiply(const VectorRegister4Int& A, const VectorRegister4Int& B)"
  },
  {
    "label": "VectorIntNegate()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "VectorIntNegate(A) VectorIntSubtract( GlobalVectorConstants::IntZero, A) FORCEINLINE VectorRegister4Int VectorIntMin(const VectorRegister4Int& A, const VectorRegister4Int& B)"
  },
  {
    "label": "VectorIntMax()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Int)",
    "insertText": "VectorIntMax(const VectorRegister4Int& A, const VectorRegister4Int& B)"
  },
  {
    "label": "VectorIntAbs()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Int)",
    "insertText": "VectorIntAbs(const VectorRegister4Int& A)"
  },
  {
    "label": "VectorIntClamp()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Int)",
    "insertText": "VectorIntClamp(const VectorRegister4Int& Vec1, const VectorRegister4Int& Vec2, const VectorRegister4Int& Vec3)"
  },
  {
    "label": "VectorIntSign()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "VectorIntSign(A) VectorIntSelect( VectorIntCompareGE(A, GlobalVectorConstants::IntZero), GlobalVectorConstants::IntOne, GlobalVectorConstants::IntMinusOne ) #define VectorIntToFloat(A) _mm_cvtepi32_ps(A) FORCEINLINE VectorRegister4Int VectorFloatToInt(const VectorRegister4Float& A)"
  },
  {
    "label": "VectorFloatToInt()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Int)",
    "insertText": "VectorFloatToInt(const VectorRegister4Double& A)"
  },
  {
    "label": "VectorDoubleToInt()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Int)",
    "insertText": "VectorDoubleToInt(const VectorRegister4Double& Vec)"
  },
  {
    "label": "_mm_cvttpd_epi32()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Int A =)",
    "insertText": "_mm_cvttpd_epi32(Vec.GetXY())"
  },
  {
    "label": "_mm_cvttpd_epi32()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Int B =)",
    "insertText": "_mm_cvttpd_epi32(Vec.GetZW())"
  },
  {
    "label": "VectorShuffleByte4()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Int)",
    "insertText": "VectorShuffleByte4(const VectorRegister4Int& Vec, const VectorRegister4Int& Mask)"
  }
]