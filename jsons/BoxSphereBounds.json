[
  {
    "label": "TBoxSphereBounds",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TBoxSphereBounds"
  },
  {
    "label": "Builder",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Builder"
  },
  {
    "label": "TIsPODType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsPODType"
  },
  {
    "label": "TIsUECoreVariant",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsUECoreVariant"
  },
  {
    "label": "TBoxSphereBounds()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Math / UnrealMathUtility . h \" # include \" Containers / UnrealString . h \" # include \" Logging / LogMacros . h \" # include \" Math / Vector . h \" # include \" Math / Sphere . h \" # include \" Math / Box . h \" # include \" Misc / LargeWorldCoordinatesSerializer . h \" namespace UE { namespace Math { template<T,TExtent> struct TBoxSphereBounds { using FReal = T ; TVector<T> Origin ; TVector<TExtent> BoxExtent ; TExtent SphereRadius ; public :)",
    "insertText": "TBoxSphereBounds()"
  },
  {
    "label": "TBoxSphereBounds()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TBoxSphereBounds(EForceInit ) : Origin(ForceInit) , BoxExtent(ForceInit) , SphereRadius(0)"
  },
  {
    "label": "DiagnosticCheckNaN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DiagnosticCheckNaN()"
  },
  {
    "label": "TBoxSphereBounds()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBoxSphereBounds(const TVector<T>& InOrigin, const TVector<TExtent>& InBoxExtent, TExtent InSphereRadius ) : Origin(InOrigin) , BoxExtent(InBoxExtent) , SphereRadius(InSphereRadius)"
  },
  {
    "label": "TBoxSphereBounds()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBoxSphereBounds(const TBox<T>& Box, const TSphere<T>& Sphere)"
  },
  {
    "label": "GetCenterAndExtents()",
    "kind": "Method",
    "detail": "Function (TVector<T> LocalExtent ; Box .)",
    "insertText": "GetCenterAndExtents(Origin, LocalExtent)"
  },
  {
    "label": "TExtent()",
    "kind": "Method",
    "detail": "Function (BoxExtent = TVector<)",
    "insertText": "TExtent(LocalExtent)"
  },
  {
    "label": "SphereRadius()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SphereRadius(TExtent)FMath::Min(LocalExtent.Size(), (Sphere.Center - Origin).Size() + Sphere.W)"
  },
  {
    "label": "TBoxSphereBounds()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBoxSphereBounds(const TBox<T>& Box)"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (SphereRadius = BoxExtent .)",
    "insertText": "Size()"
  },
  {
    "label": "TBoxSphereBounds()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBoxSphereBounds(const TSphere<T>& Sphere)"
  },
  {
    "label": "TExtent()",
    "kind": "Method",
    "detail": "Function (Origin = Sphere . Center ; SphereRadius = Sphere . W ; BoxExtent = TVector<)",
    "insertText": "TExtent(SphereRadius)"
  },
  {
    "label": "TBoxSphereBounds()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBoxSphereBounds(const TVector<T>* Points, uint32 NumPoints)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (template<TFrom,TExtentFrom)",
    "insertText": "UE_REQUIRES(!(std::is_same_v<T, TFrom> && std::is_same_v<TExtent, TExtentFrom>))> explicit TBoxSphereBounds(const TBoxSphereBounds<TFrom, TExtentFrom>& From) : TBoxSphereBounds<T, TExtent>(TVector<T>(From.Origin), TVector<TExtent>(From.BoxExtent), (TExtent)From.SphereRadius)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "Serialize(FArchive &Ar)"
  },
  {
    "label": "SerializeFromMismatchedTag()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SerializeFromMismatchedTag(FName StructTag, FArchive &Ar)"
  },
  {
    "label": "ComputeSquaredDistanceFromBoxToPoint()",
    "kind": "Method",
    "detail": "Function (public : T)",
    "insertText": "ComputeSquaredDistanceFromBoxToPoint(const TVector<T>& Point)"
  },
  {
    "label": "ComputeSquaredDistanceFromBoxToPoint()",
    "kind": "Method",
    "detail": "Function (TVector<T> Mins = Origin - BoxExtent ; TVector<T> Maxs = Origin + BoxExtent ;)",
    "insertText": "ComputeSquaredDistanceFromBoxToPoint(Mins, Maxs, Point)"
  },
  {
    "label": "SpheresIntersect()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "SpheresIntersect(const TBoxSphereBounds<T, TExtent>& A, const TBoxSphereBounds<T, TExtent>& B, TExtent Tolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "BoxesIntersect()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "BoxesIntersect(const TBoxSphereBounds<T, TExtent>& A, const TBoxSphereBounds<T, TExtent>& B)"
  },
  {
    "label": "GetBox()",
    "kind": "Method",
    "detail": "Function (} TBox<T>)",
    "insertText": "GetBox()"
  },
  {
    "label": "GetBoxExtrema()",
    "kind": "Method",
    "detail": "Function (} TVector<T>)",
    "insertText": "GetBoxExtrema(uint32 Extrema)"
  },
  {
    "label": "ExpandBy()",
    "kind": "Method",
    "detail": "Function (} TBoxSphereBounds<T,TExtent>)",
    "insertText": "ExpandBy(TExtent ExpandAmount)"
  },
  {
    "label": "TransformBy()",
    "kind": "Method",
    "detail": "Function (} TBoxSphereBounds<T,TExtent>)",
    "insertText": "TransformBy(const TMatrix<T>& M)"
  },
  {
    "label": "TransformBy()",
    "kind": "Method",
    "detail": "Function (TBoxSphereBounds<T,TExtent>)",
    "insertText": "TransformBy(const TTransform<T>& M)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "ToString()"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (TBoxSphereBounds<T,TExtent>)",
    "insertText": "Union(const TBoxSphereBounds<T, TExtent>& A,const TBoxSphereBounds<T, TExtent>& B)"
  },
  {
    "label": "logOrEnsureNanError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "logOrEnsureNanError(TEXT(\"Origin contains NaN: %s\"), *Origin.ToString())"
  },
  {
    "label": "TBoxSphereBounds()",
    "kind": "Method",
    "detail": "Function (Origin = TVector<T>::ZeroVector)",
    "insertText": "TBoxSphereBounds(this)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(BoxExtent.ContainsNaN())"
  },
  {
    "label": "logOrEnsureNanError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "logOrEnsureNanError(TEXT(\"BoxExtent contains NaN: %s\"), *BoxExtent.ToString())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(FMath::IsNaN(SphereRadius) || !FMath::IsFinite(SphereRadius))"
  },
  {
    "label": "logOrEnsureNanError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "logOrEnsureNanError(TEXT(\"SphereRadius contains NaN: %f\"), SphereRadius)"
  },
  {
    "label": "ContainsNaN()",
    "kind": "Method",
    "detail": "Function (} # endif bool)",
    "insertText": "ContainsNaN()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} public : struct Builder { Builder&)",
    "insertText": "operator(const TBoxSphereBounds<T, TExtent>& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Builder&)",
    "insertText": "operator(const TBox<T>& Box)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Builder&)",
    "insertText": "operator(const TSphere<T>& Sphere)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Builder&)",
    "insertText": "operator(const TVector<T>& Point)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "TExtent()",
    "kind": "Method",
    "detail": "Function (} operator TBoxSphereBounds<T,)",
    "insertText": "TExtent()"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (} private : Builder&)",
    "insertText": "Append(const TBoxSphereBounds<T, TExtent>& Other)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (* BoxSphereBounds =* BoxSphereBounds + Other ; } else { BoxSphereBounds .)",
    "insertText": "Emplace(Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return* this ; } TOptional<TBoxSphereBounds<T,TExtent>> BoxSphereBounds ; } ; } ; FArchive&)",
    "insertText": "operator(FArchive& Ar, TBoxSphereBounds<float, float>& Bounds)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Ar<<Bounds . Origin<<Bounds . BoxExtent<<Bounds . SphereRadius ; return Ar ; } FArchive&)",
    "insertText": "operator(FArchive& Ar, TBoxSphereBounds<double, double>& Bounds)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Ar<<Bounds . Origin<<Bounds . BoxExtent ;)",
    "insertText": "if(Ar.UEVer() >= EUnrealEngineObjectUE5Version::LARGE_WORLD_COORDINATES)"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (Ar<<Bounds . SphereRadius ; } else {)",
    "insertText": "checkf(Ar.IsLoading(), TEXT(\"float -> double conversion applied outside of load!\"))"
  },
  {
    "label": "BoundingBox()",
    "kind": "Method",
    "detail": "Function (TBox<T>)",
    "insertText": "BoundingBox(ForceInit)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TExtent SquaredSphereRadius = 0 ;)",
    "insertText": "for(uint32 PointIndex = 0; PointIndex < NumPoints; PointIndex++)"
  },
  {
    "label": "TExtent()",
    "kind": "Method",
    "detail": "Function (SquaredSphereRadius = FMath::Max<)",
    "insertText": "TExtent(SquaredSphereRadius, (Points[PointIndex] - Origin).SizeSquared())"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (} SphereRadius =)",
    "insertText": "Sqrt(SquaredSphereRadius)"
  },
  {
    "label": "BoundingBox()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BoundingBox(this->Origin - this->BoxExtent)"
  },
  {
    "label": "BoundingBox()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BoundingBox(this->Origin + this->BoxExtent)"
  },
  {
    "label": "BoundingBox()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BoundingBox(Other.Origin - Other.BoxExtent)"
  },
  {
    "label": "BoundingBox()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BoundingBox(Other.Origin + Other.BoxExtent)"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (TBoxSphereBounds<T,TExtent>)",
    "insertText": "Result(BoundingBox)"
  },
  {
    "label": "TExtent()",
    "kind": "Method",
    "detail": "Function (Result . SphereRadius = FMath::Min<)",
    "insertText": "TExtent(Result.SphereRadius, FMath::Max<TExtent>((Origin - Result.Origin).Size() + SphereRadius, (Other.Origin - Result.Origin).Size() + Other.SphereRadius))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if ENABLE_NAN_DIAGNOSTIC)",
    "insertText": "if(M.ContainsNaN())"
  },
  {
    "label": "logOrEnsureNanError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "logOrEnsureNanError(TEXT(\"Input Matrix contains NaN/Inf! %s\"), *M.ToString())"
  },
  {
    "label": "VectorLoadFloat3()",
    "kind": "Method",
    "detail": "Function (} # endif TBoxSphereBounds<T> Result ; const TVectorRegisterType<T> VecOrigin =)",
    "insertText": "VectorLoadFloat3(&Origin)"
  },
  {
    "label": "VectorLoadFloat3()",
    "kind": "Method",
    "detail": "Function (const TVectorRegisterType<T> VecExtent =)",
    "insertText": "VectorLoadFloat3(&BoxExtent)"
  },
  {
    "label": "VectorLoadAligned()",
    "kind": "Method",
    "detail": "Function (const TVectorRegisterType<T> m0 =)",
    "insertText": "VectorLoadAligned(M.M[0])"
  },
  {
    "label": "VectorLoadAligned()",
    "kind": "Method",
    "detail": "Function (const TVectorRegisterType<T> m1 =)",
    "insertText": "VectorLoadAligned(M.M[1])"
  },
  {
    "label": "VectorLoadAligned()",
    "kind": "Method",
    "detail": "Function (const TVectorRegisterType<T> m2 =)",
    "insertText": "VectorLoadAligned(M.M[2])"
  },
  {
    "label": "VectorLoadAligned()",
    "kind": "Method",
    "detail": "Function (const TVectorRegisterType<T> m3 =)",
    "insertText": "VectorLoadAligned(M.M[3])"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (TVectorRegisterType<T> NewOrigin =)",
    "insertText": "VectorMultiply(VectorReplicate(VecOrigin, 0), m0)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (NewOrigin =)",
    "insertText": "VectorMultiplyAdd(VectorReplicate(VecOrigin, 1), m1, NewOrigin)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (NewOrigin =)",
    "insertText": "VectorMultiplyAdd(VectorReplicate(VecOrigin, 2), m2, NewOrigin)"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (NewOrigin =)",
    "insertText": "VectorAdd(NewOrigin, m3)"
  },
  {
    "label": "VectorAbs()",
    "kind": "Method",
    "detail": "Function (TVectorRegisterType<T> NewExtent =)",
    "insertText": "VectorAbs(VectorMultiply(VectorReplicate(VecExtent, 0), m0))"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (NewExtent =)",
    "insertText": "VectorAdd(NewExtent, VectorAbs(VectorMultiply(VectorReplicate(VecExtent, 1), m1)))"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (NewExtent =)",
    "insertText": "VectorAdd(NewExtent, VectorAbs(VectorMultiply(VectorReplicate(VecExtent, 2), m2)))"
  },
  {
    "label": "VectorStoreFloat3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreFloat3(NewExtent, &(Result.BoxExtent.X))"
  },
  {
    "label": "VectorStoreFloat3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreFloat3(NewOrigin, &(Result.Origin.X))"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (TVectorRegisterType<T> MaxRadius =)",
    "insertText": "VectorMultiply(m0, m0)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (MaxRadius =)",
    "insertText": "VectorMultiplyAdd(m1, m1, MaxRadius)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (MaxRadius =)",
    "insertText": "VectorMultiplyAdd(m2, m2, MaxRadius)"
  },
  {
    "label": "VectorMax()",
    "kind": "Method",
    "detail": "Function (MaxRadius =)",
    "insertText": "VectorMax(VectorMax(MaxRadius, VectorReplicate(MaxRadius, 1)), VectorReplicate(MaxRadius, 2))"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (Result . SphereRadius =)",
    "insertText": "Sqrt(VectorGetComponent(MaxRadius, 0))"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (T const BoxExtentMagnitude =)",
    "insertText": "Sqrt(VectorDot3Scalar(NewExtent, NewExtent))"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (Result . SphereRadius =)",
    "insertText": "Min(Result.SphereRadius, BoxExtentMagnitude)"
  },
  {
    "label": "DiagnosticCheckNaN_All()",
    "kind": "Method",
    "detail": "Function (# if ENABLE_NAN_DIAGNOSTIC M .)",
    "insertText": "DiagnosticCheckNaN_All()"
  },
  {
    "label": "ToMatrixWithScale()",
    "kind": "Method",
    "detail": "Function (# endif const TMatrix<T> Mat = M .)",
    "insertText": "ToMatrixWithScale()"
  },
  {
    "label": "TransformBy()",
    "kind": "Method",
    "detail": "Function (TBoxSphereBounds<T,TExtent> Result =)",
    "insertText": "TransformBy(Mat)"
  }
]