[
  {
    "label": "BasicBlock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BasicBlock"
  },
  {
    "label": "BranchProbabilityInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BranchProbabilityInfo"
  },
  {
    "label": "Function",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Function"
  },
  {
    "label": "Loop",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Loop"
  },
  {
    "label": "LoopInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LoopInfo"
  },
  {
    "label": "MachineBasicBlock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineBasicBlock"
  },
  {
    "label": "MachineBranchProbabilityInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineBranchProbabilityInfo"
  },
  {
    "label": "MachineFunction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineFunction"
  },
  {
    "label": "MachineLoop",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineLoop"
  },
  {
    "label": "MachineLoopInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineLoopInfo"
  },
  {
    "label": "IrreducibleGraph",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IrreducibleGraph"
  },
  {
    "label": "BT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BT"
  },
  {
    "label": "BlockEdgesAdder",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BlockEdgesAdder"
  },
  {
    "label": "BlockMass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BlockMass"
  },
  {
    "label": "isPodLike",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "isPodLike"
  },
  {
    "label": "BlockFrequencyInfoImplBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BlockFrequencyInfoImplBase"
  },
  {
    "label": "BlockNode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BlockNode"
  },
  {
    "label": "FrequencyData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FrequencyData"
  },
  {
    "label": "LoopData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LoopData"
  },
  {
    "label": "It1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "It1"
  },
  {
    "label": "It2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "It2"
  },
  {
    "label": "WorkingData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "WorkingData"
  },
  {
    "label": "Weight",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Weight"
  },
  {
    "label": "DistType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "DistType"
  },
  {
    "label": "Distribution",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Distribution"
  },
  {
    "label": "BlockT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BlockT"
  },
  {
    "label": "TypeMap",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TypeMap"
  },
  {
    "label": "IrrNode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IrrNode"
  },
  {
    "label": "BlockFrequencyInfoImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BlockFrequencyInfoImpl"
  },
  {
    "label": "bfi_detail",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "bfi_detail"
  },
  {
    "label": "BlockMass()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_ANALYSIS_BLOCKFREQUENCYINFOIMPL_H # define LLVM_ANALYSIS_BLOCKFREQUENCYINFOIMPL_H # include \" llvm / ADT / DenseMap . h \" # include \" llvm / ADT / PostOrderIterator . h \" # include \" llvm / ADT / iterator_range . h \" # include \" llvm / IR / BasicBlock . h \" # include \" llvm / Support / BlockFrequency . h \" # include \" llvm / Support / BranchProbability . h \" # include \" llvm / Support / Debug . h \" # include \" llvm / Support / ScaledNumber . h \" # include \" llvm / Support / raw_ostream . h \" # include<deque> # include<list> # include<string> # include<vector> # define DEBUG_TYPE \" block - freq \" namespace llvm { class BasicBlock ; class BranchProbabilityInfo ; class Function ; class Loop ; class LoopInfo ; class MachineBasicBlock ; class MachineBranchProbabilityInfo ; class MachineFunction ; class MachineLoop ; class MachineLoopInfo ; namespace bfi_detail { struct IrreducibleGraph ; template<class BT> struct BlockEdgesAdder ; class BlockMass { uint64_t Mass ; public :)",
    "insertText": "BlockMass() : Mass(0)"
  },
  {
    "label": "BlockMass()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "BlockMass(uint64_t Mass) : Mass(Mass)"
  },
  {
    "label": "getEmpty()",
    "kind": "Method",
    "detail": "Function (} BlockMass)",
    "insertText": "getEmpty()"
  },
  {
    "label": "getFull()",
    "kind": "Method",
    "detail": "Function (} BlockMass)",
    "insertText": "getFull()"
  },
  {
    "label": "getMass()",
    "kind": "Method",
    "detail": "Function (} uint64_t)",
    "insertText": "getMass()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} BlockMass&)",
    "insertText": "operator(const BlockMass &X)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (uint64_t Diff = Mass - X . Mass ; Mass = Diff> Mass ? 0 : Diff ; return* this ; } BlockMass&)",
    "insertText": "operator(const BranchProbability &P)"
  },
  {
    "label": "scale()",
    "kind": "Method",
    "detail": "Function (Mass = P .)",
    "insertText": "scale(Mass)"
  },
  {
    "label": "dump()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dump()"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (raw_ostream&)",
    "insertText": "print(raw_ostream &OS)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; BlockMass)",
    "insertText": "operator(const BlockMass &L, const BlockMass &R)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} BlockMass)",
    "insertText": "operator(const BlockMass &L, const BranchProbability &R)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} BlockMass)",
    "insertText": "operator(const BranchProbability &L, const BlockMass &R)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} raw_ostream&)",
    "insertText": "operator(raw_ostream &OS, const BlockMass &X)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } template<> struct isPodLike<bfi_detail::BlockMass> { const bool value = true ; } ; class BlockFrequencyInfoImplBase { public : typedef ScaledNumber<uint64_t> Scaled64 ; typedef bfi_detail::BlockMass BlockMass ; struct BlockNode { typedef uint32_t IndexType ; IndexType Index ; bool)",
    "insertText": "operator(const BlockNode &X)"
  },
  {
    "label": "BlockNode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "BlockNode(IndexType Index) : Index(Index)"
  },
  {
    "label": "isValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValid()"
  },
  {
    "label": "getMaxIndex()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "getMaxIndex()"
  },
  {
    "label": "LoopData()",
    "kind": "Method",
    "detail": "Function (} template<class It1,class It2>)",
    "insertText": "LoopData(LoopData *Parent, It1 FirstHeader, It1 LastHeader, It2 FirstOther, It2 LastOther) : Parent(Parent), IsPackaged(false), Nodes(FirstHeader, LastHeader)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (NumHeaders = Nodes .)",
    "insertText": "size()"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (Nodes .)",
    "insertText": "insert(Nodes.end(), FirstOther, LastOther)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (BackedgeMass .)",
    "insertText": "resize(NumHeaders)"
  },
  {
    "label": "isHeader()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isHeader(const BlockNode &Node)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(isHeader(B) && \"this is only valid on loop header blocks\")"
  },
  {
    "label": "members_end()",
    "kind": "Method",
    "detail": "Function (} NodeList::const_iterator)",
    "insertText": "members_end()"
  },
  {
    "label": "members()",
    "kind": "Method",
    "detail": "Function (} iterator_range<NodeList::const_iterator>)",
    "insertText": "members()"
  },
  {
    "label": "WorkingData()",
    "kind": "Method",
    "detail": "Function (} } ; struct WorkingData { BlockNode Node ; LoopData* Loop ; BlockMass Mass ;)",
    "insertText": "WorkingData(const BlockNode &Node) : Node(Node), Loop(nullptr)"
  },
  {
    "label": "isLoopHeader()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isLoopHeader()"
  },
  {
    "label": "isDoubleLoopHeader()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isDoubleLoopHeader()"
  },
  {
    "label": "getContainingLoop()",
    "kind": "Method",
    "detail": "Function (} LoopData*)",
    "insertText": "getContainingLoop()"
  },
  {
    "label": "getPackagedLoop()",
    "kind": "Method",
    "detail": "Function (auto L =)",
    "insertText": "getPackagedLoop()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (Parent)",
    "insertText": "while(L->Parent && L->Parent->IsPackaged)"
  },
  {
    "label": "isAPackage()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isAPackage()"
  },
  {
    "label": "isADoublePackage()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isADoublePackage()"
  },
  {
    "label": "Weight()",
    "kind": "Method",
    "detail": "Function (} } ; struct Weight { enum DistType { Local,Exit,Backedge } ; DistType Type ; BlockNode TargetNode ; uint64_t Amount ;)",
    "insertText": "Weight() : Type(Local), Amount(0)"
  },
  {
    "label": "Weight()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Weight(DistType Type, BlockNode TargetNode, uint64_t Amount) : Type(Type), TargetNode(TargetNode), Amount(Amount)"
  },
  {
    "label": "Distribution()",
    "kind": "Method",
    "detail": "Function (} } ; struct Distribution { typedef SmallVector<Weight,4> WeightList ; WeightList Weights ; uint64_t Total ; bool DidOverflow ;)",
    "insertText": "Distribution() : Total(0), DidOverflow(false)"
  },
  {
    "label": "addLocal()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addLocal(const BlockNode &Node, uint64_t Amount)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(Node, Amount, Weight::Local)"
  },
  {
    "label": "addExit()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addExit(const BlockNode &Node, uint64_t Amount)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(Node, Amount, Weight::Exit)"
  },
  {
    "label": "addBackedge()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addBackedge(const BlockNode &Node, uint64_t Amount)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(Node, Amount, Weight::Backedge)"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "normalize()"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "add(const BlockNode &Node, uint64_t Amount, Weight::DistType Type)"
  },
  {
    "label": "addLoopSuccessorsToDist()",
    "kind": "Method",
    "detail": "Function (} ; std::vector<FrequencyData> Freqs ; std::vector<WorkingData> Working ; std::list<LoopData> Loops ; bool)",
    "insertText": "addLoopSuccessorsToDist(const LoopData *OuterLoop, LoopData &Loop, Distribution &Dist)"
  },
  {
    "label": "addToDist()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "addToDist(Distribution &Dist, const LoopData *OuterLoop, const BlockNode &Pred, const BlockNode &Succ, uint64_t Weight)"
  },
  {
    "label": "getLoopPackage()",
    "kind": "Method",
    "detail": "Function (LoopData&)",
    "insertText": "getLoopPackage(const BlockNode &Head)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Head.Index < Working.size())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Working[Head.Index].isLoopHeader())"
  },
  {
    "label": "updateLoopWithIrreducible()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "updateLoopWithIrreducible(LoopData &OuterLoop)"
  },
  {
    "label": "distributeMass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "distributeMass(const BlockNode &Source, LoopData *OuterLoop, Distribution &Dist)"
  },
  {
    "label": "computeLoopScale()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeLoopScale(LoopData &Loop)"
  },
  {
    "label": "adjustLoopHeaderMass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "adjustLoopHeaderMass(LoopData &Loop)"
  },
  {
    "label": "packageLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "packageLoop(LoopData &Loop)"
  },
  {
    "label": "unwrapLoops()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "unwrapLoops()"
  },
  {
    "label": "finalizeMetrics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "finalizeMetrics()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "getBlockName()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "getBlockName(const BlockNode &Node)"
  },
  {
    "label": "getLoopName()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "getLoopName(const LoopData &Loop)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print(dbgs())"
  },
  {
    "label": "getFloatingBlockFreq()",
    "kind": "Method",
    "detail": "Function (} Scaled64)",
    "insertText": "getFloatingBlockFreq(const BlockNode &Node)"
  },
  {
    "label": "getBlockFreq()",
    "kind": "Method",
    "detail": "Function (BlockFrequency)",
    "insertText": "getBlockFreq(const BlockNode &Node)"
  },
  {
    "label": "printBlockFreq()",
    "kind": "Method",
    "detail": "Function (raw_ostream&)",
    "insertText": "printBlockFreq(raw_ostream &OS, const BlockNode &Node)"
  },
  {
    "label": "printBlockFreq()",
    "kind": "Method",
    "detail": "Function (raw_ostream&)",
    "insertText": "printBlockFreq(raw_ostream &OS, const BlockFrequency &Freq)"
  },
  {
    "label": "getEntryFreq()",
    "kind": "Method",
    "detail": "Function (uint64_t)",
    "insertText": "getEntryFreq()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!Freqs.empty())"
  },
  {
    "label": "getBlockName()",
    "kind": "Method",
    "detail": "Function (} } ; namespace bfi_detail { template<class BlockT> struct TypeMap { } ; template<> struct TypeMap<BasicBlock> { typedef BasicBlock BlockT ; typedef Function FunctionT ; typedef BranchProbabilityInfo BranchProbabilityInfoT ; typedef Loop LoopT ; typedef LoopInfo LoopInfoT ; } ; template<> struct TypeMap<MachineBasicBlock> { typedef MachineBasicBlock BlockT ; typedef MachineFunction FunctionT ; typedef MachineBranchProbabilityInfo BranchProbabilityInfoT ; typedef MachineLoop LoopT ; typedef MachineLoopInfo LoopInfoT ; } ; template<class BlockT> std::string)",
    "insertText": "getBlockName(const BlockT *BB)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(BB && \"Unexpected nullptr\")"
  },
  {
    "label": "Twine()",
    "kind": "Method",
    "detail": "Function (auto MachineName = \" BB \" +)",
    "insertText": "Twine(BB->getNumber())"
  },
  {
    "label": "getBlockName()",
    "kind": "Method",
    "detail": "Function (} template<> std::string)",
    "insertText": "getBlockName(const BasicBlock *BB)"
  },
  {
    "label": "IrrNode()",
    "kind": "Method",
    "detail": "Function (} struct IrreducibleGraph { typedef BlockFrequencyInfoImplBase BFIBase ; BFIBase& BFI ; typedef BFIBase::BlockNode BlockNode ; struct IrrNode { BlockNode Node ; unsigned NumIn ; std::deque<const IrrNode*> Edges ;)",
    "insertText": "IrrNode(const BlockNode &Node) : Node(Node), NumIn(0)"
  },
  {
    "label": "pred_begin()",
    "kind": "Method",
    "detail": "Function (} typedef std::deque<const IrrNode*>::const_iterator iterator ; iterator)",
    "insertText": "pred_begin()"
  },
  {
    "label": "succ_begin()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "succ_begin()"
  },
  {
    "label": "pred_end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "pred_end()"
  },
  {
    "label": "succ_end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "succ_end()"
  },
  {
    "label": "IrreducibleGraph()",
    "kind": "Method",
    "detail": "Function (} } ; BlockNode Start ; const IrrNode* StartIrr ; std::vector<IrrNode> Nodes ; SmallDenseMap<uint32_t,IrrNode*,4> Lookup ; template<class BlockEdgesAdder>)",
    "insertText": "IrreducibleGraph(BFIBase &BFI, const BFIBase::LoopData *OuterLoop, BlockEdgesAdder addBlockEdges) : BFI(BFI), StartIrr(nullptr)"
  },
  {
    "label": "initialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "initialize(OuterLoop, addBlockEdges)"
  },
  {
    "label": "initialize()",
    "kind": "Method",
    "detail": "Function (} template<class BlockEdgesAdder> void)",
    "insertText": "initialize(const BFIBase::LoopData *OuterLoop, BlockEdgesAdder addBlockEdges)"
  },
  {
    "label": "addNodesInLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addNodesInLoop(const BFIBase::LoopData &OuterLoop)"
  },
  {
    "label": "addNodesInFunction()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addNodesInFunction()"
  },
  {
    "label": "addNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addNode(const BlockNode &Node)"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (Nodes .)",
    "insertText": "emplace_back(Node)"
  },
  {
    "label": "getMass()",
    "kind": "Method",
    "detail": "Function (BFI . Working [ Node . Index ] .)",
    "insertText": "getMass() = BlockMass::getEmpty()"
  },
  {
    "label": "indexNodes()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "indexNodes()"
  },
  {
    "label": "addEdges()",
    "kind": "Method",
    "detail": "Function (template<class BlockEdgesAdder> void)",
    "insertText": "addEdges(const BlockNode &Node, const BFIBase::LoopData *OuterLoop, BlockEdgesAdder addBlockEdges)"
  },
  {
    "label": "addEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addEdge(IrrNode &Irr, const BlockNode &Succ, const BFIBase::LoopData *OuterLoop)"
  },
  {
    "label": "addNodesInLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addNodesInLoop(*OuterLoop)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (auto L = Lookup .)",
    "insertText": "find(Node.Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (IrrNode& Irr =* L -> second ; const auto& Working = BFI . Working [ Node . Index ] ;)",
    "insertText": "if(Working.isAPackage()) for (const auto &I : Working.Loop->Exits) addEdge(Irr, I.first, OuterLoop)"
  },
  {
    "label": "rpot_begin()",
    "kind": "Method",
    "detail": "Function (} } template<class BT> class BlockFrequencyInfoImpl : BlockFrequencyInfoImplBase { typedef bfi_detail::TypeMap<BT>::BlockT BlockT ; typedef bfi_detail::TypeMap<BT>::FunctionT FunctionT ; typedef bfi_detail::TypeMap<BT>::BranchProbabilityInfoT BranchProbabilityInfoT ; typedef bfi_detail::TypeMap<BT>::LoopT LoopT ; typedef bfi_detail::TypeMap<BT>::LoopInfoT LoopInfoT ; struct bfi_detail::BlockEdgesAdder<BT> ; typedef GraphTraits<const BlockT*> Successor ; typedef GraphTraits<Inverse<const BlockT*>> Predecessor ; const BranchProbabilityInfoT* BPI ; const LoopInfoT* LI ; const FunctionT* F ; std::vector<const BlockT*> RPOT ; DenseMap<const BlockT*,BlockNode> Nodes ; typedef std::vector<const BlockT*>::const_iterator rpot_iterator ; rpot_iterator)",
    "insertText": "rpot_begin()"
  },
  {
    "label": "rpot_end()",
    "kind": "Method",
    "detail": "Function (} rpot_iterator)",
    "insertText": "rpot_end()"
  },
  {
    "label": "getIndex()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "getIndex(const rpot_iterator &I)"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (} BlockNode)",
    "insertText": "getNode(const rpot_iterator &I)"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (} BlockNode)",
    "insertText": "getNode(const BlockT *BB)"
  },
  {
    "label": "getBlock()",
    "kind": "Method",
    "detail": "Function (} const BlockT*)",
    "insertText": "getBlock(const BlockNode &Node)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Node.Index < RPOT.size())"
  },
  {
    "label": "initializeLoops()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "initializeLoops()"
  },
  {
    "label": "propagateMassToSuccessors()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "propagateMassToSuccessors(LoopData *OuterLoop, const BlockNode &Node)"
  },
  {
    "label": "computeMassInLoop()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "computeMassInLoop(LoopData &Loop)"
  },
  {
    "label": "tryToComputeMassInFunction()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "tryToComputeMassInFunction()"
  },
  {
    "label": "computeIrreducibleMass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeIrreducibleMass(LoopData *OuterLoop, std::list<LoopData>::iterator Insert)"
  },
  {
    "label": "computeMassInLoops()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeMassInLoops()"
  },
  {
    "label": "computeMassInFunction()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeMassInFunction()"
  },
  {
    "label": "getFunction()",
    "kind": "Method",
    "detail": "Function (} public : const FunctionT*)",
    "insertText": "getFunction()"
  },
  {
    "label": "BlockFrequencyInfoImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BlockFrequencyInfoImpl() : BPI(nullptr), LI(nullptr), F(nullptr)"
  },
  {
    "label": "getBlockFreq()",
    "kind": "Method",
    "detail": "Function (} using BlockFrequencyInfoImplBase::getEntryFreq ; BlockFrequency)",
    "insertText": "getBlockFreq(const BlockT *BB)"
  },
  {
    "label": "getFloatingBlockFreq()",
    "kind": "Method",
    "detail": "Function (} Scaled64)",
    "insertText": "getFloatingBlockFreq(const BlockT *BB)"
  },
  {
    "label": "printBlockFreq()",
    "kind": "Method",
    "detail": "Function (using BlockFrequencyInfoImplBase::dump ; using BlockFrequencyInfoImplBase::printBlockFreq ; raw_ostream&)",
    "insertText": "printBlockFreq(raw_ostream &OS, const BlockT *BB)"
  },
  {
    "label": "doFunction()",
    "kind": "Method",
    "detail": "Function (} } ; template<class BT> void BlockFrequencyInfoImpl<BT)",
    "insertText": "doFunction(const FunctionT *F, const BranchProbabilityInfoT *BPI, const LoopInfoT *LI)"
  },
  {
    "label": "DEBUG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DEBUG(dbgs() << \"\\nblock-frequency: \" << F->getName() << \"\\n=================\" << std::string(F->getName().size(), '=') << \"\\n\")"
  },
  {
    "label": "initializeRPOT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "initializeRPOT()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (const BlockT* Entry = F ->)",
    "insertText": "begin()"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (RPOT .)",
    "insertText": "reserve(F->size())"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copy(po_begin(Entry), po_end(Entry), std::back_inserter(RPOT))"
  },
  {
    "label": "reverse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reverse(RPOT.begin(), RPOT.end())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(RPOT.size() - 1 <= BlockNode::getMaxIndex() && \"More nodes in function than Block Frequency Info supports\")"
  },
  {
    "label": "DEBUG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DEBUG(dbgs() << \"reverse-post-order-traversal\\n\")"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (BlockNode Node =)",
    "insertText": "getNode(I)"
  },
  {
    "label": "DEBUG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DEBUG(dbgs() << \" - \" << getIndex(I) << \": \" << getBlockName(Node) << \"\\n\")"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (Nodes [* I ] = Node ; } Working .)",
    "insertText": "reserve(RPOT.size())"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (Freqs .)",
    "insertText": "resize(RPOT.size())"
  },
  {
    "label": "DEBUG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DEBUG(dbgs() << \"loop-detection\\n\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::deque<std::pair<const LoopT*,LoopData*>> Q ;)",
    "insertText": "for(const LoopT *L : *LI) Q.emplace_back(L, nullptr)"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (const LoopT* Loop = Q .)",
    "insertText": "front()"
  },
  {
    "label": "pop_front()",
    "kind": "Method",
    "detail": "Function (Q .)",
    "insertText": "pop_front()"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (BlockNode Header =)",
    "insertText": "getNode(Loop->getHeader())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Header.isValid())"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (Loops .)",
    "insertText": "emplace_back(Parent, Header)"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (Working [ Header . Index ] . Loop =& Loops .)",
    "insertText": "back()"
  },
  {
    "label": "DEBUG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DEBUG(dbgs() << \" - loop = \" << getBlockName(Header) << \"\\n\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(size_t Index = 0; Index < RPOT.size(); ++Index)"
  },
  {
    "label": "getLoopFor()",
    "kind": "Method",
    "detail": "Function (continue ; } const LoopT* Loop = LI ->)",
    "insertText": "getLoopFor(RPOT[Index])"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (const auto& HeaderData = Working [ Header . Index ] ;)",
    "insertText": "assert(HeaderData.isLoopHeader())"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Working [ Index ] . Loop = HeaderData . Loop ; HeaderData . Loop -> Nodes .)",
    "insertText": "push_back(Index)"
  },
  {
    "label": "DEBUG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DEBUG(dbgs() << \" - loop = \" << getBlockName(Header) << \": member = \" << getBlockName(Index) << \"\\n\")"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (auto Next =)",
    "insertText": "next(L)"
  },
  {
    "label": "computeIrreducibleMass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeIrreducibleMass(&*L, L.base())"
  },
  {
    "label": "prev()",
    "kind": "Method",
    "detail": "Function (L =)",
    "insertText": "prev(Next)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"unhandled irreducible control flow\")"
  },
  {
    "label": "DEBUG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DEBUG(dbgs() << \"compute-mass-in-loop: \" << getLoopName(Loop) << \"\\n\")"
  },
  {
    "label": "BranchProbability()",
    "kind": "Method",
    "detail": "Function (Mass = Remaining*)",
    "insertText": "BranchProbability(1, Loop.NumHeaders - H)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Remaining - = Mass ; })",
    "insertText": "for(const BlockNode &M : Loop.Nodes) if (!propagateMassToSuccessors(&Loop, M)) llvm_unreachable(\"unhandled irreducible control flow\")"
  },
  {
    "label": "adjustLoopHeaderMass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "adjustLoopHeaderMass(Loop)"
  },
  {
    "label": "getHeader()",
    "kind": "Method",
    "detail": "Function (} else { Working [ Loop .)",
    "insertText": "getHeader().Index].getMass() = BlockMass::getFull()"
  },
  {
    "label": "computeLoopScale()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "computeLoopScale(Loop)"
  },
  {
    "label": "packageLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "packageLoop(Loop)"
  },
  {
    "label": "DEBUG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DEBUG(dbgs() << \"compute-mass-in-function\\n\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!Working.empty() && \"no blocks in function\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!Working[0].isLoopHeader() && \"entry block is a loop header\")"
  },
  {
    "label": "getMass()",
    "kind": "Method",
    "detail": "Function (Working [ 0 ] .)",
    "insertText": "getMass() = BlockMass::getFull()"
  },
  {
    "label": "computeIrreducibleMass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeIrreducibleMass(nullptr, Loops.begin())"
  },
  {
    "label": "BlockEdgesAdder()",
    "kind": "Method",
    "detail": "Function (} namespace bfi_detail { template<class BT> struct BlockEdgesAdder { typedef BT BlockT ; typedef BlockFrequencyInfoImplBase::LoopData LoopData ; typedef GraphTraits<const BlockT*> Successor ; const BlockFrequencyInfoImpl<BT>& BFI ;)",
    "insertText": "BlockEdgesAdder(const BlockFrequencyInfoImpl<BT> &BFI) : BFI(BFI)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()(IrreducibleGraph &G, IrreducibleGraph::IrrNode &Irr, const LoopData *OuterLoop)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const BlockT* BB = BFI . RPOT [ Irr . Node . Index ] ;)",
    "insertText": "for(auto I = Successor::child_begin(BB), E = Successor::child_end(BB); I != E; ++I) G.addEdge(Irr, BFI.getNode(*I), OuterLoop)"
  },
  {
    "label": "DEBUG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DEBUG(dbgs() << \"analyze-irreducible-in-\"; if (OuterLoop) dbgs() << \"loop: \" << getLoopName(*OuterLoop) << \"\\n\"; else dbgs() << \"function\\n\")"
  },
  {
    "label": "addBlockEdges()",
    "kind": "Method",
    "detail": "Function (using namespace bfi_detail ; BlockEdgesAdder<BT>)",
    "insertText": "addBlockEdges(*this)"
  },
  {
    "label": "G()",
    "kind": "Method",
    "detail": "Function (IrreducibleGraph)",
    "insertText": "G(*this, OuterLoop, addBlockEdges)"
  },
  {
    "label": "updateLoopWithIrreducible()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "updateLoopWithIrreducible(*OuterLoop)"
  },
  {
    "label": "DEBUG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DEBUG(dbgs() << \" - node: \" << getBlockName(Node) << \"\\n\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Distribution Dist ;)",
    "insertText": "if(auto *Loop = Working[Node.Index].getPackagedLoop())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Loop != OuterLoop && \"Cannot propagate mass in a packaged loop\")"
  },
  {
    "label": "getBlock()",
    "kind": "Method",
    "detail": "Function (} else { const BlockT* BB =)",
    "insertText": "getBlock(Node)"
  },
  {
    "label": "distributeMass()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "distributeMass(Node, OuterLoop, Dist)"
  },
  {
    "label": "getName()",
    "kind": "Method",
    "detail": "Function (OS<<\" block - frequency - info : \"<<F ->)",
    "insertText": "getName()"
  }
]