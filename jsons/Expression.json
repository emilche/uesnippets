[
  {
    "label": "CEnumeration",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CEnumeration"
  },
  {
    "label": "CAstNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CAstNode"
  },
  {
    "label": "CAstCompilationUnit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CAstCompilationUnit"
  },
  {
    "label": "CExpressionBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CExpressionBase"
  },
  {
    "label": "CExprCodeBlock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CExprCodeBlock"
  },
  {
    "label": "CSemanticProgram",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CSemanticProgram"
  },
  {
    "label": "CSnippet",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CSnippet"
  },
  {
    "label": "CModule",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CModule"
  },
  {
    "label": "CModulePart",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CModulePart"
  },
  {
    "label": "CModuleAlias",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CModuleAlias"
  },
  {
    "label": "CControlScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CControlScope"
  },
  {
    "label": "CTypeAlias",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CTypeAlias"
  },
  {
    "label": "CTypeVariable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CTypeVariable"
  },
  {
    "label": "CEnumerator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CEnumerator"
  },
  {
    "label": "Class",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Class"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "SAstNodeTypeInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SAstNodeTypeInfo"
  },
  {
    "label": "SAstVisitor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SAstVisitor"
  },
  {
    "label": "VERSECOMPILER_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VERSECOMPILER_API"
  },
  {
    "label": "Verse",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Verse"
  },
  {
    "label": "SAnalysisResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SAnalysisResult"
  },
  {
    "label": "type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "type"
  },
  {
    "label": "CClause",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CClause"
  },
  {
    "label": "CMemberDefinitions",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CMemberDefinitions"
  },
  {
    "label": "definition",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "definition"
  },
  {
    "label": "TAstFunctionVisitor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TAstFunctionVisitor"
  },
  {
    "label": "TAsNullableTraitsOf",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TAsNullableTraitsOf"
  },
  {
    "label": "VERSE_VISIT_AST_NODE_TYPES()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" uLang / Common / Containers / SharedPointer . h \" # include \" uLang / Common / Containers / SharedPointerArray . h \" # include \" uLang / Common / Templates / Conditionals . h \" # include \" uLang / Common / Text / Symbol . h \" # include \" uLang / Common / Text / UTF8String . h \" # include \" uLang / Semantics / DataDefinition . h \" # include \" uLang / Semantics / SemanticTypes . h \" # include \" uLang / Semantics / Signature . h \" # include \" uLang / SourceProject / PackageRole . h \" # include \" uLang / Syntax / VstNode . h \" namespace uLang { class CEnumeration ; class CAstNode ; class CAstCompilationUnit ; class CExpressionBase ; class CExprCodeBlock ; class CSemanticProgram ; class CSnippet ; class CModule ; class CModulePart ; class CModuleAlias ; class CControlScope ; class CTypeAlias ; class CTypeVariable ; class CEnumerator ; # define)",
    "insertText": "VERSE_VISIT_AST_NODE_TYPES(v) \\ \\ v(Error_, CExprError) \\ v(Placeholder_, CExprPlaceholder) \\ v(External, CExprExternal) \\ v(PathPlusSymbol, CExprPathPlusSymbol) \\ \\ \\ v(Literal_Logic, CExprLogic) \\ v(Literal_Number, CExprNumber) \\ \\ v(Literal_Char, CExprChar) \\ v(Literal_String, CExprString) \\ v(Literal_Path, CExprPath) \\ v(Literal_Enum, CExprEnumLiteral) \\ v(Literal_Type, CExprType) \\ v(Literal_Function, CExprFunctionLiteral) \\ \\ \\ v(Identifier_Unresolved, CExprIdentifierUnresolved) \\ v(Identifier_Class, CExprIdentifierClass) \\ v(Identifier_Module, CExprIdentifierModule) \\ v(Identifier_ModuleAlias, CExprIdentifierModuleAlias) \\ v(Identifier_Enum, CExprEnumerationType) \\ v(Identifier_Interface, CExprInterfaceType) \\ v(Identifier_Data, CExprIdentifierData) \\ v(Identifier_TypeAlias, CExprIdentifierTypeAlias) \\ v(Identifier_TypeVariable, CExprIdentifierTypeVariable) \\ v(Identifier_Function, CExprIdentifierFunction) \\ v(Identifier_OverloadedFunction, CExprIdentifierOverloadedFunction) \\ v(Identifier_Self, CExprSelf) \\ v(Identifier_Local, CExprLocal) \\ v(Identifier_BuiltInMacro, CExprIdentifierBuiltInMacro) \\ \\ \\ v(Definition, CExprDefinition) \\ \\ \\ v(MacroCall, CExprMacroCall) \\ \\ \\ v(Invoke_Invocation, CExprInvocation) \\ v(Invoke_UnaryArithmetic, CExprUnaryArithmetic) \\ v(Invoke_BinaryArithmetic, CExprBinaryArithmetic) \\ v(Invoke_ShortCircuitAnd, CExprShortCircuitAnd) \\ v(Invoke_ShortCircuitOr, CExprShortCircuitOr) \\ v(Invoke_LogicalNot, CExprLogicalNot) \\ v(Invoke_Comparison, CExprComparison) \\ v(Invoke_QueryValue, CExprQueryValue) \\ v(Invoke_MakeOption, CExprMakeOption) \\ v(Invoke_MakeArray, CExprMakeArray) \\ v(Invoke_MakeMap, CExprMakeMap) \\ v(Invoke_MakeTuple, CExprMakeTuple) \\ v(Invoke_TupleElement, CExprTupleElement) \\ v(Invoke_MakeRange, CExprMakeRange) \\ v(Invoke_Type, CExprInvokeType) \\ v(Invoke_PointerToReference, CExprPointerToReference) \\ v(Invoke_Set, CExprSet) \\ v(Invoke_NewPointer, CExprNewPointer) \\ v(Invoke_ReferenceToValue, CExprReferenceToValue) \\ \\ v(Assignment, CExprAssignment) \\ \\ \\ v(Invoke_ArrayFormer, CExprArrayTypeFormer) \\ v(Invoke_GeneratorFormer, CExprGeneratorTypeFormer) \\ v(Invoke_MapFormer, CExprMapTypeFormer) \\ v(Invoke_OptionFormer, CExprOptionTypeFormer) \\ v(Invoke_Subtype, CExprSubtype) \\ v(Invoke_TupleType, CExprTupleType) \\ v(Invoke_Arrow, CExprArrow) \\ \\ v(Invoke_ArchetypeInstantiation, CExprArchetypeInstantiation) \\ \\ \\ v(Flow_CodeBlock, CExprCodeBlock) \\ v(Flow_Let, CExprLet) \\ v(Flow_Defer, CExprDefer) \\ v(Flow_If, CExprIf) \\ v(Flow_Iteration, CExprIteration) \\ v(Flow_Loop, CExprLoop) \\ v(Flow_Break, CExprBreak) \\ v(Flow_Return, CExprReturn) \\ v(Flow_ProfileBlock, CExprProfileBlock) \\ \\ v(Ir_For, CIrFor) \\ v(Ir_ForBody, CIrForBody) \\ v(Ir_ArrayAdd, CIrArrayAdd) \\ v(Ir_MapAdd, CIrMapAdd) \\ v(Ir_ArrayUnsafeCall, CIrArrayUnsafeCall) \\ v(Ir_ConvertToDynamic, CIrConvertToDynamic) \\ v(Ir_ConvertFromDynamic, CIrConvertFromDynamic) \\ \\ \\ v(Concurrent_Sync, CExprSync) \\ v(Concurrent_Rush, CExprRush) \\ v(Concurrent_Race, CExprRace) \\ v(Concurrent_SyncIterated, CExprSyncIterated) \\ v(Concurrent_RushIterated, CExprRushIterated) \\ v(Concurrent_RaceIterated, CExprRaceIterated) \\ v(Concurrent_Branch, CExprBranch) \\ v(Concurrent_Spawn, CExprSpawn) \\ \\ \\ v(Definition_Module, CExprModuleDefinition) \\ v(Definition_Enum, CExprEnumDefinition) \\ v(Definition_Interface, CExprInterfaceDefinition) \\ v(Definition_Class, CExprClassDefinition) \\ v(Definition_Data, CExprDataDefinition) \\ v(Definition_IterationPair, CExprIterationPairDefinition) \\ v(Definition_Function, CExprFunctionDefinition) \\ v(Definition_TypeAlias, CExprTypeAliasDefinition) \\ v(Definition_Using, CExprUsing) \\ v(Definition_Import, CExprImport) \\ v(Definition_Where, CExprWhere) \\ v(Definition_Var, CExprVar) \\ v(Definition_ScopedAccessLevel, CExprScopedAccessLevelDefinition) \\ v(Invoke_MakeNamed, CExprMakeNamed) \\ \\ \\ v(Context_Project, CAstProject) \\ v(Context_CompilationUnit, CAstCompilationUnit) \\ v(Context_Package, CAstPackage) \\ v(Context_Snippet, CExprSnippet) #define FORWARD_DECLARE(_, Class)"
  },
  {
    "label": "VERSE_VISIT_AST_NODE_TYPES()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VERSE_VISIT_AST_NODE_TYPES(FORWARD_DECLARE)"
  },
  {
    "label": "VISIT_AST_NODE_TYPE()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "VISIT_AST_NODE_TYPE(Name, Class) Name, VERSE_VISIT_AST_NODE_TYPES(VISIT_AST_NODE_TYPE)"
  },
  {
    "label": "GetAstNodeTypeInfo()",
    "kind": "Method",
    "detail": "Function (struct SAstNodeTypeInfo { const char* _EnumeratorName ; const char* _CppClassName ; } ; SAstNodeTypeInfo)",
    "insertText": "GetAstNodeTypeInfo(uLang::EAstNodeType Type)"
  },
  {
    "label": "InvokeTimeAsCString()",
    "kind": "Method",
    "detail": "Function (enum class EInvokeTime : uint8_t { Immediate = 1<<0,Async = 1<<1,Any_ = Immediate | Async } ; const char*)",
    "insertText": "InvokeTimeAsCString(EInvokeTime InvokeTime)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (} } struct SAstVisitor { void)",
    "insertText": "VisitImmediate(const char* FieldName, CUTF8StringView Value)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VisitImmediate(const char* FieldName, int64_t Value)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VisitImmediate(const char* FieldName, double Value)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VisitImmediate(const char* FieldName, bool Value)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VisitImmediate(const char* FieldName, const CTypeBase* Type)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VisitImmediate(const char* FieldName, const CDefinition& Definition)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VisitImmediate(const char* FieldName, const Verse::Vst::Node& VstNode)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VisitImmediate(const char* FieldName, const char* CString)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VisitImmediate(FieldName, CUTF8StringView(CString))"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Visit(const char* FieldName, CAstNode& AstNode)"
  },
  {
    "label": "BeginArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BeginArray(const char* FieldName, intptr_t Num)"
  },
  {
    "label": "VisitElement()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VisitElement(CAstNode& AstNode)"
  },
  {
    "label": "EndArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EndArray()"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (} template<NodeType,bool bAllowNull,AllocatorType,. . . AllocatorArgTypes> void)",
    "insertText": "Visit(const char* FieldName, const TSPtrG<NodeType, bAllowNull, AllocatorType, AllocatorArgTypes...>& NodePointer)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Visit(FieldName, *NodePointer)"
  },
  {
    "label": "VisitElement()",
    "kind": "Method",
    "detail": "Function (} } template<NodeType,bool bAllowNull,AllocatorType,. . . AllocatorArgTypes> void)",
    "insertText": "VisitElement(const TSPtrG<NodeType, bAllowNull, AllocatorType, AllocatorArgTypes...>& NodePointer)"
  },
  {
    "label": "VisitElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VisitElement(*NodePointer)"
  },
  {
    "label": "VisitArray()",
    "kind": "Method",
    "detail": "Function (} } template<NodeType,bool bAllowNull,NodeAllocatorType,ElementAllocatorType,. . . ElementAllocatorArgTypes> void)",
    "insertText": "VisitArray(const char* FieldName, const TArrayG<TSPtrG<NodeType, bAllowNull, NodeAllocatorType>, ElementAllocatorType, ElementAllocatorArgTypes...>& Array)"
  },
  {
    "label": "BeginArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BeginArray(FieldName, Array.Num())"
  },
  {
    "label": "VisitElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VisitElement(*Element)"
  },
  {
    "label": "VisitArray()",
    "kind": "Method",
    "detail": "Function (} template<NodeType,bool bAllowNull,ElementAllocatorType,. . . RawAllocatorArgTypes> void)",
    "insertText": "VisitArray(const char* FieldName, const TSPtrArrayG<NodeType, bAllowNull, ElementAllocatorType, RawAllocatorArgTypes...>& Array)"
  },
  {
    "label": "VisitElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VisitElement(*Node)"
  },
  {
    "label": "CAstNode()",
    "kind": "Method",
    "detail": "Function (} } ; enum class EVstMappingType { Ast,AstNonReciprocal,Ir } ; class CAstNode : public CSharedMix { public :)",
    "insertText": "CAstNode(EVstMappingType VstMappingType = EVstMappingType::Ast) : _VstMappingType(VstMappingType)"
  },
  {
    "label": "CAstNode()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "CAstNode()"
  },
  {
    "label": "GetNodeType()",
    "kind": "Method",
    "detail": "Function (EAstNodeType)",
    "insertText": "GetNodeType()"
  },
  {
    "label": "AsExpression()",
    "kind": "Method",
    "detail": "Function (const CExpressionBase*)",
    "insertText": "AsExpression()"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (const char* VstMappingTypeString ;)",
    "insertText": "switch(_VstMappingType)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (} ; Visitor .)",
    "insertText": "VisitImmediate(\"VstMappingType\", VstMappingTypeString)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"MappedVstNode\", *_MappedVstNode)"
  },
  {
    "label": "VisitChildren()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "VisitChildren(SAstVisitor& Visitor)"
  },
  {
    "label": "VisitChildrenLambda()",
    "kind": "Method",
    "detail": "Function (} template<FunctionType> ULANG_FORCEINLINE void)",
    "insertText": "VisitChildrenLambda(FunctionType&& Function)"
  },
  {
    "label": "GetErrorDesc()",
    "kind": "Method",
    "detail": "Function (CUTF8String)",
    "insertText": "GetErrorDesc()"
  },
  {
    "label": "GetMappedVstNode()",
    "kind": "Method",
    "detail": "Function (const Verse::Vst::Node*)",
    "insertText": "GetMappedVstNode()"
  },
  {
    "label": "SetIrMappedVstNode()",
    "kind": "Method",
    "detail": "Function (_VstMappingType = EVstMappingType::AstNonReciprocal ; _MappedVstNode = VstNode ; } void)",
    "insertText": "SetIrMappedVstNode(const Verse::Vst::Node* VstNode)"
  },
  {
    "label": "IsIrNode()",
    "kind": "Method",
    "detail": "Function (_VstMappingType = EVstMappingType::Ir ; _MappedVstNode = VstNode ; } bool)",
    "insertText": "IsIrNode()"
  },
  {
    "label": "CExpressionBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CExpressionBase(const CTypeBase* InResultType) : _Report(SAnalysisResult{InResultType})"
  },
  {
    "label": "VisitImmediates()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VisitImmediates(Visitor)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"ResultType\", _Report->ResultType)"
  },
  {
    "label": "DetermineInvokeTime()",
    "kind": "Method",
    "detail": "Function (} } EInvokeTime)",
    "insertText": "DetermineInvokeTime(const CSemanticProgram& Program)"
  },
  {
    "label": "FindFirstAsyncSubExpr()",
    "kind": "Method",
    "detail": "Function (} const CExpressionBase*)",
    "insertText": "FindFirstAsyncSubExpr(const CSemanticProgram& Program)"
  },
  {
    "label": "SetResultType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetResultType(const CTypeBase* InResultType)"
  },
  {
    "label": "RefineResultType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefineResultType(const CTypeBase* RefinedResultType)"
  },
  {
    "label": "IsAnalyzed()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsAnalyzed()"
  },
  {
    "label": "BaseCompare()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "BaseCompare(const CExpressionBase& A, const CExpressionBase& B)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const CExpressionBase& Other)"
  },
  {
    "label": "IsSubExprEqual()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsSubExprEqual(const CExpressionBase* Lhs, const CExpressionBase* Rhs)"
  },
  {
    "label": "IsSubExprEqual()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSubExprEqual(const CExpressionBase& Lhs, const CExpressionBase& Rhs)"
  },
  {
    "label": "IsSubExprEqual()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSubExprEqual(const TSPtr<CExpressionBase>& Lhs, const TSPtr<CExpressionBase>& Rhs)"
  },
  {
    "label": "IsSubExprEqual()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSubExprEqual(const TSRef<CExpressionBase>& Lhs, const TSRef<CExpressionBase>& Rhs)"
  },
  {
    "label": "AreSubExprsEqual()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AreSubExprsEqual(const TSPtrArray<CExpressionBase>& Lhs, const TSPtrArray<CExpressionBase>& Rhs)"
  },
  {
    "label": "AreSubExprsEqual()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AreSubExprsEqual(const TArray<TSPtr<CExpressionBase>>& Lhs, const TArray<TSPtr<CExpressionBase>>& Rhs)"
  },
  {
    "label": "IrGetResultType()",
    "kind": "Method",
    "detail": "Function (const CTypeBase*)",
    "insertText": "IrGetResultType()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (_Report = SAnalysisResult { TypeBase } ; } else { _Report .)",
    "insertText": "Reset()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } protected : struct SAnalysisResult { bool)",
    "insertText": "operator(const SAnalysisResult& Other)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (_SubExprs .)",
    "insertText": "Reserve(ReserveSubExprNum)"
  },
  {
    "label": "CExprCompoundBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CExprCompoundBase(TSPtrArray<CExpressionBase>&& SubExprs, EVstMappingType VstMappingType = EVstMappingType::Ast) : CExpressionBase(VstMappingType) , _SubExprs(Move(SubExprs))"
  },
  {
    "label": "CExprCompoundBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CExprCompoundBase(TSPtr<CExpressionBase>&& SubExpr1, TSPtr<CExpressionBase>&& SubExpr2) : CExprCompoundBase(2)"
  },
  {
    "label": "AppendSubExpr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendSubExpr(Move(SubExpr1))"
  },
  {
    "label": "AppendSubExpr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendSubExpr(Move(SubExpr2))"
  },
  {
    "label": "CExprCompoundBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CExprCompoundBase()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "SubExprNum()",
    "kind": "Method",
    "detail": "Function (} int32_t)",
    "insertText": "SubExprNum()"
  },
  {
    "label": "GetLastSubExpr()",
    "kind": "Method",
    "detail": "Function (} const uLang::CExpressionBase*)",
    "insertText": "GetLastSubExpr()"
  },
  {
    "label": "GetSubExprs()",
    "kind": "Method",
    "detail": "Function (} const TSPtrArray<CExpressionBase>&)",
    "insertText": "GetSubExprs()"
  },
  {
    "label": "AppendSubExpr()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendSubExpr(TSPtr<CExpressionBase> SubExpr)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (_SubExprs .)",
    "insertText": "Add(Move(SubExpr))"
  },
  {
    "label": "PrependSubExpr()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PrependSubExpr(TSPtr<CExpressionBase> SubExpr)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (_SubExprs .)",
    "insertText": "Insert(Move(SubExpr), 0)"
  },
  {
    "label": "SetSubExprs()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetSubExprs(TSPtrArray<CExpressionBase> AnalyzedExprs)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_SubExprs =)",
    "insertText": "Move(AnalyzedExprs)"
  },
  {
    "label": "ReplaceSubExpr()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ReplaceSubExpr(TSPtr<CExpressionBase> SubExpr, int32_t Index)"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(Index >= 0 && Index < _SubExprs.Num(), \"Replacing invalid subexpression index\")"
  },
  {
    "label": "ReplaceAt()",
    "kind": "Method",
    "detail": "Function (_SubExprs .)",
    "insertText": "ReplaceAt(Move(SubExpr), Index)"
  },
  {
    "label": "CanFail()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "CanFail()"
  },
  {
    "label": "VisitArray()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitArray(\"SubExprs\", _SubExprs)"
  },
  {
    "label": "Lhs()",
    "kind": "Method",
    "detail": "Function (protected : TSPtrArray<CExpressionBase> _SubExprs ; } ; class CExprBinaryOp : public CExpressionBase { private : TSPtr<CExpressionBase> _Lhs ; TSPtr<CExpressionBase> _Rhs ; public : const TSPtr<CExpressionBase>&)",
    "insertText": "Lhs()"
  },
  {
    "label": "SetLhs()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetLhs(TSPtr<CExpressionBase>&& NewLhs)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Lhs =)",
    "insertText": "Move(NewLhs)"
  },
  {
    "label": "SetRhs()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetRhs(TSPtr<CExpressionBase>&& NewRhs)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Rhs =)",
    "insertText": "Move(NewRhs)"
  },
  {
    "label": "CExprBinaryOp()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CExprBinaryOp(TSPtr<CExpressionBase>&& Lhs, TSPtr<CExpressionBase>&& Rhs) : _Lhs(Move(Lhs)), _Rhs(Move(Rhs))"
  },
  {
    "label": "FindFirstAsyncSubExpr()",
    "kind": "Method",
    "detail": "Function (const CExpressionBase* AsyncExpr = _Lhs ->)",
    "insertText": "FindFirstAsyncSubExpr(Program)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"Lhs\", _Lhs)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"Rhs\", _Rhs)"
  },
  {
    "label": "CExprExternal()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprExternal : public CExpressionBase { public :)",
    "insertText": "CExprExternal(const CSemanticProgram& Program)"
  },
  {
    "label": "CExprLogic()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprLogic : public CExpressionBase { public : bool _Value ;)",
    "insertText": "CExprLogic(const CSemanticProgram& Program, bool Value)"
  },
  {
    "label": "VisitImmediates()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VisitImmediates(SAstVisitor& Visitor)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"Value\", _Value)"
  },
  {
    "label": "CExprNumber()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprNumber : public CExpressionBase { private : union { Integer _IntValue ; Float _FloatValue ; } ; bool _bIsFloat : 1 ; public : ULANG_FORCEINLINE)",
    "insertText": "CExprNumber() : _IntValue(0) , _bIsFloat(false)"
  },
  {
    "label": "CExprNumber()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CExprNumber(CSemanticProgram&, Integer)"
  },
  {
    "label": "CExprNumber()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CExprNumber(CSemanticProgram&, Float)"
  },
  {
    "label": "IsFloat()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsFloat()"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(!_bIsFloat, \"Float number being treated as integer.\")"
  },
  {
    "label": "GetFloatValue()",
    "kind": "Method",
    "detail": "Function (Float)",
    "insertText": "GetFloatValue()"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(_bIsFloat, \"Int number being treated as float\")"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"FloatValue\", _FloatValue)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (} else { Visitor .)",
    "insertText": "VisitImmediate(\"IntValue\", _IntValue)"
  },
  {
    "label": "CExprChar()",
    "kind": "Method",
    "detail": "Function (} } } ; class CExprChar : public CExpressionBase { public : enum class EType { UTF8CodeUnit,UnicodeCodePoint } ; uint32_t _CodePoint ; EType _Type ;)",
    "insertText": "CExprChar(uint32_t CodePoint, EType Type) : _CodePoint(CodePoint) , _Type(Type)"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(_CodePoint <= 0xFF, \"utf8 code units must be <= 0xFF\")"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"CodePoint\", static_cast<int64_t>(_CodePoint))"
  },
  {
    "label": "CExprString()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprString : public CExpressionBase { public : CUTF8String _String ;)",
    "insertText": "CExprString(CUTF8String String) : _String(Move(String))"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"String\", _String)"
  },
  {
    "label": "CExprPath()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprPath : public CExpressionBase { public : CUTF8String _Path ;)",
    "insertText": "CExprPath(CUTF8String Path) : _Path(Move(Path))"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"Path\", _Path)"
  },
  {
    "label": "CExprPathPlusSymbol()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprPathPlusSymbol : public CExpressionBase { public : const CSymbol _Symbol ;)",
    "insertText": "CExprPathPlusSymbol(const CSymbol& Symbol) : _Symbol(Symbol)"
  },
  {
    "label": "CExprIdentifierBase()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprIdentifierBase : public CExpressionBase { public :)",
    "insertText": "CExprIdentifierBase(TSPtr<CExpressionBase>&& Context = nullptr, TSPtr<CExpressionBase>&& Qualifier = nullptr) : _Context(Move(Context)), _Qualifier(Move(Qualifier))"
  },
  {
    "label": "Context()",
    "kind": "Method",
    "detail": "Function (} const TSPtr<CExpressionBase>&)",
    "insertText": "Context()"
  },
  {
    "label": "TakeQualifier()",
    "kind": "Method",
    "detail": "Function (} TSPtr<CExpressionBase>&&)",
    "insertText": "TakeQualifier()"
  },
  {
    "label": "SetContext()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetContext(TSPtr<CExpressionBase> Context)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Context =)",
    "insertText": "Move(Context)"
  },
  {
    "label": "SetQualifier()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetQualifier(TSPtr<CExpressionBase> Qualifier)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Qualifier =)",
    "insertText": "Move(Qualifier)"
  },
  {
    "label": "MayHaveAttributes()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "MayHaveAttributes()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const CExpressionBase* AsyncExpr = nullptr ;)",
    "insertText": "if(_Context)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!AsyncExpr && _Qualifier)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"Context\", _Context)"
  },
  {
    "label": "CExprEnumLiteral()",
    "kind": "Method",
    "detail": "Function (} private : TSPtr<CExpressionBase> _Context ; TSPtr<CExpressionBase> _Qualifier ; } ; class CExprEnumLiteral : public CExprIdentifierBase { public : const CEnumerator* _Enumerator ; ULANG_FORCEINLINE)",
    "insertText": "CExprEnumLiteral(const CEnumerator* Enumerator, TSPtr<CExpressionBase>&& Context = nullptr, TSPtr<CExpressionBase>&& Qualifier = nullptr) : CExprIdentifierBase(Move(Context), Move(Qualifier)) , _Enumerator(Enumerator)"
  },
  {
    "label": "CExprType()",
    "kind": "Method",
    "detail": "Function (} ; class CExprType : public CExpressionBase { public : const TSRef<CExpressionBase> _AbstractValue ;)",
    "insertText": "CExprType(TSRef<CExpressionBase>&& AbstractValue, const CTypeType& TypeType) : _AbstractValue(Move(AbstractValue))"
  },
  {
    "label": "SetResultType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetResultType(&TypeType)"
  },
  {
    "label": "GetTypeType()",
    "kind": "Method",
    "detail": "Function (} const CTypeType*)",
    "insertText": "GetTypeType()"
  },
  {
    "label": "GetType()",
    "kind": "Method",
    "detail": "Function (} const CTypeBase*)",
    "insertText": "GetType()"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"AbstractValue\", _AbstractValue)"
  },
  {
    "label": "CExprFunctionLiteral()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprFunctionLiteral : public CExpressionBase { public :)",
    "insertText": "CExprFunctionLiteral(TSRef<CExpressionBase>&& Domain, TSRef<CExpressionBase>&& Range) : _Domain(Move(Domain)) , _Range(Move(Range))"
  },
  {
    "label": "Domain()",
    "kind": "Method",
    "detail": "Function (} const TSRef<CExpressionBase>&)",
    "insertText": "Domain()"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Domain =)",
    "insertText": "Move(NewDomain)"
  },
  {
    "label": "SetRange()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetRange(TSRef<CExpressionBase>&& NewRange)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Range =)",
    "insertText": "Move(NewRange)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"Domain\", _Domain)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"Range\", _Range)"
  },
  {
    "label": "CExprSelf()",
    "kind": "Method",
    "detail": "Function (} private : TSRef<CExpressionBase> _Domain ; TSRef<CExpressionBase> _Range ; } ; class CExprSelf : public CExprIdentifierBase { public :)",
    "insertText": "CExprSelf(const CTypeBase* Type, TSPtr<CExpressionBase>&& Qualifier = nullptr) : CExprIdentifierBase(nullptr, Move(Qualifier))"
  },
  {
    "label": "SetResultType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetResultType(Type)"
  },
  {
    "label": "GetScope()",
    "kind": "Method",
    "detail": "Function (} const CScope&)",
    "insertText": "GetScope()"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"Symbol\", _Symbol.AsStringView())"
  },
  {
    "label": "CExprIdentifierUnresolved()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprIdentifierUnresolved : public CExprIdentifierBase { public : const CSymbol _Symbol ; bool _bAllowUnrestrictedAccess ; const bool _bAllowReservedOperators ;)",
    "insertText": "CExprIdentifierUnresolved(const CSymbol& Symbol, TSPtr<CExpressionBase>&& Context = nullptr, TSPtr<CExpressionBase>&& Qualifier = nullptr, bool bAllowReservedOperators = false) : CExprIdentifierBase( Move(Context), Move(Qualifier)) , _Symbol(Symbol) , _bAllowUnrestrictedAccess(false) , _bAllowReservedOperators(bAllowReservedOperators)"
  },
  {
    "label": "GrantUnrestrictedAccess()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GrantUnrestrictedAccess()"
  },
  {
    "label": "CExprIdentifierClass()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprIdentifierClass : public CExprIdentifierBase { public :)",
    "insertText": "CExprIdentifierClass(const CTypeType* Type, TSPtr<CExpressionBase>&& Context = nullptr, TSPtr<CExpressionBase>&& Qualifier = nullptr)"
  },
  {
    "label": "GetTypeType()",
    "kind": "Method",
    "detail": "Function (const CTypeType*)",
    "insertText": "GetTypeType(const CSemanticProgram& Program)"
  },
  {
    "label": "GetClass()",
    "kind": "Method",
    "detail": "Function (const CClass*)",
    "insertText": "GetClass(const CSemanticProgram& Program)"
  },
  {
    "label": "CExprIdentifierModule()",
    "kind": "Method",
    "detail": "Function (} ; class CExprIdentifierModule : public CExprIdentifierBase { public :)",
    "insertText": "CExprIdentifierModule(const CModule* Module, TSPtr<CExpressionBase>&& Context = nullptr, TSPtr<CExpressionBase>&& Qualifier = nullptr)"
  },
  {
    "label": "GetModule()",
    "kind": "Method",
    "detail": "Function (CModule const*)",
    "insertText": "GetModule(const CSemanticProgram& Program)"
  },
  {
    "label": "SetResultType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetResultType(TypeType)"
  },
  {
    "label": "GetEnumeration()",
    "kind": "Method",
    "detail": "Function (const CEnumeration*)",
    "insertText": "GetEnumeration(const CSemanticProgram& Program)"
  },
  {
    "label": "GetInterface()",
    "kind": "Method",
    "detail": "Function (} const CInterface*)",
    "insertText": "GetInterface(const CSemanticProgram& Program)"
  },
  {
    "label": "GetName()",
    "kind": "Method",
    "detail": "Function (const CSymbol&)",
    "insertText": "GetName()"
  },
  {
    "label": "GetResultType()",
    "kind": "Method",
    "detail": "Function (} const CTypeBase*)",
    "insertText": "GetResultType(const CSemanticProgram& Program)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"DataDefinition\", _DataDefinition)"
  },
  {
    "label": "CExprIdentifierTypeAlias()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprIdentifierTypeAlias : public CExprIdentifierBase { public : const CTypeAlias& _TypeAlias ;)",
    "insertText": "CExprIdentifierTypeAlias(const CTypeAlias& TypeAlias, TSPtr<CExpressionBase>&& Context = nullptr, TSPtr<CExpressionBase>&& Qualifier = nullptr)"
  },
  {
    "label": "CExprIdentifierTypeVariable()",
    "kind": "Method",
    "detail": "Function (} ; class CExprIdentifierTypeVariable : public CExprIdentifierBase { public : const CTypeVariable& _TypeVariable ;)",
    "insertText": "CExprIdentifierTypeVariable(const CTypeVariable& TypeVariable, TSPtr<CExpressionBase>&& Context = nullptr, TSPtr<CExpressionBase>&& Qualifier = nullptr)"
  },
  {
    "label": "CExprIdentifierFunction()",
    "kind": "Method",
    "detail": "Function (} ; class CExprIdentifierFunction : public CExprIdentifierBase { public : const CFunction& _Function ; TArray<SInstantiatedTypeVariable> _InstantiatedTypeVariables ; const CTypeBase* _ConstructorNegativeReturnType ; const bool _bSuperQualified ;)",
    "insertText": "CExprIdentifierFunction(const CFunction& Function, const CTypeBase* ResultType, TSPtr<CExpressionBase>&& Context = nullptr, TSPtr<CExpressionBase>&& Qualifier = nullptr) : CExprIdentifierFunction(Function, {}, ResultType, nullptr, Move(Context), Move(Qualifier), false)"
  },
  {
    "label": "CExprIdentifierFunction()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CExprIdentifierFunction(const CFunction& Function, TArray<SInstantiatedTypeVariable> InstTypeVariables, const CTypeBase* ResultType, const CTypeBase* ConstructorNegativeReturnType, TSPtr<CExpressionBase>&& Context, TSPtr<CExpressionBase>&& Qualifier, bool bSuperQualified)"
  },
  {
    "label": "CExprIdentifierOverloadedFunction()",
    "kind": "Method",
    "detail": "Function (} ; class CExprIdentifierOverloadedFunction : public CExprIdentifierBase { public : const TArray<const CFunction*> _FunctionOverloads ; bool _bConstructor ; const CSymbol _Symbol ; const CTypeBase* _TypeOverload ; bool _bAllowUnrestrictedAccess ;)",
    "insertText": "CExprIdentifierOverloadedFunction(TArray<const CFunction*>&& OverloadedFunctions, bool bConstructor, const CSymbol Symbol, const CTypeBase* OverloadedType, TSPtr<CExpressionBase>&& Context, TSPtr<CExpressionBase>&& Qualifier, const CTypeBase* Type)"
  },
  {
    "label": "CExprDefinition()",
    "kind": "Method",
    "detail": "Function (} ; class CExprDefinition : public CExpressionBase { public :)",
    "insertText": "CExprDefinition(TSPtr<CExpressionBase>&& Element, TSPtr<CExpressionBase>&& ValueDomain, TSPtr<CExpressionBase>&& Value, EVstMappingType VstMappingType = EVstMappingType::Ast) : CExpressionBase(VstMappingType)"
  },
  {
    "label": "SetElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetElement(Move(Element.AsRef()))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ValueDomain)"
  },
  {
    "label": "SetValueDomain()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetValueDomain(Move(ValueDomain.AsRef()))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Value)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetValue(Move(Value.AsRef()))"
  },
  {
    "label": "CExprDefinition()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "CExprDefinition(EVstMappingType VstMappingType = EVstMappingType::Ast) : CExpressionBase(VstMappingType)"
  },
  {
    "label": "Element()",
    "kind": "Method",
    "detail": "Function (} const TSPtr<CExpressionBase>&)",
    "insertText": "Element()"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Element =)",
    "insertText": "Move(Element)"
  },
  {
    "label": "TakeElement()",
    "kind": "Method",
    "detail": "Function (} TSPtr<CExpressionBase>)",
    "insertText": "TakeElement()"
  },
  {
    "label": "SetName()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetName(CSymbol Name)"
  },
  {
    "label": "ValueDomain()",
    "kind": "Method",
    "detail": "Function (} const TSPtr<CExpressionBase>&)",
    "insertText": "ValueDomain()"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_ValueDomain =)",
    "insertText": "Move(ValueDomain)"
  },
  {
    "label": "TakeValueDomain()",
    "kind": "Method",
    "detail": "Function (} TSPtr<CExpressionBase>)",
    "insertText": "TakeValueDomain()"
  },
  {
    "label": "Value()",
    "kind": "Method",
    "detail": "Function (} const TSPtr<CExpressionBase>&)",
    "insertText": "Value()"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Value =)",
    "insertText": "Move(Value)"
  },
  {
    "label": "TakeValue()",
    "kind": "Method",
    "detail": "Function (} TSPtr<CExpressionBase>)",
    "insertText": "TakeValue()"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"Element\", _Element)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"ValueDomain\", _ValueDomain)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"Value\", _Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (protected : TSPtr<CExpressionBase> _Element ; TSPtr<CExpressionBase> _ValueDomain ; TSPtr<CExpressionBase> _Value ; CSymbol _Name ; } ; enum class EMacroClauseTag : uint32_t { None = 0 x1<<0,Of = 0 x1<<1,Do = 0 x1<<2 } ; EMacroClauseTag)",
    "insertText": "operator(EMacroClauseTag A, EMacroClauseTag B)"
  },
  {
    "label": "HasAnyTags()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasAnyTags(EMacroClauseTag A, EMacroClauseTag B)"
  },
  {
    "label": "HasAllTags()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasAllTags(EMacroClauseTag A, EMacroClauseTag RequiredTags)"
  },
  {
    "label": "MacroClauseTagAsCString()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "MacroClauseTagAsCString(EMacroClauseTag Tag)"
  },
  {
    "label": "MacroClauseFormAsCString()",
    "kind": "Method",
    "detail": "Function (} ; } const char*)",
    "insertText": "MacroClauseFormAsCString(Verse::Vst::Clause::EForm Form)"
  },
  {
    "label": "CClause()",
    "kind": "Method",
    "detail": "Function (} ; } class CExprMacroCall : public CExpressionBase { public : class CClause { public : using EForm = Verse::Vst::Clause::EForm ;)",
    "insertText": "CClause(EMacroClauseTag Tag, EForm Form, TArray<TSRef<CExpressionBase>>&& Exprs) : _Tag(Tag) , _Form(Form) , _Exprs(Move(Exprs))"
  },
  {
    "label": "Tag()",
    "kind": "Method",
    "detail": "Function (} EMacroClauseTag)",
    "insertText": "Tag()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (_Clauses .)",
    "insertText": "Reserve(NumClauses)"
  },
  {
    "label": "AppendClause()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "AppendClause(CClause&& Clause)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (_Clauses .)",
    "insertText": "Add(Move(Clause))"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (} TSRef<CExpressionBase> const&)",
    "insertText": "Name()"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Name =)",
    "insertText": "Move(NewName)"
  },
  {
    "label": "TakeName()",
    "kind": "Method",
    "detail": "Function (} TSRef<CExpressionBase>&&)",
    "insertText": "TakeName()"
  },
  {
    "label": "Clauses()",
    "kind": "Method",
    "detail": "Function (} TArray<CClause> const&)",
    "insertText": "Clauses()"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"Name\", _Name)"
  },
  {
    "label": "BeginArray()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "BeginArray(\"Clauses\", _Clauses.Num())"
  },
  {
    "label": "VisitArray()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitArray(\"Exprs\", Clause.Exprs())"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"Tag\", MacroClauseTagAsCString(Clause.Tag()))"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"Form\", MacroClauseFormAsCString(Clause.Form()))"
  },
  {
    "label": "CExprInvocation()",
    "kind": "Method",
    "detail": "Function (} private : TSRef<CExpressionBase> _Name ; TArray<CClause> _Clauses ; } ; class CExprInvocation : public CExpressionBase { public : enum class EBracketingStyle { Undefined,Parentheses,SquareBrackets,} ; EBracketingStyle _CallsiteBracketStyle = EBracketingStyle::Undefined ;)",
    "insertText": "CExprInvocation(EBracketingStyle CallsiteBracketStyle, TSRef<CExpressionBase>&& Callee, TSRef<CExpressionBase>&& Argument) : _CallsiteBracketStyle(CallsiteBracketStyle) , _Callee(Move(Callee)) , _Argument(Move(Argument))"
  },
  {
    "label": "CExprInvocation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CExprInvocation(EBracketingStyle CallsiteBracketStyle, const TSRef<CExpressionBase>& Callee, const TSRef<CExpressionBase>& Argument) : _CallsiteBracketStyle(CallsiteBracketStyle) , _Callee(Callee) , _Argument(Argument)"
  },
  {
    "label": "CExprInvocation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CExprInvocation(EBracketingStyle CallsiteBracketStyle, const TSRef<CExpressionBase>& Callee, const TSRef<CExpressionBase>& Argument, const CFunctionType* ResolvedCalleeType, const CTypeBase* ResultType) : CExprInvocation(CallsiteBracketStyle, Callee, Argument)"
  },
  {
    "label": "SetResolvedCalleeType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetResolvedCalleeType(ResolvedCalleeType)"
  },
  {
    "label": "SetResultType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetResultType(ResultType)"
  },
  {
    "label": "CExprInvocation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CExprInvocation(TSRef<CExpressionBase>&& Argument) : _Argument(Move(Argument))"
  },
  {
    "label": "CExprInvocation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CExprInvocation(CExprInvocation&& Rhs) : _Callee(Move(Rhs._Callee)) , _Argument(Move(Rhs._Argument)) , _ResolvedCalleeType(Rhs._ResolvedCalleeType)"
  },
  {
    "label": "GetCallee()",
    "kind": "Method",
    "detail": "Function (} const TSPtr<CExpressionBase>&)",
    "insertText": "GetCallee()"
  },
  {
    "label": "SetCallee()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetCallee(TSPtr<CExpressionBase>&& Callee)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Callee =)",
    "insertText": "Move(Callee)"
  },
  {
    "label": "GetArgument()",
    "kind": "Method",
    "detail": "Function (} const TSPtr<CExpressionBase>&)",
    "insertText": "GetArgument()"
  },
  {
    "label": "SetArgument()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetArgument(TSPtr<CExpressionBase>&& Arguments)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Argument =)",
    "insertText": "Move(Arguments)"
  },
  {
    "label": "GetResolvedCalleeType()",
    "kind": "Method",
    "detail": "Function (} const CFunctionType*)",
    "insertText": "GetResolvedCalleeType()"
  },
  {
    "label": "SetResolvedCalleeType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetResolvedCalleeType(const CFunctionType* ResolvedCalleeType)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"Callee\", _Callee)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"Argument\", _Argument)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (const char* BracketStyleString ;)",
    "insertText": "switch(_CallsiteBracketStyle)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (} ; Visitor .)",
    "insertText": "VisitImmediate(\"CallsiteBracketStyle\", BracketStyleString)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"ResolvedCalleeType\", _ResolvedCalleeType)"
  },
  {
    "label": "GetConstructorInvocationCallee()",
    "kind": "Method",
    "detail": "Function (private : TSPtr<CExpressionBase> _Callee ; TSPtr<CExpressionBase> _Argument ; const CFunctionType* _ResolvedCalleeType { nullptr } ; } ; const CExprIdentifierFunction*)",
    "insertText": "GetConstructorInvocationCallee(const CExprInvocation&)"
  },
  {
    "label": "GetConstructorInvocationCallee()",
    "kind": "Method",
    "detail": "Function (const CExprIdentifierFunction*)",
    "insertText": "GetConstructorInvocationCallee(const CExpressionBase&)"
  },
  {
    "label": "IsConstructorInvocation()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsConstructorInvocation(const CExprInvocation&)"
  },
  {
    "label": "IsConstructorInvocation()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsConstructorInvocation(const CExpressionBase&)"
  },
  {
    "label": "CExprTupleElement()",
    "kind": "Method",
    "detail": "Function (class CExprTupleElement : public CExpressionBase { public : TSPtr<CExpressionBase> _TupleExpr ; Integer _ElemIdx ; TSPtr<CExpressionBase> _ElemIdxExpr ;)",
    "insertText": "CExprTupleElement(CExprInvocation& Invocation) : _TupleExpr(Invocation.TakeCallee()), _ElemIdx(-1)"
  },
  {
    "label": "GetMappedVstNode()",
    "kind": "Method",
    "detail": "Function (Invocation .)",
    "insertText": "GetMappedVstNode()->AddMapping(this)"
  },
  {
    "label": "CExprTupleElement()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CExprTupleElement(TSPtr<CExpressionBase> TupleExpr, Integer ElemIdx, const Verse::Vst::Node* MappedVstNode) : _TupleExpr(TupleExpr), _ElemIdx(ElemIdx)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"TupleExpr\", _TupleExpr)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"ElemIdxExpr\", _ElemIdxExpr)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"ElemIdx\", _ElemIdx)"
  },
  {
    "label": "CExprAssignment()",
    "kind": "Method",
    "detail": "Function (} ; class CExprAssignment : public CExpressionBase { public : using EOp = Verse::Vst::Assignment::EOp ;)",
    "insertText": "CExprAssignment(EOp Op, TSPtr<CExpressionBase>&& Lhs, TSPtr<CExpressionBase>&& Rhs) : _Op(Op), _Lhs(Move(Lhs)), _Rhs(Move(Rhs))"
  },
  {
    "label": "Op()",
    "kind": "Method",
    "detail": "Function (} EOp)",
    "insertText": "Op()"
  },
  {
    "label": "TakeRhs()",
    "kind": "Method",
    "detail": "Function (} TSPtr<CExpressionBase>&&)",
    "insertText": "TakeRhs()"
  },
  {
    "label": "SetLhs()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetLhs(TSPtr<CExpressionBase>&& Lhs)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Lhs =)",
    "insertText": "Move(Lhs)"
  },
  {
    "label": "SetRhs()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetRhs(TSPtr<CExpressionBase>&& Rhs)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Rhs =)",
    "insertText": "Move(Rhs)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"Op\", Verse::Vst::AssignmentOpAsCString(_Op))"
  },
  {
    "label": "CExprUnaryOp()",
    "kind": "Method",
    "detail": "Function (private : const EOp _Op ; TSPtr<CExpressionBase> _Lhs ; TSPtr<CExpressionBase> _Rhs ; } ; class CExprUnaryOp : public CExpressionBase { public :)",
    "insertText": "CExprUnaryOp(TSPtr<CExpressionBase>&& Operand, EVstMappingType VstMappingType = EVstMappingType::Ast) : CExpressionBase(VstMappingType)"
  },
  {
    "label": "SetOperand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetOperand(Move(Operand))"
  },
  {
    "label": "Operand()",
    "kind": "Method",
    "detail": "Function (} const TSPtr<CExpressionBase>&)",
    "insertText": "Operand()"
  },
  {
    "label": "SetOperand()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetOperand(TSPtr<CExpressionBase>&& Operand)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Operand =)",
    "insertText": "Move(Operand)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"Operand\", _Operand)"
  },
  {
    "label": "CExprUnaryArithmetic()",
    "kind": "Method",
    "detail": "Function (} private : TSPtr<CExpressionBase> _Operand ; } ; class CExprUnaryArithmetic : public CExprInvocation { public : enum class EOp { Negate } ;)",
    "insertText": "CExprUnaryArithmetic(EOp Op, TSRef<CExpressionBase>&& Rhs) : CExprInvocation(Move(Rhs)) , _Op(Op)"
  },
  {
    "label": "SetOperand()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetOperand(TSPtr<CExpressionBase>&& NewOperand)"
  },
  {
    "label": "SetArgument()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetArgument(Move(NewOperand))"
  },
  {
    "label": "TakeOperand()",
    "kind": "Method",
    "detail": "Function (} TSPtr<CExpressionBase>&&)",
    "insertText": "TakeOperand()"
  },
  {
    "label": "CExprBinaryArithmetic()",
    "kind": "Method",
    "detail": "Function (} EOp _Op ; } ; class CExprBinaryArithmetic : public CExprInvocation { public : enum class EOp { Add,Sub,Mul,Div } ;)",
    "insertText": "CExprBinaryArithmetic(EOp Op, TSRef<CExpressionBase>&& Argument) : CExprInvocation(Move(Argument)) , _Op(Op)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (const char* OpString ;)",
    "insertText": "switch(_Op)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (} ; Visitor .)",
    "insertText": "VisitImmediate(\"Op\", OpString)"
  },
  {
    "label": "CExprShortCircuitAnd()",
    "kind": "Method",
    "detail": "Function (} EOp _Op ; } ; class CExprShortCircuitAnd : public CExprBinaryOp { public :)",
    "insertText": "CExprShortCircuitAnd(TSPtr<CExpressionBase>&& Lhs, TSPtr<CExpressionBase>&& Rhs) : CExprBinaryOp(Move(Lhs), Move(Rhs))"
  },
  {
    "label": "CExprShortCircuitOr()",
    "kind": "Method",
    "detail": "Function (} ; class CExprShortCircuitOr : public CExprBinaryOp { public :)",
    "insertText": "CExprShortCircuitOr(TSPtr<CExpressionBase>&& Lhs, TSPtr<CExpressionBase>&& Rhs, const CTypeBase* JoinType = nullptr) : CExprBinaryOp(Move(Lhs), Move(Rhs))"
  },
  {
    "label": "SetResultType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetResultType(JoinType)"
  },
  {
    "label": "CExprLogicalNot()",
    "kind": "Method",
    "detail": "Function (private : } ; class CExprLogicalNot : public CExprUnaryOp { public :)",
    "insertText": "CExprLogicalNot(TSPtr<CExpressionBase>&& Operand): CExprUnaryOp(Move(Operand))"
  },
  {
    "label": "CExprComparison()",
    "kind": "Method",
    "detail": "Function (} ; class CExprComparison : public CExprInvocation { public : using EOp = Verse::Vst::BinaryOpCompare::op ;)",
    "insertText": "CExprComparison(EOp Op, TSRef<CExpressionBase>&& Argument) : CExprInvocation(Move(Argument)) , _Op(Op)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"Op\", Verse::Vst::BinaryCompareOpAsCString(_Op))"
  },
  {
    "label": "GetOptionType()",
    "kind": "Method",
    "detail": "Function (} COptionType const*)",
    "insertText": "GetOptionType(const CSemanticProgram& Program)"
  },
  {
    "label": "GetResultType()",
    "kind": "Method",
    "detail": "Function (const CTypeBase* MyResultType =)",
    "insertText": "GetResultType(Program)"
  },
  {
    "label": "CExprMakeArray()",
    "kind": "Method",
    "detail": "Function (} ; class CExprMakeArray : public CExprCompoundBase { public :)",
    "insertText": "CExprMakeArray(int32_t ReserveSubExprNum) : CExprCompoundBase(ReserveSubExprNum)"
  },
  {
    "label": "GetArrayType()",
    "kind": "Method",
    "detail": "Function (} const CArrayType*)",
    "insertText": "GetArrayType(const CSemanticProgram& Program)"
  },
  {
    "label": "GetMapType()",
    "kind": "Method",
    "detail": "Function (} const CMapType*)",
    "insertText": "GetMapType(const CSemanticProgram& Program)"
  },
  {
    "label": "GetTupleType()",
    "kind": "Method",
    "detail": "Function (} ; class CExprMakeTuple : public CExprCompoundBase { public : using CExprCompoundBase::CExprCompoundBase ; const CTupleType*)",
    "insertText": "GetTupleType(const CSemanticProgram& Program)"
  },
  {
    "label": "SetLhs()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetLhs(TSRef<CExpressionBase>&& Lhs)"
  },
  {
    "label": "SetRhs()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetRhs(TSRef<CExpressionBase>&& Rhs)"
  },
  {
    "label": "CExprInvokeType()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprInvokeType : public CExpressionBase { public : const CTypeBase* _NegativeType ; const bool _bIsFallible ; const TSPtr<CExpressionBase> _TypeAst ; const TSRef<CExpressionBase> _Argument ;)",
    "insertText": "CExprInvokeType(const CTypeBase* NegativeType, const CTypeBase* PositiveType, bool bIsFallible, TSPtr<CExpressionBase>&& TypeAst, TSRef<CExpressionBase>&& Argument)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"TypeAst\", _TypeAst)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"NegativeType\", _NegativeType)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"bIsFallible\", _bIsFallible)"
  },
  {
    "label": "CExprPointerToReference()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprPointerToReference : public CExprUnaryOp { public :)",
    "insertText": "CExprPointerToReference(TSRef<CExpressionBase>&& Variable) : CExprUnaryOp(Move(Variable))"
  },
  {
    "label": "CExprNewPointer()",
    "kind": "Method",
    "detail": "Function (} ; class CExprNewPointer : public CExpressionBase { public : const TSRef<CExpressionBase> _Value ;)",
    "insertText": "CExprNewPointer(const CPointerType* PointerType, TSRef<CExpressionBase>&& Value) : CExpressionBase(PointerType) , _Value(Move(Value))"
  },
  {
    "label": "CExprReferenceToValue()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprReferenceToValue : public CExprUnaryOp { public :)",
    "insertText": "CExprReferenceToValue(TSPtr<CExpressionBase>&& Operand)"
  },
  {
    "label": "CExprCodeBlock()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprCodeBlock : public CExprCompoundBase { public : TSPtr<CControlScope> _AssociatedScope ;)",
    "insertText": "CExprCodeBlock(int32_t ReserveSubExprNum = 0) : CExprCompoundBase(ReserveSubExprNum)"
  },
  {
    "label": "CExprReturn()",
    "kind": "Method",
    "detail": "Function (} ; class CExprReturn : public CExpressionBase { public :)",
    "insertText": "CExprReturn()"
  },
  {
    "label": "CExprReturn()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CExprReturn(TSPtr<CExpressionBase>&& Result, const CFunction* Function = nullptr)"
  },
  {
    "label": "SetResult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetResult(Move(Result))"
  },
  {
    "label": "SetFunction()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetFunction(Function)"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (} const TSPtr<CExpressionBase>&)",
    "insertText": "Result()"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Result =)",
    "insertText": "Move(Result)"
  },
  {
    "label": "Function()",
    "kind": "Method",
    "detail": "Function (} const CFunction*)",
    "insertText": "Function()"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"Result\", _Result)"
  },
  {
    "label": "CExprIf()",
    "kind": "Method",
    "detail": "Function (} private : TSPtr<CExpressionBase> _Result ; const CFunction* _Function { nullptr } ; } ; class CExprIf : public CExpressionBase { public :)",
    "insertText": "CExprIf(TSRef<CExprCodeBlock>&& Condition, TSPtr<CExpressionBase>&& ThenClause, TSPtr<CExpressionBase>&& ElseClause = nullptr) : _Condition(Move(Condition)) , _ThenClause(Move(ThenClause)) , _ElseClause(Move(ElseClause))"
  },
  {
    "label": "GetCondition()",
    "kind": "Method",
    "detail": "Function (} const TSRef<CExprCodeBlock>&)",
    "insertText": "GetCondition()"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Condition =)",
    "insertText": "Move(Condition)"
  },
  {
    "label": "GetThenClause()",
    "kind": "Method",
    "detail": "Function (} const TSPtr<CExpressionBase>&)",
    "insertText": "GetThenClause()"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_ThenClause =)",
    "insertText": "Move(ThenClause)"
  },
  {
    "label": "GetElseClause()",
    "kind": "Method",
    "detail": "Function (} const TSPtr<CExpressionBase>&)",
    "insertText": "GetElseClause()"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_ElseClause =)",
    "insertText": "Move(ElseClause)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"Condition\", _Condition)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"ThenClause\", _ThenClause)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"ElseClause\", _ElseClause)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"bIsFilter\", _bIsFilter)"
  },
  {
    "label": "CExprIteration()",
    "kind": "Method",
    "detail": "Function (bool _bIsFilter { false } ; private : TSRef<CExprCodeBlock> _Condition ; TSPtr<CExpressionBase> _ThenClause ; TSPtr<CExpressionBase> _ElseClause ; } ; class CExprIteration : public CExpressionBase { public :)",
    "insertText": "CExprIteration()"
  },
  {
    "label": "SetBody()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetBody(TSPtr<CExpressionBase>&& Body)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Body =)",
    "insertText": "Move(Body)"
  },
  {
    "label": "AddFilter()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddFilter(TSRef<CExpressionBase>&& Filter)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (_Filters .)",
    "insertText": "Add(Move(Filter))"
  },
  {
    "label": "VisitArray()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitArray(\"Filters\", _Filters)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"Body\", _Body)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"TypeType\", _TypeType)"
  },
  {
    "label": "CExprUnaryTypeFormer()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprUnaryTypeFormer : public CExprTypeFormer { public :)",
    "insertText": "CExprUnaryTypeFormer(TSRef<CExpressionBase>&& InnerTypeAst): _InnerTypeAst(Move(InnerTypeAst))"
  },
  {
    "label": "GetInnerTypeAst()",
    "kind": "Method",
    "detail": "Function (} const TSRef<CExpressionBase>&)",
    "insertText": "GetInnerTypeAst()"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_InnerTypeAst =)",
    "insertText": "Move(InnerTypeAst)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"InnerTypeAst\", _InnerTypeAst)"
  },
  {
    "label": "CExprArrayTypeFormer()",
    "kind": "Method",
    "detail": "Function (} private : TSRef<CExpressionBase> _InnerTypeAst ; } ; class CExprArrayTypeFormer : public CExprUnaryTypeFormer { public :)",
    "insertText": "CExprArrayTypeFormer(TSRef<CExpressionBase>&& InnerTypeAst): CExprUnaryTypeFormer(Move(InnerTypeAst))"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(_TypeType, \"GetArrayType called on unanalyzed expression\")"
  },
  {
    "label": "CExprGeneratorTypeFormer()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprGeneratorTypeFormer : public CExprUnaryTypeFormer { public :)",
    "insertText": "CExprGeneratorTypeFormer(TSRef<CExpressionBase>&& InnerTypeAst) : CExprUnaryTypeFormer(Move(InnerTypeAst))"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(_TypeType, \"GetGeneratorType called on unanalyzed expression\")"
  },
  {
    "label": "CExprMapTypeFormer()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprMapTypeFormer : public CExprTypeFormer { public :)",
    "insertText": "CExprMapTypeFormer(TArray<TSRef<CExpressionBase>>&& KeyTypeAsts, TSRef<CExpressionBase>&& ValueTypeAst) : CExprTypeFormer() , _KeyTypeAsts(KeyTypeAsts) , _ValueTypeAst(ValueTypeAst)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_KeyTypeAsts [ Index ] =)",
    "insertText": "Move(KeyTypeAst)"
  },
  {
    "label": "ValueTypeAst()",
    "kind": "Method",
    "detail": "Function (} const TSRef<CExpressionBase>&)",
    "insertText": "ValueTypeAst()"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_ValueTypeAst =)",
    "insertText": "Move(ValueTypeAst)"
  },
  {
    "label": "GetMapType()",
    "kind": "Method",
    "detail": "Function (} const CMapType*)",
    "insertText": "GetMapType()"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(_TypeType, \"GetMapType called on unanalyzed expression\")"
  },
  {
    "label": "VisitArray()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitArray(\"KeyTypeAsts\", _KeyTypeAsts)"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"ValueTypeAst\", _ValueTypeAst)"
  },
  {
    "label": "CExprOptionTypeFormer()",
    "kind": "Method",
    "detail": "Function (} private : TArray<TSRef<CExpressionBase>> _KeyTypeAsts ; TSRef<CExpressionBase> _ValueTypeAst ; } ; class CExprOptionTypeFormer : public CExprUnaryTypeFormer { public :)",
    "insertText": "CExprOptionTypeFormer(TSRef<CExpressionBase>&& InnerTypeAst): CExprUnaryTypeFormer(Move(InnerTypeAst))"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(_TypeType, \"GetOptionType called on unanalyzed expression\")"
  },
  {
    "label": "CExprSubtype()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprSubtype : public CExprUnaryTypeFormer { public :)",
    "insertText": "CExprSubtype(TSRef<CExpressionBase>&& InnerTypeAst): CExprUnaryTypeFormer(Move(InnerTypeAst))"
  },
  {
    "label": "CExprTupleType()",
    "kind": "Method",
    "detail": "Function (} ; class CExprTupleType : public CExprTypeFormer { public :)",
    "insertText": "CExprTupleType(int32_t ReserveTypeExprNum = 0)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (_ElementTypeExprs .)",
    "insertText": "Reserve(ReserveTypeExprNum)"
  },
  {
    "label": "GetElementTypeExprs()",
    "kind": "Method",
    "detail": "Function (} const TSPtrArray<CExpressionBase>&)",
    "insertText": "GetElementTypeExprs()"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(Index >= 0 && Index < _ElementTypeExprs.Num(), \"Replacing invalid subexpression index\")"
  },
  {
    "label": "ReplaceAt()",
    "kind": "Method",
    "detail": "Function (_ElementTypeExprs .)",
    "insertText": "ReplaceAt(Move(TypeExpr), Index)"
  },
  {
    "label": "VisitArray()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitArray(\"ElemTypeExprs\", _ElementTypeExprs)"
  },
  {
    "label": "GetTupleType()",
    "kind": "Method",
    "detail": "Function (const CTupleType*)",
    "insertText": "GetTupleType()"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(_TypeType, \"GetTupleType called on unanalyzed expression\")"
  },
  {
    "label": "CExprArrow()",
    "kind": "Method",
    "detail": "Function (} protected : TSPtrArray<CExpressionBase> _ElementTypeExprs ; } ; class CExprArrow : public CExprTypeFormer { public :)",
    "insertText": "CExprArrow(TSRef<CExpressionBase>&& Domain, TSRef<CExpressionBase>&& Range) : _Domain(Move(Domain)) , _Range(Move(Range))"
  },
  {
    "label": "GetFunctionType()",
    "kind": "Method",
    "detail": "Function (} const CFunctionType*)",
    "insertText": "GetFunctionType()"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(_TypeType, \"GetFunctionType called on unanalyzed expression\")"
  },
  {
    "label": "CExprArchetypeInstantiation()",
    "kind": "Method",
    "detail": "Function (} private : TSRef<CExpressionBase> _Domain ; TSRef<CExpressionBase> _Range ; } ; class CExprArchetypeInstantiation : public CExpressionBase { public :)",
    "insertText": "CExprArchetypeInstantiation(TSRef<CExpressionBase>&& ClassAst, CExprMacroCall::CClause&& BodyAst, const CTypeBase* ResultType)"
  },
  {
    "label": "Arguments()",
    "kind": "Method",
    "detail": "Function (const TSRefArray<CExpressionBase>&)",
    "insertText": "Arguments()"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"ClassAst\", _ClassAst)"
  },
  {
    "label": "VisitArray()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitArray(\"BodyAstExprs\", _BodyAst.Exprs())"
  },
  {
    "label": "BeginArray()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "BeginArray(\"Arguments\", _Arguments.Num())"
  },
  {
    "label": "VisitElement()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitElement(Argument)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"BodyAstTag\", MacroClauseTagAsCString(_BodyAst.Tag()))"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"BodyAstForm\", MacroClauseFormAsCString(_BodyAst.Form()))"
  },
  {
    "label": "CExprConcurrentBlockBase()",
    "kind": "Method",
    "detail": "Function (TSRef<CExpressionBase> _ClassAst ; CExprMacroCall::CClause _BodyAst ; private : TSRefArray<CExpressionBase> _Arguments ; } ; class CExprConcurrentBlockBase : public CExprCompoundBase { public :)",
    "insertText": "CExprConcurrentBlockBase(int32_t ReserveSubExprNum = 0) : CExprCompoundBase(ReserveSubExprNum)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_BlockExpr =)",
    "insertText": "Move(Expr)"
  },
  {
    "label": "Expr()",
    "kind": "Method",
    "detail": "Function (} const TSPtr<CExpressionBase>&)",
    "insertText": "Expr()"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"BlockExpr\", _BlockExpr)"
  },
  {
    "label": "CMemberDefinitions()",
    "kind": "Method",
    "detail": "Function (} ; class CMemberDefinitions { public :)",
    "insertText": "CMemberDefinitions()"
  },
  {
    "label": "CMemberDefinitions()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CMemberDefinitions(TArray<TSRef<CExpressionBase>>&& Members) : _Members(Move(Members))"
  },
  {
    "label": "Members()",
    "kind": "Method",
    "detail": "Function (} const TArray<TSRef<CExpressionBase>>&)",
    "insertText": "Members()"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Members =)",
    "insertText": "Move(Members)"
  },
  {
    "label": "AppendMember()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendMember(TSRef<CExpressionBase>&& Member)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (_Members .)",
    "insertText": "Add(Move(Member))"
  },
  {
    "label": "SetMember()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetMember(TSRef<CExpressionBase>&& Member, int32_t Index)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_Members [ Index ] =)",
    "insertText": "Move(Member)"
  },
  {
    "label": "VisitMembers()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VisitMembers(SAstVisitor& Visitor)"
  },
  {
    "label": "VisitArray()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitArray(\"Members\", _Members)"
  },
  {
    "label": "CExprSnippet()",
    "kind": "Method",
    "detail": "Function (} private : TArray<TSRef<CExpressionBase>> _Members ; } ; class CExprSnippet : public CExpressionBase,public CMemberDefinitions { public : CUTF8String _Path ; CSnippet* _SemanticSnippet { nullptr } ;)",
    "insertText": "CExprSnippet(const CUTF8StringView& Path) : _Path(Path)"
  },
  {
    "label": "VisitMembers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VisitMembers(Visitor)"
  },
  {
    "label": "CExprModuleDefinition()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprModuleDefinition : public CExpressionBase,public CMemberDefinitions { public : CUTF8String _Name ; CModulePart* _SemanticModule { nullptr } ; bool _bLegacyPublic = false ;)",
    "insertText": "CExprModuleDefinition(const CUTF8StringView& Name, EVstMappingType VstMappingType = EVstMappingType::Ast) : CExpressionBase(VstMappingType) , _Name(Name)"
  },
  {
    "label": "CExprModuleDefinition()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CExprModuleDefinition(CModulePart& Module, TArray<TSRef<CExpressionBase>>&& Members)"
  },
  {
    "label": "CExprModuleDefinition()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "CExprModuleDefinition()"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"Name\", _Name)"
  },
  {
    "label": "CExprEnumDefinition()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprEnumDefinition : public CExpressionBase { public : CEnumeration& _Enum ; const TArray<TSRef<CExpressionBase>> _Members ;)",
    "insertText": "CExprEnumDefinition(CEnumeration& Enum, TArray<TSRef<CExpressionBase>>&& Members, EVstMappingType = EVstMappingType::Ast)"
  },
  {
    "label": "CExprEnumDefinition()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "CExprEnumDefinition()"
  },
  {
    "label": "CExprScopedAccessLevelDefinition()",
    "kind": "Method",
    "detail": "Function (} ; class CExprScopedAccessLevelDefinition : public CExpressionBase { public : TSRef<CScopedAccessLevelDefinition> _AccessLevelDefinition ; TArray<TSRef<CExpressionBase>> _ScopeReferenceExprs ;)",
    "insertText": "CExprScopedAccessLevelDefinition(TSRef<CScopedAccessLevelDefinition>& AccessLevelDefinition, EVstMappingType VstMappingType = EVstMappingType::Ast)"
  },
  {
    "label": "CExprScopedAccessLevelDefinition()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "CExprScopedAccessLevelDefinition()"
  },
  {
    "label": "VisitArray()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitArray(\"Scopes\", _ScopeReferenceExprs)"
  },
  {
    "label": "SuperInterfaces()",
    "kind": "Method",
    "detail": "Function (} ; class CExprInterfaceDefinition : public CExpressionBase,public CMemberDefinitions { public : CInterface& _Interface ; const TArray<TSRef<CExpressionBase>>&)",
    "insertText": "SuperInterfaces()"
  },
  {
    "label": "SetSuperInterface()",
    "kind": "Method",
    "detail": "Function (_SuperInterfaces = SuperInterfaces ; } void)",
    "insertText": "SetSuperInterface(TSRef<CExpressionBase>&& SuperInterface, int32_t Index)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_SuperInterfaces [ Index ] =)",
    "insertText": "Move(SuperInterface)"
  },
  {
    "label": "CExprInterfaceDefinition()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CExprInterfaceDefinition(CInterface& Interface, TArray<TSRef<CExpressionBase>>&& SuperInterfaces, TArray<TSRef<CExpressionBase>>&& Members, EVstMappingType = EVstMappingType::Ast)"
  },
  {
    "label": "CExprInterfaceDefinition()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CExprInterfaceDefinition(CInterface& Interface, EVstMappingType VstMappingType = EVstMappingType::Ast) : CExprInterfaceDefinition(Interface, {}, {}, VstMappingType)"
  },
  {
    "label": "CExprInterfaceDefinition()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "CExprInterfaceDefinition()"
  },
  {
    "label": "CExprClassDefinition()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CExprClassDefinition(CClass& Class, EVstMappingType VstMappingType = EVstMappingType::Ast) : CExprClassDefinition(Class, {}, {}, VstMappingType)"
  },
  {
    "label": "CExprClassDefinition()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "CExprClassDefinition()"
  },
  {
    "label": "SuperTypes()",
    "kind": "Method",
    "detail": "Function (const TArray<TSRef<CExpressionBase>>&)",
    "insertText": "SuperTypes()"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_SuperTypes =)",
    "insertText": "Move(SuperTypes)"
  },
  {
    "label": "SetSuperType()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetSuperType(TSRef<CExpressionBase>&& SuperType, int32_t Index)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_SuperTypes [ Index ] =)",
    "insertText": "Move(SuperType)"
  },
  {
    "label": "CExprDataDefinition()",
    "kind": "Method",
    "detail": "Function (private : TArray<TSRef<CExpressionBase>> _SuperTypes ; } ; class CExprDataDefinition : public CExprDefinition { public : const TSRef<CDataDefinition> _DataMember ;)",
    "insertText": "CExprDataDefinition(const TSRef<CDataDefinition>& DataMember, TSPtr<CExpressionBase>&& Element, TSPtr<CExpressionBase>&& ValueDomain, TSPtr<CExpressionBase>&& Value, EVstMappingType = EVstMappingType::Ast)"
  },
  {
    "label": "CExprDataDefinition()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "CExprDataDefinition()"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"DataMember\", *_DataMember)"
  },
  {
    "label": "CExprIterationPairDefinition()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprIterationPairDefinition : public CExprDefinition { public : const TSRef<CDataDefinition> _KeyDefinition ; const TSRef<CDataDefinition> _ValueDefinition ;)",
    "insertText": "CExprIterationPairDefinition(TSRef<CDataDefinition>&& KeyDefinition, TSRef<CDataDefinition>&& ValueDefinition, TSPtr<CExpressionBase>&& Element, TSPtr<CExpressionBase>&& ValueDomain, TSPtr<CExpressionBase>&& Value, EVstMappingType VstMappingType = EVstMappingType::Ast)"
  },
  {
    "label": "CExprIterationPairDefinition()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "CExprIterationPairDefinition()"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"KeyDefinition\", *_KeyDefinition)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"ValueDefinition\", *_ValueDefinition)"
  },
  {
    "label": "CIrArrayAdd()",
    "kind": "Method",
    "detail": "Function (} } ; class CIrArrayAdd : public CExpressionBase { public :)",
    "insertText": "CIrArrayAdd(TSRef<CExpressionBase>&& Source) : CExpressionBase(EVstMappingType::Ir) , _Source(Move(Source))"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"Source\", _Source)"
  },
  {
    "label": "CIrMapAdd()",
    "kind": "Method",
    "detail": "Function (} TSRef<CExpressionBase> _Source ; } ; class CIrMapAdd : public CExpressionBase { public :)",
    "insertText": "CIrMapAdd(TSRef<CExpressionBase>&& Key, TSRef<CExpressionBase>&& Value) : CExpressionBase(EVstMappingType::Ir) , _Key(Move(Key)) , _Value(Move(Value))"
  },
  {
    "label": "FindFirstAsyncSubExpr()",
    "kind": "Method",
    "detail": "Function (const CExpressionBase*)",
    "insertText": "FindFirstAsyncSubExpr(const CSemanticProgram&)"
  },
  {
    "label": "CIrArrayUnsafeCall()",
    "kind": "Method",
    "detail": "Function (TSRef<CExpressionBase> _Key ; TSRef<CExpressionBase> _Value ; } ; class CIrArrayUnsafeCall : public CExpressionBase { public :)",
    "insertText": "CIrArrayUnsafeCall(TSRef<CExpressionBase>&& Callee, TSRef<CExpressionBase>&& Arguments) : _Callee(Move(Callee)) , _Argument(Move(Arguments))"
  },
  {
    "label": "CIrConvertToDynamic()",
    "kind": "Method",
    "detail": "Function (} TSRef<CExpressionBase> _Callee ; TSRef<CExpressionBase> _Argument ; } ; class CIrConvertToDynamic : public CExprUnaryOp { public :)",
    "insertText": "CIrConvertToDynamic(const CTypeBase* ResultType, TSRef<CExpressionBase>&& Value)"
  },
  {
    "label": "CIrConvertFromDynamic()",
    "kind": "Method",
    "detail": "Function (} } ; class CIrConvertFromDynamic : public CExprUnaryOp { public :)",
    "insertText": "CIrConvertFromDynamic(const CTypeBase* ResultType, TSRef<CExpressionBase>&& Value)"
  },
  {
    "label": "CIrFor()",
    "kind": "Method",
    "detail": "Function (} } ; class CIrFor : public CExpressionBase { public : bool _bOutermost { true } ; bool _bGenerateResult { true } ; bool _bCanFail { false } ; const TSPtr<CDataDefinition> _KeyMember ; const TSRef<CDataDefinition> _DataMember ; const TSRef<CExprDefinition> _Definition ;)",
    "insertText": "CIrFor(const TSRef<CDataDefinition>& DataMember, TSPtr<CExpressionBase>&& Element, TSPtr<CExpressionBase>&& ValueDomain, TSPtr<CExpressionBase>&& Value) : CExpressionBase(EVstMappingType::Ir) , _KeyMember() , _DataMember(DataMember) , _Definition(TSRef<CExprDefinition>::New(Move(Element), Move(ValueDomain), Move(Value), EVstMappingType::Ir))"
  },
  {
    "label": "CIrFor()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CIrFor(const TSRef<CDataDefinition>& KeyMember, const TSRef<CDataDefinition>& DataMember, TSPtr<CExpressionBase>&& Element, TSPtr<CExpressionBase>&& ValueDomain, TSPtr<CExpressionBase>&& Value) : CExpressionBase(EVstMappingType::Ir) , _KeyMember(KeyMember) , _DataMember(DataMember) , _Definition(TSRef<CExprDefinition>::New(Move(Element), Move(ValueDomain), Move(Value), EVstMappingType::Ir))"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"Definition\", _Definition)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"bGenerateResult\", _bGenerateResult)"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"KeyMember\", *_KeyMember)"
  },
  {
    "label": "CIrForBody()",
    "kind": "Method",
    "detail": "Function (public : TSPtr<CControlScope> _AssociatedScope ; TSPtr<CExpressionBase> _Body ; } ; class CIrForBody : public CExpressionBase { public :)",
    "insertText": "CIrForBody(TSPtr<CExpressionBase>&& Body) : CExpressionBase(EVstMappingType::Ir) , _Body(Body)"
  },
  {
    "label": "CExprFunctionDefinition()",
    "kind": "Method",
    "detail": "Function (public : TSPtr<CExpressionBase> _Body ; } ; class CExprFunctionDefinition : public CExprDefinition { public : const TSRef<CFunction> _Function ;)",
    "insertText": "CExprFunctionDefinition(const TSRef<CFunction>& Function, TSPtr<CExpressionBase>&& Element, TSPtr<CExpressionBase>&& ValueDomain, TSPtr<CExpressionBase>&& Value, EVstMappingType = EVstMappingType::Ast)"
  },
  {
    "label": "CExprFunctionDefinition()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "CExprFunctionDefinition()"
  },
  {
    "label": "CExprTypeAliasDefinition()",
    "kind": "Method",
    "detail": "Function (} ; class CExprTypeAliasDefinition : public CExprDefinition { public : const TSRef<CTypeAlias> _TypeAlias ;)",
    "insertText": "CExprTypeAliasDefinition(const TSRef<CTypeAlias>& TypeAlias, TSPtr<CExpressionBase>&& Element, TSPtr<CExpressionBase>&& ValueDomain, TSPtr<CExpressionBase>&& Value, EVstMappingType = EVstMappingType::Ast)"
  },
  {
    "label": "CExprTypeAliasDefinition()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "CExprTypeAliasDefinition()"
  },
  {
    "label": "CExprUsing()",
    "kind": "Method",
    "detail": "Function (} } ; class CExprUsing : public CExpressionBase { public : const CModule* _Module = nullptr ; TSRef<CExpressionBase> _Context ;)",
    "insertText": "CExprUsing(TSRef<CExpressionBase>&& Context) : _Context(Move(Context))"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"UserTag\", _UserTag)"
  },
  {
    "label": "VisitChildren()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VisitChildren(Visitor)"
  },
  {
    "label": "CExprImport()",
    "kind": "Method",
    "detail": "Function (} TSPtr<uLang::CExpressionBase> _UserTag ; } ; class CExprImport : public CExpressionBase { public : const TSRef<CModuleAlias> _ModuleAlias ; const TSRef<CExpressionBase> _Path ;)",
    "insertText": "CExprImport(const TSRef<CModuleAlias>& ModuleAlias, TSRef<CExpressionBase>&& Path, EVstMappingType VstMappingType = EVstMappingType::Ast)"
  },
  {
    "label": "CExprImport()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "CExprImport()"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "Visit(\"Path\", _Path)"
  },
  {
    "label": "CExprWhere()",
    "kind": "Method",
    "detail": "Function (} ; class CExprWhere : public CExpressionBase { public :)",
    "insertText": "CExprWhere(TSRef<CExpressionBase>&& Lhs, TSPtrArray<CExpressionBase>&& Rhs) : _Lhs(Move(Lhs)) , _Rhs(Move(Rhs))"
  },
  {
    "label": "VisitArray()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitArray(\"Rhs\", _Rhs)"
  },
  {
    "label": "SetRhs()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetRhs(TSPtrArray<CExpressionBase> NewRhs)"
  },
  {
    "label": "CExprMakeNamed()",
    "kind": "Method",
    "detail": "Function (} ; class CExprMakeNamed : public CExpressionBase { public :)",
    "insertText": "CExprMakeNamed(CSymbol Name) : _Name(Name)"
  },
  {
    "label": "CExprMakeNamed()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CExprMakeNamed(CSymbol Name, TSPtr<CExpressionBase>&& Argument) : _Name(Name) , _Value(Move(Argument))"
  },
  {
    "label": "VisitImmediate()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitImmediate(\"Name\", _Name.AsStringView())"
  },
  {
    "label": "CAstPackage()",
    "kind": "Method",
    "detail": "Function (} private : CSymbol _Name ; TSPtr<CExpressionBase> _Value ; } ; class CAstPackage : public CAstNode,public CMemberDefinitions { public : CUTF8String _Name ; CUTF8String _VersePath ; CModulePart* _RootModule = nullptr ; TArray<const CAstPackage*> _Dependencies ; TArray<const CAstPackage*> _UsedDependencies ; EVerseScope _VerseScope ; EPackageRole _Role ; uint32_t _EffectiveVerseVersion ; uint32_t _UploadedAtFNVersion = VerseFN::UploadedAtFNVersion::Latest ; int32_t _NumPersistentVars = 0 ; bool _bAllowNative ; bool _bTreatModulesAsImplicit ; bool _bAllowExperimental ; CAstCompilationUnit* _CompilationUnit = nullptr ;)",
    "insertText": "CAstPackage(const CUTF8String& Name, const CUTF8String& VersePath, const EVerseScope VerseScope, const EPackageRole Role, const uint32_t EffectiveVerseVersion, const uint32_t UploadedAtFNVersion, const bool bAllowNative, const bool bTreatDefinitionsAsImplicit, const bool bAllowExperimental) : _Name(Name) , _VersePath(VersePath) , _VerseScope(VerseScope) , _Role(Role) , _EffectiveVerseVersion(EffectiveVerseVersion) , _UploadedAtFNVersion(UploadedAtFNVersion) , _bAllowNative(bAllowNative) , _bTreatModulesAsImplicit(bTreatDefinitionsAsImplicit) , _bAllowExperimental(bAllowExperimental)"
  },
  {
    "label": "CanSeeDefinition()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CanSeeDefinition(const CDefinition& Definition)"
  },
  {
    "label": "Packages()",
    "kind": "Method",
    "detail": "Function (} ; class CAstCompilationUnit : public CAstNode { public : const TSRefArray<CAstPackage>&)",
    "insertText": "Packages()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (_Packages .)",
    "insertText": "Reserve(Num)"
  },
  {
    "label": "AppendPackage()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendPackage(TSRef<CAstPackage>&& Package)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (_Packages .)",
    "insertText": "Add(Move(Package))"
  },
  {
    "label": "GetRole()",
    "kind": "Method",
    "detail": "Function (} EPackageRole)",
    "insertText": "GetRole()"
  },
  {
    "label": "IsAllowNative()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsAllowNative()"
  },
  {
    "label": "VisitArray()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitArray(\"Packages\", _Packages)"
  },
  {
    "label": "CAstProject()",
    "kind": "Method",
    "detail": "Function (} private : TSRefArray<CAstPackage> _Packages ; } ; class CAstProject : public CAstNode { public : CUTF8String _Name ;)",
    "insertText": "CAstProject(const CUTF8StringView& Name) : _Name(Name)"
  },
  {
    "label": "OrderedCompilationUnits()",
    "kind": "Method",
    "detail": "Function (} const TSRefArray<CAstCompilationUnit>&)",
    "insertText": "OrderedCompilationUnits()"
  },
  {
    "label": "AppendCompilationUnit()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendCompilationUnit(TSRef<CAstCompilationUnit>&& CompilationUnit)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (_OrderedCompilationUnits .)",
    "insertText": "Add(Move(CompilationUnit))"
  },
  {
    "label": "FindPackageByName()",
    "kind": "Method",
    "detail": "Function (} const CAstPackage*)",
    "insertText": "FindPackageByName(const CUTF8String& PackageName)"
  },
  {
    "label": "GetNumPackages()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "GetNumPackages()"
  },
  {
    "label": "VisitArray()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "VisitArray(\"CompilationUnits\", _OrderedCompilationUnits)"
  },
  {
    "label": "TAstFunctionVisitor()",
    "kind": "Method",
    "detail": "Function (} private : TSRefArray<CAstCompilationUnit> _OrderedCompilationUnits ; } ; template<FunctionType> struct TAstFunctionVisitor : public SAstVisitor { FunctionType _Function ;)",
    "insertText": "TAstFunctionVisitor(FunctionType&& Function) : _Function(ForwardArg<FunctionType>(Function))"
  },
  {
    "label": "_Function()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_Function(*this, AstNode)"
  },
  {
    "label": "FunctionVisitor()",
    "kind": "Method",
    "detail": "Function (TAstFunctionVisitor<FunctionType>)",
    "insertText": "FunctionVisitor(ForwardArg<FunctionType>(Function))"
  },
  {
    "label": "VisitChildren()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VisitChildren(FunctionVisitor)"
  },
  {
    "label": "Cast()",
    "kind": "Method",
    "detail": "Function (} } ; template<TOut> struct TAsNullableTraitsOf<TSRef<CExpressionBase>,TOut> { using TResult = TSPtr<TOut> ; TResult)",
    "insertText": "Cast(TSRef<CExpressionBase> X)"
  },
  {
    "label": "Cast()",
    "kind": "Method",
    "detail": "Function (} } ; template<TOut> struct TAsNullableTraitsOf<CExpressionBase*,TOut> { using TResult = TOut* ; TResult)",
    "insertText": "Cast(CExpressionBase* X)"
  },
  {
    "label": "Cast()",
    "kind": "Method",
    "detail": "Function (} } ; template<TOut> struct TAsNullableTraitsOf<const CExpressionBase*,TOut> { using TResult = const TOut* ; TResult)",
    "insertText": "Cast(const CExpressionBase* X)"
  },
  {
    "label": "AsNullable()",
    "kind": "Method",
    "detail": "Function (} } ; template<TOut,TIn,Traits = TAsNullableTraitsOf<TIn,TOut>> Traits::TResult)",
    "insertText": "AsNullable(TIn Expr)"
  },
  {
    "label": "VISIT_AST_NODE_TYPE()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "VISIT_AST_NODE_TYPE(Name, Class) \\ if constexpr (std::is_same_v<TOut, Class>)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(Expr && Expr->GetNodeType() == EAstNodeType::Name)"
  },
  {
    "label": "Cast()",
    "kind": "Method",
    "detail": "Function (\\ return)",
    "insertText": "Cast(Expr)"
  },
  {
    "label": "VERSE_VISIT_AST_NODE_TYPES()",
    "kind": "Method",
    "detail": "Function (\\ } \\ })",
    "insertText": "VERSE_VISIT_AST_NODE_TYPES(VISIT_AST_NODE_TYPE)"
  }
]