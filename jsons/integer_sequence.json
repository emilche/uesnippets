[
  {
    "label": "_Tp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tp"
  },
  {
    "label": "_LIBCPP_TEMPLATE_VIS",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_LIBCPP_TEMPLATE_VIS"
  },
  {
    "label": "__make_integer_sequence_checked",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__make_integer_sequence_checked"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___UTILITY_INTEGER_SEQUENCE_H # define _LIBCPP___UTILITY_INTEGER_SEQUENCE_H # include<__config> # include<type_traits> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (typedef _Tp value_type ;)",
    "insertText": "static_assert(is_integral<_Tp>::value, \"std::integer_sequence can only be instantiated with an integral type\")"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_INLINE_VISIBILITY size_t)",
    "insertText": "size()"
  },
  {
    "label": "__has_builtin()",
    "kind": "Method",
    "detail": "Function (} } ; template<size_t . . . _Ip> using index_sequence = integer_sequence<size_t,_Ip . . .> ; # if)",
    "insertText": "__has_builtin(__make_integer_seq) && !defined(_LIBCPP_TESTING_FALLBACK_MAKE_INTEGER_SEQUENCE)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# else template<_Tp,_Tp _Np> using __make_integer_sequence_unchecked _LIBCPP_NODEBUG = __detail::__make<_Np>::type::template __convert<integer_sequence,_Tp> ; template<class _Tp,_Tp _Ep> struct __make_integer_sequence_checked {)",
    "insertText": "static_assert(is_integral<_Tp>::value, \"std::make_integer_sequence can only be instantiated with an integral type\")"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (typedef _LIBCPP_NODEBUG __make_integer_sequence_unchecked<_Tp,0<= _Ep ? _Ep : 0> type ; } ; template<class _Tp,_Tp _Ep> using __make_integer_sequence _LIBCPP_NODEBUG = __make_integer_sequence_checked<_Tp,_Ep>::type ; # endif template<class _Tp,_Tp _Np> using make_integer_sequence = __make_integer_sequence<_Tp,_Np> ; template<size_t _Np> using make_index_sequence = make_integer_sequence<size_t,_Np> ; template<class . . . _Tp> using index_sequence_for = make_index_sequence<)",
    "insertText": "sizeof(_Tp)"
  }
]