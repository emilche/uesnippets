[
  {
    "label": "_Fun",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Fun"
  },
  {
    "label": "_Tuple",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tuple"
  },
  {
    "label": "_Tuple1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tuple1"
  },
  {
    "label": "_Tuple2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tuple2"
  },
  {
    "label": "_Tp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tp"
  },
  {
    "label": "zip_view",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "zip_view"
  },
  {
    "label": "__iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "__iterator"
  },
  {
    "label": "__sentinel",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "__sentinel"
  },
  {
    "label": "__zip_view_iterator_category_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__zip_view_iterator_category_base"
  },
  {
    "label": "_Iter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Iter"
  },
  {
    "label": "__fn",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__fn"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___RANGES_ZIP_VIEW_H # define _LIBCPP___RANGES_ZIP_VIEW_H # include<__config> # include<__algorithm / ranges_min . h> # include<__compare / three_way_comparable . h> # include<__concepts / convertible_to . h> # include<__concepts / equality_comparable . h> # include<__functional / invoke . h> # include<__functional / operations . h> # include<__iterator / concepts . h> # include<__iterator / incrementable_traits . h> # include<__iterator / iter_move . h> # include<__iterator / iter_swap . h> # include<__iterator / iterator_traits . h> # include<__ranges / access . h> # include<__ranges / all . h> # include<__ranges / concepts . h> # include<__ranges / empty_view . h> # include<__ranges / enable_borrowed_range . h> # include<__ranges / size . h> # include<__ranges / view_interface . h> # include<__utility / forward . h> # include<__utility / integer_sequence . h> # include<__utility / move . h> # include<tuple> # include<type_traits> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER) # pragma GCC system_header #endif _LIBCPP_PUSH_MACROS #include <__undef_macros> _LIBCPP_BEGIN_NAMESPACE_STD #if _LIBCPP_STD_VER > 20 && !defined(_LIBCPP_HAS_NO_INCOMPLETE_RANGES)"
  },
  {
    "label": "__zip_is_common()",
    "kind": "Method",
    "detail": "Function (template<class . . . _Ranges> concept)",
    "insertText": "__zip_is_common(sizeof...(_Ranges) == 1 && (common_range<_Ranges> && ...)) || (!(bidirectional_range<_Ranges> && ...) && (common_range<_Ranges> && ...)) || ((random_access_range<_Ranges> && ...) && (sized_range<_Ranges> && ...))"
  },
  {
    "label": "__tuple_or_pair_test()",
    "kind": "Method",
    "detail": "Function (pair<_Tp, _Up>)",
    "insertText": "__tuple_or_pair_test()"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (tuple<_Types...>)",
    "insertText": "requires(sizeof...(_Types) != 2) auto __tuple_or_pair_test()"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (template<class . . . _Types> using __tuple_or_pair =)",
    "insertText": "decltype(__tuple_or_pair_test<_Types...>())"
  },
  {
    "label": "__tuple_transform()",
    "kind": "Method",
    "detail": "Function (template<class _Fun,class _Tuple> _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "__tuple_transform(_Fun&& __f, _Tuple&& __tuple)"
  },
  {
    "label": "__tuple_for_each()",
    "kind": "Method",
    "detail": "Function (} template<class _Fun,class _Tuple> _LIBCPP_HIDE_FROM_ABI void)",
    "insertText": "__tuple_for_each(_Fun&& __f, _Tuple&& __tuple)"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "apply([&]<class... _Types>(_Types&&... __elements) { (std::invoke(__f, std::forward<_Types>(__elements)), ...); }, std::forward<_Tuple>(__tuple))"
  },
  {
    "label": "__tuple_zip_transform()",
    "kind": "Method",
    "detail": "Function (} template<class _Fun,class _Tuple1,class _Tuple2,size_t . . . _Indices> _LIBCPP_HIDE_FROM_ABI __tuple_or_pair<invoke_result_t<_Fun&,tuple_element<_Indices,remove_cvref_t<_Tuple1>>::type,tuple_element<_Indices,remove_cvref_t<_Tuple2>>::type> . . .>)",
    "insertText": "__tuple_zip_transform(_Fun&& __f, _Tuple1&& __tuple1, _Tuple2&& __tuple2, index_sequence<_Indices...>)"
  },
  {
    "label": "__tuple_zip_transform()",
    "kind": "Method",
    "detail": "Function (} template<class _Fun,class _Tuple1,class _Tuple2> _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "__tuple_zip_transform(_Fun&& __f, _Tuple1&& __tuple1, _Tuple2&& __tuple2)"
  },
  {
    "label": "__tuple_zip_for_each()",
    "kind": "Method",
    "detail": "Function (} template<class _Fun,class _Tuple1,class _Tuple2,size_t . . . _Indices> _LIBCPP_HIDE_FROM_ABI void)",
    "insertText": "__tuple_zip_for_each(_Fun&& __f, _Tuple1&& __tuple1, _Tuple2&& __tuple2, index_sequence<_Indices...>)"
  },
  {
    "label": "__tuple_zip_for_each()",
    "kind": "Method",
    "detail": "Function (} template<class _Fun,class _Tuple1,class _Tuple2> _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "__tuple_zip_for_each(_Fun&& __f, _Tuple1&& __tuple1, _Tuple2&& __tuple2)"
  },
  {
    "label": "__tuple_any_equals()",
    "kind": "Method",
    "detail": "Function (} template<class _Tuple1,class _Tuple2> _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "__tuple_any_equals(const _Tuple1& __tuple1, const _Tuple2& __tuple2)"
  },
  {
    "label": "__tuple_zip_transform()",
    "kind": "Method",
    "detail": "Function (const auto __equals =)",
    "insertText": "__tuple_zip_transform(std::equal_to<>(), __tuple1, __tuple2)"
  },
  {
    "label": "__abs()",
    "kind": "Method",
    "detail": "Function (} template<class _Tp> _LIBCPP_HIDE_FROM_ABI _Tp)",
    "insertText": "__abs(_Tp __t)"
  },
  {
    "label": "zip_view()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_NO_UNIQUE_ADDRESS tuple<_Views . . .> __views_ ; template<bool> class __iterator ; template<bool> class __sentinel ; public : _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "zip_view()"
  },
  {
    "label": "zip_view()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI)",
    "insertText": "zip_view(_Views... __views) : __views_(std::move(__views)...)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "begin() requires(!(__simple_view<_Views> && ...))"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "begin() const requires(range<const _Views> && ...)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "end() requires(!(__simple_view<_Views> && ...))"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr((random_access_range<_Views> && ...))"
  },
  {
    "label": "false()",
    "kind": "Method",
    "detail": "Function (} else { return __iterator<)",
    "insertText": "false(ranges::__tuple_transform(ranges::end, __views_))"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} } _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "end() const requires(range<const _Views> && ...)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr((random_access_range<const _Views> && ...))"
  },
  {
    "label": "true()",
    "kind": "Method",
    "detail": "Function (} else { return __iterator<)",
    "insertText": "true(ranges::__tuple_transform(ranges::end, __views_))"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} } _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "size() requires(sized_range<_Views> && ...)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "size() const requires(sized_range<const _Views> && ...)"
  },
  {
    "label": "zip_view()",
    "kind": "Method",
    "detail": "Function (zip_view<views::all_t<_Ranges>...>)",
    "insertText": "zip_view(_Ranges&&...)"
  },
  {
    "label": "__zip_all_random_access()",
    "kind": "Method",
    "detail": "Function (template<bool _Const,class . . . _Views> concept)",
    "insertText": "__zip_all_random_access(random_access_range<__maybe_const<_Const, _Views>> && ...)"
  },
  {
    "label": "__zip_all_bidirectional()",
    "kind": "Method",
    "detail": "Function (template<bool _Const,class . . . _Views> concept)",
    "insertText": "__zip_all_bidirectional(bidirectional_range<__maybe_const<_Const, _Views>> && ...)"
  },
  {
    "label": "__zip_all_forward()",
    "kind": "Method",
    "detail": "Function (template<bool _Const,class . . . _Views> concept)",
    "insertText": "__zip_all_forward(forward_range<__maybe_const<_Const, _Views>> && ...)"
  },
  {
    "label": "__get_zip_view_iterator_tag()",
    "kind": "Method",
    "detail": "Function (template<bool _Const,class . . . _Views> consteval auto)",
    "insertText": "__get_zip_view_iterator_tag()"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(__zip_all_bidirectional<_Const, _Views...>)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(__zip_all_forward<_Const, _Views...>)"
  },
  {
    "label": "input_iterator_tag()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "input_iterator_tag()"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (} } template<bool _Const,class . . . _Views> struct __zip_view_iterator_category_base { } ; template<bool _Const,class . . . _Views> requires __zip_all_forward<_Const,_Views . . .> struct __zip_view_iterator_category_base<_Const,_Views . . .> { using iterator_category = input_iterator_tag ; } ; template<input_range . . . _Views>)",
    "insertText": "requires(view<_Views> && ...) && (sizeof...(_Views) > 0)"
  },
  {
    "label": "__iterator()",
    "kind": "Method",
    "detail": "Function (__tuple_or_pair<iterator_t<__maybe_const<_Const,_Views>> . . .> __current_ ; _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__iterator(__tuple_or_pair<iterator_t<__maybe_const<_Const, _Views>>...> __current) : __current_(std::move(__current))"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<bool> class zip_view<_Views . . .>::__iterator ; template<bool> class zip_view<_Views . . .>::__sentinel ; class zip_view<_Views . . .> ; public : using iterator_concept =)",
    "insertText": "decltype(__get_zip_view_iterator_tag<_Const, _Views...>())"
  },
  {
    "label": "__iterator()",
    "kind": "Method",
    "detail": "Function (using value_type = __tuple_or_pair<range_value_t<__maybe_const<_Const,_Views>> . . .> ; using difference_type = common_type_t<range_difference_t<__maybe_const<_Const,_Views>> . . .> ; _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__iterator()"
  },
  {
    "label": "__iterator()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__iterator(__iterator<!_Const> __i) requires _Const && (convertible_to<iterator_t<_Views>, iterator_t<__maybe_const<_Const, _Views>>> && ...) : __current_(std::move(__i.__current_))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()"
  },
  {
    "label": "__tuple_for_each()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__tuple_for_each([](auto& __i) { ++__i; }, __current_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (+ +* this ; } _LIBCPP_HIDE_FROM_ABI __iterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "__tuple_for_each()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__tuple_for_each([](auto& __i) { --__i; }, __current_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (auto __tmp =* this ; - -* this ; return __tmp ; } _LIBCPP_HIDE_FROM_ABI __iterator&)",
    "insertText": "operator(difference_type __x)"
  },
  {
    "label": "__tuple_for_each()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__tuple_for_each([&]<class _Iter>(_Iter& __i) { __i += iter_difference_t<_Iter>(__x); }, __current_)"
  },
  {
    "label": "__tuple_for_each()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__tuple_for_each([&]<class _Iter>(_Iter& __i) { __i -= iter_difference_t<_Iter>(__x); }, __current_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "operator(const __iterator& __x, const __iterator& __y) requires(equality_comparable<iterator_t<__maybe_const<_Const, _Views>>> && ...)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "operator(const __iterator& __x, const __iterator& __y)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator(const __iterator& __x, const __iterator& __y) requires __zip_all_random_access<_Const, _Views...> && (three_way_comparable<iterator_t<__maybe_const<_Const, _Views>>> && ...)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (auto __r = __i ; __r + = __n ; return __r ; } _LIBCPP_HIDE_FROM_ABI __iterator)",
    "insertText": "operator(difference_type __n, const __iterator& __i)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (auto __r = __i ; __r - = __n ; return __r ; } _LIBCPP_HIDE_FROM_ABI difference_type)",
    "insertText": "operator(const __iterator& __x, const __iterator& __y) requires(sized_sentinel_for<iterator_t<__maybe_const<_Const, _Views>>, iterator_t<__maybe_const<_Const, _Views>>> && ...)"
  },
  {
    "label": "__tuple_zip_transform()",
    "kind": "Method",
    "detail": "Function (const auto __diffs =)",
    "insertText": "__tuple_zip_transform(minus<>(), __x.__current_, __y.__current_)"
  },
  {
    "label": "iter_move()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "iter_move(const __iterator& __i) noexcept( (noexcept(ranges::iter_move(declval<const iterator_t<__maybe_const<_Const, _Views>>&>())) && ...) && (is_nothrow_move_constructible_v<range_rvalue_reference_t<__maybe_const<_Const, _Views>>> && ...))"
  },
  {
    "label": "iter_swap()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI void)",
    "insertText": "iter_swap(const __iterator& __l, const __iterator& __r) noexcept( (noexcept(ranges::iter_swap(declval<const iterator_t<__maybe_const<_Const, _Views>>&>(), declval<const iterator_t<__maybe_const<_Const, _Views>>&>())) && ...)) requires(indirectly_swappable<iterator_t<__maybe_const<_Const, _Views>>> && ...)"
  },
  {
    "label": "__tuple_zip_for_each()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__tuple_zip_for_each(ranges::iter_swap, __l.__current_, __r.__current_)"
  },
  {
    "label": "__sentinel()",
    "kind": "Method",
    "detail": "Function (__tuple_or_pair<sentinel_t<__maybe_const<_Const,_Views>> . . .> __end_ ; _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__sentinel(__tuple_or_pair<sentinel_t<__maybe_const<_Const, _Views>>...> __end) : __end_(__end)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} class zip_view<_Views . . .> ; template<bool _OtherConst> _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "decltype(auto) __iter_current(zip_view<_Views...>::__iterator<_OtherConst> const& __it)"
  },
  {
    "label": "__sentinel()",
    "kind": "Method",
    "detail": "Function (} public : _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__sentinel()"
  },
  {
    "label": "__sentinel()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__sentinel(__sentinel<!_Const> __i) requires _Const && (convertible_to<sentinel_t<_Views>, sentinel_t<__maybe_const<_Const, _Views>>> && ...) : __end_(std::move(__i.__end_))"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (} template<bool _OtherConst>)",
    "insertText": "requires(sentinel_for<sentinel_t<__maybe_const<_Const, _Views>>, iterator_t<__maybe_const<_OtherConst, _Views>>> && ...) _LIBCPP_HIDE_FROM_ABI friend constexpr bool operator==(const __iterator<_OtherConst>& __x, const __sentinel& __y)"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (} template<bool _OtherConst>)",
    "insertText": "requires(sized_sentinel_for<sentinel_t<__maybe_const<_Const, _Views>>, iterator_t<__maybe_const<_OtherConst, _Views>>> && ...) _LIBCPP_HIDE_FROM_ABI friend constexpr common_type_t<range_difference_t<__maybe_const<_OtherConst, _Views>>...> operator-(const __iterator<_OtherConst>& __x, const __sentinel& __y)"
  },
  {
    "label": "__tuple_zip_transform()",
    "kind": "Method",
    "detail": "Function (const auto __diffs =)",
    "insertText": "__tuple_zip_transform(minus<>(), __iter_current(__x), __y.__end_)"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (} template<bool _OtherConst>)",
    "insertText": "requires(sized_sentinel_for<sentinel_t<__maybe_const<_Const, _Views>>, iterator_t<__maybe_const<_OtherConst, _Views>>> && ...) _LIBCPP_HIDE_FROM_ABI friend constexpr common_type_t<range_difference_t<__maybe_const<_OtherConst, _Views>>...> operator-(const __sentinel& __y, const __iterator<_OtherConst>& __x)"
  },
  {
    "label": "_Views()",
    "kind": "Method",
    "detail": "Function (} } ; template<class . . . _Views> bool enable_borrowed_range<zip_view<)",
    "insertText": "_Views(enable_borrowed_range<_Views> && ...)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (namespace views { namespace __zip { struct __fn { _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()()"
  }
]