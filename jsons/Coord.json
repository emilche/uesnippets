[
  {
    "label": "split",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "split"
  },
  {
    "label": "Coord",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Coord"
  },
  {
    "label": "CoordBBox",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CoordBBox"
  },
  {
    "label": "Iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Iterator"
  },
  {
    "label": "hash",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "hash"
  },
  {
    "label": "Coord()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_MATH_COORD_HAS_BEEN_INCLUDED # define OPENVDB_MATH_COORD_HAS_BEEN_INCLUDED # include<functional> # include<algorithm> # include<array> # include<iostream> # include<limits> # include<openvdb / Platform . h> # include \" Math . h \" # include \" Vec3 . h \" namespace tbb { class split ; } namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace math { class Coord { public : using Int32 = int32_t ; using Index32 = uint32_t ; using Vec3i = Vec3<Int32> ; using Vec3I = Vec3<Index32> ; using ValueType = Int32 ; using Limits = std::numeric_limits<ValueType> ;)",
    "insertText": "Coord()"
  },
  {
    "label": "Coord()",
    "kind": "Method",
    "detail": "Function ({ 0,0,0 } } { })",
    "insertText": "Coord(Int32 xyz)"
  },
  {
    "label": "Coord()",
    "kind": "Method",
    "detail": "Function ({ xyz,xyz,xyz } } { })",
    "insertText": "Coord(Int32 x, Int32 y, Int32 z)"
  },
  {
    "label": "Coord()",
    "kind": "Method",
    "detail": "Function ({ x,y,z } } { })",
    "insertText": "Coord(const Vec3i& v)"
  },
  {
    "label": "Coord()",
    "kind": "Method",
    "detail": "Function ({ v [ 0 ],v [ 1 ],v [ 2 ] } } { })",
    "insertText": "Coord(const Vec3I& v)"
  },
  {
    "label": "Int32()",
    "kind": "Method",
    "detail": "Function ({)",
    "insertText": "Int32(v[0]), Int32(v[1]), Int32(v[2])"
  },
  {
    "label": "Coord()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Coord(const Int32* v)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function ({ v [ 0 ],v [ 1 ],v [ 2 ] } } { } Coord)",
    "insertText": "min()"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (} Coord)",
    "insertText": "max()"
  },
  {
    "label": "round()",
    "kind": "Method",
    "detail": "Function (} template<T> Coord)",
    "insertText": "round(const Vec3<T>& xyz)"
  },
  {
    "label": "floor()",
    "kind": "Method",
    "detail": "Function (} template<T> Coord)",
    "insertText": "floor(const Vec3<T>& xyz)"
  },
  {
    "label": "ceil()",
    "kind": "Method",
    "detail": "Function (} template<T> Coord)",
    "insertText": "ceil(const Vec3<T>& xyz)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (} Coord&)",
    "insertText": "reset(Int32 x, Int32 y, Int32 z)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (mVec [ 0 ] = x ; mVec [ 1 ] = y ; mVec [ 2 ] = z ; return* this ; } Coord&)",
    "insertText": "reset(Int32 xyz)"
  },
  {
    "label": "setX()",
    "kind": "Method",
    "detail": "Function (} Coord&)",
    "insertText": "setX(Int32 x)"
  },
  {
    "label": "setY()",
    "kind": "Method",
    "detail": "Function (mVec [ 0 ] = x ; return* this ; } Coord&)",
    "insertText": "setY(Int32 y)"
  },
  {
    "label": "setZ()",
    "kind": "Method",
    "detail": "Function (mVec [ 1 ] = y ; return* this ; } Coord&)",
    "insertText": "setZ(Int32 z)"
  },
  {
    "label": "offset()",
    "kind": "Method",
    "detail": "Function (mVec [ 2 ] = z ; return* this ; } Coord&)",
    "insertText": "offset(Int32 dx, Int32 dy, Int32 dz)"
  },
  {
    "label": "offset()",
    "kind": "Method",
    "detail": "Function (mVec [ 0 ] + = dx ; mVec [ 1 ] + = dy ; mVec [ 2 ] + = dz ; return* this ; } Coord&)",
    "insertText": "offset(Int32 n)"
  },
  {
    "label": "offsetBy()",
    "kind": "Method",
    "detail": "Function (} Coord)",
    "insertText": "offsetBy(Int32 dx, Int32 dy, Int32 dz)"
  },
  {
    "label": "offsetBy()",
    "kind": "Method",
    "detail": "Function (} Coord)",
    "insertText": "offsetBy(Int32 n)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Coord&)",
    "insertText": "operator(const Coord& rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Coord)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Coord)",
    "insertText": "operator(size_t n)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (mVec [ 0 ]>> = n ; mVec [ 1 ]>> = n ; mVec [ 2 ]>> = n ; return* this ; } Coord)",
    "insertText": "operator(Int32 n)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (mVec [ 0 ] | = n ; mVec [ 1 ] | = n ; mVec [ 2 ] | = n ; return* this ; } Int32)",
    "insertText": "x()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i < 3)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (} Int32*)",
    "insertText": "data()"
  },
  {
    "label": "asPointer()",
    "kind": "Method",
    "detail": "Function (} const Int32*)",
    "insertText": "asPointer()"
  },
  {
    "label": "asVec3d()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "asVec3d()"
  },
  {
    "label": "asVec3s()",
    "kind": "Method",
    "detail": "Function (} Vec3s)",
    "insertText": "asVec3s()"
  },
  {
    "label": "asVec3i()",
    "kind": "Method",
    "detail": "Function (} Vec3i)",
    "insertText": "asVec3i()"
  },
  {
    "label": "asVec3I()",
    "kind": "Method",
    "detail": "Function (} Vec3I)",
    "insertText": "asVec3I()"
  },
  {
    "label": "asXYZ()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "asXYZ(Int32& x, Int32& y, Int32& z)"
  },
  {
    "label": "minComponent()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "minComponent(const Coord& other)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (mVec [ 0 ] =)",
    "insertText": "min(mVec[0], other.mVec[0])"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (mVec [ 1 ] =)",
    "insertText": "min(mVec[1], other.mVec[1])"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (mVec [ 2 ] =)",
    "insertText": "min(mVec[2], other.mVec[2])"
  },
  {
    "label": "maxComponent()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "maxComponent(const Coord& other)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (mVec [ 0 ] =)",
    "insertText": "max(mVec[0], other.mVec[0])"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (mVec [ 1 ] =)",
    "insertText": "max(mVec[1], other.mVec[1])"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (mVec [ 2 ] =)",
    "insertText": "max(mVec[2], other.mVec[2])"
  },
  {
    "label": "minComponent()",
    "kind": "Method",
    "detail": "Function (} Coord)",
    "insertText": "minComponent(const Coord& lhs, const Coord& rhs)"
  },
  {
    "label": "maxComponent()",
    "kind": "Method",
    "detail": "Function (} Coord)",
    "insertText": "maxComponent(const Coord& lhs, const Coord& rhs)"
  },
  {
    "label": "lessThan()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "lessThan(const Coord& a, const Coord& b)"
  },
  {
    "label": "minIndex()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "minIndex()"
  },
  {
    "label": "maxIndex()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "maxIndex()"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "read(std::istream& is)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(mVec.data()), sizeof(mVec))"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "write(std::ostream& os)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(mVec.data()), sizeof(mVec))"
  },
  {
    "label": "hash()",
    "kind": "Method",
    "detail": "Function (} template<int Log2N = 2 0> size_t)",
    "insertText": "hash()"
  },
  {
    "label": "Iterator()",
    "kind": "Method",
    "detail": "Function (} private : std::array<Int32,3> mVec ; } ; class CoordBBox { public : using Index64 = uint64_t ; using ValueType = Coord::ValueType ; template<bool ZYXOrder> class Iterator { public :)",
    "insertText": "Iterator(const CoordBBox& b): mPos(b.min()), mMin(b.min()), mMax(b.max())"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (ZYXOrder ?)",
    "insertText": "next() : next<0,1,2>()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const Iterator& other)"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (} private : template<size_t a,size_t b,size_t c> void)",
    "insertText": "next()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + mPos [ a ] ; } else)",
    "insertText": "if(mPos[b] < mMax[b])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mPos [ a ] = mMin [ a ] ; + + mPos [ b ] ; } else)",
    "insertText": "if(mPos[c] <= mMax[c])"
  },
  {
    "label": "CoordBBox()",
    "kind": "Method",
    "detail": "Function (mPos [ a ] = mMin [ a ] ; mPos [ b ] = mMin [ b ] ; + + mPos [ c ] ; } } Coord mPos,mMin,mMax ; class CoordBBox ; } ; using ZYXIterator = Iterator<true> ; using XYZIterator = Iterator<false> ;)",
    "insertText": "CoordBBox(): mMin(Coord::max()), mMax(Coord::min())"
  },
  {
    "label": "CoordBBox()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CoordBBox(const Coord& min, const Coord& max): mMin(min), mMax(max)"
  },
  {
    "label": "CoordBBox()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CoordBBox(ValueType xMin, ValueType yMin, ValueType zMin, ValueType xMax, ValueType yMax, ValueType zMax) : mMin(xMin, yMin, zMin), mMax(xMax, yMax, zMax)"
  },
  {
    "label": "CoordBBox()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CoordBBox(CoordBBox& other, const tbb::split&): mMin(other.mMin), mMax(other.mMax)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(this->is_divisible())"
  },
  {
    "label": "maxExtent()",
    "kind": "Method",
    "detail": "Function (const size_t n = this ->)",
    "insertText": "maxExtent()"
  },
  {
    "label": "n()",
    "kind": "Method",
    "detail": "Function (mMax [)",
    "insertText": "n(mMin[n] + mMax[n])"
  },
  {
    "label": "createCube()",
    "kind": "Method",
    "detail": "Function (other . mMin [ n ] = mMax [ n ] + 1 ; } CoordBBox)",
    "insertText": "createCube(const Coord& min, ValueType dim)"
  },
  {
    "label": "inf()",
    "kind": "Method",
    "detail": "Function (} CoordBBox)",
    "insertText": "inf()"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "reset(const Coord& min, const Coord& max)"
  },
  {
    "label": "resetToCube()",
    "kind": "Method",
    "detail": "Function (mMin = min ; mMax = max ; } void)",
    "insertText": "resetToCube(const Coord& min, ValueType dim)"
  },
  {
    "label": "offsetBy()",
    "kind": "Method",
    "detail": "Function (mMin = min ; mMax = min .)",
    "insertText": "offsetBy(dim - 1)"
  },
  {
    "label": "getStart()",
    "kind": "Method",
    "detail": "Function (} Coord)",
    "insertText": "getStart()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} ZYXIterator)",
    "insertText": "begin()"
  },
  {
    "label": "endZYX()",
    "kind": "Method",
    "detail": "Function (ZYXIterator it {* this } ; it . mPos [ 0 ] = mMax [ 0 ] + 1 ; return it ; } ZYXIterator)",
    "insertText": "endZYX()"
  },
  {
    "label": "endXYZ()",
    "kind": "Method",
    "detail": "Function (} XYZIterator)",
    "insertText": "endXYZ()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (XYZIterator it {* this } ; it . mPos [ 2 ] = mMax [ 2 ] + 1 ; return it ; } bool)",
    "insertText": "operator(const CoordBBox& rhs)"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(__GNUC__) && !defined(__INTEL_COMPILER) #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wstrict-overflow\" #endif return (mMin[0] > mMax[0] || mMin[1] > mMax[1] || mMin[2] > mMax[2])"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(__GNUC__) && !defined(__INTEL_COMPILER) #pragma GCC diagnostic pop #endif } operator bool()"
  },
  {
    "label": "hasVolume()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasVolume()"
  },
  {
    "label": "getCenter()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "getCenter()"
  },
  {
    "label": "dim()",
    "kind": "Method",
    "detail": "Function (} Coord)",
    "insertText": "dim()"
  },
  {
    "label": "extents()",
    "kind": "Method",
    "detail": "Function (} Coord)",
    "insertText": "extents()"
  },
  {
    "label": "volume()",
    "kind": "Method",
    "detail": "Function (} Index64)",
    "insertText": "volume()"
  },
  {
    "label": "is_divisible()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_divisible()"
  },
  {
    "label": "isInside()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isInside(const Coord& xyz)"
  },
  {
    "label": "isInside()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isInside(const CoordBBox& b)"
  },
  {
    "label": "hasOverlap()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasOverlap(const CoordBBox& b)"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "expand(ValueType padding)"
  },
  {
    "label": "offset()",
    "kind": "Method",
    "detail": "Function (mMin .)",
    "insertText": "offset(-padding)"
  },
  {
    "label": "offset()",
    "kind": "Method",
    "detail": "Function (mMax .)",
    "insertText": "offset(padding)"
  },
  {
    "label": "expandBy()",
    "kind": "Method",
    "detail": "Function (} CoordBBox)",
    "insertText": "expandBy(ValueType padding)"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "expand(const Coord& xyz)"
  },
  {
    "label": "minComponent()",
    "kind": "Method",
    "detail": "Function (mMin .)",
    "insertText": "minComponent(xyz)"
  },
  {
    "label": "maxComponent()",
    "kind": "Method",
    "detail": "Function (mMax .)",
    "insertText": "maxComponent(xyz)"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "expand(const CoordBBox& bbox)"
  },
  {
    "label": "minComponent()",
    "kind": "Method",
    "detail": "Function (mMin .)",
    "insertText": "minComponent(bbox.min())"
  },
  {
    "label": "maxComponent()",
    "kind": "Method",
    "detail": "Function (mMax .)",
    "insertText": "maxComponent(bbox.max())"
  },
  {
    "label": "intersect()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "intersect(const CoordBBox& bbox)"
  },
  {
    "label": "maxComponent()",
    "kind": "Method",
    "detail": "Function (mMin .)",
    "insertText": "maxComponent(bbox.min())"
  },
  {
    "label": "minComponent()",
    "kind": "Method",
    "detail": "Function (mMax .)",
    "insertText": "minComponent(bbox.max())"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "expand(const Coord& min, Coord::ValueType dim)"
  },
  {
    "label": "minComponent()",
    "kind": "Method",
    "detail": "Function (mMin .)",
    "insertText": "minComponent(min)"
  },
  {
    "label": "maxComponent()",
    "kind": "Method",
    "detail": "Function (mMax .)",
    "insertText": "maxComponent(min.offsetBy(dim-1))"
  },
  {
    "label": "translate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "translate(const Coord& t)"
  },
  {
    "label": "moveMin()",
    "kind": "Method",
    "detail": "Function (mMin + = t ; mMax + = t ; } void)",
    "insertText": "moveMin(const Coord& min)"
  },
  {
    "label": "moveMax()",
    "kind": "Method",
    "detail": "Function (mMax + = min - mMin ; mMin = min ; } void)",
    "insertText": "moveMax(const Coord& max)"
  },
  {
    "label": "getCornerPoints()",
    "kind": "Method",
    "detail": "Function (mMin + = max - mMax ; mMax = max ; } void)",
    "insertText": "getCornerPoints(Coord *p)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(p != nullptr)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (p ->)",
    "insertText": "reset(mMin.x(), mMin.y(), mMin.z())"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (+ + p ; p ->)",
    "insertText": "reset(mMin.x(), mMin.y(), mMax.z())"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (+ + p ; p ->)",
    "insertText": "reset(mMin.x(), mMax.y(), mMin.z())"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (+ + p ; p ->)",
    "insertText": "reset(mMin.x(), mMax.y(), mMax.z())"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (+ + p ; p ->)",
    "insertText": "reset(mMax.x(), mMin.y(), mMin.z())"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (+ + p ; p ->)",
    "insertText": "reset(mMax.x(), mMin.y(), mMax.z())"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (+ + p ; p ->)",
    "insertText": "reset(mMax.x(), mMax.y(), mMin.z())"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (+ + p ; p ->)",
    "insertText": "reset(mMax.x(), mMax.y(), mMax.z())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (mMin>> = n ; mMax>> = n ; return* this ; } CoordBBox)",
    "insertText": "operator(Coord::Int32 n)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (mMin .)",
    "insertText": "read(is)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (mMin .)",
    "insertText": "write(os)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} private : Coord mMin,mMax ; } ; std::ostream&)",
    "insertText": "operator(std::ostream& os, const Coord& xyz)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T> Vec3<promote<T,Coord::ValueType>::type>)",
    "insertText": "operator(const Vec3<T>& v0, const Coord& v1)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (Vec3<promote<T,Coord::ValueType>::type>)",
    "insertText": "result(v0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (result [ 0 ] + = v1 [ 0 ] ; result [ 1 ] + = v1 [ 1 ] ; result [ 2 ] + = v1 [ 2 ] ; return result ; } template<T> Vec3<promote<T,Coord::ValueType>::type>)",
    "insertText": "operator(const Coord& v1, const Vec3<T>& v0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (result [ 0 ] - = v1 [ 0 ] ; result [ 1 ] - = v1 [ 1 ] ; result [ 2 ] - = v1 [ 2 ] ; return - result ; } std::ostream&)",
    "insertText": "operator(std::ostream& os, const CoordBBox& b)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (os<<b .)",
    "insertText": "min() << \" -> \" << b.max()"
  }
]