[
  {
    "label": "cgltf_file_type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "cgltf_file_type"
  },
  {
    "label": "cgltf_result",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "cgltf_result"
  },
  {
    "label": "cgltf_memory_options",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_memory_options"
  },
  {
    "label": "cgltf_file_options",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_file_options"
  },
  {
    "label": "cgltf_options",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_options"
  },
  {
    "label": "cgltf_buffer_view_type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "cgltf_buffer_view_type"
  },
  {
    "label": "cgltf_attribute_type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "cgltf_attribute_type"
  },
  {
    "label": "cgltf_component_type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "cgltf_component_type"
  },
  {
    "label": "cgltf_type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "cgltf_type"
  },
  {
    "label": "cgltf_primitive_type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "cgltf_primitive_type"
  },
  {
    "label": "cgltf_alpha_mode",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "cgltf_alpha_mode"
  },
  {
    "label": "cgltf_animation_path_type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "cgltf_animation_path_type"
  },
  {
    "label": "cgltf_interpolation_type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "cgltf_interpolation_type"
  },
  {
    "label": "cgltf_camera_type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "cgltf_camera_type"
  },
  {
    "label": "cgltf_light_type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "cgltf_light_type"
  },
  {
    "label": "cgltf_data_free_method",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "cgltf_data_free_method"
  },
  {
    "label": "cgltf_extras",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_extras"
  },
  {
    "label": "cgltf_extension",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_extension"
  },
  {
    "label": "cgltf_buffer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_buffer"
  },
  {
    "label": "cgltf_meshopt_compression_mode",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "cgltf_meshopt_compression_mode"
  },
  {
    "label": "cgltf_meshopt_compression_filter",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "cgltf_meshopt_compression_filter"
  },
  {
    "label": "cgltf_meshopt_compression",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_meshopt_compression"
  },
  {
    "label": "cgltf_buffer_view",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_buffer_view"
  },
  {
    "label": "cgltf_accessor_sparse",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_accessor_sparse"
  },
  {
    "label": "cgltf_accessor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_accessor"
  },
  {
    "label": "cgltf_attribute",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_attribute"
  },
  {
    "label": "cgltf_image",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_image"
  },
  {
    "label": "cgltf_sampler",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_sampler"
  },
  {
    "label": "cgltf_texture",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_texture"
  },
  {
    "label": "cgltf_texture_transform",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_texture_transform"
  },
  {
    "label": "cgltf_texture_view",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_texture_view"
  },
  {
    "label": "cgltf_pbr_metallic_roughness",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_pbr_metallic_roughness"
  },
  {
    "label": "cgltf_pbr_specular_glossiness",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_pbr_specular_glossiness"
  },
  {
    "label": "cgltf_clearcoat",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_clearcoat"
  },
  {
    "label": "cgltf_transmission",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_transmission"
  },
  {
    "label": "cgltf_ior",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_ior"
  },
  {
    "label": "cgltf_specular",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_specular"
  },
  {
    "label": "cgltf_volume",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_volume"
  },
  {
    "label": "cgltf_sheen",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_sheen"
  },
  {
    "label": "cgltf_emissive_strength",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_emissive_strength"
  },
  {
    "label": "cgltf_material",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_material"
  },
  {
    "label": "cgltf_material_mapping",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_material_mapping"
  },
  {
    "label": "cgltf_morph_target",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_morph_target"
  },
  {
    "label": "cgltf_draco_mesh_compression",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_draco_mesh_compression"
  },
  {
    "label": "cgltf_primitive",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_primitive"
  },
  {
    "label": "cgltf_mesh",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_mesh"
  },
  {
    "label": "cgltf_node",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_node"
  },
  {
    "label": "cgltf_skin",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_skin"
  },
  {
    "label": "cgltf_camera_perspective",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_camera_perspective"
  },
  {
    "label": "cgltf_camera_orthographic",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_camera_orthographic"
  },
  {
    "label": "cgltf_camera",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_camera"
  },
  {
    "label": "cgltf_light",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_light"
  },
  {
    "label": "cgltf_scene",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_scene"
  },
  {
    "label": "cgltf_animation_sampler",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_animation_sampler"
  },
  {
    "label": "cgltf_animation_channel",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_animation_channel"
  },
  {
    "label": "cgltf_animation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_animation"
  },
  {
    "label": "cgltf_material_variant",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_material_variant"
  },
  {
    "label": "cgltf_asset",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_asset"
  },
  {
    "label": "cgltf_data",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cgltf_data"
  },
  {
    "label": "jsmnerr",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "jsmnerr"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (# ifndef CGLTF_H_INCLUDED__ # define CGLTF_H_INCLUDED__ # include<stddef . h> # ifdef __cplusplus \" C \" { # endif typedef size_t cgltf_size ; typedef float cgltf_float ; typedef int cgltf_int ; typedef unsigned int cgltf_uint ; typedef int cgltf_bool ; typedef enum cgltf_file_type { cgltf_file_type_invalid,cgltf_file_type_gltf,cgltf_file_type_glb,} cgltf_file_type ; typedef enum cgltf_result { cgltf_result_success,cgltf_result_data_too_short,cgltf_result_unknown_format,cgltf_result_invalid_json,cgltf_result_invalid_gltf,cgltf_result_invalid_options,cgltf_result_file_not_found,cgltf_result_io_error,cgltf_result_out_of_memory,cgltf_result_legacy_gltf,} cgltf_result ; typedef struct cgltf_memory_options {)",
    "insertText": "void(*alloc)(void* user, cgltf_size size)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "void(*free) (void* user, void* ptr)"
  },
  {
    "label": "cgltf_result()",
    "kind": "Method",
    "detail": "Function (void* user_data ; } cgltf_memory_options ; typedef struct cgltf_file_options {)",
    "insertText": "cgltf_result(*read)(const struct cgltf_memory_options* memory_options, const struct cgltf_file_options* file_options, const char* path, cgltf_size* size, void** data)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "void(*release)(const struct cgltf_memory_options* memory_options, const struct cgltf_file_options* file_options, void* data)"
  },
  {
    "label": "cgltf_parse()",
    "kind": "Method",
    "detail": "Function (void* user_data ; } cgltf_file_options ; typedef struct cgltf_options { cgltf_file_type type ; cgltf_size json_token_count ; cgltf_memory_options memory ; cgltf_file_options file ; } cgltf_options ; typedef enum cgltf_buffer_view_type { cgltf_buffer_view_type_invalid,cgltf_buffer_view_type_indices,cgltf_buffer_view_type_vertices,} cgltf_buffer_view_type ; typedef enum cgltf_attribute_type { cgltf_attribute_type_invalid,cgltf_attribute_type_position,cgltf_attribute_type_normal,cgltf_attribute_type_tangent,cgltf_attribute_type_texcoord,cgltf_attribute_type_color,cgltf_attribute_type_joints,cgltf_attribute_type_weights,} cgltf_attribute_type ; typedef enum cgltf_component_type { cgltf_component_type_invalid,cgltf_component_type_r_8,cgltf_component_type_r_8u,cgltf_component_type_r_16,cgltf_component_type_r_16u,cgltf_component_type_r_32u,cgltf_component_type_r_32f,} cgltf_component_type ; typedef enum cgltf_type { cgltf_type_invalid,cgltf_type_scalar,cgltf_type_vec2,cgltf_type_vec3,cgltf_type_vec4,cgltf_type_mat2,cgltf_type_mat3,cgltf_type_mat4,} cgltf_type ; typedef enum cgltf_primitive_type { cgltf_primitive_type_points,cgltf_primitive_type_lines,cgltf_primitive_type_line_loop,cgltf_primitive_type_line_strip,cgltf_primitive_type_triangles,cgltf_primitive_type_triangle_strip,cgltf_primitive_type_triangle_fan,} cgltf_primitive_type ; typedef enum cgltf_alpha_mode { cgltf_alpha_mode_opaque,cgltf_alpha_mode_mask,cgltf_alpha_mode_blend,} cgltf_alpha_mode ; typedef enum cgltf_animation_path_type { cgltf_animation_path_type_invalid,cgltf_animation_path_type_translation,cgltf_animation_path_type_rotation,cgltf_animation_path_type_scale,cgltf_animation_path_type_weights,} cgltf_animation_path_type ; typedef enum cgltf_interpolation_type { cgltf_interpolation_type_linear,cgltf_interpolation_type_step,cgltf_interpolation_type_cubic_spline,} cgltf_interpolation_type ; typedef enum cgltf_camera_type { cgltf_camera_type_invalid,cgltf_camera_type_perspective,cgltf_camera_type_orthographic,} cgltf_camera_type ; typedef enum cgltf_light_type { cgltf_light_type_invalid,cgltf_light_type_directional,cgltf_light_type_point,cgltf_light_type_spot,} cgltf_light_type ; typedef enum cgltf_data_free_method { cgltf_data_free_method_none,cgltf_data_free_method_file_release,cgltf_data_free_method_memory_free,} cgltf_data_free_method ; typedef struct cgltf_extras { cgltf_size start_offset ; cgltf_size end_offset ; } cgltf_extras ; typedef struct cgltf_extension { char* name ; char* data ; } cgltf_extension ; typedef struct cgltf_buffer { char* name ; cgltf_size size ; char* uri ; void* data ; cgltf_data_free_method data_free_method ; cgltf_extras extras ; cgltf_size extensions_count ; cgltf_extension* extensions ; } cgltf_buffer ; typedef enum cgltf_meshopt_compression_mode { cgltf_meshopt_compression_mode_invalid,cgltf_meshopt_compression_mode_attributes,cgltf_meshopt_compression_mode_triangles,cgltf_meshopt_compression_mode_indices,} cgltf_meshopt_compression_mode ; typedef enum cgltf_meshopt_compression_filter { cgltf_meshopt_compression_filter_none,cgltf_meshopt_compression_filter_octahedral,cgltf_meshopt_compression_filter_quaternion,cgltf_meshopt_compression_filter_exponential,} cgltf_meshopt_compression_filter ; typedef struct cgltf_meshopt_compression { cgltf_buffer* buffer ; cgltf_size offset ; cgltf_size size ; cgltf_size stride ; cgltf_size count ; cgltf_meshopt_compression_mode mode ; cgltf_meshopt_compression_filter filter ; } cgltf_meshopt_compression ; typedef struct cgltf_buffer_view { char* name ; cgltf_buffer* buffer ; cgltf_size offset ; cgltf_size size ; cgltf_size stride ; cgltf_buffer_view_type type ; void* data ; cgltf_bool has_meshopt_compression ; cgltf_meshopt_compression meshopt_compression ; cgltf_extras extras ; cgltf_size extensions_count ; cgltf_extension* extensions ; } cgltf_buffer_view ; typedef struct cgltf_accessor_sparse { cgltf_size count ; cgltf_buffer_view* indices_buffer_view ; cgltf_size indices_byte_offset ; cgltf_component_type indices_component_type ; cgltf_buffer_view* values_buffer_view ; cgltf_size values_byte_offset ; cgltf_extras extras ; cgltf_extras indices_extras ; cgltf_extras values_extras ; cgltf_size extensions_count ; cgltf_extension* extensions ; cgltf_size indices_extensions_count ; cgltf_extension* indices_extensions ; cgltf_size values_extensions_count ; cgltf_extension* values_extensions ; } cgltf_accessor_sparse ; typedef struct cgltf_accessor { char* name ; cgltf_component_type component_type ; cgltf_bool normalized ; cgltf_type type ; cgltf_size offset ; cgltf_size count ; cgltf_size stride ; cgltf_buffer_view* buffer_view ; cgltf_bool has_min ; cgltf_float min [ 1 6 ] ; cgltf_bool has_max ; cgltf_float max [ 1 6 ] ; cgltf_bool is_sparse ; cgltf_accessor_sparse sparse ; cgltf_extras extras ; cgltf_size extensions_count ; cgltf_extension* extensions ; } cgltf_accessor ; typedef struct cgltf_attribute { char* name ; cgltf_attribute_type type ; cgltf_int index ; cgltf_accessor* data ; } cgltf_attribute ; typedef struct cgltf_image { char* name ; char* uri ; cgltf_buffer_view* buffer_view ; char* mime_type ; cgltf_extras extras ; cgltf_size extensions_count ; cgltf_extension* extensions ; } cgltf_image ; typedef struct cgltf_sampler { char* name ; cgltf_int mag_filter ; cgltf_int min_filter ; cgltf_int wrap_s ; cgltf_int wrap_t ; cgltf_extras extras ; cgltf_size extensions_count ; cgltf_extension* extensions ; } cgltf_sampler ; typedef struct cgltf_texture { char* name ; cgltf_image* image ; cgltf_sampler* sampler ; cgltf_bool has_basisu ; cgltf_image* basisu_image ; cgltf_extras extras ; cgltf_size extensions_count ; cgltf_extension* extensions ; } cgltf_texture ; typedef struct cgltf_texture_transform { cgltf_float offset [ 2 ] ; cgltf_float rotation ; cgltf_float scale [ 2 ] ; cgltf_bool has_texcoord ; cgltf_int texcoord ; } cgltf_texture_transform ; typedef struct cgltf_texture_view { cgltf_texture* texture ; cgltf_int texcoord ; cgltf_float scale ; cgltf_bool has_transform ; cgltf_texture_transform transform ; cgltf_extras extras ; cgltf_size extensions_count ; cgltf_extension* extensions ; } cgltf_texture_view ; typedef struct cgltf_pbr_metallic_roughness { cgltf_texture_view base_color_texture ; cgltf_texture_view metallic_roughness_texture ; cgltf_float base_color_factor [ 4 ] ; cgltf_float metallic_factor ; cgltf_float roughness_factor ; cgltf_extras extras ; } cgltf_pbr_metallic_roughness ; typedef struct cgltf_pbr_specular_glossiness { cgltf_texture_view diffuse_texture ; cgltf_texture_view specular_glossiness_texture ; cgltf_float diffuse_factor [ 4 ] ; cgltf_float specular_factor [ 3 ] ; cgltf_float glossiness_factor ; } cgltf_pbr_specular_glossiness ; typedef struct cgltf_clearcoat { cgltf_texture_view clearcoat_texture ; cgltf_texture_view clearcoat_roughness_texture ; cgltf_texture_view clearcoat_normal_texture ; cgltf_float clearcoat_factor ; cgltf_float clearcoat_roughness_factor ; } cgltf_clearcoat ; typedef struct cgltf_transmission { cgltf_texture_view transmission_texture ; cgltf_float transmission_factor ; } cgltf_transmission ; typedef struct cgltf_ior { cgltf_float ior ; } cgltf_ior ; typedef struct cgltf_specular { cgltf_texture_view specular_texture ; cgltf_texture_view specular_color_texture ; cgltf_float specular_color_factor [ 3 ] ; cgltf_float specular_factor ; } cgltf_specular ; typedef struct cgltf_volume { cgltf_texture_view thickness_texture ; cgltf_float thickness_factor ; cgltf_float attenuation_color [ 3 ] ; cgltf_float attenuation_distance ; } cgltf_volume ; typedef struct cgltf_sheen { cgltf_texture_view sheen_color_texture ; cgltf_float sheen_color_factor [ 3 ] ; cgltf_texture_view sheen_roughness_texture ; cgltf_float sheen_roughness_factor ; } cgltf_sheen ; typedef struct cgltf_emissive_strength { cgltf_float emissive_strength ; } cgltf_emissive_strength ; typedef struct cgltf_material { char* name ; cgltf_bool has_pbr_metallic_roughness ; cgltf_bool has_pbr_specular_glossiness ; cgltf_bool has_clearcoat ; cgltf_bool has_transmission ; cgltf_bool has_volume ; cgltf_bool has_ior ; cgltf_bool has_specular ; cgltf_bool has_sheen ; cgltf_bool has_emissive_strength ; cgltf_pbr_metallic_roughness pbr_metallic_roughness ; cgltf_pbr_specular_glossiness pbr_specular_glossiness ; cgltf_clearcoat clearcoat ; cgltf_ior ior ; cgltf_specular specular ; cgltf_sheen sheen ; cgltf_transmission transmission ; cgltf_volume volume ; cgltf_emissive_strength emissive_strength ; cgltf_texture_view normal_texture ; cgltf_texture_view occlusion_texture ; cgltf_texture_view emissive_texture ; cgltf_float emissive_factor [ 3 ] ; cgltf_alpha_mode alpha_mode ; cgltf_float alpha_cutoff ; cgltf_bool double_sided ; cgltf_bool unlit ; cgltf_extras extras ; cgltf_size extensions_count ; cgltf_extension* extensions ; } cgltf_material ; typedef struct cgltf_material_mapping { cgltf_size variant ; cgltf_material* material ; cgltf_extras extras ; } cgltf_material_mapping ; typedef struct cgltf_morph_target { cgltf_attribute* attributes ; cgltf_size attributes_count ; } cgltf_morph_target ; typedef struct cgltf_draco_mesh_compression { cgltf_buffer_view* buffer_view ; cgltf_attribute* attributes ; cgltf_size attributes_count ; } cgltf_draco_mesh_compression ; typedef struct cgltf_primitive { cgltf_primitive_type type ; cgltf_accessor* indices ; cgltf_material* material ; cgltf_attribute* attributes ; cgltf_size attributes_count ; cgltf_morph_target* targets ; cgltf_size targets_count ; cgltf_extras extras ; cgltf_bool has_draco_mesh_compression ; cgltf_draco_mesh_compression draco_mesh_compression ; cgltf_material_mapping* mappings ; cgltf_size mappings_count ; cgltf_size extensions_count ; cgltf_extension* extensions ; } cgltf_primitive ; typedef struct cgltf_mesh { char* name ; cgltf_primitive* primitives ; cgltf_size primitives_count ; cgltf_float* weights ; cgltf_size weights_count ; char** target_names ; cgltf_size target_names_count ; cgltf_extras extras ; cgltf_size extensions_count ; cgltf_extension* extensions ; } cgltf_mesh ; typedef struct cgltf_node cgltf_node ; typedef struct cgltf_skin { char* name ; cgltf_node** joints ; cgltf_size joints_count ; cgltf_node* skeleton ; cgltf_accessor* inverse_bind_matrices ; cgltf_extras extras ; cgltf_size extensions_count ; cgltf_extension* extensions ; } cgltf_skin ; typedef struct cgltf_camera_perspective { cgltf_bool has_aspect_ratio ; cgltf_float aspect_ratio ; cgltf_float yfov ; cgltf_bool has_zfar ; cgltf_float zfar ; cgltf_float znear ; cgltf_extras extras ; } cgltf_camera_perspective ; typedef struct cgltf_camera_orthographic { cgltf_float xmag ; cgltf_float ymag ; cgltf_float zfar ; cgltf_float znear ; cgltf_extras extras ; } cgltf_camera_orthographic ; typedef struct cgltf_camera { char* name ; cgltf_camera_type type ; union { cgltf_camera_perspective perspective ; cgltf_camera_orthographic orthographic ; } data ; cgltf_extras extras ; cgltf_size extensions_count ; cgltf_extension* extensions ; } cgltf_camera ; typedef struct cgltf_light { char* name ; cgltf_float color [ 3 ] ; cgltf_float intensity ; cgltf_light_type type ; cgltf_float range ; cgltf_float spot_inner_cone_angle ; cgltf_float spot_outer_cone_angle ; cgltf_extras extras ; } cgltf_light ; struct cgltf_node { char* name ; cgltf_node* parent ; cgltf_node** children ; cgltf_size children_count ; cgltf_skin* skin ; cgltf_mesh* mesh ; cgltf_camera* camera ; cgltf_light* light ; cgltf_float* weights ; cgltf_size weights_count ; cgltf_bool has_translation ; cgltf_bool has_rotation ; cgltf_bool has_scale ; cgltf_bool has_matrix ; cgltf_float translation [ 3 ] ; cgltf_float rotation [ 4 ] ; cgltf_float scale [ 3 ] ; cgltf_float matrix [ 1 6 ] ; cgltf_extras extras ; cgltf_size extensions_count ; cgltf_extension* extensions ; } ; typedef struct cgltf_scene { char* name ; cgltf_node** nodes ; cgltf_size nodes_count ; cgltf_extras extras ; cgltf_size extensions_count ; cgltf_extension* extensions ; } cgltf_scene ; typedef struct cgltf_animation_sampler { cgltf_accessor* input ; cgltf_accessor* output ; cgltf_interpolation_type interpolation ; cgltf_extras extras ; cgltf_size extensions_count ; cgltf_extension* extensions ; } cgltf_animation_sampler ; typedef struct cgltf_animation_channel { cgltf_animation_sampler* sampler ; cgltf_node* target_node ; cgltf_animation_path_type target_path ; cgltf_extras extras ; cgltf_size extensions_count ; cgltf_extension* extensions ; } cgltf_animation_channel ; typedef struct cgltf_animation { char* name ; cgltf_animation_sampler* samplers ; cgltf_size samplers_count ; cgltf_animation_channel* channels ; cgltf_size channels_count ; cgltf_extras extras ; cgltf_size extensions_count ; cgltf_extension* extensions ; } cgltf_animation ; typedef struct cgltf_material_variant { char* name ; cgltf_extras extras ; } cgltf_material_variant ; typedef struct cgltf_asset { char* copyright ; char* generator ; char* version ; char* min_version ; cgltf_extras extras ; cgltf_size extensions_count ; cgltf_extension* extensions ; } cgltf_asset ; typedef struct cgltf_data { cgltf_file_type file_type ; void* file_data ; cgltf_asset asset ; cgltf_mesh* meshes ; cgltf_size meshes_count ; cgltf_material* materials ; cgltf_size materials_count ; cgltf_accessor* accessors ; cgltf_size accessors_count ; cgltf_buffer_view* buffer_views ; cgltf_size buffer_views_count ; cgltf_buffer* buffers ; cgltf_size buffers_count ; cgltf_image* images ; cgltf_size images_count ; cgltf_texture* textures ; cgltf_size textures_count ; cgltf_sampler* samplers ; cgltf_size samplers_count ; cgltf_skin* skins ; cgltf_size skins_count ; cgltf_camera* cameras ; cgltf_size cameras_count ; cgltf_light* lights ; cgltf_size lights_count ; cgltf_node* nodes ; cgltf_size nodes_count ; cgltf_scene* scenes ; cgltf_size scenes_count ; cgltf_scene* scene ; cgltf_animation* animations ; cgltf_size animations_count ; cgltf_material_variant* variants ; cgltf_size variants_count ; cgltf_extras extras ; cgltf_size data_extensions_count ; cgltf_extension* data_extensions ; char** extensions_used ; cgltf_size extensions_used_count ; char** extensions_required ; cgltf_size extensions_required_count ; const char* json ; cgltf_size json_size ; const void* bin ; cgltf_size bin_size ; cgltf_memory_options memory ; cgltf_file_options file ; } cgltf_data ; cgltf_result)",
    "insertText": "cgltf_parse(const cgltf_options* options, const void* data, cgltf_size size, cgltf_data** out_data)"
  },
  {
    "label": "cgltf_parse_file()",
    "kind": "Method",
    "detail": "Function (cgltf_result)",
    "insertText": "cgltf_parse_file(const cgltf_options* options, const char* path, cgltf_data** out_data)"
  },
  {
    "label": "cgltf_load_buffers()",
    "kind": "Method",
    "detail": "Function (cgltf_result)",
    "insertText": "cgltf_load_buffers(const cgltf_options* options, cgltf_data* data, const char* gltf_path)"
  },
  {
    "label": "cgltf_load_buffer_base64()",
    "kind": "Method",
    "detail": "Function (cgltf_result)",
    "insertText": "cgltf_load_buffer_base64(const cgltf_options* options, cgltf_size size, const char* base64, void** out_data)"
  },
  {
    "label": "cgltf_decode_string()",
    "kind": "Method",
    "detail": "Function (cgltf_size)",
    "insertText": "cgltf_decode_string(char* string)"
  },
  {
    "label": "cgltf_decode_uri()",
    "kind": "Method",
    "detail": "Function (cgltf_size)",
    "insertText": "cgltf_decode_uri(char* uri)"
  },
  {
    "label": "cgltf_validate()",
    "kind": "Method",
    "detail": "Function (cgltf_result)",
    "insertText": "cgltf_validate(cgltf_data* data)"
  },
  {
    "label": "cgltf_free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cgltf_free(cgltf_data* data)"
  },
  {
    "label": "cgltf_node_transform_local()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cgltf_node_transform_local(const cgltf_node* node, cgltf_float* out_matrix)"
  },
  {
    "label": "cgltf_node_transform_world()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cgltf_node_transform_world(const cgltf_node* node, cgltf_float* out_matrix)"
  },
  {
    "label": "cgltf_accessor_read_float()",
    "kind": "Method",
    "detail": "Function (cgltf_bool)",
    "insertText": "cgltf_accessor_read_float(const cgltf_accessor* accessor, cgltf_size index, cgltf_float* out, cgltf_size element_size)"
  },
  {
    "label": "cgltf_accessor_read_uint()",
    "kind": "Method",
    "detail": "Function (cgltf_bool)",
    "insertText": "cgltf_accessor_read_uint(const cgltf_accessor* accessor, cgltf_size index, cgltf_uint* out, cgltf_size element_size)"
  },
  {
    "label": "cgltf_accessor_read_index()",
    "kind": "Method",
    "detail": "Function (cgltf_size)",
    "insertText": "cgltf_accessor_read_index(const cgltf_accessor* accessor, cgltf_size index)"
  },
  {
    "label": "cgltf_num_components()",
    "kind": "Method",
    "detail": "Function (cgltf_size)",
    "insertText": "cgltf_num_components(cgltf_type type)"
  },
  {
    "label": "cgltf_accessor_unpack_floats()",
    "kind": "Method",
    "detail": "Function (cgltf_size)",
    "insertText": "cgltf_accessor_unpack_floats(const cgltf_accessor* accessor, cgltf_float* out, cgltf_size float_count)"
  },
  {
    "label": "cgltf_copy_extras_json()",
    "kind": "Method",
    "detail": "Function (cgltf_result)",
    "insertText": "cgltf_copy_extras_json(const cgltf_data* data, const cgltf_extras* extras, char* dest, cgltf_size* dest_size)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifdef __cplusplus } # endif # endif # if)",
    "insertText": "defined(__INTELLISENSE__) || defined(__JETBRAINS_IDE__) #define CGLTF_IMPLEMENTATION #endif #ifdef CGLTF_IMPLEMENTATION #include <stdint.h> #include <string.h> #include <stdio.h> #include <limits.h> #include <float.h> #if !defined(CGLTF_MALLOC) || !defined(CGLTF_FREE) || !defined(CGLTF_ATOI) || !defined(CGLTF_ATOF) || !defined(CGLTF_ATOLL)"
  },
  {
    "label": "jsmn_init()",
    "kind": "Method",
    "detail": "Function (JSMN_UNDEFINED = 0,JSMN_OBJECT = 1,JSMN_ARRAY = 2,JSMN_STRING = 3,JSMN_PRIMITIVE = 4 } jsmntype_t ; enum jsmnerr { JSMN_ERROR_NOMEM = - 1,JSMN_ERROR_INVAL = - 2,JSMN_ERROR_PART = - 3 } ; typedef struct { jsmntype_t type ; int start ; int end ; int size ; # ifdef JSMN_PARENT_LINKS int parent ; # endif } jsmntok_t ; typedef struct { unsigned int pos ; unsigned int toknext ; int toksuper ; } jsmn_parser ; void)",
    "insertText": "jsmn_init(jsmn_parser *parser)"
  },
  {
    "label": "jsmn_parse()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "jsmn_parse(jsmn_parser *parser, const char *js, size_t len, jsmntok_t *tokens, size_t num_tokens)"
  },
  {
    "label": "CGLTF_MALLOC()",
    "kind": "Method",
    "detail": "Function (const cgltf_size GlbHeaderSize = 1 2 ; const cgltf_size GlbChunkHeaderSize = 8 ; const uint32_t GlbVersion = 2 ; const uint32_t GlbMagic = 0 x46546C67 ; const uint32_t GlbMagicJsonChunk = 0 x4E4F534A ; const uint32_t GlbMagicBinChunk = 0 x004E4942 ; # ifndef CGLTF_MALLOC # define)",
    "insertText": "CGLTF_MALLOC(size) malloc(size) #endif #ifndef CGLTF_FREE #define CGLTF_FREE(ptr) free(ptr) #endif #ifndef CGLTF_ATOI #define CGLTF_ATOI(str) atoi(str) #endif #ifndef CGLTF_ATOF #define CGLTF_ATOF(str) atof(str) #endif #ifndef CGLTF_ATOLL #define CGLTF_ATOLL(str) atoll(str) #endif #ifndef CGLTF_VALIDATE_ENABLE_ASSERTS #define CGLTF_VALIDATE_ENABLE_ASSERTS 0 #endif static void* cgltf_default_alloc(void* user, cgltf_size size)"
  },
  {
    "label": "cgltf_default_free()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "cgltf_default_free(void* user, void* ptr)"
  },
  {
    "label": "CGLTF_FREE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CGLTF_FREE(ptr)"
  },
  {
    "label": "cgltf_calloc()",
    "kind": "Method",
    "detail": "Function (} void*)",
    "insertText": "cgltf_calloc(cgltf_options* options, size_t element_size, cgltf_size count)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (alloc ? memory_options->alloc : &cgltf_default_alloc)",
    "insertText": "void(*memory_alloc)(void*, cgltf_size)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (free ? memory_options->free : &cgltf_default_free)",
    "insertText": "void(*memory_free)(void*, void*)"
  },
  {
    "label": "fopen()",
    "kind": "Method",
    "detail": "Function (FILE* file =)",
    "insertText": "fopen(path, \"rb\")"
  },
  {
    "label": "fseek()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fseek(file, 0, SEEK_END)"
  },
  {
    "label": "_ftelli64()",
    "kind": "Method",
    "detail": "Function (# ifdef _WIN32 __int64 length =)",
    "insertText": "_ftelli64(file)"
  },
  {
    "label": "ftell()",
    "kind": "Method",
    "detail": "Function (# else long length =)",
    "insertText": "ftell(file)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(length < 0)"
  },
  {
    "label": "fclose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fclose(file)"
  },
  {
    "label": "file_size()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "file_size(cgltf_size)"
  },
  {
    "label": "file_data()",
    "kind": "Method",
    "detail": "Function (} char*)",
    "insertText": "file_data(char*)memory_alloc(memory_options->user_data, file_size)"
  },
  {
    "label": "memory_free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memory_free(memory_options->user_data, file_data)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* size = file_size ; })",
    "insertText": "if(data)"
  },
  {
    "label": "cgltf_default_file_release()",
    "kind": "Method",
    "detail": "Function (* data = file_data ; } return cgltf_result_success ; } void)",
    "insertText": "cgltf_default_file_release(const struct cgltf_memory_options* memory_options, const struct cgltf_file_options* file_options, void* data)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (free ? memory_options->free : &cgltf_default_free)",
    "insertText": "void(*memfree)(void*, void*)"
  },
  {
    "label": "memfree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memfree(memory_options->user_data, data)"
  },
  {
    "label": "cgltf_parse_json()",
    "kind": "Method",
    "detail": "Function (} cgltf_result)",
    "insertText": "cgltf_parse_json(cgltf_options* options, const uint8_t* json_chunk, cgltf_size size, cgltf_data** out_data)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (fixed_options . memory . alloc =& cgltf_default_alloc ; })",
    "insertText": "if(fixed_options.memory.free == NULL)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (fixed_options . memory . free =& cgltf_default_free ; } uint32_t tmp ;)",
    "insertText": "memcpy(&tmp, data, 4)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (fixed_options . type = cgltf_file_type_gltf ; } else)",
    "insertText": "if(fixed_options.type == cgltf_file_type_glb)"
  },
  {
    "label": "cgltf_parse_json()",
    "kind": "Method",
    "detail": "Function (cgltf_result json_result =)",
    "insertText": "cgltf_parse_json(&fixed_options, (const uint8_t*)data, size, out_data)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&tmp, ptr + 4, 4)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uint32_t version = tmp ;)",
    "insertText": "if(version != GlbVersion)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (const uint8_t* bin_chunk = json_chunk + json_length ; uint32_t bin_length ;)",
    "insertText": "memcpy(&bin_length, bin_chunk, 4)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (file.release ? options->file.release : cgltf_default_file_release)",
    "insertText": "void(*file_release)(const struct cgltf_memory_options*, const struct cgltf_file_options*, void* data)"
  },
  {
    "label": "file_read()",
    "kind": "Method",
    "detail": "Function (void* file_data = NULL ; cgltf_size file_size = 0 ; cgltf_result result =)",
    "insertText": "file_read(&options->memory, &options->file, path, &file_size, &file_data)"
  },
  {
    "label": "file_release()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "file_release(&options->memory, &options->file, file_data)"
  },
  {
    "label": "strrchr()",
    "kind": "Method",
    "detail": "Function (const char* s0 =)",
    "insertText": "strrchr(base, '/')"
  },
  {
    "label": "strrchr()",
    "kind": "Method",
    "detail": "Function (const char* s1 =)",
    "insertText": "strrchr(base, '\\\\')"
  },
  {
    "label": "s0()",
    "kind": "Method",
    "detail": "Function (const char* slash =)",
    "insertText": "s0(s1 && s1 > s0 ? s1 : s0)"
  },
  {
    "label": "strncpy()",
    "kind": "Method",
    "detail": "Function (size_t prefix = slash - base + 1 ;)",
    "insertText": "strncpy(path, base, prefix)"
  },
  {
    "label": "strcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "strcpy(path + prefix, uri)"
  },
  {
    "label": "strcpy()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "strcpy(path, uri)"
  },
  {
    "label": "cgltf_load_buffer_file()",
    "kind": "Method",
    "detail": "Function (} } cgltf_result)",
    "insertText": "cgltf_load_buffer_file(const cgltf_options* options, cgltf_size size, const char* uri, const char* gltf_path, void** out_data)"
  },
  {
    "label": "cgltf_result()",
    "kind": "Method",
    "detail": "Function (file.read ? options->file.read : &cgltf_default_file_read)",
    "insertText": "cgltf_result(*file_read)(const struct cgltf_memory_options*, const struct cgltf_file_options*, const char*, cgltf_size*, void**)"
  },
  {
    "label": "path()",
    "kind": "Method",
    "detail": "Function (char*)",
    "insertText": "path(char*)memory_alloc(options->memory.user_data, strlen(uri) + strlen(gltf_path) + 1)"
  },
  {
    "label": "cgltf_decode_uri()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cgltf_decode_uri(path + strlen(path) - strlen(uri))"
  },
  {
    "label": "file_read()",
    "kind": "Method",
    "detail": "Function (void* file_data = NULL ; cgltf_result result =)",
    "insertText": "file_read(&options->memory, &options->file, path, &size, &file_data)"
  },
  {
    "label": "memory_free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memory_free(options->memory.user_data, path)"
  },
  {
    "label": "out_data()",
    "kind": "Method",
    "detail": "Function (*)",
    "insertText": "out_data(result == cgltf_result_success)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (unsigned char*)",
    "insertText": "data(unsigned char*)memory_alloc(options->memory.user_data, size)"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (char ch =* base64 + + ; int)",
    "insertText": "index(unsigned)(ch - 'A') < 26 ? (ch - 'A') : (unsigned)(ch - 'a') < 26 ? (ch - 'a') + 26 : (unsigned)(ch - '0') < 10 ? (ch - '0')"
  },
  {
    "label": "memory_free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memory_free(options->memory.user_data, data)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (buffer_bits + = 6 ; } data [)",
    "insertText": "i(unsigned char)(buffer >> (buffer_bits - 8))"
  },
  {
    "label": "cgltf_unhex()",
    "kind": "Method",
    "detail": "Function (buffer_bits - = 8 ; }* out_data = data ; return cgltf_result_success ; } int)",
    "insertText": "cgltf_unhex(char ch)"
  },
  {
    "label": "strcspn()",
    "kind": "Method",
    "detail": "Function (char* read = string +)",
    "insertText": "strcspn(string, \"\\\\\")"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (cgltf_size written = read - last ;)",
    "insertText": "memmove(write, last, written)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (write + = written ;)",
    "insertText": "if(*read++ == 0)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (break ; })",
    "insertText": "switch(*read++)"
  },
  {
    "label": "character()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "character(character << 4) + cgltf_unhex(*read++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(character <= 0x7F)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* write + + = character& 0 xFF ; } else)",
    "insertText": "if(character <= 0x7FF)"
  },
  {
    "label": "xC0()",
    "kind": "Method",
    "detail": "Function (* write + + = 0)",
    "insertText": "xC0((character >> 6) & 0xFF)"
  },
  {
    "label": "x80()",
    "kind": "Method",
    "detail": "Function (* write + + = 0)",
    "insertText": "x80(character & 0x3F)"
  },
  {
    "label": "xE0()",
    "kind": "Method",
    "detail": "Function (} else {* write + + = 0)",
    "insertText": "xE0((character >> 12) & 0xFF)"
  },
  {
    "label": "x80()",
    "kind": "Method",
    "detail": "Function (* write + + = 0)",
    "insertText": "x80((character >> 6) & 0x3F)"
  },
  {
    "label": "strcspn()",
    "kind": "Method",
    "detail": "Function (} break ; } default : break ; } last = read ; read + =)",
    "insertText": "strcspn(read, \"\\\\\")"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (char* write = uri ; char* i = uri ;)",
    "insertText": "while(*i)"
  },
  {
    "label": "cgltf_unhex()",
    "kind": "Method",
    "detail": "Function (int ch1 =)",
    "insertText": "cgltf_unhex(i[1])"
  },
  {
    "label": "cgltf_unhex()",
    "kind": "Method",
    "detail": "Function (int ch2 =)",
    "insertText": "cgltf_unhex(i[2])"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (*)",
    "insertText": "write(char)(ch1 * 16 + ch2)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (data -> buffers [ 0 ] . data_free_method = cgltf_data_free_method_none ; })",
    "insertText": "for(cgltf_size i = 0; i < data->buffers_count; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; } const char* uri = data -> buffers [ i ] . uri ;)",
    "insertText": "if(uri == NULL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(strncmp(uri, \"data:\", 5) == 0)"
  },
  {
    "label": "strchr()",
    "kind": "Method",
    "detail": "Function (const char* comma =)",
    "insertText": "strchr(uri, ',')"
  },
  {
    "label": "cgltf_load_buffer_base64()",
    "kind": "Method",
    "detail": "Function (cgltf_result res =)",
    "insertText": "cgltf_load_buffer_base64(options, data->buffers[i].size, comma + 1, &data->buffers[i].data)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (data -> buffers [ i ] . data_free_method = cgltf_data_free_method_memory_free ;)",
    "insertText": "if(res != cgltf_result_success)"
  }
]