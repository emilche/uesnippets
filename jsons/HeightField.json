[
  {
    "label": "FHeightfieldRaycastVisitor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FHeightfieldRaycastVisitor"
  },
  {
    "label": "FMTDInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMTDInfo"
  },
  {
    "label": "FMeshContactGenerator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMeshContactGenerator"
  },
  {
    "label": "FHeightField",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FHeightField"
  },
  {
    "label": "FClosestFaceData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FClosestFaceData"
  },
  {
    "label": "FData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FData"
  },
  {
    "label": "MinMaxHeights",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MinMaxHeights"
  },
  {
    "label": "FBounds2D",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBounds2D"
  },
  {
    "label": "FWalkingData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FWalkingData"
  },
  {
    "label": "FHeightField()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Array . h \" # include \" Chaos / CollisionResolutionTypes . h \" # include \" ImplicitObject . h \" # include \" Box . h \" # include \" TriangleMeshImplicitObject . h \" # include \" ChaosArchive . h \" # include \" Serialization / MemoryWriter . h \" # include \" Math / NumericLimits . h \" # include \" Templates / UniqueObj . h \" # include \" Templates / UnrealTypeTraits . h \" # include \" UniformGrid . h \" # include \" Utilities . h \" # include \" UObject / ExternalPhysicsCustomObjectVersion . h \" namespace Chaos { class FHeightfieldRaycastVisitor ; struct FMTDInfo ; } namespace Chaos::Private { class FMeshContactGenerator ; } namespace Chaos { class FHeightField final : public FImplicitObject { public : using FImplicitObject::GetTypeName ;)",
    "insertText": "FHeightField(TArray<FReal>&& Height, TArray<uint8>&& InMaterialIndices, int32 InNumRows, int32 InNumCols, const FVec3& InScale)"
  },
  {
    "label": "FHeightField()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FHeightField(TArrayView<const uint16> InHeights, TArrayView<const uint8> InMaterialIndices, int32 InNumRows, int32 InNumCols, const FVec3& InScale)"
  },
  {
    "label": "FHeightField()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FHeightField(const FHeightField& Other)"
  },
  {
    "label": "FHeightField()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FHeightField()"
  },
  {
    "label": "EditHeights()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "EditHeights(TArrayView<FReal> InHeights, int32 InBeginRow, int32 InBeginCol, int32 InNumRows, int32 InNumCols)"
  },
  {
    "label": "EditHeights()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EditHeights(TArrayView<const uint16> InHeights, int32 InBeginRow, int32 InBeginCol, int32 InNumRows, int32 InNumCols)"
  },
  {
    "label": "GetHeight()",
    "kind": "Method",
    "detail": "Function (FReal)",
    "insertText": "GetHeight(int32 InIndex)"
  },
  {
    "label": "GetPointScaled()",
    "kind": "Method",
    "detail": "Function (FVec3)",
    "insertText": "GetPointScaled(int32 InIndex)"
  },
  {
    "label": "GetHeight()",
    "kind": "Method",
    "detail": "Function (FReal)",
    "insertText": "GetHeight(int32 InX, int32 InY)"
  },
  {
    "label": "GetMaterialIndex()",
    "kind": "Method",
    "detail": "Function (uint8)",
    "insertText": "GetMaterialIndex(int32 InIndex)"
  },
  {
    "label": "GetMaterialIndex()",
    "kind": "Method",
    "detail": "Function (uint8)",
    "insertText": "GetMaterialIndex(int32 InX, int32 InY)"
  },
  {
    "label": "IsHole()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsHole(int32 InIndex)"
  },
  {
    "label": "IsHole()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsHole(int32 InCellX, int32 InCellY)"
  },
  {
    "label": "GetNormalAt()",
    "kind": "Method",
    "detail": "Function (FVec3)",
    "insertText": "GetNormalAt(const FVec2& InGridLocationLocal)"
  },
  {
    "label": "GetHeightAt()",
    "kind": "Method",
    "detail": "Function (FReal)",
    "insertText": "GetHeightAt(const FVec2& InGridLocationLocal)"
  },
  {
    "label": "GetMaterialIndexAt()",
    "kind": "Method",
    "detail": "Function (uint8)",
    "insertText": "GetMaterialIndexAt(const FVec2& InGridLocationLocal)"
  },
  {
    "label": "GetNumRows()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumRows()"
  },
  {
    "label": "Raycast()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Raycast(const FVec3& StartPoint, const FVec3& Dir, const FReal Length, const FReal Thickness, FReal& OutTime, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex)"
  },
  {
    "label": "Overlap()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Overlap(const FVec3& Point, const FReal Thickness)"
  },
  {
    "label": "OverlapGeom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OverlapGeom(const TSphere<FReal, 3>& QueryGeom, const FRigidTransform3& QueryTM, const FReal Thickness, FMTDInfo* OutMTD = nullptr)"
  },
  {
    "label": "OverlapGeom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OverlapGeom(const TBox<FReal, 3>& QueryGeom, const FRigidTransform3& QueryTM, const FReal Thickness, FMTDInfo* OutMTD = nullptr)"
  },
  {
    "label": "OverlapGeom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OverlapGeom(const FCapsule& QueryGeom, const FRigidTransform3& QueryTM, const FReal Thickness, FMTDInfo* OutMTD = nullptr)"
  },
  {
    "label": "OverlapGeom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OverlapGeom(const FConvex& QueryGeom, const FRigidTransform3& QueryTM, const FReal Thickness, FMTDInfo* OutMTD = nullptr)"
  },
  {
    "label": "OverlapGeom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OverlapGeom(const TImplicitObjectScaled<TSphere<FReal, 3>>& QueryGeom, const FRigidTransform3& QueryTM, const FReal Thickness, FMTDInfo* OutMTD = nullptr)"
  },
  {
    "label": "OverlapGeom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OverlapGeom(const TImplicitObjectScaled<TBox<FReal, 3>>& QueryGeom, const FRigidTransform3& QueryTM, const FReal Thickness, FMTDInfo* OutMTD = nullptr)"
  },
  {
    "label": "OverlapGeom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OverlapGeom(const TImplicitObjectScaled<FCapsule>& QueryGeom, const FRigidTransform3& QueryTM, const FReal Thickness, FMTDInfo* OutMTD = nullptr)"
  },
  {
    "label": "OverlapGeom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OverlapGeom(const TImplicitObjectScaled<FConvex>& QueryGeom, const FRigidTransform3& QueryTM, const FReal Thickness, FMTDInfo* OutMTD = nullptr)"
  },
  {
    "label": "SweepGeom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SweepGeom(const TSphere<FReal, 3>& QueryGeom, const FRigidTransform3& StartTM, const FVec3& Dir, const FReal Length, FReal& OutTime, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex, FVec3& OutFaceNormal, const FReal Thickness = 0, bool bComputeMTD = false)"
  },
  {
    "label": "SweepGeom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SweepGeom(const TBox<FReal, 3>& QueryGeom, const FRigidTransform3& StartTM, const FVec3& Dir, const FReal Length, FReal& OutTime, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex, FVec3& OutFaceNormal, const FReal Thickness = 0, bool bComputeMTD = false)"
  },
  {
    "label": "SweepGeom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SweepGeom(const FCapsule& QueryGeom, const FRigidTransform3& StartTM, const FVec3& Dir, const FReal Length, FReal& OutTime, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex, FVec3& OutFaceNormal, const FReal Thickness = 0, bool bComputeMTD = false)"
  },
  {
    "label": "SweepGeom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SweepGeom(const FConvex& QueryGeom, const FRigidTransform3& StartTM, const FVec3& Dir, const FReal Length, FReal& OutTime, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex, FVec3& OutFaceNormal, const FReal Thickness = 0, bool bComputeMTD = false)"
  },
  {
    "label": "SweepGeom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SweepGeom(const TImplicitObjectScaled<TSphere<FReal, 3>>& QueryGeom, const FRigidTransform3& StartTM, const FVec3& Dir, const FReal Length, FReal& OutTime, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex, FVec3& OutFaceNormal, const FReal Thickness = 0, bool bComputeMTD = false)"
  },
  {
    "label": "SweepGeom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SweepGeom(const TImplicitObjectScaled<TBox<FReal, 3>>& QueryGeom, const FRigidTransform3& StartTM, const FVec3& Dir, const FReal Length, FReal& OutTime, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex, FVec3& OutFaceNormal, const FReal Thickness = 0, bool bComputeMTD = false)"
  },
  {
    "label": "SweepGeom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SweepGeom(const TImplicitObjectScaled<FCapsule>& QueryGeom, const FRigidTransform3& StartTM, const FVec3& Dir, const FReal Length, FReal& OutTime, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex, FVec3& OutFaceNormal, const FReal Thickness = 0, bool bComputeMTD = false)"
  },
  {
    "label": "SweepGeom()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SweepGeom(const TImplicitObjectScaled<FConvex>& QueryGeom, const FRigidTransform3& StartTM, const FVec3& Dir, const FReal Length, FReal& OutTime, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex, FVec3& OutFaceNormal, const FReal Thickness = 0, bool bComputeMTD = false)"
  },
  {
    "label": "SweepGeomCCD()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SweepGeomCCD(const TSphere<FReal, 3>& QueryGeom, const FRigidTransform3& StartTM, const FVec3& Dir, const FReal Length, const FReal IgnorePenetration, const FReal TargetPenetration, FReal& OutTOI, FReal& OutPhi, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex, FVec3& OutFaceNormal)"
  },
  {
    "label": "SweepGeomCCD()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SweepGeomCCD(const TBox<FReal, 3>& QueryGeom, const FRigidTransform3& StartTM, const FVec3& Dir, const FReal Length, const FReal IgnorePenetration, const FReal TargetPenetration, FReal& OutTOI, FReal& OutPhi, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex, FVec3& OutFaceNormal)"
  },
  {
    "label": "SweepGeomCCD()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SweepGeomCCD(const FCapsule& QueryGeom, const FRigidTransform3& StartTM, const FVec3& Dir, const FReal Length, const FReal IgnorePenetration, const FReal TargetPenetration, FReal& OutTOI, FReal& OutPhi, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex, FVec3& OutFaceNormal)"
  },
  {
    "label": "SweepGeomCCD()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SweepGeomCCD(const FConvex& QueryGeom, const FRigidTransform3& StartTM, const FVec3& Dir, const FReal Length, const FReal IgnorePenetration, const FReal TargetPenetration, FReal& OutTOI, FReal& OutPhi, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex, FVec3& OutFaceNormal)"
  },
  {
    "label": "SweepGeomCCD()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SweepGeomCCD(const TImplicitObjectScaled<TSphere<FReal, 3>>& QueryGeom, const FRigidTransform3& StartTM, const FVec3& Dir, const FReal Length, const FReal IgnorePenetration, const FReal TargetPenetration, FReal& OutTOI, FReal& OutPhi, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex, FVec3& OutFaceNormal)"
  },
  {
    "label": "SweepGeomCCD()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SweepGeomCCD(const TImplicitObjectScaled<TBox<FReal, 3>>& QueryGeom, const FRigidTransform3& StartTM, const FVec3& Dir, const FReal Length, const FReal IgnorePenetration, const FReal TargetPenetration, FReal& OutTOI, FReal& OutPhi, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex, FVec3& OutFaceNormal)"
  },
  {
    "label": "SweepGeomCCD()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SweepGeomCCD(const TImplicitObjectScaled<FCapsule>& QueryGeom, const FRigidTransform3& StartTM, const FVec3& Dir, const FReal Length, const FReal IgnorePenetration, const FReal TargetPenetration, FReal& OutTOI, FReal& OutPhi, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex, FVec3& OutFaceNormal)"
  },
  {
    "label": "SweepGeomCCD()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SweepGeomCCD(const TImplicitObjectScaled<FConvex>& QueryGeom, const FRigidTransform3& StartTM, const FVec3& Dir, const FReal Length, const FReal IgnorePenetration, const FReal TargetPenetration, FReal& OutTOI, FReal& OutPhi, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex, FVec3& OutFaceNormal)"
  },
  {
    "label": "GJKContactPoint()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GJKContactPoint(const TBox<FReal, 3>& QueryGeom, const FRigidTransform3& QueryTM, const FReal Thickness, FVec3& ContactLocation, FVec3& ContactNormal, FReal& ContactPhi, int32& ContactFaceIndex)"
  },
  {
    "label": "GJKContactPoint()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GJKContactPoint(const TSphere<FReal, 3>& QueryGeom, const FRigidTransform3& QueryTM, const FReal Thickness, FVec3& ContactLocation, FVec3& ContactNormal, FReal& ContactPhi, int32& ContactFaceIndex)"
  },
  {
    "label": "GJKContactPoint()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GJKContactPoint(const FCapsule& QueryGeom, const FRigidTransform3& QueryTM, const FReal Thickness, FVec3& ContactLocation, FVec3& ContactNormal, FReal& ContactPhi, int32& ContactFaceIndex)"
  },
  {
    "label": "GJKContactPoint()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GJKContactPoint(const FConvex& QueryGeom, const FRigidTransform3& QueryTM, const FReal Thickness, FVec3& ContactLocation, FVec3& ContactNormal, FReal& ContactPhi, int32& ContactFaceIndex)"
  },
  {
    "label": "GJKContactPoint()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GJKContactPoint(const TImplicitObjectScaled<TBox<FReal, 3>>& QueryGeom, const FRigidTransform3& QueryTM, const FReal Thickness, FVec3& ContactLocation, FVec3& ContactNormal, FReal& ContactPhi, int32& ContactFaceIndex)"
  },
  {
    "label": "GJKContactPoint()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GJKContactPoint(const TImplicitObjectScaled<TSphere<FReal, 3>>& QueryGeom, const FRigidTransform3& QueryTM, const FReal Thickness, FVec3& ContactLocation, FVec3& ContactNormal, FReal& ContactPhi, int32& ContactFaceIndex)"
  },
  {
    "label": "GJKContactPoint()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GJKContactPoint(const TImplicitObjectScaled<FCapsule>& QueryGeom, const FRigidTransform3& QueryTM, const FReal Thickness, FVec3& ContactLocation, FVec3& ContactNormal, FReal& ContactPhi, int32& ContactFaceIndex)"
  },
  {
    "label": "GJKContactPoint()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GJKContactPoint(const TImplicitObjectScaled<FConvex>& QueryGeom, const FRigidTransform3& QueryTM, const FReal Thickness, FVec3& ContactLocation, FVec3& ContactNormal, FReal& ContactPhi, int32& ContactFaceIndex)"
  },
  {
    "label": "FindMostOpposingFace()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "FindMostOpposingFace(const FVec3& Position, const FVec3& UnitDir, int32 HintFaceIndex, FReal SearchDist)"
  },
  {
    "label": "FindGeometryOpposingNormal()",
    "kind": "Method",
    "detail": "Function (FVec3)",
    "insertText": "FindGeometryOpposingNormal(const FVec3& DenormDir, int32 FaceIndex, const FVec3& OriginalNormal)"
  },
  {
    "label": "GetTransformedTriangle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetTransformedTriangle(const int32 TriangleIndex, const FRigidTransform3& Transform, FTriangle& OutTriangle, int32& OutVertexIndex0, int32& OutVertexIndex1, int32& OutVertexIndex2)"
  },
  {
    "label": "CellIndex()",
    "kind": "Method",
    "detail": "Function (const int32 CellIndex = TriangleIndex / 2 ; const int32 CellRowIndex =)",
    "insertText": "CellIndex(GeomData.NumCols - 1)"
  },
  {
    "label": "TransformPosition()",
    "kind": "Method",
    "detail": "Function (const int32 CellVertexIndex = CellRowIndex* GeomData . NumCols + CellColIndex ; const int32 VertexIndex0 = CellVertexIndex ; const int32 VertexIndex1 = CellVertexIndex + 1 ; const int32 VertexIndex2 = CellVertexIndex + GeomData . NumCols ; const int32 VertexIndex3 = CellVertexIndex + GeomData . NumCols + 1 ; const FVec3 Vertex0 = Transform .)",
    "insertText": "TransformPosition(GeomData.GetPointScaled(VertexIndex0))"
  },
  {
    "label": "TransformPosition()",
    "kind": "Method",
    "detail": "Function (const FVec3 Vertex1 = Transform .)",
    "insertText": "TransformPosition(GeomData.GetPointScaled(VertexIndex1))"
  },
  {
    "label": "TransformPosition()",
    "kind": "Method",
    "detail": "Function (const FVec3 Vertex2 = Transform .)",
    "insertText": "TransformPosition(GeomData.GetPointScaled(VertexIndex2))"
  },
  {
    "label": "TransformPosition()",
    "kind": "Method",
    "detail": "Function (const FVec3 Vertex3 = Transform .)",
    "insertText": "TransformPosition(GeomData.GetPointScaled(VertexIndex3))"
  },
  {
    "label": "bStandardWinding()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "bStandardWinding((GeomData.Scale.X * GeomData.Scale.Y * GeomData.Scale.Z) >= FReal(0))"
  },
  {
    "label": "bIsFirstTriangle()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "bIsFirstTriangle((TriangleIndex & 1) == 0)"
  },
  {
    "label": "FTriangle()",
    "kind": "Method",
    "detail": "Function (OutTriangle =)",
    "insertText": "FTriangle(Vertex0, Vertex1, Vertex3)"
  },
  {
    "label": "FTriangle()",
    "kind": "Method",
    "detail": "Function (OutVertexIndex0 = VertexIndex0 ; OutVertexIndex1 = VertexIndex1 ; OutVertexIndex2 = VertexIndex3 ; } else { OutTriangle =)",
    "insertText": "FTriangle(Vertex0, Vertex3, Vertex1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OutVertexIndex0 = VertexIndex0 ; OutVertexIndex1 = VertexIndex3 ; OutVertexIndex2 = VertexIndex1 ; } } else {)",
    "insertText": "if(bStandardWinding)"
  },
  {
    "label": "FTriangle()",
    "kind": "Method",
    "detail": "Function (OutTriangle =)",
    "insertText": "FTriangle(Vertex0, Vertex3, Vertex2)"
  },
  {
    "label": "FTriangle()",
    "kind": "Method",
    "detail": "Function (OutVertexIndex0 = VertexIndex0 ; OutVertexIndex1 = VertexIndex3 ; OutVertexIndex2 = VertexIndex2 ; } else { OutTriangle =)",
    "insertText": "FTriangle(Vertex0, Vertex2, Vertex3)"
  },
  {
    "label": "VisitTriangles()",
    "kind": "Method",
    "detail": "Function (OutVertexIndex0 = VertexIndex0 ; OutVertexIndex1 = VertexIndex2 ; OutVertexIndex2 = VertexIndex3 ; } } } template<TriangleVisitor> void)",
    "insertText": "VisitTriangles(const FAABB3& QueryBounds, const FRigidTransform3& QueryTransform, const TriangleVisitor& Visitor)"
  },
  {
    "label": "FVec2()",
    "kind": "Method",
    "detail": "Function (FBounds2D GridQueryBounds ; GridQueryBounds . Min =)",
    "insertText": "FVec2(QueryBounds.Min()[0], QueryBounds.Min()[1])"
  },
  {
    "label": "FVec2()",
    "kind": "Method",
    "detail": "Function (GridQueryBounds . Max =)",
    "insertText": "FVec2(QueryBounds.Max()[0], QueryBounds.Max()[1])"
  },
  {
    "label": "GetGridIntersections()",
    "kind": "Method",
    "detail": "Function (TArray<TVec2<int32>> Intersections ;)",
    "insertText": "GetGridIntersections(GridQueryBounds, Intersections)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FVec3 Points [ 4 ] ; FTriangle Triangles [ 2 ] ;)",
    "insertText": "for(const TVec2<int32>& Cell : Intersections)"
  },
  {
    "label": "Cell()",
    "kind": "Method",
    "detail": "Function (const int32 CellVertexIndex = Cell [ 1 ]* GeomData . NumCols + Cell [ 0 ] ; const int32 CellIndex =)",
    "insertText": "Cell(GeomData.NumCols - 1)"
  },
  {
    "label": "GetPointsAndBoundsScaled()",
    "kind": "Method",
    "detail": "Function (continue ; } FAABB3 CellBounds ; GeomData .)",
    "insertText": "GetPointsAndBoundsScaled(CellVertexIndex, Points, CellBounds)"
  },
  {
    "label": "TransformPositionNoScale()",
    "kind": "Method",
    "detail": "Function (Points [ 0 ] = QueryTransform .)",
    "insertText": "TransformPositionNoScale(Points[0])"
  },
  {
    "label": "TransformPositionNoScale()",
    "kind": "Method",
    "detail": "Function (Points [ 1 ] = QueryTransform .)",
    "insertText": "TransformPositionNoScale(Points[1])"
  },
  {
    "label": "TransformPositionNoScale()",
    "kind": "Method",
    "detail": "Function (Points [ 2 ] = QueryTransform .)",
    "insertText": "TransformPositionNoScale(Points[2])"
  },
  {
    "label": "TransformPositionNoScale()",
    "kind": "Method",
    "detail": "Function (Points [ 3 ] = QueryTransform .)",
    "insertText": "TransformPositionNoScale(Points[3])"
  },
  {
    "label": "FTriangle()",
    "kind": "Method",
    "detail": "Function (Triangles [ 0 ] =)",
    "insertText": "FTriangle(Points[0], Points[1], Points[3])"
  },
  {
    "label": "FTriangle()",
    "kind": "Method",
    "detail": "Function (Triangles [ 1 ] =)",
    "insertText": "FTriangle(Points[0], Points[3], Points[2])"
  },
  {
    "label": "Visitor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Visitor(Triangles[0], FaceIndex0, VertexIndex0, VertexIndex1, VertexIndex3)"
  },
  {
    "label": "Visitor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Visitor(Triangles[1], FaceIndex1, VertexIndex0, VertexIndex3, VertexIndex2)"
  },
  {
    "label": "FTriangle()",
    "kind": "Method",
    "detail": "Function (} else { Triangles [ 0 ] =)",
    "insertText": "FTriangle(Points[0], Points[3], Points[1])"
  },
  {
    "label": "FTriangle()",
    "kind": "Method",
    "detail": "Function (Triangles [ 1 ] =)",
    "insertText": "FTriangle(Points[0], Points[2], Points[3])"
  },
  {
    "label": "Visitor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Visitor(Triangles[0], FaceIndex0, VertexIndex0, VertexIndex3, VertexIndex1)"
  },
  {
    "label": "Visitor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Visitor(Triangles[1], FaceIndex1, VertexIndex0, VertexIndex2, VertexIndex3)"
  },
  {
    "label": "CollectTriangles()",
    "kind": "Method",
    "detail": "Function (} } } } void)",
    "insertText": "CollectTriangles(const FAABB3& QueryBounds, const FRigidTransform3& QueryTransform, const FAABB3& ObjectBounds, Private::FMeshContactGenerator& Collector)"
  },
  {
    "label": "VisitOverlappingLeafObjectsImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VisitOverlappingLeafObjectsImpl(const FAABB3& QueryBounds, const FRigidTransform3& ObjectTransform, const int32 RootObjectIndex, int32& ObjectIndex, int32& LeafObjectIndex, const FImplicitHierarchyVisitor& VisitorFunc)"
  },
  {
    "label": "VisitorFunc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VisitorFunc(this, ObjectTransform, RootObjectIndex, ObjectIndex, LeafObjectIndex)"
  },
  {
    "label": "IsOverlappingBoundsImpl()",
    "kind": "Method",
    "detail": "Function (} + + ObjectIndex ; + + LeafObjectIndex ; } bool)",
    "insertText": "IsOverlappingBoundsImpl(const FAABB3& QueryBounds)"
  },
  {
    "label": "IsOverlappingAnyCells()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsOverlappingAnyCells(const FAABB3& QueryBounds)"
  },
  {
    "label": "GetFlatBounds()",
    "kind": "Method",
    "detail": "Function (const FBounds2D FlatBounds =)",
    "insertText": "GetFlatBounds()"
  },
  {
    "label": "FromPoints()",
    "kind": "Method",
    "detail": "Function (GridQueryBounds =)",
    "insertText": "FromPoints(FlatBounds.Clamp(GridQueryBounds.Min) / Scale2D, FlatBounds.Clamp(GridQueryBounds.Max) / Scale2D)"
  },
  {
    "label": "FAABBVectorized()",
    "kind": "Method",
    "detail": "Function (FAABBVectorized QueryBoundsSimd =)",
    "insertText": "FAABBVectorized(QueryBounds)"
  },
  {
    "label": "Cell()",
    "kind": "Method",
    "detail": "Function (TVec2<int32> FirstCell = FlatGrid .)",
    "insertText": "Cell(GridQueryBounds.Min)"
  },
  {
    "label": "Cell()",
    "kind": "Method",
    "detail": "Function (TVec2<int32> LastCell = FlatGrid .)",
    "insertText": "Cell(GridQueryBounds.Max)"
  },
  {
    "label": "GetBoundsScaled()",
    "kind": "Method",
    "detail": "Function (FAABBVectorized RegionBounds ; GeomData .)",
    "insertText": "GetBoundsScaled(FirstCell, LastCell - FirstCell, RegionBounds)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (} struct FClosestFaceData { int32 FaceIndex = INDEX_NONE ; FReal DistanceToFaceSq = TNumericLimits<FReal)",
    "insertText": "Max()"
  },
  {
    "label": "FindClosestFace()",
    "kind": "Method",
    "detail": "Function (bool bWasSampleBehind = false ; } ; FClosestFaceData)",
    "insertText": "FindClosestFace(const FVec3& Position, FReal SearchDist)"
  },
  {
    "label": "GetMaterialIndex()",
    "kind": "Method",
    "detail": "Function (uint16)",
    "insertText": "GetMaterialIndex(uint32 HintIndex)"
  },
  {
    "label": "FromPoints()",
    "kind": "Method",
    "detail": "Function (CachedBounds =)",
    "insertText": "FromPoints(LocalBounds.Min() * GeomData.Scale, LocalBounds.Max() * GeomData.Scale)"
  },
  {
    "label": "Writer()",
    "kind": "Method",
    "detail": "Function (TArray<uint8> Bytes ; FMemoryWriter)",
    "insertText": "Writer(Bytes)"
  },
  {
    "label": "ChaosAr()",
    "kind": "Method",
    "detail": "Function (FChaosArchive)",
    "insertText": "ChaosAr(Writer)"
  },
  {
    "label": "FHeightField()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "FHeightField(this)->Serialize(ChaosAr)"
  },
  {
    "label": "StaticType()",
    "kind": "Method",
    "detail": "Function (} EImplicitObjectType)",
    "insertText": "StaticType()"
  },
  {
    "label": "ScopedMemory()",
    "kind": "Method",
    "detail": "Function (FChaosArchiveScopedMemory)",
    "insertText": "ScopedMemory(Ar, GetTypeName())"
  },
  {
    "label": "SerializeImp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SerializeImp(Ar)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (GeomData .)",
    "insertText": "Serialize(Ar)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FExternalPhysicsCustomObjectVersion::GUID)"
  },
  {
    "label": "SerializeAsAABB()",
    "kind": "Method",
    "detail": "Function (Ar<<FlatGrid ; Ar<<FlattenedBounds . Min ; Ar<<FlattenedBounds . Max ; TBox<FReal,3)",
    "insertText": "SerializeAsAABB(Ar, LocalBounds)"
  },
  {
    "label": "CalcBounds()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "CalcBounds()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Ar.IsLoading())"
  },
  {
    "label": "BuildQueryData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BuildQueryData()"
  },
  {
    "label": "BoundingBox()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BoundingBox()"
  },
  {
    "label": "SetScale()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetScale(const FVec3& InScale)"
  },
  {
    "label": "MakeVectorRegisterFloatFromDouble()",
    "kind": "Method",
    "detail": "Function (GeomData . Scale = InScale ; GeomData . ScaleSimd =)",
    "insertText": "MakeVectorRegisterFloatFromDouble(MakeVectorRegisterDouble(InScale.X, InScale.Y, InScale.Z, 0.0))"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} template<InStorageType> struct FData { using StorageType = InStorageType ;)",
    "insertText": "static_assert(std::is_same_v<StorageType, uint8> || std::is_same_v<StorageType, uint16> || std::is_same_v<StorageType, uint32> || std::is_same_v<StorageType, uint64>, \"Expected unsigned integer type for heightfield data storage\")"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (int32 RealSize =)",
    "insertText": "sizeof(FReal)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (int32 StorageSize =)",
    "insertText": "sizeof(StorageType)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (int32 LowResInc = 6 ; TArray<StorageType> Heights ; struct MinMaxHeights { StorageType Min ; StorageType Max ; void)",
    "insertText": "Serialize(FChaosArchive& Ar)"
  },
  {
    "label": "GetCellWidth()",
    "kind": "Method",
    "detail": "Function (Ar<<Min ; Ar<<Max ; } } ; TArray<MinMaxHeights> LowResolutionHeights ; TArray<uint8> MaterialIndices ; FVec3 Scale ; VectorRegister4Float ScaleSimd ; FReal MinValue ; FReal MaxValue ; uint16 NumRows ; uint16 NumCols ; FReal Range ; FReal HeightPerUnit ; uint16 NumColsLowRes ; FReal)",
    "insertText": "GetCellWidth()"
  },
  {
    "label": "CellIndex()",
    "kind": "Method",
    "detail": "Function (const int32 CellY =)",
    "insertText": "CellIndex(NumCols - 1)"
  },
  {
    "label": "GetPoint()",
    "kind": "Method",
    "detail": "Function (const int32 HeightIndex = CellIndex + CellY ; return HeightIndex ; } FVec3)",
    "insertText": "GetPoint(int32 Index)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (const FReal Height = MinValue + Heights [ Index ]* HeightPerUnit ; const int32 X =)",
    "insertText": "Index(NumCols)"
  },
  {
    "label": "GetPointScaled()",
    "kind": "Method",
    "detail": "Function (} FVec3)",
    "insertText": "GetPointScaled(int32 Index)"
  },
  {
    "label": "GetPoints()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetPoints(int32 Index, FVec3 OutPts[4])"
  },
  {
    "label": "OutPts()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OutPts(FReal)X, (FReal)"
  },
  {
    "label": "OutPts()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OutPts(FReal)X + 1, (FReal)"
  },
  {
    "label": "GetPointsAndBounds()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetPointsAndBounds(int32 Index, FVec3 OutPts[4], FAABB3& OutBounds)"
  },
  {
    "label": "FReal()",
    "kind": "Method",
    "detail": "Function (const FReal MinZ = FMath::Min<)",
    "insertText": "FReal(H0, FMath::Min<FReal>(H1, FMath::Min<FReal>(H2, H3)))"
  },
  {
    "label": "FReal()",
    "kind": "Method",
    "detail": "Function (const FReal MaxZ = FMath::Max<)",
    "insertText": "FReal(H0, FMath::Max<FReal>(H1, FMath::Max<FReal>(H2, H3)))"
  },
  {
    "label": "FAABB3()",
    "kind": "Method",
    "detail": "Function (OutBounds =)",
    "insertText": "FAABB3(FVec3((FReal)X, (FReal)Y, MinZ), FVec3((FReal)X + 1, (FReal)Y + 1, MaxZ))"
  },
  {
    "label": "GetPointsAndBoundsSimd()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetPointsAndBoundsSimd(int32 Index, VectorRegister4Float OutPts[4], FAABBVectorized& OutBounds)"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (const FRealSingle H0 = static_cast<)",
    "insertText": "FRealSingle(MinValue + Heights[Index] * HeightPerUnit)"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (const FRealSingle H1 = static_cast<)",
    "insertText": "FRealSingle(MinValue + Heights[Index + 1] * HeightPerUnit)"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (const FRealSingle H2 = static_cast<)",
    "insertText": "FRealSingle(MinValue + Heights[Index + NumCols] * HeightPerUnit)"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (const FRealSingle H3 = static_cast<)",
    "insertText": "FRealSingle(MinValue + Heights[Index + NumCols + 1] * HeightPerUnit)"
  },
  {
    "label": "MakeVectorRegisterFloat()",
    "kind": "Method",
    "detail": "Function (OutPts [ 0 ] =)",
    "insertText": "MakeVectorRegisterFloat((FRealSingle)X, (FRealSingle)Y, H0, 0.0f)"
  },
  {
    "label": "MakeVectorRegisterFloat()",
    "kind": "Method",
    "detail": "Function (OutPts [ 1 ] =)",
    "insertText": "MakeVectorRegisterFloat((FRealSingle)X + 1, (FRealSingle)Y, H1, 0.0f)"
  },
  {
    "label": "MakeVectorRegisterFloat()",
    "kind": "Method",
    "detail": "Function (OutPts [ 2 ] =)",
    "insertText": "MakeVectorRegisterFloat((FRealSingle)X, (FRealSingle)Y + 1, H2, 0.0f)"
  },
  {
    "label": "MakeVectorRegisterFloat()",
    "kind": "Method",
    "detail": "Function (OutPts [ 3 ] =)",
    "insertText": "MakeVectorRegisterFloat((FRealSingle)X + 1, (FRealSingle)Y + 1, H3, 0.0f)"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (const FRealSingle MinZ = FMath::Min<)",
    "insertText": "FRealSingle(H0, FMath::Min<FRealSingle>(H1, FMath::Min<FRealSingle>(H2, H3)))"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (const FRealSingle MaxZ = FMath::Max<)",
    "insertText": "FRealSingle(H0, FMath::Max<FRealSingle>(H1, FMath::Max<FRealSingle>(H2, H3)))"
  },
  {
    "label": "FAABBVectorized()",
    "kind": "Method",
    "detail": "Function (OutBounds =)",
    "insertText": "FAABBVectorized(MakeVectorRegisterFloat((FRealSingle)X, (FRealSingle)Y, MinZ, 0.0f), MakeVectorRegisterFloat((FRealSingle)X + 1, (FRealSingle)Y + 1, MaxZ, 0.0f))"
  },
  {
    "label": "GetBoundsSimd()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetBoundsSimd(int32 Index, FAABBVectorized& OutBounds)"
  },
  {
    "label": "GetBounds()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetBounds(TVec2<int32> CellIdx, TVec2<int32> Area, FAABBVectorized& OutBounds)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (FRealSingle MinHeight = UE_BIG_NUMBER ; FRealSingle MaxHeight = - UE_BIG_NUMBER ; const int32 EndIndexX = CellIdx [ 0 ] + Area [ 0 ] ; int32 FirstIndexX = FMath::Min<)",
    "insertText": "int32(CellIdx[0], EndIndexX)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (FirstIndexX = FMath::Max<)",
    "insertText": "int32(FirstIndexX, 0)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (LastIndexX + + ; LastIndexX = FMath::Min<)",
    "insertText": "int32(LastIndexX, NumCols-1)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (const int32 EndIndexY = CellIdx [ 1 ] + Area [ 1 ] ; int32 FirstIndexY = FMath::Min<)",
    "insertText": "int32(CellIdx[1], EndIndexY)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (FirstIndexY = FMath::Max<)",
    "insertText": "int32(FirstIndexY, 0)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (LastIndexY + + ; LastIndexY = FMath::Min<)",
    "insertText": "int32(LastIndexY, NumRows-1)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (const int32 Index = IndexY* NumCols + IndexX ;)",
    "insertText": "check(Index < Heights.Num())"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (const FRealSingle CurrHeight = Heights [ Index ] ; MinHeight = FMath::Min<)",
    "insertText": "FRealSingle(CurrHeight, MinHeight)"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (MaxHeight = FMath::Max<)",
    "insertText": "FRealSingle(CurrHeight, MaxHeight)"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (} } const FRealSingle MinValueSingle = static_cast<)",
    "insertText": "FRealSingle(MinValue)"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (const FRealSingle HeightPerUnitSingle = static_cast<)",
    "insertText": "FRealSingle(HeightPerUnit)"
  },
  {
    "label": "FAABBVectorized()",
    "kind": "Method",
    "detail": "Function (MinHeight = MinValueSingle + MinHeight* HeightPerUnitSingle ; MaxHeight = MinValueSingle + MaxHeight* HeightPerUnitSingle ; OutBounds =)",
    "insertText": "FAABBVectorized(MakeVectorRegisterFloat(static_cast<FRealSingle>(FirstIndexX), static_cast<FRealSingle>(FirstIndexY), MinHeight, 0.0f), MakeVectorRegisterFloat(static_cast<FRealSingle>(LastIndexX), static_cast<FRealSingle>(LastIndexY), MaxHeight, 0.0f))"
  },
  {
    "label": "GetLowResBounds()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetLowResBounds(TVec2<int32> CellIdx, FAABBVectorized& OutBounds)"
  },
  {
    "label": "IndexLowResY()",
    "kind": "Method",
    "detail": "Function (const int32 IndexLowResX = CellIdx [ 0 ] / LowResInc ; const int32 IndexLowResY = CellIdx [ 1 ] / LowResInc ; const int32 Index =)",
    "insertText": "IndexLowResY(NumColsLowRes - 1)"
  },
  {
    "label": "FAABBVectorized()",
    "kind": "Method",
    "detail": "Function (MinHeight = MinValueSingle + MinHeight* HeightPerUnitSingle ; MaxHeight = MinValueSingle + MaxHeight* HeightPerUnitSingle ; OutBounds =)",
    "insertText": "FAABBVectorized(MakeVectorRegisterFloat(static_cast<FRealSingle>(IndexLowResX *LowResInc), static_cast<FRealSingle>(IndexLowResY *LowResInc), MinHeight, 0.0f), MakeVectorRegisterFloat(static_cast<FRealSingle>((IndexLowResX +1) * LowResInc), static_cast<FRealSingle>((IndexLowResY + 1) * LowResInc), MaxHeight, 0.0f))"
  },
  {
    "label": "GetPointsScaled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetPointsScaled(int32 Index, FVec3 OutPts[4])"
  },
  {
    "label": "GetPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPoints(Index, OutPts)"
  },
  {
    "label": "GetPointsAndBoundsScaled()",
    "kind": "Method",
    "detail": "Function (OutPts [ 0 ]* = Scale ; OutPts [ 1 ]* = Scale ; OutPts [ 2 ]* = Scale ; OutPts [ 3 ]* = Scale ; } void)",
    "insertText": "GetPointsAndBoundsScaled(int32 Index, FVec3 OutPts[4], FAABB3& OutBounds)"
  },
  {
    "label": "GetPointsAndBounds()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPointsAndBounds(Index, OutPts, OutBounds)"
  },
  {
    "label": "FromPoints()",
    "kind": "Method",
    "detail": "Function (OutPts [ 0 ]* = Scale ; OutPts [ 1 ]* = Scale ; OutPts [ 2 ]* = Scale ; OutPts [ 3 ]* = Scale ; OutBounds =)",
    "insertText": "FromPoints(OutBounds.Min() * Scale, OutBounds.Max() * Scale)"
  },
  {
    "label": "GetPointsAndBoundsScaledSimd()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetPointsAndBoundsScaledSimd(int32 Index, VectorRegister4Float OutPts[4], FAABBVectorized& OutBounds)"
  },
  {
    "label": "GetPointsAndBoundsSimd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPointsAndBoundsSimd(Index, OutPts, OutBounds)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (OutPts [ 0 ] =)",
    "insertText": "VectorMultiply(OutPts[0], ScaleSimd)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (OutPts [ 1 ] =)",
    "insertText": "VectorMultiply(OutPts[1], ScaleSimd)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (OutPts [ 2 ] =)",
    "insertText": "VectorMultiply(OutPts[2], ScaleSimd)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (OutPts [ 3 ] =)",
    "insertText": "VectorMultiply(OutPts[3], ScaleSimd)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float P0 =)",
    "insertText": "VectorMultiply(OutBounds.GetMin(), ScaleSimd)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float P1 =)",
    "insertText": "VectorMultiply(OutBounds.GetMax(), ScaleSimd)"
  },
  {
    "label": "VectorMin()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Min =)",
    "insertText": "VectorMin(P0, P1)"
  },
  {
    "label": "VectorMax()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Max =)",
    "insertText": "VectorMax(P0, P1)"
  },
  {
    "label": "FAABBVectorized()",
    "kind": "Method",
    "detail": "Function (OutBounds =)",
    "insertText": "FAABBVectorized(Min, Max)"
  },
  {
    "label": "GetBoundsScaledSimd()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetBoundsScaledSimd(int32 Index, FAABBVectorized& OutBounds)"
  },
  {
    "label": "GetBoundsSimd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetBoundsSimd(Index, OutBounds)"
  },
  {
    "label": "GetBoundsScaled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetBoundsScaled(TVec2<int32> CellIdx, TVec2<int32> Area, FAABBVectorized& OutBounds)"
  },
  {
    "label": "GetBounds()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetBounds(CellIdx, Area, OutBounds)"
  },
  {
    "label": "GetBoundsScaled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetBoundsScaled(TVec2<int32> CellIdx, FAABBVectorized& OutBounds)"
  },
  {
    "label": "GetBounds()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetBounds(CellIdx, TVec2<int32>(1, 1), OutBounds)"
  },
  {
    "label": "GetLowResBoundsScaled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetLowResBoundsScaled(TVec2<int32> CellIdx, FAABBVectorized& OutBounds)"
  },
  {
    "label": "GetLowResBounds()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetLowResBounds(CellIdx, OutBounds)"
  },
  {
    "label": "GetMinHeight()",
    "kind": "Method",
    "detail": "Function (} FReal)",
    "insertText": "GetMinHeight()"
  },
  {
    "label": "MakeVectorRegisterFloatFromDouble()",
    "kind": "Method",
    "detail": "Function (} Ar<<Heights ; Ar<<Scale ; Ar<<MinValue ; Ar<<MaxValue ; Ar<<NumRows ; Ar<<NumCols ; ScaleSimd =)",
    "insertText": "MakeVectorRegisterFloatFromDouble(MakeVectorRegisterDouble(Scale.X, Scale.Y, Scale.Z, 0.0))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Ar<<Range ; Ar<<HeightPerUnit ;)",
    "insertText": "if(Ar.CustomVer(FExternalPhysicsCustomObjectVersion::GUID) < FExternalPhysicsCustomObjectVersion::HeightfieldImplicitBounds)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<TUniqueObj<FBoxFloat3>> CellBounds ; Ar<<CellBounds ; } else)",
    "insertText": "if(Ar.CustomVer(FExternalPhysicsCustomObjectVersion::GUID) < FExternalPhysicsCustomObjectVersion::HeightfieldUsesHeightsDirectly)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<float> OldHeights ; Ar<<OldHeights ; } })",
    "insertText": "if(Ar.CustomVer(FExternalPhysicsCustomObjectVersion::GUID) >= FExternalPhysicsCustomObjectVersion::AddedMaterialManager)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar<<MaterialIndices ; } Ar .)",
    "insertText": "UsingCustomVersion(FUE5MainStreamObjectVersion::GUID)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Ar<<LowResolutionHeights ; Ar<<NumColsLowRes ; } else)",
    "insertText": "if(Ar.CustomVer(FUE5MainStreamObjectVersion::GUID) >= FUE5MainStreamObjectVersion::DecreaseLowResolutionHeightField)"
  },
  {
    "label": "BuildLowResolutionData()",
    "kind": "Method",
    "detail": "Function (Ar<<LowResolutionHeights ; Ar<<NumColsLowRes ; } else {)",
    "insertText": "BuildLowResolutionData()"
  },
  {
    "label": "CeilToInt()",
    "kind": "Method",
    "detail": "Function (const int32 NumRowsLowRes =)",
    "insertText": "CeilToInt(FRealSingle(NumRows) / LowResInc)"
  },
  {
    "label": "uint16()",
    "kind": "Method",
    "detail": "Function (NumColsLowRes =)",
    "insertText": "uint16(FMath::CeilToInt(FRealSingle(NumCols) / LowResInc))"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (const int32 NumLowResHeights = NumRowsLowRes* NumColsLowRes ; LowResolutionHeights .)",
    "insertText": "SetNum(NumLowResHeights)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (FDataType::StorageType MinHeight = std::numeric_limits<FDataType::StorageType)",
    "insertText": "max()"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (FDataType::StorageType MaxHeight = std::numeric_limits<FDataType::StorageType)",
    "insertText": "min()"
  },
  {
    "label": "StorageType()",
    "kind": "Method",
    "detail": "Function (const int32 HeightIndex = RowIdx* NumCols + ColIdx ; MaxHeight = FMath::Max<)",
    "insertText": "StorageType(Heights[HeightIndex], MaxHeight)"
  },
  {
    "label": "StorageType()",
    "kind": "Method",
    "detail": "Function (MinHeight = FMath::Min<)",
    "insertText": "StorageType(Heights[HeightIndex], MinHeight)"
  },
  {
    "label": "FBounds2D()",
    "kind": "Method",
    "detail": "Function (} } const int32 HeightLowResIndex = RowIdxLowRes* NumColsLowRes + ColIdxLowRes ; LowResolutionHeights [ HeightLowResIndex ] . Max = MaxHeight ; LowResolutionHeights [ HeightLowResIndex ] . Min = MinHeight ; } } } } ; using FDataType = FData<uint16> ; FDataType GeomData ; private : struct FBounds2D { FVec2 Min ; FVec2 Max ;)",
    "insertText": "FBounds2D() : Min(0) , Max(0)"
  },
  {
    "label": "FBounds2D()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FBounds2D(const FVec2& InMin, const FVec2& InMax) : Min(InMin) , Max(InMax)"
  },
  {
    "label": "FromPoints()",
    "kind": "Method",
    "detail": "Function (} template<. . . Points> FBounds2D)",
    "insertText": "FromPoints(const FVec2& P0, const Points&... InPoints)"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (FBounds2D)",
    "insertText": "Result(P0, P0)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Set(In3DBounds)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Set(const FAABB3& In3DBounds)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (Min = { In3DBounds .)",
    "insertText": "Min()[0], In3DBounds.Min()"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (Max = { In3DBounds .)",
    "insertText": "Max()[0], In3DBounds.Max()"
  },
  {
    "label": "GetExtent()",
    "kind": "Method",
    "detail": "Function (} FVec2)",
    "insertText": "GetExtent()"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (Min = {)",
    "insertText": "Min(Min.X, InPoint.X), FMath::Min(Min.Y, InPoint.Y)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (Max = {)",
    "insertText": "Max(Max.X, InPoint.X), FMath::Max(Max.Y, InPoint.Y)"
  },
  {
    "label": "Inflate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Inflate(const FVec2& InInflation)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (Min - = InInflation ; Max + = InInflation ; } FVec2)",
    "insertText": "Clamp(const FVec2& InToClamp, FReal InNudge = UE_SMALL_NUMBER)"
  },
  {
    "label": "NudgeVec()",
    "kind": "Method",
    "detail": "Function (const FVec2)",
    "insertText": "NudgeVec(InNudge, InNudge)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (const FVec2 TestMin = Min + NudgeVec ; const FVec2 TestMax = Max - NudgeVec ; FVec2 OutVec = InToClamp ; OutVec [ 0 ] =)",
    "insertText": "Max(OutVec[0], TestMin[0])"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (OutVec [ 1 ] =)",
    "insertText": "Max(OutVec[1], TestMin[1])"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (OutVec [ 0 ] =)",
    "insertText": "Min(OutVec[0], TestMax[0])"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (OutVec [ 1 ] =)",
    "insertText": "Min(OutVec[1], TestMax[1])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FReal TA,TB ;)",
    "insertText": "if(Utilities::IntersectLineSegments2D(InStart, InEnd, Min, FVec2(Min[0] + Extent[0], Min[1]), TA, TB) || Utilities::IntersectLineSegments2D(InStart, InEnd, Min, FVec2(Min[0], Min[1] + Extent[1]), TA, TB) || Utilities::IntersectLineSegments2D(InStart, InEnd, Max, FVec2(Max[0] - Extent[0], Max[1]), TA, TB) || Utilities::IntersectLineSegments2D(InStart, InEnd, Max, FVec2(Max[0], Max[1] - Extent[1]), TA, TB))"
  },
  {
    "label": "TempStart()",
    "kind": "Method",
    "detail": "Function (FVec2)",
    "insertText": "TempStart(InStart[0], InStart[1])"
  },
  {
    "label": "TempEnd()",
    "kind": "Method",
    "detail": "Function (FVec2)",
    "insertText": "TempEnd(InEnd[0], InEnd[1])"
  },
  {
    "label": "ClipLine()",
    "kind": "Method",
    "detail": "Function (bool bLineIntersects =)",
    "insertText": "ClipLine(TempStart, TempEnd)"
  },
  {
    "label": "ClipLine()",
    "kind": "Method",
    "detail": "Function (OutClippedStart = TempStart ; OutClippedEnd = TempEnd ; return bLineIntersects ; } bool)",
    "insertText": "ClipLine(FVec2& InOutStart, FVec2& InOutEnd)"
  },
  {
    "label": "IsInside()",
    "kind": "Method",
    "detail": "Function (const bool bStartInside =)",
    "insertText": "IsInside(InOutStart)"
  },
  {
    "label": "IsInside()",
    "kind": "Method",
    "detail": "Function (const bool bEndInside =)",
    "insertText": "IsInside(InOutEnd)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bPerpendicular [ Axis ] = Dir [ Axis ] = = 0 ; InvDir [ Axis ] = bPerpendicular [ Axis ] ? 0 : 1 / Dir [ Axis ] ; })",
    "insertText": "if(bStartInside)"
  },
  {
    "label": "ComputeTimeToExit()",
    "kind": "Method",
    "detail": "Function (const FReal TimeToExit =)",
    "insertText": "ComputeTimeToExit(InOutStart,InvDir)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (InOutEnd = InOutStart + Dir* TimeToExit ; return true ; })",
    "insertText": "if(bEndInside)"
  },
  {
    "label": "ComputeTimeToExit()",
    "kind": "Method",
    "detail": "Function (const FReal TimeToExit =)",
    "insertText": "ComputeTimeToExit(InOutEnd,-InvDir)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (InOutStart = InOutEnd - Dir* TimeToExit ; return true ; } FReal TimesToEnter [ 2 ] = { TNumericLimits<FReal)",
    "insertText": "Max(),TNumericLimits<FReal>::Max()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TimesToEnter [ Axis ] = 0 ; } } else {)",
    "insertText": "if(Dir[Axis] > 0)"
  },
  {
    "label": "FReal()",
    "kind": "Method",
    "detail": "Function (TimesToEnter [ Axis ] = FMath::Max<)",
    "insertText": "FReal(Min[Axis] - InOutStart[Axis], 0)"
  },
  {
    "label": "Axis()",
    "kind": "Method",
    "detail": "Function (TimesToExit [)",
    "insertText": "Axis(Max[Axis] - InOutStart[Axis])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(Dir[Axis] < 0)"
  },
  {
    "label": "FReal()",
    "kind": "Method",
    "detail": "Function (TimesToEnter [ Axis ] = FMath::Max<)",
    "insertText": "FReal(InOutStart[Axis] - Max[Axis],0)"
  },
  {
    "label": "Axis()",
    "kind": "Method",
    "detail": "Function (TimesToExit [)",
    "insertText": "Axis(InOutStart[Axis] - Min[Axis])"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (} } } } const FReal TimeToEnter =)",
    "insertText": "Max(FMath::Abs(TimesToEnter[0]),FMath::Abs(TimesToEnter[1]))"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (const FReal TimeToExit =)",
    "insertText": "Min(FMath::Abs(TimesToExit[0]),FMath::Abs(TimesToExit[1]))"
  },
  {
    "label": "Axis()",
    "kind": "Method",
    "detail": "Function (Times [)",
    "insertText": "Axis(Max[Axis] - Start[Axis])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(InvDir[Axis] < 0)"
  },
  {
    "label": "Axis()",
    "kind": "Method",
    "detail": "Function (Times [)",
    "insertText": "Axis(Start[Axis] - Min[Axis])"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (} } const FReal MinTime =)",
    "insertText": "Min(FMath::Abs(Times[0]),FMath::Abs(Times[1]))"
  },
  {
    "label": "GetCellBounds3D()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetCellBounds3D(const TVec2<int32> InCoord, FVec3& OutMin, FVec3& OutMax, const FVec3& InInflate = FVec3(0))"
  },
  {
    "label": "GetCellBounds2DScaled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetCellBounds2DScaled(const TVec2<int32> InCoord, FBounds2D& OutBounds, const FVec2& InInflate = {0})"
  },
  {
    "label": "GetCellBounds3DScaled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetCellBounds3DScaled(const TVec2<int32> InCoord, FVec3& OutMin, FVec3& OutMax, const FVec3& InInflate = FVec3(0))"
  },
  {
    "label": "CalcCellBounds3D()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CalcCellBounds3D(const TVec2<int32> InCoord, FVec3& OutMin, FVec3& OutMax, const FVec3& InInflate = FVec3(0))"
  },
  {
    "label": "GridSweep()",
    "kind": "Method",
    "detail": "Function (template<SQVisitor> bool)",
    "insertText": "GridSweep(const FVec3& StartPoint, const FVec3& Dir, const FReal Length, const FVec3 InHalfExtents, SQVisitor& Visitor)"
  },
  {
    "label": "FWalkingData()",
    "kind": "Method",
    "detail": "Function (struct FWalkingData {)",
    "insertText": "FWalkingData(FHeightfieldRaycastVisitor& VisitorIn) : Visitor(VisitorIn)"
  },
  {
    "label": "WalkSlow()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float CurrentLengthSimd ; FVec2 ScaledMin ; FReal CurrentLength ; FReal ZMidPoint ; FVec3 Dir ; FVec3 InvDir ; FVec3 NextStart ; FVec3 ScaleSign ; FVec3 ScaledDx ; FVec2 ScaledDx2D ; TVec2<int32> CellIdx ; bool bParallel [ 3 ] ; FHeightfieldRaycastVisitor& Visitor ; } ; bool)",
    "insertText": "WalkSlow(FWalkingData& WalkingData, int32 IndexLowResX, int32 IndexLowResY)"
  },
  {
    "label": "WalkFast()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "WalkFast(FWalkingData& WalkingData, const FVec2& Scale2D, const FVec3& DirScaled)"
  },
  {
    "label": "WalkOnLowRes()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "WalkOnLowRes(FWalkingData& WalkingData, const FVec2& Scale2D, const FVec3& DirScaled)"
  },
  {
    "label": "GridCast()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GridCast(const FVec3& StartPoint, const FVec3& Dir, const FReal Length, FHeightfieldRaycastVisitor& Visitor)"
  },
  {
    "label": "GetGridIntersections()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetGridIntersections(FBounds2D InFlatBounds, TArray<TVec2<int32>>& OutInterssctions)"
  },
  {
    "label": "GetGridIntersectionsBatch()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetGridIntersectionsBatch(FBounds2D InFlatBounds, TArray<TVec2<int32>>& OutIntersections, const FAABBVectorized& Bounds)"
  },
  {
    "label": "GetOverlappingCellRange()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetOverlappingCellRange(const FAABB3& QueryBounds, TVec2<int32>& OutBeginCell, TVec2<int32>& OutEndCell)"
  },
  {
    "label": "FHeightField()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FHeightField() : FImplicitObject(EImplicitObject::HasBoundingBox, ImplicitObjectType::HeightField)"
  },
  {
    "label": "OverlapGeomImp()",
    "kind": "Method",
    "detail": "Function (} FImplicitObject ; template<QueryGeomType> bool)",
    "insertText": "OverlapGeomImp(const QueryGeomType& QueryGeom, const FRigidTransform3& QueryTM, const FReal Thickness, FMTDInfo* OutMTD = nullptr)"
  },
  {
    "label": "SweepGeomImp()",
    "kind": "Method",
    "detail": "Function (template<QueryGeomType> bool)",
    "insertText": "SweepGeomImp(const QueryGeomType& QueryGeom, const FRigidTransform3& StartTM, const FVec3& Dir, const FReal Length, FReal& OutTime, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex, const FReal Thickness, bool bComputeMTD)"
  },
  {
    "label": "SweepGeomCCDImp()",
    "kind": "Method",
    "detail": "Function (template<QueryGeomType> bool)",
    "insertText": "SweepGeomCCDImp(const QueryGeomType& QueryGeom, const FRigidTransform3& StartTM, const FVec3& Dir, const FReal Length, const FReal IgnorePenetration, const FReal TargetPenetration, FReal& OutTOI, FReal& OutPhi, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex)"
  },
  {
    "label": "GJKContactPointImp()",
    "kind": "Method",
    "detail": "Function (template<GeomType> bool)",
    "insertText": "GJKContactPointImp(const GeomType& QueryGeom, const FRigidTransform3& QueryTM, const FReal Thickness, FVec3& ContactLocation, FVec3& ContactNormal, FReal& ContactPhi, int32& ContactFaceIndex)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar, FHeightField::FDataType::MinMaxHeights& Value)"
  }
]