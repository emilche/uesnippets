[
  {
    "label": "FixedInt",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FixedInt"
  },
  {
    "label": "VariableAndFixedInt",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VariableAndFixedInt"
  },
  {
    "label": "get_fixed_value",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "get_fixed_value"
  },
  {
    "label": "cleanup_index_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cleanup_index_type"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_INTEGRAL_CONSTANT_H # define EIGEN_INTEGRAL_CONSTANT_H namespace Eigen { namespace internal { template<int N> class FixedInt ; template<int N> class VariableAndFixedInt ; template<int N> class FixedInt { public : const int value = N ; EIGEN_CONSTEXPR operator)",
    "insertText": "int()"
  },
  {
    "label": "FixedInt()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FixedInt(VariableAndFixedInt<N> other)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_INTERNAL_DEBUGGING)",
    "insertText": "EIGEN_UNUSED_VARIABLE(other)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "eigen_internal_assert(int(other)==N)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FixedInt<- N>)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<int M> FixedInt<N + M>)",
    "insertText": "operator(FixedInt<M>)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # if EIGEN_HAS_CXX14_VARIABLE_TEMPLATES FixedInt)",
    "insertText": "operator() ()"
  },
  {
    "label": "FixedInt()",
    "kind": "Method",
    "detail": "Function (} # else)",
    "insertText": "FixedInt(FixedInt<N> (*)())"
  },
  {
    "label": "FixedInt()",
    "kind": "Method",
    "detail": "Function (} # endif # if EIGEN_HAS_CXX11)",
    "insertText": "FixedInt(std::integral_constant<int,N>)"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (m_value = val ; } protected : int m_value ; } ; template<T,int Default = Dynamic> struct get_fixed_value { const int value = Default ; } ; template<int N,int Default> struct get_fixed_value<FixedInt<N>,Default> { const int value = N ; } ; # if ! EIGEN_HAS_CXX14 template<int N,int Default> struct get_fixed_value<FixedInt<)",
    "insertText": "N(*)()"
  },
  {
    "label": "get_runtime_value()",
    "kind": "Method",
    "detail": "Function (const int value = N ; } ; # endif template<int N,int Default> struct get_fixed_value<VariableAndFixedInt<N>,Default> { const int value = N ; } ; template<T,int N,int Default> struct get_fixed_value<variable_if_dynamic<T,N>,Default> { const int value = N ; } ; template<T> EIGEN_DEVICE_FUNC Index)",
    "insertText": "get_runtime_value(const T &x)"
  },
  {
    "label": "fix()",
    "kind": "Method",
    "detail": "Function (typedef FixedInt<N> type ; } ; # endif template<int N,int DynamicKey> struct cleanup_index_type<VariableAndFixedInt<N>,DynamicKey> { typedef FixedInt<N> type ; } ; template<int DynamicKey> struct cleanup_index_type<VariableAndFixedInt<DynamicKey>,DynamicKey> { typedef Index type ; } ; # if EIGEN_HAS_CXX11 template<int N,int DynamicKey> struct cleanup_index_type<std::integral_constant<int,N>,DynamicKey> { typedef FixedInt<N> type ; } ; # endif } # ifndef EIGEN_PARSED_BY_DOXYGEN # if EIGEN_HAS_CXX14_VARIABLE_TEMPLATES template<int N> const internal::FixedInt<N> fix { } ; # else template<int N> internal::FixedInt<N>)",
    "insertText": "fix()"
  },
  {
    "label": "fix()",
    "kind": "Method",
    "detail": "Function (} template<int N,T> internal::VariableAndFixedInt<N>)",
    "insertText": "fix(T val)"
  },
  {
    "label": "fix()",
    "kind": "Method",
    "detail": "Function (template<int N> const auto)",
    "insertText": "fix(int val)"
  }
]