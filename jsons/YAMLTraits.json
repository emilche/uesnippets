[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "MappingTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MappingTraits"
  },
  {
    "label": "ScalarEnumerationTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ScalarEnumerationTraits"
  },
  {
    "label": "ScalarBitSetTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ScalarBitSetTraits"
  },
  {
    "label": "ScalarTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ScalarTraits"
  },
  {
    "label": "BlockScalarTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BlockScalarTraits"
  },
  {
    "label": "SequenceTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SequenceTraits"
  },
  {
    "label": "DocumentListTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DocumentListTraits"
  },
  {
    "label": "SameType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SameType"
  },
  {
    "label": "MissingTrait",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MissingTrait"
  },
  {
    "label": "has_ScalarEnumerationTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "has_ScalarEnumerationTraits"
  },
  {
    "label": "IO",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IO"
  },
  {
    "label": "has_ScalarBitSetTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "has_ScalarBitSetTraits"
  },
  {
    "label": "has_ScalarTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "has_ScalarTraits"
  },
  {
    "label": "has_BlockScalarTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "has_BlockScalarTraits"
  },
  {
    "label": "has_MappingTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "has_MappingTraits"
  },
  {
    "label": "has_MappingValidateTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "has_MappingValidateTraits"
  },
  {
    "label": "has_SequenceMethodTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "has_SequenceMethodTraits"
  },
  {
    "label": "has_FlowTraits",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "has_FlowTraits"
  },
  {
    "label": "Fallback",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Fallback"
  },
  {
    "label": "Derived",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Derived"
  },
  {
    "label": "has_SequenceTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "has_SequenceTraits"
  },
  {
    "label": "has_DocumentListTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "has_DocumentListTraits"
  },
  {
    "label": "missingTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "missingTraits"
  },
  {
    "label": "validatedMappingTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "validatedMappingTraits"
  },
  {
    "label": "unvalidatedMappingTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "unvalidatedMappingTraits"
  },
  {
    "label": "trying",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "trying"
  },
  {
    "label": "MappingNormalization",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MappingNormalization"
  },
  {
    "label": "MappingNormalizationHeap",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MappingNormalizationHeap"
  },
  {
    "label": "Input",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Input"
  },
  {
    "label": "HNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HNode"
  },
  {
    "label": "EmptyHNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "EmptyHNode"
  },
  {
    "label": "ScalarHNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScalarHNode"
  },
  {
    "label": "MapHNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MapHNode"
  },
  {
    "label": "SequenceHNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SequenceHNode"
  },
  {
    "label": "Output",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Output"
  },
  {
    "label": "InState",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "InState"
  },
  {
    "label": "_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_type"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_SUPPORT_YAMLTRAITS_H # define LLVM_SUPPORT_YAMLTRAITS_H # include \" llvm / ADT / DenseMap . h \" # include \" llvm / ADT / DenseMapInfo . h \" # include \" llvm / ADT / Optional . h \" # include \" llvm / ADT / SmallVector . h \" # include \" llvm / ADT / StringMap . h \" # include \" llvm / ADT / StringRef . h \" # include \" llvm / ADT / StringSwitch . h \" # include \" llvm / ADT / Twine . h \" # include \" llvm / Support / Compiler . h \" # include \" llvm / Support / Regex . h \" # include \" llvm / Support / SourceMgr . h \" # include \" llvm / Support / YAMLParser . h \" # include \" llvm / Support / raw_ostream . h \" # include<system_error> namespace llvm { namespace yaml { template<class T> struct MappingTraits { } ; template<T> struct ScalarEnumerationTraits { } ; template<T> struct ScalarBitSetTraits { } ; template<T> struct ScalarTraits { } ; template<T> struct BlockScalarTraits { } ; template<T> struct SequenceTraits { } ; template<T> struct DocumentListTraits { } ; template<T,T> struct SameType ; template<T> struct MissingTrait ; template<class T> struct has_ScalarEnumerationTraits { typedef)",
    "insertText": "void(*Signature_enumeration)(class IO&, T&)"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (template<U> char)",
    "insertText": "test(SameType<Signature_enumeration, &U::enumeration>*)"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (template<U> double)",
    "insertText": "test(...)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (public : bool const)",
    "insertText": "value(sizeof(test<ScalarEnumerationTraits<T> >(nullptr)) == 1)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} ; template<class T> struct has_ScalarBitSetTraits { typedef)",
    "insertText": "void(*Signature_bitset)(class IO&, T&)"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (template<U> char)",
    "insertText": "test(SameType<Signature_bitset, &U::bitset>*)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (public : bool const)",
    "insertText": "value(sizeof(test<ScalarBitSetTraits<T> >(nullptr)) == 1)"
  },
  {
    "label": "StringRef()",
    "kind": "Method",
    "detail": "Function (} ; template<class T> struct has_ScalarTraits { typedef)",
    "insertText": "StringRef(*Signature_input)(StringRef, void*, T&)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "void(*Signature_output)(const T&, void*, llvm::raw_ostream&)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "bool(*Signature_mustQuote)(StringRef)"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (template<U> char)",
    "insertText": "test(SameType<Signature_input, &U::input> *, SameType<Signature_output, &U::output> *, SameType<Signature_mustQuote, &U::mustQuote> *)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (public : bool const)",
    "insertText": "value(sizeof(test<ScalarTraits<T>>(nullptr, nullptr, nullptr)) == 1)"
  },
  {
    "label": "StringRef()",
    "kind": "Method",
    "detail": "Function (} ; template<class T> struct has_BlockScalarTraits { typedef)",
    "insertText": "StringRef(*Signature_input)(StringRef, void *, T &)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "void(*Signature_output)(const T &, void *, llvm::raw_ostream &)"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (template<U> char)",
    "insertText": "test(SameType<Signature_input, &U::input> *, SameType<Signature_output, &U::output> *)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (public : bool const)",
    "insertText": "value(sizeof(test<BlockScalarTraits<T>>(nullptr, nullptr)) == 1)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} ; template<class T> struct has_MappingTraits { typedef)",
    "insertText": "void(*Signature_mapping)(class IO&, T&)"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (template<U> char)",
    "insertText": "test(SameType<Signature_mapping, &U::mapping>*)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (public : bool const)",
    "insertText": "value(sizeof(test<MappingTraits<T> >(nullptr)) == 1)"
  },
  {
    "label": "StringRef()",
    "kind": "Method",
    "detail": "Function (} ; template<class T> struct has_MappingValidateTraits { typedef)",
    "insertText": "StringRef(*Signature_validate)(class IO&, T&)"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (template<U> char)",
    "insertText": "test(SameType<Signature_validate, &U::validate>*)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (} ; template<class T> struct has_SequenceMethodTraits { typedef)",
    "insertText": "size_t(*Signature_size)(class IO&, T&)"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (template<U> char)",
    "insertText": "test(SameType<Signature_size, &U::size>*)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (public : bool const)",
    "insertText": "value(sizeof(test<SequenceTraits<T> >(nullptr)) == 1)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (} ; template<T,bool Enabled = std::is_class<T>::value> class has_FlowTraits { public : const bool value = false ; } ; template<class T> struct has_FlowTraits<T,true> { struct Fallback { bool flow ; } ; struct Derived : T,Fallback { } ; template<C>)",
    "insertText": "char(&f(SameType<bool Fallback::*, &C::flow>*))"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (template<C>)",
    "insertText": "char(&f(...))"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (public : bool const value =)",
    "insertText": "sizeof(f<Derived>(nullptr))"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (public : bool const)",
    "insertText": "value(sizeof(test<DocumentListTraits<T> >(nullptr))==1)"
  },
  {
    "label": "isNumber()",
    "kind": "Method",
    "detail": "Function (} ; bool)",
    "insertText": "isNumber(StringRef S)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const char OctalChars [ ] = \" 0 1 2 3 4 5 6 7 \" ;)",
    "insertText": "if(S.startswith(\"0\") && S.drop_front().find_first_not_of(OctalChars) == StringRef::npos)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const char HexChars [ ] = \" 0 1 2 3 4 5 6 7 8 9 abcdefABCDEF \" ;)",
    "insertText": "if(S.startswith(\"0x\") && S.drop_front(2).find_first_not_of(HexChars) == StringRef::npos)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const char DecChars [ ] = \" 0 1 2 3 4 5 6 7 8 9 \" ;)",
    "insertText": "if(S.find_first_not_of(DecChars) == StringRef::npos)"
  },
  {
    "label": "FloatMatcher()",
    "kind": "Method",
    "detail": "Function (Regex)",
    "insertText": "FloatMatcher(\"^(\\\\.[0-9]+|[0-9]+(\\\\.[0-9]*)?)([eE][-+]?[0-9]+)?$\")"
  },
  {
    "label": "isBool()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isBool(StringRef S)"
  },
  {
    "label": "needsQuotes()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "needsQuotes(StringRef S)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const char ScalarSafeChars [ ] = \" abcdefghijklmnopqrstuvwxyz \" \" ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_ - / ^ .,\\ t \" ;)",
    "insertText": "if(S.find_first_not_of(ScalarSafeChars) != StringRef::npos)"
  },
  {
    "label": "IO()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "IO()"
  },
  {
    "label": "outputting()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "outputting()"
  },
  {
    "label": "beginSequence()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "beginSequence()"
  },
  {
    "label": "preflightElement()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "preflightElement(unsigned, void *&)"
  },
  {
    "label": "postflightElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "postflightElement(void*)"
  },
  {
    "label": "endSequence()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "endSequence()"
  },
  {
    "label": "canElideEmptySequence()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "canElideEmptySequence()"
  },
  {
    "label": "beginFlowSequence()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "beginFlowSequence()"
  },
  {
    "label": "preflightFlowElement()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "preflightFlowElement(unsigned, void *&)"
  },
  {
    "label": "postflightFlowElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "postflightFlowElement(void*)"
  },
  {
    "label": "endFlowSequence()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "endFlowSequence()"
  },
  {
    "label": "mapTag()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "mapTag(StringRef Tag, bool Default=false)"
  },
  {
    "label": "beginMapping()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "beginMapping()"
  },
  {
    "label": "endMapping()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "endMapping()"
  },
  {
    "label": "preflightKey()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "preflightKey(const char*, bool, bool, bool &, void *&)"
  },
  {
    "label": "postflightKey()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "postflightKey(void*)"
  },
  {
    "label": "beginFlowMapping()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "beginFlowMapping()"
  },
  {
    "label": "endFlowMapping()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "endFlowMapping()"
  },
  {
    "label": "beginEnumScalar()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "beginEnumScalar()"
  },
  {
    "label": "matchEnumScalar()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "matchEnumScalar(const char*, bool)"
  },
  {
    "label": "matchEnumFallback()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "matchEnumFallback()"
  },
  {
    "label": "endEnumScalar()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "endEnumScalar()"
  },
  {
    "label": "beginBitSetScalar()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "beginBitSetScalar(bool &)"
  },
  {
    "label": "bitSetMatch()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "bitSetMatch(const char*, bool)"
  },
  {
    "label": "endBitSetScalar()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "endBitSetScalar()"
  },
  {
    "label": "scalarString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "scalarString(StringRef &, bool)"
  },
  {
    "label": "blockScalarString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "blockScalarString(StringRef &)"
  },
  {
    "label": "setError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setError(const Twine &)"
  },
  {
    "label": "enumCase()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "enumCase(T &Val, const char* Str, const T ConstVal)"
  },
  {
    "label": "enumCase()",
    "kind": "Method",
    "detail": "Function (Val = ConstVal ; } } template<T> void)",
    "insertText": "enumCase(T &Val, const char* Str, const uint32_t ConstVal)"
  },
  {
    "label": "enumFallback()",
    "kind": "Method",
    "detail": "Function (Val = ConstVal ; } } template<FBT,T> void)",
    "insertText": "enumFallback(T &Val)"
  },
  {
    "label": "Res()",
    "kind": "Method",
    "detail": "Function (FBT)",
    "insertText": "Res(uint64_t)"
  },
  {
    "label": "yamlize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "yamlize(*this, Res, true)"
  },
  {
    "label": "Val()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Val(uint64_t)"
  },
  {
    "label": "bitSetCase()",
    "kind": "Method",
    "detail": "Function (} } template<T> void)",
    "insertText": "bitSetCase(T &Val, const char* Str, const T ConstVal)"
  },
  {
    "label": "bitSetCase()",
    "kind": "Method",
    "detail": "Function (Val = Val | ConstVal ; } } template<T> void)",
    "insertText": "bitSetCase(T &Val, const char* Str, const uint32_t ConstVal)"
  },
  {
    "label": "maskedBitSetCase()",
    "kind": "Method",
    "detail": "Function (Val = Val | ConstVal ; } } template<T> void)",
    "insertText": "maskedBitSetCase(T &Val, const char *Str, T ConstVal, T Mask)"
  },
  {
    "label": "maskedBitSetCase()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "maskedBitSetCase(T &Val, const char *Str, uint32_t ConstVal, uint32_t Mask)"
  },
  {
    "label": "getContext()",
    "kind": "Method",
    "detail": "Function (} void*)",
    "insertText": "getContext()"
  },
  {
    "label": "setContext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setContext(void *)"
  },
  {
    "label": "mapRequired()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "mapRequired(const char* Key, T& Val)"
  },
  {
    "label": "processKey()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "processKey(Key, Val, true)"
  },
  {
    "label": "mapOptional()",
    "kind": "Method",
    "detail": "Function (} template<T> std::enable_if<has_SequenceTraits<T>::value,void>::type)",
    "insertText": "mapOptional(const char* Key, T& Val)"
  },
  {
    "label": "processKey()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "processKey(Key, Val, false)"
  },
  {
    "label": "mapOptional()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "mapOptional(const char* Key, Optional<T> &Val)"
  },
  {
    "label": "processKeyWithDefault()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "processKeyWithDefault(Key, Val, Optional<T>(), false)"
  },
  {
    "label": "mapOptional()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "mapOptional(const char* Key, T& Val, const T& Default)"
  },
  {
    "label": "processKeyWithDefault()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "processKeyWithDefault(Key, Val, Default, false)"
  },
  {
    "label": "processKeyWithDefault()",
    "kind": "Method",
    "detail": "Function (} private : template<T> void)",
    "insertText": "processKeyWithDefault(const char *Key, Optional<T> &Val, const Optional<T> &DefaultValue, bool Required)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(DefaultValue.hasValue() == false && \"Optional<T> shouldn't have a value!\")"
  },
  {
    "label": "outputting()",
    "kind": "Method",
    "detail": "Function (void* SaveInfo ; bool UseDefault ; const bool sameAsDefault =)",
    "insertText": "outputting() && !Val.hasValue()"
  },
  {
    "label": "yamlize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "yamlize(*this, Val.getValue(), Required)"
  },
  {
    "label": "postflightKey()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "postflightKey(SaveInfo)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(UseDefault)"
  },
  {
    "label": "processKeyWithDefault()",
    "kind": "Method",
    "detail": "Function (} } template<T> void)",
    "insertText": "processKeyWithDefault(const char *Key, T &Val, const T& DefaultValue, bool Required)"
  },
  {
    "label": "yamlize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "yamlize(*this, Val, Required)"
  },
  {
    "label": "processKey()",
    "kind": "Method",
    "detail": "Function (} } template<T> void)",
    "insertText": "processKey(const char *Key, T &Val, bool Required)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (void* SaveInfo ; bool UseDefault ;)",
    "insertText": "if(this->preflightKey(Key, Required, false, UseDefault, SaveInfo))"
  },
  {
    "label": "yamlize()",
    "kind": "Method",
    "detail": "Function (} } private : void* Ctxt ; } ; template<T> std::enable_if<has_ScalarEnumerationTraits<T>::value,void>::type)",
    "insertText": "yamlize(IO &io, T &Val, bool)"
  },
  {
    "label": "enumeration()",
    "kind": "Method",
    "detail": "Function (ScalarEnumerationTraits<T)",
    "insertText": "enumeration(io, Val)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool DoClear ;)",
    "insertText": "if(io.beginBitSetScalar(DoClear))"
  },
  {
    "label": "bitset()",
    "kind": "Method",
    "detail": "Function (ScalarBitSetTraits<T)",
    "insertText": "bitset(io, Val)"
  },
  {
    "label": "Buffer()",
    "kind": "Method",
    "detail": "Function (std::string Storage ; llvm::raw_string_ostream)",
    "insertText": "Buffer(Storage)"
  },
  {
    "label": "output()",
    "kind": "Method",
    "detail": "Function (ScalarTraits<T)",
    "insertText": "output(Val, io.getContext(), Buffer)"
  },
  {
    "label": "str()",
    "kind": "Method",
    "detail": "Function (StringRef Str = Buffer .)",
    "insertText": "str()"
  },
  {
    "label": "scalarString()",
    "kind": "Method",
    "detail": "Function (io .)",
    "insertText": "scalarString(Str, ScalarTraits<T>::mustQuote(Str))"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef Result = ScalarTraits<T)",
    "insertText": "input(Str, io.getContext(), Val)"
  },
  {
    "label": "setError()",
    "kind": "Method",
    "detail": "Function (io .)",
    "insertText": "setError(llvm::Twine(Result))"
  },
  {
    "label": "yamlize()",
    "kind": "Method",
    "detail": "Function (} } } template<T> std::enable_if<has_BlockScalarTraits<T>::value,void>::type)",
    "insertText": "yamlize(IO &YamlIO, T &Val, bool)"
  },
  {
    "label": "output()",
    "kind": "Method",
    "detail": "Function (BlockScalarTraits<T)",
    "insertText": "output(Val, YamlIO.getContext(), Buffer)"
  },
  {
    "label": "blockScalarString()",
    "kind": "Method",
    "detail": "Function (YamlIO .)",
    "insertText": "blockScalarString(Str)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef Result = BlockScalarTraits<T)",
    "insertText": "input(Str, YamlIO.getContext(), Val)"
  },
  {
    "label": "validate()",
    "kind": "Method",
    "detail": "Function (StringRef Err = MappingTraits<T)",
    "insertText": "validate(io, Val)"
  },
  {
    "label": "errs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "errs()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Err.empty() && \"invalid struct trying to be written as yaml\")"
  },
  {
    "label": "mapping()",
    "kind": "Method",
    "detail": "Function (} } MappingTraits<T)",
    "insertText": "mapping(io, Val)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(has_FlowTraits<MappingTraits<T>>::value) io.endFlowMapping()"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (char missing_yaml_trait_for_type [)",
    "insertText": "sizeof(MissingTrait<T>)"
  },
  {
    "label": "yamlize()",
    "kind": "Method",
    "detail": "Function (} template<T> std::enable_if<has_SequenceTraits<T>::value,void>::type)",
    "insertText": "yamlize(IO &io, T &Seq, bool)"
  },
  {
    "label": "outputting()",
    "kind": "Method",
    "detail": "Function (unsigned count = io .)",
    "insertText": "outputting() ? SequenceTraits<T>::size(io, Seq)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (void* SaveInfo ;)",
    "insertText": "if(io.preflightFlowElement(i, SaveInfo))"
  },
  {
    "label": "yamlize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "yamlize(io, SequenceTraits<T>::element(io, Seq, i), true)"
  },
  {
    "label": "postflightFlowElement()",
    "kind": "Method",
    "detail": "Function (io .)",
    "insertText": "postflightFlowElement(SaveInfo)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (void* SaveInfo ;)",
    "insertText": "if(io.preflightElement(i, SaveInfo))"
  },
  {
    "label": "postflightElement()",
    "kind": "Method",
    "detail": "Function (io .)",
    "insertText": "postflightElement(SaveInfo)"
  },
  {
    "label": "output()",
    "kind": "Method",
    "detail": "Function (} } template<> struct ScalarTraits<bool> { void)",
    "insertText": "output(const bool &, void*, llvm::raw_ostream &)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "input(StringRef, void*, bool &)"
  },
  {
    "label": "mustQuote()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "mustQuote(StringRef)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "input(StringRef, void*, StringRef &)"
  },
  {
    "label": "mustQuote()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "mustQuote(StringRef S)"
  },
  {
    "label": "output()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct ScalarTraits<std::string> { void)",
    "insertText": "output(const std::string &, void*, llvm::raw_ostream &)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "input(StringRef, void*, std::string &)"
  },
  {
    "label": "output()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct ScalarTraits<uint8_t> { void)",
    "insertText": "output(const uint8_t &, void*, llvm::raw_ostream &)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "input(StringRef, void*, uint8_t &)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "input(StringRef, void*, uint16_t &)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "input(StringRef, void*, uint32_t &)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "input(StringRef, void*, uint64_t &)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "input(StringRef, void*, int8_t &)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "input(StringRef, void*, int16_t &)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "input(StringRef, void*, int32_t &)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "input(StringRef, void*, int64_t &)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "input(StringRef, void*, float &)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "input(StringRef, void*, double &)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (BufPtr =)",
    "insertText": "new(&Buffer) TNorm(io, Obj)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (} else { BufPtr =)",
    "insertText": "new(&Buffer) TNorm(io)"
  },
  {
    "label": "MappingNormalization()",
    "kind": "Method",
    "detail": "Function (} } ~)",
    "insertText": "MappingNormalization()"
  },
  {
    "label": "denormalize()",
    "kind": "Method",
    "detail": "Function (Result = BufPtr ->)",
    "insertText": "denormalize(io)"
  },
  {
    "label": "TNorm()",
    "kind": "Method",
    "detail": "Function (} BufPtr -> ~)",
    "insertText": "TNorm()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TNorm*)",
    "insertText": "operator()"
  },
  {
    "label": "TNorm()",
    "kind": "Method",
    "detail": "Function (} else { BufPtr = new)",
    "insertText": "TNorm(io)"
  },
  {
    "label": "MappingNormalizationHeap()",
    "kind": "Method",
    "detail": "Function (} } ~)",
    "insertText": "MappingNormalizationHeap()"
  },
  {
    "label": "Input()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "Input()"
  },
  {
    "label": "error()",
    "kind": "Method",
    "detail": "Function (std::error_code)",
    "insertText": "error()"
  },
  {
    "label": "mapTag()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "mapTag(StringRef, bool)"
  },
  {
    "label": "preflightKey()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "preflightKey(const char *, bool, bool, bool &, void *&)"
  },
  {
    "label": "postflightKey()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "postflightKey(void *)"
  },
  {
    "label": "preflightElement()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "preflightElement(unsigned index, void *&)"
  },
  {
    "label": "postflightElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "postflightElement(void *)"
  },
  {
    "label": "preflightFlowElement()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "preflightFlowElement(unsigned , void *&)"
  },
  {
    "label": "postflightFlowElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "postflightFlowElement(void *)"
  },
  {
    "label": "bitSetMatch()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "bitSetMatch(const char *, bool)"
  },
  {
    "label": "setError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setError(const Twine &message)"
  },
  {
    "label": "anchor()",
    "kind": "Method",
    "detail": "Function (class HNode { void)",
    "insertText": "anchor()"
  },
  {
    "label": "HNode()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "HNode(Node *n) : _node(n)"
  },
  {
    "label": "HNode()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "HNode()"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "classof(const HNode *)"
  },
  {
    "label": "EmptyHNode()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "EmptyHNode(Node *n) : HNode(n)"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "classof(const HNode *n)"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "classof(const EmptyHNode *)"
  },
  {
    "label": "ScalarHNode()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "ScalarHNode(Node *n, StringRef s) : HNode(n), _value(s)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} StringRef)",
    "insertText": "value()"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "classof(const ScalarHNode *)"
  },
  {
    "label": "MapHNode()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "MapHNode(Node *n) : HNode(n)"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "classof(const MapHNode *)"
  },
  {
    "label": "SequenceHNode()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "SequenceHNode(Node *n) : HNode(n)"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "classof(const SequenceHNode *)"
  },
  {
    "label": "setError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setError(HNode *hnode, const Twine &message)"
  },
  {
    "label": "setError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setError(Node *node, const Twine &message)"
  },
  {
    "label": "setCurrentDocument()",
    "kind": "Method",
    "detail": "Function (public : bool)",
    "insertText": "setCurrentDocument()"
  },
  {
    "label": "nextDocument()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "nextDocument()"
  },
  {
    "label": "getCurrentNode()",
    "kind": "Method",
    "detail": "Function (const Node*)",
    "insertText": "getCurrentNode()"
  },
  {
    "label": "Output()",
    "kind": "Method",
    "detail": "Function (private : llvm::SourceMgr SrcMgr ; std::unique_ptr<llvm::yaml::Stream> Strm ; std::unique_ptr<HNode> TopNode ; std::error_code EC ; llvm::BumpPtrAllocator StringAllocator ; llvm::yaml::document_iterator DocIterator ; std::vector<bool> BitValuesUsed ; HNode* CurrentNode ; bool ScalarMatchFound ; } ; class Output : public IO { public :)",
    "insertText": "Output(llvm::raw_ostream &, void *Ctxt = nullptr, int WrapColumn = 70)"
  },
  {
    "label": "Output()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "Output()"
  },
  {
    "label": "preflightKey()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "preflightKey(const char *key, bool, bool, bool &, void *&)"
  },
  {
    "label": "beginDocuments()",
    "kind": "Method",
    "detail": "Function (public : void)",
    "insertText": "beginDocuments()"
  },
  {
    "label": "preflightDocument()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "preflightDocument(unsigned)"
  },
  {
    "label": "postflightDocument()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "postflightDocument()"
  },
  {
    "label": "endDocuments()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "endDocuments()"
  },
  {
    "label": "output()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "output(StringRef s)"
  },
  {
    "label": "outputUpToEndOfLine()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "outputUpToEndOfLine(StringRef s)"
  },
  {
    "label": "newLineCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "newLineCheck()"
  },
  {
    "label": "outputNewLine()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "outputNewLine()"
  },
  {
    "label": "paddedKey()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "paddedKey(StringRef key)"
  },
  {
    "label": "flowKey()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "flowKey(StringRef Key)"
  },
  {
    "label": "LLVM_YAML_STRONG_TYPEDEF()",
    "kind": "Method",
    "detail": "Function (enum InState { inSeq,inFlowSeq,inMapFirstKey,inMapOtherKey,inFlowMapFirstKey,inFlowMapOtherKey } ; llvm::raw_ostream& Out ; int WrapColumn ; SmallVector<InState,8> StateStack ; int Column ; int ColumnAtFlowStart ; int ColumnAtMapFlowStart ; bool NeedBitValueComma ; bool NeedFlowSequenceComma ; bool EnumerationMatchFound ; bool NeedsNewLine ; } ; # define)",
    "insertText": "LLVM_YAML_STRONG_TYPEDEF(_base, _type)"
  },
  {
    "label": "_type()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "_type()"
  },
  {
    "label": "_type()",
    "kind": "Method",
    "detail": "Function (} \\)",
    "insertText": "_type(const _base v) : value(v)"
  },
  {
    "label": "_type()",
    "kind": "Method",
    "detail": "Function (} \\)",
    "insertText": "_type(const _type &v) : value(v.value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} \\ _type&)",
    "insertText": "operator(const _type &rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (value = rhs . value ; return* this ; } \\ _type&)",
    "insertText": "operator(const _base &rhs)"
  },
  {
    "label": "_base()",
    "kind": "Method",
    "detail": "Function (value = rhs ; return* this ; } \\ operator const)",
    "insertText": "_base()"
  },
  {
    "label": "output()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "output(const Hex8 &, void*, llvm::raw_ostream &)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "input(StringRef, void*, Hex8 &)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "input(StringRef, void*, Hex16 &)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "input(StringRef, void*, Hex32 &)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "input(StringRef, void*, Hex64 &)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int i = 0 ;)",
    "insertText": "while(yin.setCurrentDocument())"
  },
  {
    "label": "yamlize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "yamlize(yin, DocumentListTraits<T>::element(yin, docList, i), true)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (+ + i ; } return yin ; } template<T> std::enable_if<has_MappingTraits<T>::value,Input&>::type)",
    "insertText": "operator(Input &yin, T &docMap)"
  },
  {
    "label": "yamlize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "yamlize(yin, docMap, true)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (const size_t count = DocumentListTraits<T)",
    "insertText": "size(yout, docList)"
  },
  {
    "label": "yamlize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "yamlize(yout, DocumentListTraits<T>::element(yout, docList, i), true)"
  },
  {
    "label": "yamlize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "yamlize(yout, map, true)"
  },
  {
    "label": "yamlize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "yamlize(yout, seq, true)"
  },
  {
    "label": "yamlize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "yamlize(Out, Val, true)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (\\ namespace yaml { \\ template<> \\ struct SequenceTraits<std::vector<_type>> { \\ size_t)",
    "insertText": "size(IO &io, std::vector<_type> &seq)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (\\ return seq .)",
    "insertText": "size()"
  },
  {
    "label": "element()",
    "kind": "Method",
    "detail": "Function (\\ } \\ _type&)",
    "insertText": "element(IO &io, std::vector<_type> &seq, size_t index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(index >= seq.size() ) \\ seq.resize(index+1)"
  },
  {
    "label": "LLVM_YAML_IS_FLOW_SEQUENCE_VECTOR()",
    "kind": "Method",
    "detail": "Function (\\ return seq [ index ] ; \\ } \\ } ; \\ } \\ } # define)",
    "insertText": "LLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(_type)"
  },
  {
    "label": "LLVM_YAML_IS_DOCUMENT_LIST_VECTOR()",
    "kind": "Method",
    "detail": "Function (\\ return seq [ index ] ; \\ } \\ const bool flow = true ; \\ } ; \\ } \\ } # define)",
    "insertText": "LLVM_YAML_IS_DOCUMENT_LIST_VECTOR(_type)"
  }
]