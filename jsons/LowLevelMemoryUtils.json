[
  {
    "label": "FLLMArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLLMArray"
  },
  {
    "label": "LLMMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LLMMap"
  },
  {
    "label": "Values",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Values"
  },
  {
    "label": "FBaseIterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBaseIterator"
  },
  {
    "label": "FIterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FIterator"
  },
  {
    "label": "FTuple",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTuple"
  },
  {
    "label": "ThisType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ThisType"
  },
  {
    "label": "FConstIterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FConstIterator"
  },
  {
    "label": "FConstTuple",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FConstTuple"
  },
  {
    "label": "StripeData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StripeData"
  },
  {
    "label": "PointerKey",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PointerKey"
  },
  {
    "label": "TSizedLLMAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSizedLLMAllocator"
  },
  {
    "label": "ForAnyElementType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ForAnyElementType"
  },
  {
    "label": "ForElementType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ForElementType"
  },
  {
    "label": "FDefaultBitArrayLLMAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDefaultBitArrayLLMAllocator"
  },
  {
    "label": "FDefaultSparseArrayLLMAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDefaultSparseArrayLLMAllocator"
  },
  {
    "label": "FDefaultSetLLMAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDefaultSetLLMAllocator"
  },
  {
    "label": "TFastPointerSetKeyFuncs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TFastPointerSetKeyFuncs"
  },
  {
    "label": "TFastPointerMapKeyFuncs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TFastPointerMapKeyFuncs"
  },
  {
    "label": "TFastPointerLLMMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TFastPointerLLMMap"
  },
  {
    "label": "TFastPointerLLMSet",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TFastPointerLLMSet"
  },
  {
    "label": "ETopologicalSortOrder",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ETopologicalSortOrder"
  },
  {
    "label": "FVisitData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FVisitData"
  },
  {
    "label": "LLM_PAGE_SIZE()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" HAL / LowLevelMemTracker . h \" # if ENABLE_LOW_LEVEL_MEM_TRACKER # include \" Algo / BinarySearch . h \" # include \" Containers / ContainerAllocationPolicies . h \" # include \" Containers / Map . h \" # include \" Containers / Set . h \" # include \" Math / NumericLimits . h \" # include \" Misc / ScopeLock . h \" # include \" Templates / Tuple . h \" # include<type_traits> # define)",
    "insertText": "LLM_PAGE_SIZE(16*1024)"
  },
  {
    "label": "FLLMArray()",
    "kind": "Method",
    "detail": "Function (# else typedef uint32 LLMNumAllocsType ; # endif template<T,SizeType = int32> class FLLMArray { public :)",
    "insertText": "FLLMArray() : Array(StaticArray) , Count(0) , Capacity(StaticArrayCapacity) , Allocator(nullptr)"
  },
  {
    "label": "FLLMArray()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FLLMArray()"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Clear(true)"
  },
  {
    "label": "SetAllocator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetAllocator(UE::LLMPrivate::FLLMAllocator* InAllocator)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (Allocator = InAllocator ; } SizeType)",
    "insertText": "Num()"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (Allocator ->)",
    "insertText": "Free(Array, Capacity * sizeof(T))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Array = StaticArray ; } Capacity = StaticArrayCapacity ; } Count = 0 ; } void)",
    "insertText": "Add(const T& Item)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (SizeType NewCapacity = DefaultCapacity ;)",
    "insertText": "if(Capacity)"
  },
  {
    "label": "Capacity()",
    "kind": "Method",
    "detail": "Function (NewCapacity =)",
    "insertText": "Capacity(Capacity / 2)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Reserve(NewCapacity)"
  },
  {
    "label": "RemoveLast()",
    "kind": "Method",
    "detail": "Function (} Array [ Count ] = Item ; + + Count ; } T)",
    "insertText": "RemoveLast()"
  },
  {
    "label": "LLMCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LLMCheck(Count > 0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (- - Count ; T Last = Array [ Count ] ; return Last ; } T&)",
    "insertText": "operator(SizeType Index)"
  },
  {
    "label": "LLMCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LLMCheck(Index >= 0 && Index < Count)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(StaticArray, Array, Count * sizeof(T))"
  },
  {
    "label": "AlignArbitrary()",
    "kind": "Method",
    "detail": "Function (Array = StaticArray ; Capacity = StaticArrayCapacity ; } } else { NewCapacity =)",
    "insertText": "AlignArbitrary(NewCapacity, ItemsPerPage)"
  },
  {
    "label": "NewArray()",
    "kind": "Method",
    "detail": "Function (T*)",
    "insertText": "NewArray(T*)Allocator->Alloc(NewCapacity * sizeof(T))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(NewArray, Array, Count * sizeof(T))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Array != StaticArray)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Array = NewArray ; Capacity = NewCapacity ; } } void)",
    "insertText": "operator(const FLLMArray<T>& Other)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Clear()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reserve(Other.Count)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(Array, Other.Array, Other.Count * sizeof(T))"
  },
  {
    "label": "Trim()",
    "kind": "Method",
    "detail": "Function (Count = Other . Count ; } void)",
    "insertText": "Trim()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reserve(Count)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} } private : T* Array ; SizeType Count ; SizeType Capacity ; UE::LLMPrivate::FLLMAllocator* Allocator ; const int StaticArrayCapacity = 6 4 ; T StaticArray [ StaticArrayCapacity ] ; const int ItemsPerPage = LLM_PAGE_SIZE /)",
    "insertText": "sizeof(T)"
  },
  {
    "label": "LLMMap()",
    "kind": "Method",
    "detail": "Function (const int DefaultCapacity = ItemsPerPage ; } ; template<TKey,TValue1,TValue2,SizeType = int32> class LLMMap { public : typedef LLMMap<TKey,TValue1,TValue2,SizeType> ThisType ; struct Values { TKey Key ; TValue1 Value1 ; TValue2 Value2 ; } ;)",
    "insertText": "LLMMap() : bAllStripesLocked(false)"
  },
  {
    "label": "LLMMap()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "LLMMap()"
  },
  {
    "label": "SetAllocator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetAllocator(UE::LLMPrivate::FLLMAllocator* InAllocator, SizeType InDefaultCapacity = DefaultCapacity)"
  },
  {
    "label": "SetAllocator()",
    "kind": "Method",
    "detail": "Function (Stripe . Allocator = InAllocator ; Stripe . Keys .)",
    "insertText": "SetAllocator(InAllocator)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Stripe .)",
    "insertText": "Reserve(InDefaultCapacity / StripeCount)"
  },
  {
    "label": "AllocationScopeLock()",
    "kind": "Method",
    "detail": "Function (FScopeLock)",
    "insertText": "AllocationScopeLock(&Stripe.CriticalSection)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (Stripe . Allocator ->)",
    "insertText": "Free(Stripe.Map, Stripe.Capacity * sizeof(SizeType))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Stripe . Map = NULL ; Stripe . Count = 0 ; Stripe . Capacity = 0 ; } } void)",
    "insertText": "Add(const TKey& Key, const TValue1& Value1, const TValue2& Value2)"
  },
  {
    "label": "GetHashCode()",
    "kind": "Method",
    "detail": "Function (SizeType KeyHash = Key .)",
    "insertText": "GetHashCode()"
  },
  {
    "label": "GetStripeIndex()",
    "kind": "Method",
    "detail": "Function (StripeData& Stripe = MapStripes [)",
    "insertText": "GetStripeIndex(KeyHash)"
  },
  {
    "label": "LLMCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LLMCheck(Stripe.Map)"
  },
  {
    "label": "GetMapIndex()",
    "kind": "Method",
    "detail": "Function (SizeType MapIndex = Stripe .)",
    "insertText": "GetMapIndex(Key, KeyHash)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (SizeType KeyIndex = Stripe . Map [ MapIndex ] ;)",
    "insertText": "if(KeyIndex != InvalidIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool ShownWarning = false ;)",
    "insertText": "if(!ShownWarning)"
  },
  {
    "label": "LowLevelOutputDebugString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LowLevelOutputDebugString(TEXT(\"LLM WARNING: Replacing allocation in tracking map. Alloc/Free Mismatch.\\n\"))"
  },
  {
    "label": "MaxCount()",
    "kind": "Method",
    "detail": "Function (ShownWarning = true ; } Stripe . Values1 [ KeyIndex ] = Value1 ; Stripe . Values2 [ KeyIndex ] = Value2 ; } else { SizeType)",
    "insertText": "MaxCount(Stripe.Capacity >= 256U * 256U ? (Stripe.Capacity / 256U) * Margin : (Margin * Stripe.Capacity) / 256U)"
  },
  {
    "label": "LowLevelOutputDebugString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LowLevelOutputDebugString(TEXT(\"LLM Error: Integer overflow in LLMap::Add, Capacity has reached its maximum size.\\n\"))"
  },
  {
    "label": "PLATFORM_BREAK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PLATFORM_BREAK()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Stripe.Count > MaxCount)"
  },
  {
    "label": "LowLevelOutputDebugString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LowLevelOutputDebugString(TEXT(\"LLM Assertion failure: Count > MaxCount.\\n\"))"
  },
  {
    "label": "Grow()",
    "kind": "Method",
    "detail": "Function (} Stripe .)",
    "insertText": "Grow()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Stripe.FreeKeyIndices.Num())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Stripe . Keys .)",
    "insertText": "Add(Key)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Stripe . KeyHashes .)",
    "insertText": "Add(KeyHash)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Stripe . Values1 .)",
    "insertText": "Add(Value1)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Stripe . Values2 .)",
    "insertText": "Add(Value2)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (} + + Stripe . Count ; } } Values)",
    "insertText": "GetValue(const TKey& Key)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (Values RetValues ; RetValues . Key =)",
    "insertText": "Find(Key, RetValues.Value1, RetValues.Value2)"
  },
  {
    "label": "LLMEnsure()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LLMEnsure(RetValues.Key)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (SizeType KeyIndex = Stripe . Map [ MapIndex ] ;)",
    "insertText": "if(KeyIndex == InvalidIndex)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} OutValue1 = Stripe . Values1 [ KeyIndex ] ; OutValue2 = Stripe . Values2 [ KeyIndex ] ; return Stripe . Keys [ KeyIndex ] ; } bool)",
    "insertText": "Remove(const TKey& Key, Values& OutValues)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} else { Stripe . FreeKeyIndices .)",
    "insertText": "Add(KeyIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} SizeType IndexIter = MapIndex ; SizeType FirstIndex = MapIndex ;)",
    "insertText": "if(!IndexIter)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (IndexIter = Stripe . Capacity ; } - - IndexIter ;)",
    "insertText": "while(Stripe.IsItemInUse(IndexIter))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (IndexIter = Stripe . Capacity ; } - - IndexIter ; } bool Found = false ;)",
    "insertText": "for(;;)"
  },
  {
    "label": "IndexIter2()",
    "kind": "Method",
    "detail": "Function (SizeType)",
    "insertText": "IndexIter2(MapIndex + 1) & (Stripe.Capacity - 1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (SizeType SwapIndex = InvalidIndex ;)",
    "insertText": "while(Stripe.IsItemInUse(IndexIter2))"
  },
  {
    "label": "SearchHashCode()",
    "kind": "Method",
    "detail": "Function (SizeType SearchKeyIndex = Stripe . Map [ IndexIter2 ] ; const SizeType SearchHashCode = Stripe . KeyHashes [ SearchKeyIndex ] ; const SizeType SearchInsertIndex =)",
    "insertText": "SearchHashCode(Stripe.Capacity - 1)"
  },
  {
    "label": "IndexIter2()",
    "kind": "Method",
    "detail": "Function (SwapIndex = IndexIter2 ; Found = true ; })",
    "insertText": "IndexIter2(IndexIter2 + 1) & (Stripe.Capacity - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Found)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (SizeType TotalCount = 0 ;)",
    "insertText": "for(StripeData& Stripe : MapStripes)"
  },
  {
    "label": "HasKey()",
    "kind": "Method",
    "detail": "Function (TotalCount + = Stripe . Count ; } return TotalCount ; } bool)",
    "insertText": "HasKey(const TKey& Key)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } struct FBaseIterator { public : FBaseIterator&)",
    "insertText": "operator()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (+ + MapIndex ;)",
    "insertText": "while(StripeIndex < StripeCount)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (StripeData& Stripe = MapRef . MapStripes [ StripeIndex ] ;)",
    "insertText": "while(MapIndex < Stripe.Capacity)"
  },
  {
    "label": "MapIndex()",
    "kind": "Method",
    "detail": "Function (StripeIndex = StripeCount ; MapIndex = 0 ; } else { StripeIndex = 0 ;)",
    "insertText": "MapIndex(*this)"
  },
  {
    "label": "FTuple()",
    "kind": "Method",
    "detail": "Function (} } ThisType& MapRef ; int32 StripeIndex ; SizeType MapIndex ; } ; struct FIterator ; struct FTuple { const TKey& Key ; TValue1& Value1 ; TValue2& Value2 ; private :)",
    "insertText": "FTuple(const TKey& InKey, TValue1& InValue1, TValue2& InValue2) :Key(InKey), Value1(InValue1), Value2(InValue2)"
  },
  {
    "label": "FIterator()",
    "kind": "Method",
    "detail": "Function (} struct ThisType::FIterator ; } ; struct FIterator : public FBaseIterator {)",
    "insertText": "FIterator(ThisType& InMap, bool bEnd) : FBaseIterator(InMap, bEnd)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FIterator& Other)"
  },
  {
    "label": "FTuple()",
    "kind": "Method",
    "detail": "Function (ThisType& LocalMap = FBaseIterator::MapRef ; StripeData& Stripe = LocalMap . MapStripes [ FBaseIterator::StripeIndex ] ; SizeType KeyIndex = Stripe . Map [ FBaseIterator::MapIndex ] ; return)",
    "insertText": "FTuple(Stripe.Keys[KeyIndex], Stripe.Values1[KeyIndex], Stripe.Values2[KeyIndex])"
  },
  {
    "label": "FConstTuple()",
    "kind": "Method",
    "detail": "Function (} } ; struct FConstIterator ; struct FConstTuple { const TKey& Key ; const TValue1& Value1 ; const TValue2& Value2 ; private :)",
    "insertText": "FConstTuple(const TKey& InKey, const TValue1& InValue1, const TValue2& InValue2) :Key(InKey), Value1(InValue1), Value2(InValue2)"
  },
  {
    "label": "FConstIterator()",
    "kind": "Method",
    "detail": "Function (} struct ThisType::FConstIterator ; } ; struct FConstIterator : public FBaseIterator {)",
    "insertText": "FConstIterator(const ThisType& InMap, bool bEnd) : FBaseIterator(const_cast<ThisType&>(InMap), bEnd)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FConstIterator& Other)"
  },
  {
    "label": "FConstTuple()",
    "kind": "Method",
    "detail": "Function (ThisType& LocalMap = FBaseIterator::MapRef ; StripeData& Stripe = LocalMap . MapStripes [ FBaseIterator::StripeIndex ] ; SizeType KeyIndex = Stripe . Map [ FBaseIterator::MapIndex ] ; return)",
    "insertText": "FConstTuple(Stripe.Keys[KeyIndex], Stripe.Values1[KeyIndex], Stripe.Values2[KeyIndex])"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} } ; FIterator)",
    "insertText": "begin()"
  },
  {
    "label": "LLMCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LLMCheck(bAllStripesLocked)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} FIterator)",
    "insertText": "end()"
  },
  {
    "label": "LockAll()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "LockAll()"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (AllStripesLock .)",
    "insertText": "Lock()"
  },
  {
    "label": "LLMCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LLMCheck(bAllStripesLocked == false)"
  },
  {
    "label": "UnlockAll()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "UnlockAll()"
  },
  {
    "label": "Unlock()",
    "kind": "Method",
    "detail": "Function (Stripe . CriticalSection .)",
    "insertText": "Unlock()"
  },
  {
    "label": "LLMCheck()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "LLMCheck(bAllStripesLocked == true)"
  },
  {
    "label": "Margin()",
    "kind": "Method",
    "detail": "Function (} private : const int32 StripeCountLog2 = 4 ; enum { StripeCount = 1<<StripeCountLog2 } ; enum { DefaultCapacity = 1 0 2 4* 1 0 2 4 } ; enum { InvalidIndex = - 1 } ; const SizeType)",
    "insertText": "Margin(30 * 256)"
  },
  {
    "label": "GetStripeIndex()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetStripeIndex(uint32 KeyHash)"
  },
  {
    "label": "GetStripeIndex()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetStripeIndex(uint64 KeyHash)"
  },
  {
    "label": "StripeData()",
    "kind": "Method",
    "detail": "Function (} struct StripeData {)",
    "insertText": "StripeData() : Allocator(nullptr) , Map(nullptr) , Count(0) , Capacity(0) #ifdef PROFILE_LLMMAP , IterAcc(0) , IterCount(0)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reserve(SizeType NewCapacity)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (NewCapacity =)",
    "insertText": "Max(NewCapacity, (SizeType)1)"
  },
  {
    "label": "SizeType()",
    "kind": "Method",
    "detail": "Function (NewCapacity = static_cast<)",
    "insertText": "SizeType(FPlatformMath::RoundUpToPowerOfTwo64(static_cast<uint64>(NewCapacity)))"
  },
  {
    "label": "LLMCheck()",
    "kind": "Method",
    "detail": "Function (SizeType* OldMap = Map ; SizeType OldCapacity = Capacity ;)",
    "insertText": "LLMCheck(NewCapacity > OldCapacity)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (Capacity = NewCapacity ;)",
    "insertText": "Map(SizeType*)Allocator->Alloc(NewCapacity * sizeof(SizeType))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (SizeType* OldItem = OldMap ;)",
    "insertText": "for(SizeType Index = 0; Index < OldCapacity; ++Index, ++OldItem)"
  },
  {
    "label": "GetMapIndex()",
    "kind": "Method",
    "detail": "Function (SizeType MapIndex =)",
    "insertText": "GetMapIndex(Keys[KeyIndex], KeyHashes[KeyIndex])"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (Map [ MapIndex ] = KeyIndex ; } } Allocator ->)",
    "insertText": "Free(OldMap, OldCapacity * sizeof(SizeType))"
  },
  {
    "label": "IsItemInUse()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsItemInUse(SizeType MapIndex)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (SizeType Mask = Capacity - 1 ; SizeType MapIndex = Hash& Mask ; SizeType KeyIndex = Map [ MapIndex ] ;)",
    "insertText": "while(KeyIndex != InvalidIndex && !(Keys[KeyIndex] == Key))"
  },
  {
    "label": "MapIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MapIndex(MapIndex + 1)"
  },
  {
    "label": "IterAcc()",
    "kind": "Method",
    "detail": "Function (KeyIndex = Map [ MapIndex ] ; # ifdef PROFILE_LLMMAP + + IterAcc ; # endif } # ifdef PROFILE_LLMMAP + + IterCount ; double Average =)",
    "insertText": "IterAcc(double)"
  },
  {
    "label": "Seconds()",
    "kind": "Method",
    "detail": "Function (double LastWriteTime = 0 . 0 ; double Now =)",
    "insertText": "Seconds()"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (LastWriteTime = Now ;)",
    "insertText": "UE_LOG(LogStats, Log, TEXT(\"WARNING: LLMMap average: %f\\n\"), (float)Average)"
  },
  {
    "label": "InRange()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "InRange(const SizeType Index, const SizeType StartIndex, const SizeType EndIndex)"
  },
  {
    "label": "PointerKey()",
    "kind": "Method",
    "detail": "Function (} FCriticalSection CriticalSection ; UE::LLMPrivate::FLLMAllocator* Allocator ; SizeType* Map ; SizeType Count ; SizeType Capacity ; FLLMArray<TKey,SizeType> Keys ; FLLMArray<SizeType,SizeType> KeyHashes ; FLLMArray<TValue1,SizeType> Values1 ; FLLMArray<TValue2,SizeType> Values2 ; FLLMArray<SizeType,SizeType> FreeKeyIndices ; # ifdef PROFILE_LLMMAP int64 IterAcc ; int64 IterCount ; # endif } ; StripeData MapStripes [ StripeCount ] ; FCriticalSection AllStripesLock ; std::atomic_bool bAllStripesLocked ; } ; struct PointerKey {)",
    "insertText": "PointerKey()"
  },
  {
    "label": "PointerKey()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PointerKey(const void* InPointer, uint16 ExtraData=0) : Pointer((UPTRINT(InPointer) << 16) | UPTRINT(ExtraData))"
  },
  {
    "label": "LLMEnsure()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LLMEnsure(UPTRINT(InPointer) && UPTRINT(InPointer) <= 0x0000'ffff'ffff'ffff)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const PointerKey& other)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "GetExtraData()",
    "kind": "Method",
    "detail": "Function (} ; uint64)",
    "insertText": "GetExtraData()"
  },
  {
    "label": "GetHashCodeImpl()",
    "kind": "Method",
    "detail": "Function (} private : UPTRINT Pointer = 0 ; template<int HashSize,int PointerSize> LLMNumAllocsType)",
    "insertText": "GetHashCodeImpl()"
  },
  {
    "label": "Key()",
    "kind": "Method",
    "detail": "Function (uint64)",
    "insertText": "Key(uint64)GetPointer()"
  },
  {
    "label": "Key()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Key(~Key) + (Key << 21)"
  },
  {
    "label": "Key()",
    "kind": "Method",
    "detail": "Function (Key =)",
    "insertText": "Key(Key >> 24)"
  },
  {
    "label": "Key()",
    "kind": "Method",
    "detail": "Function (Key = Key* 2 6 5 ; Key =)",
    "insertText": "Key(Key >> 14)"
  },
  {
    "label": "Key()",
    "kind": "Method",
    "detail": "Function (Key = Key* 2 1 ; Key =)",
    "insertText": "Key(Key >> 28)"
  },
  {
    "label": "Key()",
    "kind": "Method",
    "detail": "Function (Key =)",
    "insertText": "Key(Key << 31)"
  },
  {
    "label": "Key()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Key(~Key) + (Key << 18)"
  },
  {
    "label": "Key()",
    "kind": "Method",
    "detail": "Function (Key =)",
    "insertText": "Key(Key >> 31)"
  },
  {
    "label": "Key()",
    "kind": "Method",
    "detail": "Function (Key = Key* 2 1 ; Key =)",
    "insertText": "Key(Key >> 11)"
  },
  {
    "label": "Key()",
    "kind": "Method",
    "detail": "Function (Key =)",
    "insertText": "Key(Key << 6)"
  },
  {
    "label": "Key()",
    "kind": "Method",
    "detail": "Function (Key =)",
    "insertText": "Key(Key >> 22)"
  },
  {
    "label": "OnInvalidLLMAllocatorNum()",
    "kind": "Method",
    "detail": "Function (} } ; namespace UE::Core::Private { [ [ noreturn ] ] void)",
    "insertText": "OnInvalidLLMAllocatorNum(int32 IndexSize, int64 NewNum, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "ForAnyElementType()",
    "kind": "Method",
    "detail": "Function (} template<int IndexSize> class TSizedLLMAllocator { public : using SizeType = TBitsToSizeType<IndexSize>::Type ; private : using USizeType = std::make_unsigned_t<SizeType> ; public : enum { NeedsElementType = false } ; enum { RequireRangeCheck = true } ; class ForAnyElementType { template<int> class TSizedLLMAllocator ; public :)",
    "insertText": "ForAnyElementType() : Data(nullptr) , Size(0)"
  },
  {
    "label": "MoveToEmptyFromOtherAllocator()",
    "kind": "Method",
    "detail": "Function (} template<OtherAllocator> void)",
    "insertText": "MoveToEmptyFromOtherAllocator(typename OtherAllocator::ForAnyElementType& Other)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (UE::LLMPrivate::)",
    "insertText": "Get()->Free(Data, Size)"
  },
  {
    "label": "MoveToEmpty()",
    "kind": "Method",
    "detail": "Function (} Data = Other . Data ; Size = Other . Size ; Other . Data = nullptr ; Other . Size = 0 ; } void)",
    "insertText": "MoveToEmpty(ForAnyElementType& Other)"
  },
  {
    "label": "TSizedLLMAllocator()",
    "kind": "Method",
    "detail": "Function (this -> MoveToEmptyFromOtherAllocator<)",
    "insertText": "TSizedLLMAllocator(Other)"
  },
  {
    "label": "ForAnyElementType()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ForAnyElementType()"
  },
  {
    "label": "GetAllocation()",
    "kind": "Method",
    "detail": "Function (} } void*)",
    "insertText": "GetAllocation()"
  },
  {
    "label": "NumBytesPerElement()",
    "kind": "Method",
    "detail": "Function (bool bInvalidResize = NewMax<0 | | NumBytesPerElement<1 | |)",
    "insertText": "NumBytesPerElement(SIZE_T)"
  },
  {
    "label": "bInvalidResize()",
    "kind": "Method",
    "detail": "Function (bInvalidResize =)",
    "insertText": "bInvalidResize(SIZE_T)(USizeType)NewMax > (SIZE_T)TNumericLimits<SizeType>::Max()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(UNLIKELY(bInvalidResize))"
  },
  {
    "label": "OnInvalidLLMAllocatorNum()",
    "kind": "Method",
    "detail": "Function (UE::Core::)",
    "insertText": "OnInvalidLLMAllocatorNum(IndexSize, NewMax, NumBytesPerElement)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} size_t NewSize = NewMax* NumBytesPerElement ; Data = UE::LLMPrivate::)",
    "insertText": "Get()->Realloc(Data, Size, NewSize)"
  },
  {
    "label": "CalculateSlackReserve()",
    "kind": "Method",
    "detail": "Function (Size = NewSize ; } } SizeType)",
    "insertText": "CalculateSlackReserve(SizeType NewMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "CalculateSlackShrink()",
    "kind": "Method",
    "detail": "Function (} SizeType)",
    "insertText": "CalculateSlackShrink(SizeType NewMax, SizeType CurrentMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "CalculateSlackGrow()",
    "kind": "Method",
    "detail": "Function (} SizeType)",
    "insertText": "CalculateSlackGrow(SizeType NewMax, SizeType CurrentMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (} SIZE_T)",
    "insertText": "GetAllocatedSize(SizeType CurrentMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "ForElementType()",
    "kind": "Method",
    "detail": "Function (void* Data ; size_t Size ; } ; template<ElementType> class ForElementType : public ForAnyElementType { public :)",
    "insertText": "ForElementType()"
  },
  {
    "label": "ResizeAllocation()",
    "kind": "Method",
    "detail": "Function (} } ; } ; template FORCENOINLINE void TSizedLLMAllocator<3 2>::)",
    "insertText": "ResizeAllocation(SizeType CurrentNum, SizeType NewMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "GetKeyHash()",
    "kind": "Method",
    "detail": "Function (using FDefaultLLMAllocator = TSizedLLMAllocator<3 2> ; using FDefaultLLMAllocator64 = TSizedLLMAllocator<6 4> ; class FDefaultBitArrayLLMAllocator : public TInlineAllocator<4,FDefaultLLMAllocator> { public : typedef TInlineAllocator<4,FDefaultLLMAllocator> Typedef ; } ; class FDefaultSparseArrayLLMAllocator : public TSparseArrayAllocator<FDefaultLLMAllocator,FDefaultBitArrayLLMAllocator> { public : typedef TSparseArrayAllocator<FDefaultLLMAllocator,FDefaultBitArrayLLMAllocator> Typedef ; } ; class FDefaultSetLLMAllocator : public TSetAllocator<FDefaultSparseArrayLLMAllocator,TInlineAllocator<1,FDefaultLLMAllocator>> { public : typedef TSetAllocator<FDefaultSparseArrayLLMAllocator,TInlineAllocator<1,FDefaultLLMAllocator>> Typedef ; } ; namespace UE { namespace LLMPrivate { template<KeyType> struct TFastPointerSetKeyFuncs : public DefaultKeyFuncs<KeyType> { using DefaultKeyFuncs<KeyType>::KeyInitType ; uint32)",
    "insertText": "GetKeyHash(KeyInitType Key)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# if PLATFORM_64BITS)",
    "insertText": "static_assert(sizeof(UPTRINT) == sizeof(uint64), \"Expected pointer size to be 64 bits\")"
  },
  {
    "label": "uint64()",
    "kind": "Method",
    "detail": "Function (const uint64 ImportantBits = reinterpret_cast<)",
    "insertText": "uint64(Key)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "static_assert(sizeof(UPTRINT) == sizeof(uint32), \"Expected pointer size to be 32 bits\")"
  },
  {
    "label": "TopologicalSort()",
    "kind": "Method",
    "detail": "Function (} } ; } } template<KeyType,ValueType> class TFastPointerLLMMap : public TMap<KeyType,ValueType,FDefaultSetLLMAllocator,UE::LLMPrivate::TFastPointerMapKeyFuncs<KeyType,ValueType,false>> { } ; template<KeyType> class TFastPointerLLMSet : public TSet<KeyType,UE::LLMPrivate::TFastPointerSetKeyFuncs<KeyType>,FDefaultSetLLMAllocator> { } ; namespace LLMAlgoImpl { enum ETopologicalSortOrder { RootToLeaf,LeafToRoot } ; template<T,GetEdgesType,SizeType> void)",
    "insertText": "TopologicalSort(T* VertexData, SizeType NumVertices, GetEdgesType GetEdges, ETopologicalSortOrder SortOrder)"
  },
  {
    "label": "TopologicalSortRootToLeaf()",
    "kind": "Method",
    "detail": "Function (} namespace LLMAlgo { template<RangeType,GetEdgesType> void)",
    "insertText": "TopologicalSortRootToLeaf(RangeType&& Range, GetEdgesType GetEdges)"
  },
  {
    "label": "TopologicalSort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TopologicalSort(GetData(Range), GetNum(Range), GetEdges, LLMAlgoImpl::ETopologicalSortOrder::RootToLeaf)"
  },
  {
    "label": "TopologicalSortLeafToRoot()",
    "kind": "Method",
    "detail": "Function (} template<RangeType,GetEdgesType> void)",
    "insertText": "TopologicalSortLeafToRoot(RangeType&& Range, GetEdgesType GetEdges)"
  },
  {
    "label": "TopologicalSort()",
    "kind": "Method",
    "detail": "Function (using namespace LLMAlgoImpl ;)",
    "insertText": "TopologicalSort(GetData(Range), GetNum(Range), GetEdges, ETopologicalSortOrder::LeafToRoot)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (SizeType TraversalStart,TraversalEnd,TraversalDir ;)",
    "insertText": "if(SortOrder == ETopologicalSortOrder::RootToLeaf)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (TraversalStart = NumVertices - 1 ; TraversalEnd = - 1 ; TraversalDir = - 1 ; } else { TraversalStart = 0 ; TraversalEnd = NumVertices ; TraversalDir = 1 ; } TArray<SizeType,FDefaultLLMAllocator> LeafToRootOrder ; LeafToRootOrder .)",
    "insertText": "Reserve(NumVertices)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (TArray<SizeType,FDefaultLLMAllocator> EdgeBuffer ; EdgeBuffer .)",
    "insertText": "AddUninitialized(NumVertices)"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (SizeType* EdgeBufferData = EdgeBuffer .)",
    "insertText": "GetData()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (TArray<SizeType,FDefaultLLMAllocator> EdgesOnStack ; EdgesOnStack .)",
    "insertText": "Reserve(NumVertices * ExpectedMaxNumEdges)"
  },
  {
    "label": "AddDefaulted()",
    "kind": "Method",
    "detail": "Function (TArray<bool,FDefaultLLMAllocator> Visited ; Visited .)",
    "insertText": "AddDefaulted(NumVertices)"
  },
  {
    "label": "NumVertices()",
    "kind": "Method",
    "detail": "Function (auto PushVertex = [& EdgesOnStack,& Stack,& GetEdges,& Visited,EdgeBufferData,)",
    "insertText": "NumVertices(SizeType Vertex)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Visited [ Vertex ] = true ; Stack .)",
    "insertText": "Add(FVisitData{ Vertex, EdgesOnStack.Num(), EdgesOnStack.Num() })"
  },
  {
    "label": "SizeType()",
    "kind": "Method",
    "detail": "Function (SizeType NumEdges = static_cast<)",
    "insertText": "SizeType(-1)"
  },
  {
    "label": "GetEdges()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetEdges(Vertex, EdgeBufferData, NumEdges)"
  },
  {
    "label": "LLMCheckf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LLMCheckf(0 <= NumEdges && NumEdges <= NumVertices, TEXT(\"GetEdges function passed into TopologicalSort did not write OutNumEdges, or wrote an invalid value\"))"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (EdgesOnStack .)",
    "insertText": "Append(EdgeBufferData, NumEdges)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "for(SizeType RootVertex = TraversalStart; RootVertex != TraversalEnd; RootVertex += TraversalDir)"
  },
  {
    "label": "PushVertex()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "PushVertex(RootVertex)"
  },
  {
    "label": "Last()",
    "kind": "Method",
    "detail": "Function (FVisitData& VisitData = Stack .)",
    "insertText": "Last()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (SizeType TargetVertex = EdgesOnStack [ VisitData . NextEdge ] ;)",
    "insertText": "if(!Visited[TargetVertex])"
  },
  {
    "label": "PushVertex()",
    "kind": "Method",
    "detail": "Function (+ + VisitData . NextEdge ;)",
    "insertText": "PushVertex(TargetVertex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bPushed = true ; break ; } })",
    "insertText": "if(!bPushed)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (LeafToRootOrder .)",
    "insertText": "Add(VisitData.Vertex)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (EdgesOnStack .)",
    "insertText": "SetNum(VisitData.EdgeStart, EAllowShrinking::No)"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (Stack .)",
    "insertText": "Pop(EAllowShrinking::No)"
  },
  {
    "label": "LLMCheck()",
    "kind": "Method",
    "detail": "Function (} } } })",
    "insertText": "LLMCheck(LeafToRootOrder.Num() == NumVertices)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Original .)",
    "insertText": "Add(MoveTemp(VertexData[n]))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(SizeType LeafToRootIndex = 0; LeafToRootIndex < NumVertices; ++LeafToRootIndex)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (SizeType WriteIndex = TraversalStart + TraversalDir* LeafToRootIndex ; SizeType ReadIndex = LeafToRootOrder [ LeafToRootIndex ] ; VertexData [ WriteIndex ] =)",
    "insertText": "MoveTemp(Original[ReadIndex])"
  }
]