[
  {
    "label": "TVectorZero()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Math / VectorRegister . h \" # include \" Chaos / Core . h \" template<T> T)",
    "insertText": "TVectorZero()"
  },
  {
    "label": "VectorRegister4Float()",
    "kind": "Method",
    "detail": "Function (template<> VectorRegister4Float TVectorZero<)",
    "insertText": "VectorRegister4Float()"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (} template<> VectorRegister4Double TVectorZero<)",
    "insertText": "VectorRegister4Double()"
  },
  {
    "label": "TMakeVectorRegister()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "TMakeVectorRegister(float X, float Y, float Z, float W)"
  },
  {
    "label": "VectorRegister4Float()",
    "kind": "Method",
    "detail": "Function (template<> VectorRegister4Float TMakeVectorRegister<)",
    "insertText": "VectorRegister4Float(float X, float Y, float Z, float W)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (} template<> VectorRegister4Double TMakeVectorRegister<)",
    "insertText": "VectorRegister4Double(float X, float Y, float Z, float W)"
  },
  {
    "label": "TMakeVectorRegisterConstant()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "TMakeVectorRegisterConstant(float X, float Y, float Z, float W)"
  },
  {
    "label": "TMakeVectorRegisterFloatFromDouble()",
    "kind": "Method",
    "detail": "Function (} template<T> VectorRegister4Float)",
    "insertText": "TMakeVectorRegisterFloatFromDouble(const T& V)"
  },
  {
    "label": "VectorRegister4Double()",
    "kind": "Method",
    "detail": "Function (template<> VectorRegister4Float TMakeVectorRegisterFloatFromDouble<)",
    "insertText": "VectorRegister4Double(const VectorRegister4Double& V)"
  },
  {
    "label": "VectorRegister4Float()",
    "kind": "Method",
    "detail": "Function (} template<> VectorRegister4Float TMakeVectorRegisterFloatFromDouble<)",
    "insertText": "VectorRegister4Float(const VectorRegister4Float& V)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (#)",
    "insertText": "if(!defined(_MSC_VER) || PLATFORM_ENABLE_VECTORINTRINSICS_NEON) && PLATFORM_ENABLE_VECTORINTRINSICS return VectorRegister4Float(V)"
  },
  {
    "label": "_mm_castsi128_ps()",
    "kind": "Method",
    "detail": "Function (# elif PLATFORM_ENABLE_VECTORINTRINSICS return)",
    "insertText": "_mm_castsi128_ps(V)"
  },
  {
    "label": "VectorCastIntToFloat()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "VectorCastIntToFloat(Vec)"
  },
  {
    "label": "VectorCast4FloatTo4Int()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Int)",
    "insertText": "VectorCast4FloatTo4Int(const VectorRegister4Float& V)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (#)",
    "insertText": "if(!defined(_MSC_VER) || PLATFORM_ENABLE_VECTORINTRINSICS_NEON) && PLATFORM_ENABLE_VECTORINTRINSICS return VectorRegister4Int(V)"
  },
  {
    "label": "_mm_castps_si128()",
    "kind": "Method",
    "detail": "Function (# elif PLATFORM_ENABLE_VECTORINTRINSICS return)",
    "insertText": "_mm_castps_si128(V)"
  },
  {
    "label": "VectorCastFloatToInt()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "VectorCastFloatToInt(Vec)"
  },
  {
    "label": "VectorUnpackLo()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorUnpackLo(const VectorRegister4Float& A, const VectorRegister4Float& B)"
  },
  {
    "label": "vzip1q_f32()",
    "kind": "Method",
    "detail": "Function (# if PLATFORM_ENABLE_VECTORINTRINSICS_NEON return)",
    "insertText": "vzip1q_f32(A, B)"
  },
  {
    "label": "_mm_unpacklo_ps()",
    "kind": "Method",
    "detail": "Function (# elif PLATFORM_ENABLE_VECTORINTRINSICS return)",
    "insertText": "_mm_unpacklo_ps(A, B)"
  },
  {
    "label": "MakeVectorRegisterFloat()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "MakeVectorRegisterFloat(A.V[0], B.V[0], A.V[1], B.V[1])"
  },
  {
    "label": "VectorUnpackLo()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorUnpackLo(const VectorRegister4Double& A, const VectorRegister4Double& B)"
  },
  {
    "label": "vzip1q_f64()",
    "kind": "Method",
    "detail": "Function (# if PLATFORM_ENABLE_VECTORINTRINSICS_NEON VectorRegister4Double Result ; Result . XY =)",
    "insertText": "vzip1q_f64(A.XY, B.XY)"
  },
  {
    "label": "vzip2q_f64()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "vzip2q_f64(A.XY, B.XY)"
  },
  {
    "label": "_mm_unpacklo_pd()",
    "kind": "Method",
    "detail": "Function (# else VectorRegister4Double Result ; Result . XY =)",
    "insertText": "_mm_unpacklo_pd(A.XY, B.XY)"
  },
  {
    "label": "_mm_unpackhi_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_unpackhi_pd(A.XY, B.XY)"
  },
  {
    "label": "VectorUnpackHi()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorUnpackHi(const VectorRegister4Float& A, const VectorRegister4Float& B)"
  },
  {
    "label": "vzip2q_f32()",
    "kind": "Method",
    "detail": "Function (# if PLATFORM_ENABLE_VECTORINTRINSICS_NEON return)",
    "insertText": "vzip2q_f32(A, B)"
  },
  {
    "label": "_mm_unpackhi_ps()",
    "kind": "Method",
    "detail": "Function (# elif PLATFORM_ENABLE_VECTORINTRINSICS return)",
    "insertText": "_mm_unpackhi_ps(A, B)"
  },
  {
    "label": "MakeVectorRegisterFloat()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "MakeVectorRegisterFloat(A.V[2], B.V[2], A.V[3], B.V[3])"
  },
  {
    "label": "VectorMoveLh()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorMoveLh(const VectorRegister4Float& A, const VectorRegister4Float& B)"
  },
  {
    "label": "vzip1q_f64()",
    "kind": "Method",
    "detail": "Function (# if PLATFORM_ENABLE_VECTORINTRINSICS_NEON return)",
    "insertText": "vzip1q_f64(A, B)"
  },
  {
    "label": "VectorCombineLow()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "VectorCombineLow(A, B)"
  },
  {
    "label": "VectorDot3FastX()",
    "kind": "Method",
    "detail": "Function (# endif } namespace Chaos::Private { VectorRegister4Float)",
    "insertText": "VectorDot3FastX(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (# if PLATFORM_ENABLE_VECTORINTRINSICS_NEON VectorRegister4Float Temp =)",
    "insertText": "VectorMultiply(Vec1, Vec2)"
  },
  {
    "label": "vpadd_f32()",
    "kind": "Method",
    "detail": "Function (float32x2_t sum =)",
    "insertText": "vpadd_f32(vget_low_f32(Temp), vget_high_f32(Temp))"
  },
  {
    "label": "vpadd_f32()",
    "kind": "Method",
    "detail": "Function (sum =)",
    "insertText": "vpadd_f32(sum, sum)"
  },
  {
    "label": "_mm_dp_ps()",
    "kind": "Method",
    "detail": "Function (# elif PLATFORM_ENABLE_VECTORINTRINSICS return)",
    "insertText": "_mm_dp_ps(Vec1, Vec2, 0xFF)"
  },
  {
    "label": "VectorDot3()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "VectorDot3(Vec1, Vec2)"
  },
  {
    "label": "VectorMatrixMultiply()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Float)",
    "insertText": "VectorMatrixMultiply(const VectorRegister4Float& Vec, const FMatrix33& M)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float VecX =)",
    "insertText": "VectorReplicate(Vec, 0)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float VecY =)",
    "insertText": "VectorReplicate(Vec, 1)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float VecZ =)",
    "insertText": "VectorReplicate(Vec, 2)"
  },
  {
    "label": "MakeVectorRegisterFloatFromDouble()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float R0 =)",
    "insertText": "MakeVectorRegisterFloatFromDouble(MakeVectorRegister(M.M[0][0], M.M[0][1], M.M[0][2], 0.0))"
  },
  {
    "label": "MakeVectorRegisterFloatFromDouble()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float R1 =)",
    "insertText": "MakeVectorRegisterFloatFromDouble(MakeVectorRegister(M.M[1][0], M.M[1][1], M.M[1][2], 0.0))"
  },
  {
    "label": "MakeVectorRegisterFloatFromDouble()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float R2 =)",
    "insertText": "MakeVectorRegisterFloatFromDouble(MakeVectorRegister(M.M[2][0], M.M[2][1], M.M[2][2], 0.0))"
  },
  {
    "label": "VectorCrossNoFMA()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "VectorCrossNoFMA(const VectorRegister4Float& Vec1, const VectorRegister4Float& Vec2)"
  },
  {
    "label": "VectorCross()",
    "kind": "Method",
    "detail": "Function (# if PLATFORM_ENABLE_VECTORINTRINSICS_NEON return)",
    "insertText": "VectorCross(Vec1, Vec2)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (# elif PLATFORM_ENABLE_VECTORINTRINSICS VectorRegister4Float A =)",
    "insertText": "VectorSwizzle(Vec2, 1, 2, 0, 3)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float B =)",
    "insertText": "VectorSwizzle(Vec1, 1, 2, 0, 3)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (A =)",
    "insertText": "VectorMultiply(A, Vec1)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (A =)",
    "insertText": "VectorSubtract(A, VectorMultiply(B, Vec2))"
  },
  {
    "label": "VectorCrossNoFMA()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorCrossNoFMA(const VectorRegister4Double& Vec1, const VectorRegister4Double& Vec2)"
  },
  {
    "label": "VectorBitwiseNotAnd()",
    "kind": "Method",
    "detail": "Function (# endif } } VectorRegister4Float)",
    "insertText": "VectorBitwiseNotAnd(const VectorRegister4Float& A, const VectorRegister4Float& B)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (# if PLATFORM_ENABLE_VECTORINTRINSICS_NEON)",
    "insertText": "return(VectorRegister4Float)vandq_u32(vmvnq_u32((VectorRegister4Int)A), (VectorRegister4Int)B)"
  },
  {
    "label": "_mm_andnot_ps()",
    "kind": "Method",
    "detail": "Function (# elif PLATFORM_ENABLE_VECTORINTRINSICS return)",
    "insertText": "_mm_andnot_ps(A, B)"
  },
  {
    "label": "MakeVectorRegisterFloat()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "MakeVectorRegisterFloat(uint32(~((uint32*)(A.V))[0] & ((uint32*)(B.V))[0]), uint32(~((uint32*)(A.V))[1] & ((uint32*)(B.V))[1]), uint32(~((uint32*)(A.V))[2] & ((uint32*)(B.V))[2]), uint32(~((uint32*)(A.V))[3] & ((uint32*)(B.V))[3]))"
  },
  {
    "label": "VectorBitwiseNotAnd()",
    "kind": "Method",
    "detail": "Function (# endif } VectorRegister4Double)",
    "insertText": "VectorBitwiseNotAnd(const VectorRegister4Double& A, const VectorRegister4Double& B)"
  },
  {
    "label": "XY()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double Result ; # if PLATFORM_ENABLE_VECTORINTRINSICS_NEON Result .)",
    "insertText": "XY(VectorRegister2Double)vandq_u32(vmvnq_u32((VectorRegister2Double)A.XY), (VectorRegister2Double)B.XY)"
  },
  {
    "label": "ZW()",
    "kind": "Method",
    "detail": "Function (Result .)",
    "insertText": "ZW(VectorRegister2Double)vandq_u32(vmvnq_u32((VectorRegister2Double)A.ZW), (VectorRegister2Double)B.ZW)"
  },
  {
    "label": "_mm_cvtps_pd()",
    "kind": "Method",
    "detail": "Function (# elif PLATFORM_ENABLE_VECTORINTRINSICS # if ! UE_PLATFORM_MATH_USE_AVX Result . XY =)",
    "insertText": "_mm_cvtps_pd(_mm_andnot_ps(_mm_cvtpd_ps(A.XY), _mm_cvtpd_ps(B.XY)))"
  },
  {
    "label": "_mm_cvtps_pd()",
    "kind": "Method",
    "detail": "Function (Result . ZW =)",
    "insertText": "_mm_cvtps_pd(_mm_andnot_ps(_mm_cvtpd_ps(A.ZW), _mm_cvtpd_ps(B.ZW)))"
  },
  {
    "label": "_mm256_andnot_pd()",
    "kind": "Method",
    "detail": "Function (# else Result =)",
    "insertText": "_mm256_andnot_pd(A, B)"
  },
  {
    "label": "MakeVectorRegisterDouble()",
    "kind": "Method",
    "detail": "Function (# endif # else Result =)",
    "insertText": "MakeVectorRegisterDouble(uint64(~((uint64*)(A.V))[0] & ((uint64*)(B.V))[0]), uint64(~((uint64*)(A.V))[1] & ((uint64*)(B.V))[1]), uint64(~((uint64*)(A.V))[2] & ((uint64*)(B.V))[2]), uint64(~((uint64*)(A.V))[3] & ((uint64*)(B.V))[3]))"
  }
]