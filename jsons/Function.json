[
  {
    "label": "_LIBCPP_EXCEPTION_ABI",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_LIBCPP_EXCEPTION_ABI"
  },
  {
    "label": "_Fp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Fp"
  },
  {
    "label": "_LIBCPP_DEPRECATED_CXX03_FUNCTION",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_LIBCPP_DEPRECATED_CXX03_FUNCTION"
  },
  {
    "label": "_Rp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Rp"
  },
  {
    "label": "__maybe_derive_from_unary_function",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__maybe_derive_from_unary_function"
  },
  {
    "label": "_A1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_A1"
  },
  {
    "label": "__maybe_derive_from_binary_function",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__maybe_derive_from_binary_function"
  },
  {
    "label": "_A2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_A2"
  },
  {
    "label": "_Ret",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Ret"
  },
  {
    "label": "_Class",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Class"
  },
  {
    "label": "_Ap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Ap"
  },
  {
    "label": "_FB",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_FB"
  },
  {
    "label": "__alloc_func",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "__alloc_func"
  },
  {
    "label": "__default_alloc_func",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "__default_alloc_func"
  },
  {
    "label": "_LIBCPP_TEMPLATE_VIS",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_LIBCPP_TEMPLATE_VIS"
  },
  {
    "label": "__base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "__base"
  },
  {
    "label": "_FD",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_FD"
  },
  {
    "label": "_Alloc",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Alloc"
  },
  {
    "label": "__func",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "__func"
  },
  {
    "label": "__value_func",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "__value_func"
  },
  {
    "label": "__use_small_storage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__use_small_storage"
  },
  {
    "label": "__policy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__policy"
  },
  {
    "label": "__policy_invoker",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__policy_invoker"
  },
  {
    "label": "__policy_func",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "__policy_func"
  },
  {
    "label": "_Rp1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Rp1"
  },
  {
    "label": "__callable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__callable"
  },
  {
    "label": "_R2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_R2"
  },
  {
    "label": "__strip_signature",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__strip_signature"
  },
  {
    "label": "_Gp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Gp"
  },
  {
    "label": "_Stripped",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Stripped"
  },
  {
    "label": "_A0",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_A0"
  },
  {
    "label": "_B0",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_B0"
  },
  {
    "label": "_B1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_B1"
  },
  {
    "label": "_B2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_B2"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___FUNCTIONAL_FUNCTION_H # define _LIBCPP___FUNCTIONAL_FUNCTION_H # include<__assert> # include<__config> # include<__functional / binary_function . h> # include<__functional / invoke . h> # include<__functional / unary_function . h> # include<__iterator / iterator_traits . h> # include<__memory / addressof . h> # include<__memory / allocator_traits . h> # include<__memory / compressed_pair . h> # include<__memory / shared_ptr . h> # include<__utility / forward . h> # include<__utility / move . h> # include<__utility / swap . h> # include<exception> # include<memory> # include<type_traits> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER) # pragma GCC system_header #endif _LIBCPP_BEGIN_NAMESPACE_STD _LIBCPP_DIAGNOSTIC_PUSH _LIBCPP_CLANG_DIAGNOSTIC_IGNORED(\"-Wweak-vtables\")"
  },
  {
    "label": "bad_function_call()",
    "kind": "Method",
    "detail": "Function (public : # ifdef _LIBCPP_ABI_BAD_FUNCTION_CALL_KEY_FUNCTION ~)",
    "insertText": "bad_function_call()"
  },
  {
    "label": "what()",
    "kind": "Method",
    "detail": "Function (} # endif # ifdef _LIBCPP_ABI_BAD_FUNCTION_CALL_GOOD_WHAT_MESSAGE const char*)",
    "insertText": "what()"
  },
  {
    "label": "__throw_bad_function_call()",
    "kind": "Method",
    "detail": "Function (# endif } ; _LIBCPP_DIAGNOSTIC_POP _LIBCPP_NORETURN _LIBCPP_INLINE_VISIBILITY void)",
    "insertText": "__throw_bad_function_call()"
  },
  {
    "label": "abort()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "abort()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif } # if)",
    "insertText": "defined(_LIBCPP_CXX03_LANG) && !defined(_LIBCPP_DISABLE_DEPRECATION_WARNINGS) && __has_attribute(deprecated) # define _LIBCPP_DEPRECATED_CXX03_FUNCTION \\ __attribute__((deprecated(\"Using std::function in C++03 is not supported anymore. Please upgrade to C++11 or later, or use a different type\")))"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (namespace __function { template<class _Rp> struct __maybe_derive_from_unary_function { } ; template<class _Rp,class _A1> struct __maybe_derive_from_unary_function<)",
    "insertText": "_Rp(_A1)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} ; template<class _Rp> struct __maybe_derive_from_binary_function { } ; template<class _Rp,class _A1,class _A2> struct __maybe_derive_from_binary_function<)",
    "insertText": "_Rp(_A1, _A2)"
  },
  {
    "label": "__not_null()",
    "kind": "Method",
    "detail": "Function (} ; template<class _Fp> _LIBCPP_INLINE_VISIBILITY bool)",
    "insertText": "__not_null(_Fp const&)"
  },
  {
    "label": "__target()",
    "kind": "Method",
    "detail": "Function (__compressed_pair<_Fp,_Ap> __f_ ; public : typedef _LIBCPP_NODEBUG _Fp _Target ; typedef _LIBCPP_NODEBUG _Ap _Alloc ; _LIBCPP_INLINE_VISIBILITY const _Target&)",
    "insertText": "__target()"
  },
  {
    "label": "__get_allocator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY const _Alloc&)",
    "insertText": "__get_allocator()"
  },
  {
    "label": "__alloc_func()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__alloc_func(_Target&& __f) : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)), _VSTD::forward_as_tuple())"
  },
  {
    "label": "__alloc_func()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__alloc_func(const _Target& __f, const _Alloc& __a) : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f), _VSTD::forward_as_tuple(__a))"
  },
  {
    "label": "__alloc_func()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__alloc_func(const _Target& __f, _Alloc&& __a) : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f), _VSTD::forward_as_tuple(_VSTD::move(__a)))"
  },
  {
    "label": "__alloc_func()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__alloc_func(_Target&& __f, _Alloc&& __a) : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)), _VSTD::forward_as_tuple(_VSTD::move(__a)))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY _Rp)",
    "insertText": "operator()(_ArgTypes&&... __arg)"
  },
  {
    "label": "__call()",
    "kind": "Method",
    "detail": "Function (typedef __invoke_void_return_wrapper<_Rp> _Invoker ; return)",
    "insertText": "__call(__f_.first(), _VSTD::forward<_ArgTypes>(__arg)...)"
  },
  {
    "label": "__clone()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY __alloc_func*)",
    "insertText": "__clone()"
  },
  {
    "label": "__a()",
    "kind": "Method",
    "detail": "Function (typedef allocator_traits<_Alloc> __alloc_traits ; typedef __rebind_alloc_helper<__alloc_traits,__alloc_func>::type _AA ; _AA)",
    "insertText": "__a(__f_.second())"
  },
  {
    "label": "__hold()",
    "kind": "Method",
    "detail": "Function (typedef __allocator_destructor<_AA> _Dp ; unique_ptr<__alloc_func,_Dp>)",
    "insertText": "__hold(__a.allocate(1), _Dp(__a, 1))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)__hold.get()) __alloc_func(__f_.first(), _Alloc(__a))"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY void)",
    "insertText": "destroy()"
  },
  {
    "label": "_Alloc()",
    "kind": "Method",
    "detail": "Function (__f_ . ~ __compressed_pair<_Target,)",
    "insertText": "_Alloc()"
  },
  {
    "label": "__destroy_and_delete()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "__destroy_and_delete(__alloc_func* __f)"
  },
  {
    "label": "__a()",
    "kind": "Method",
    "detail": "Function (typedef allocator_traits<_Alloc> __alloc_traits ; typedef __rebind_alloc_helper<__alloc_traits,__alloc_func>::type _FunAlloc ; _FunAlloc)",
    "insertText": "__a(__f->__get_allocator())"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (__a .)",
    "insertText": "deallocate(__f, 1)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} } ; template<class _Fp,class _Rp,class . . . _ArgTypes> class __default_alloc_func<_Fp,)",
    "insertText": "_Rp(_ArgTypes...)"
  },
  {
    "label": "__default_alloc_func()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__default_alloc_func(const _Target& __f) : __f_(__f)"
  },
  {
    "label": "__call()",
    "kind": "Method",
    "detail": "Function (typedef __invoke_void_return_wrapper<_Rp> _Invoker ; return)",
    "insertText": "__call(__f_, _VSTD::forward<_ArgTypes>(__arg)...)"
  },
  {
    "label": "__default_alloc_func()",
    "kind": "Method",
    "detail": "Function (__builtin_new_allocator::__holder_t __hold = __builtin_new_allocator::__allocate_type<)",
    "insertText": "__default_alloc_func(1)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (__default_alloc_func* __res)",
    "insertText": "new((void*)__hold.get()) __default_alloc_func(__f_)"
  },
  {
    "label": "_Target()",
    "kind": "Method",
    "detail": "Function (__f_ . ~)",
    "insertText": "_Target()"
  },
  {
    "label": "__destroy_and_delete()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "__destroy_and_delete(__default_alloc_func* __f)"
  },
  {
    "label": "__default_alloc_func()",
    "kind": "Method",
    "detail": "Function (__builtin_new_allocator::__deallocate_type<)",
    "insertText": "__default_alloc_func(__f, 1)"
  },
  {
    "label": "__base()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__base(const __base&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (__base&)",
    "insertText": "operator(const __base&)"
  },
  {
    "label": "__base()",
    "kind": "Method",
    "detail": "Function (public : _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__base()"
  },
  {
    "label": "__clone()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__clone(__base*)"
  },
  {
    "label": "destroy_deallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy_deallocate()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (_Rp)",
    "insertText": "operator()(_ArgTypes&& ...)"
  },
  {
    "label": "target()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP_NO_RTTI const void*)",
    "insertText": "target(const type_info&)"
  },
  {
    "label": "target_type()",
    "kind": "Method",
    "detail": "Function (const std::type_info&)",
    "insertText": "target_type()"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<class _FD,class _Alloc,class _FB> class __func ; template<class _Fp,class _Alloc,class _Rp,class . . . _ArgTypes> class __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_ArgTypes...)> : public __base<_Rp(_ArgTypes...)"
  },
  {
    "label": "__func()",
    "kind": "Method",
    "detail": "Function (public : _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__func(_Fp&& __f) : __f_(_VSTD::move(__f))"
  },
  {
    "label": "__func()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__func(const _Fp& __f, const _Alloc& __a) : __f_(__f, __a)"
  },
  {
    "label": "__func()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__func(const _Fp& __f, _Alloc&& __a) : __f_(__f, _VSTD::move(__a))"
  },
  {
    "label": "__func()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__func(_Fp&& __f, _Alloc&& __a) : __f_(_VSTD::move(__f), _VSTD::move(__a))"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} __base<)",
    "insertText": "_Rp(_ArgTypes...)>* __clone()"
  },
  {
    "label": "__clone()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__clone(__base<_Rp(_ArgTypes...)>*)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<class _Fp,class _Alloc,class _Rp,class . . . _ArgTypes> __base<)",
    "insertText": "_Rp(_ArgTypes...)>* __func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone()"
  },
  {
    "label": "__a()",
    "kind": "Method",
    "detail": "Function (typedef allocator_traits<_Alloc> __alloc_traits ; typedef __rebind_alloc_helper<__alloc_traits,__func>::type _Ap ; _Ap)",
    "insertText": "__a(__f_.__get_allocator())"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)__hold.get()) __func(__f_.__target(), _Alloc(__a))"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class . . . _ArgTypes> void __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)__p) __func(__f_.__target(), __f_.__get_allocator())"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class . . . _ArgTypes> void __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_ArgTypes...)>::destroy()"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class . . . _ArgTypes> void __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_ArgTypes...)>::destroy_deallocate()"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (__a .)",
    "insertText": "deallocate(this, 1)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class . . . _ArgTypes> _Rp __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} # ifndef _LIBCPP_NO_RTTI template<class _Fp,class _Alloc,class _Rp,class . . . _ArgTypes> const void* __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_ArgTypes...)>::target(const type_info& __ti)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (aligned_storage<3*)",
    "insertText": "sizeof(void*)"
  },
  {
    "label": "__as_base()",
    "kind": "Method",
    "detail": "Function (__func* __f_ ; _LIBCPP_NO_CFI __func*)",
    "insertText": "__as_base(void* __p)"
  },
  {
    "label": "__value_func()",
    "kind": "Method",
    "detail": "Function (} public : _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__value_func() _NOEXCEPT : __f_(nullptr)"
  },
  {
    "label": "__value_func()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__value_func(_Fp&& __f, const _Alloc& __a) : __f_(nullptr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (typedef __rebind_alloc_helper<__alloc_traits,_Fun>::type _FunAlloc ;)",
    "insertText": "if(__function::__not_null(__f))"
  },
  {
    "label": "__af()",
    "kind": "Method",
    "detail": "Function (_FunAlloc)",
    "insertText": "__af(__a)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (__f_)",
    "insertText": "new((void*)&__buf_) _Fun(_VSTD::move(__f), _Alloc(__af))"
  },
  {
    "label": "__hold()",
    "kind": "Method",
    "detail": "Function (} else { typedef __allocator_destructor<_FunAlloc> _Dp ; unique_ptr<__func,_Dp>)",
    "insertText": "__hold(__af.allocate(1), _Dp(__af, 1))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)__hold.get()) _Fun(_VSTD::move(__f), _Alloc(__a))"
  },
  {
    "label": "release()",
    "kind": "Method",
    "detail": "Function (__f_ = __hold .)",
    "insertText": "release()"
  },
  {
    "label": "__value_func()",
    "kind": "Method",
    "detail": "Function (} } } template<class _Fp,class = enable_if<! is_same<decay<_Fp>::type,__value_func>::value>::type> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__value_func(_Fp&& __f) : __value_func(_VSTD::forward<_Fp>(__f), allocator<_Fp>())"
  },
  {
    "label": "__value_func()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__value_func(const __value_func& __f)"
  },
  {
    "label": "__as_base()",
    "kind": "Method",
    "detail": "Function (__f_ =)",
    "insertText": "__as_base(&__buf_)"
  },
  {
    "label": "__clone()",
    "kind": "Method",
    "detail": "Function (__f . __f_ ->)",
    "insertText": "__clone(__f_)"
  },
  {
    "label": "__value_func()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__value_func(__value_func&& __f)"
  },
  {
    "label": "__value_func()",
    "kind": "Method",
    "detail": "Function (} else { __f_ = __f . __f_ ; __f . __f_ = nullptr ; } } _LIBCPP_INLINE_VISIBILITY ~)",
    "insertText": "__value_func()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY __value_func&)",
    "insertText": "operator(__value_func&& __f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* this = nullptr ;)",
    "insertText": "if(__f.__f_ == nullptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} else { __f_ = __f . __f_ ; __f . __f_ = nullptr ; } return* this ; } _LIBCPP_INLINE_VISIBILITY __value_func&)",
    "insertText": "operator(nullptr_t)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (__func* __f = __f_ ; __f_ = nullptr ;)",
    "insertText": "if((void*)__f == &__buf_) __f->destroy()"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY void)",
    "insertText": "swap(__value_func& __f)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (aligned_storage<)",
    "insertText": "sizeof(__buf_)"
  },
  {
    "label": "__as_base()",
    "kind": "Method",
    "detail": "Function (__func* __t =)",
    "insertText": "__as_base(&__tempbuf)"
  },
  {
    "label": "__clone()",
    "kind": "Method",
    "detail": "Function (__f_ ->)",
    "insertText": "__clone(__t)"
  },
  {
    "label": "__clone()",
    "kind": "Method",
    "detail": "Function (__f_ = nullptr ; __f . __f_ ->)",
    "insertText": "__clone(__as_base(&__buf_))"
  },
  {
    "label": "__clone()",
    "kind": "Method",
    "detail": "Function (__t ->)",
    "insertText": "__clone(__as_base(&__f.__buf_))"
  },
  {
    "label": "__as_base()",
    "kind": "Method",
    "detail": "Function (__f . __f_ =)",
    "insertText": "__as_base(&__f.__buf_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((void*)__f_ == &__buf_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((void*)__f.__f_ == &__f.__buf_)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "swap(__f_, __f.__f_)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY operator)",
    "insertText": "bool()"
  },
  {
    "label": "target()",
    "kind": "Method",
    "detail": "Function (} template<_Tp> _LIBCPP_INLINE_VISIBILITY const _Tp*)",
    "insertText": "target()"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (void* __large ; } ; template<_Fun> struct __use_small_storage : public integral_constant<bool,)",
    "insertText": "sizeof(_Fun) <= sizeof(__policy_storage) && _LIBCPP_ALIGNOF(_Fun) <= _LIBCPP_ALIGNOF(__policy_storage)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} ; struct __policy {)",
    "insertText": "void(*const __clone)(const void*)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "void(*const __destroy)(void*)"
  },
  {
    "label": "__create()",
    "kind": "Method",
    "detail": "Function (const bool __is_null ; const std::type_info* const __type_info ; template<_Fun> _LIBCPP_INLINE_VISIBILITY const __policy*)",
    "insertText": "__create()"
  },
  {
    "label": "__create_empty()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY const __policy*)",
    "insertText": "__create_empty()"
  },
  {
    "label": "typeid()",
    "kind": "Method",
    "detail": "Function (const _LIBCPP_CONSTEXPR __policy __policy_ = { nullptr,nullptr,true,# ifndef _LIBCPP_NO_RTTI&)",
    "insertText": "typeid(void)"
  },
  {
    "label": "_Fun()",
    "kind": "Method",
    "detail": "Function (const _Fun* __f = static_cast<const)",
    "insertText": "_Fun(__s)"
  },
  {
    "label": "__large_destroy()",
    "kind": "Method",
    "detail": "Function (} template<_Fun> void)",
    "insertText": "__large_destroy(void* __s)"
  },
  {
    "label": "__destroy_and_delete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__destroy_and_delete(static_cast<_Fun*>(__s))"
  },
  {
    "label": "__choose_policy()",
    "kind": "Method",
    "detail": "Function (} template<_Fun> _LIBCPP_INLINE_VISIBILITY const __policy*)",
    "insertText": "__choose_policy(false_type)"
  },
  {
    "label": "typeid()",
    "kind": "Method",
    "detail": "Function (const _LIBCPP_CONSTEXPR __policy __policy_ = {& __large_clone<_Fun>,& __large_destroy<_Fun>,false,# ifndef _LIBCPP_NO_RTTI&)",
    "insertText": "typeid(typename _Fun::_Target)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "_Rp(*__Call)(const __policy_storage*, __fast_forward<_ArgTypes>...)"
  },
  {
    "label": "__policy_invoker()",
    "kind": "Method",
    "detail": "Function (__Call __call_ ; _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__policy_invoker() : __call_(&__call_empty)"
  },
  {
    "label": "__policy_invoker()",
    "kind": "Method",
    "detail": "Function (} private : _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__policy_invoker(__Call __c) : __call_(__c)"
  },
  {
    "label": "__call_empty()",
    "kind": "Method",
    "detail": "Function (} _Rp)",
    "insertText": "__call_empty(const __policy_storage*, __fast_forward<_ArgTypes>...)"
  },
  {
    "label": "__call_impl()",
    "kind": "Method",
    "detail": "Function (} template<_Fun> _Rp)",
    "insertText": "__call_impl(const __policy_storage* __buf, __fast_forward<_ArgTypes>... __args)"
  },
  {
    "label": "_Fun()",
    "kind": "Method",
    "detail": "Function (_Fun* __f = reinterpret_cast<)",
    "insertText": "_Fun(__use_small_storage<_Fun>::value ? &__buf->__small : __buf->__large)"
  },
  {
    "label": "__policy_func()",
    "kind": "Method",
    "detail": "Function (__invoker __invoker_ ; const __policy* __policy_ ; public : _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__policy_func() : __policy_(__policy::__create_empty())"
  },
  {
    "label": "__policy_func()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__policy_func(_Fp&& __f, const _Alloc& __a) : __policy_(__policy::__create_empty())"
  },
  {
    "label": "_Fun()",
    "kind": "Method",
    "detail": "Function (__invoker_ = __invoker::template __create<)",
    "insertText": "_Fun()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)&__buf_.__small) _Fun(_VSTD::move(__f), _Alloc(__af))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)__hold.get()) _Fun(_VSTD::move(__f), _Alloc(__af))"
  },
  {
    "label": "__policy_func()",
    "kind": "Method",
    "detail": "Function (} } } template<class _Fp,class = enable_if<! is_same<decay<_Fp>::type,__policy_func>::value>::type> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__policy_func(_Fp&& __f) : __policy_(__policy::__create_empty())"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)&__buf_.__small) _Fun(_VSTD::move(__f))"
  },
  {
    "label": "_Fun()",
    "kind": "Method",
    "detail": "Function (} else { __builtin_new_allocator::__holder_t __hold = __builtin_new_allocator::__allocate_type<)",
    "insertText": "_Fun(1)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (__buf_ . __large)",
    "insertText": "new((void*)__hold.get()) _Fun(_VSTD::move(__f))"
  },
  {
    "label": "__policy_func()",
    "kind": "Method",
    "detail": "Function (} } } _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__policy_func(const __policy_func& __f) : __buf_(__f.__buf_), __invoker_(__f.__invoker_), __policy_(__f.__policy_)"
  },
  {
    "label": "__policy_func()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__policy_func(__policy_func&& __f) : __buf_(__f.__buf_), __invoker_(__f.__invoker_), __policy_(__f.__policy_)"
  },
  {
    "label": "__invoker()",
    "kind": "Method",
    "detail": "Function (__f . __invoker_ =)",
    "insertText": "__invoker()"
  },
  {
    "label": "__policy_func()",
    "kind": "Method",
    "detail": "Function (} } _LIBCPP_INLINE_VISIBILITY ~)",
    "insertText": "__policy_func()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY __policy_func&)",
    "insertText": "operator(__policy_func&& __f)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY void)",
    "insertText": "swap(__policy_func& __f)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(__invoker_, __f.__invoker_)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(__policy_, __f.__policy_)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(__buf_, __f.__buf_)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # endif } ; # if)",
    "insertText": "defined(_LIBCPP_HAS_BLOCKS_RUNTIME) && !defined(_LIBCPP_HAS_OBJC_ARC) extern \"C\" void *_Block_copy(const void *)"
  },
  {
    "label": "_Block_release()",
    "kind": "Method",
    "detail": "Function (\" C \" void)",
    "insertText": "_Block_release(const void *)"
  },
  {
    "label": "_Rp1()",
    "kind": "Method",
    "detail": "Function (template<class _Rp1,class . . . _ArgTypes1,class _Alloc,class _Rp,class . . . _ArgTypes> class __func<)",
    "insertText": "_Rp1(^)(_ArgTypes1...), _Alloc, _Rp(_ArgTypes...)> : public __base<_Rp(_ArgTypes...)"
  },
  {
    "label": "_Rp1()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "_Rp1(^__block_type)(_ArgTypes1...)"
  },
  {
    "label": "__func()",
    "kind": "Method",
    "detail": "Function (__block_type __f_ ; public : _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__func(__block_type const& __f) : __f_(reinterpret_cast<__block_type>(__f ? _Block_copy(__f) : nullptr))"
  },
  {
    "label": "__func()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "__func(__block_type __f, const _Alloc& ) : __f_(reinterpret_cast<__block_type>(__f ? _Block_copy(__f) : nullptr))"
  },
  {
    "label": "_LIBCPP_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_LIBCPP_ASSERT(false, \"Block pointers are just pointers, so they should always fit into \" \"std::function's small buffer optimization. This function should \" \"never be invoked.\")"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)__p) __func(__f_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} _Rp)",
    "insertText": "operator()(_ArgTypes&& ... __arg)"
  },
  {
    "label": "target()",
    "kind": "Method",
    "detail": "Function (} # ifndef _LIBCPP_NO_RTTI const void*)",
    "insertText": "target(type_info const& __ti)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} # endif } ; # endif } template<class _Rp,class . . . _ArgTypes> class _LIBCPP_TEMPLATE_VIS function<)",
    "insertText": "_Rp(_ArgTypes...)> : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>, public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (# endif __func __f_ ; template<class _Fp,bool = _And<_IsNotSame<__uncvref_t<_Fp>,function>,__invokable<_Fp,_ArgTypes . . .>>::value> struct __callable ; template<class _Fp> struct __callable<_Fp,true> { const bool value = is_void<_Rp>::value | | __is_core_convertible<__invoke_of<_Fp,_ArgTypes . . .>::type,_Rp>::value ; } ; template<class _Fp> struct __callable<_Fp,false> { const bool value = false ; } ; template<class _Fp> using _EnableIfLValueCallable = enable_if<__callable<_Fp&>::value>::type ; public : typedef _Rp result_type ; _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "function()"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "function(nullptr_t)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "function(const function&)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "function(function&&)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (template<class _Fp,class = _EnableIfLValueCallable<_Fp>>)",
    "insertText": "function(_Fp)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (# if _LIBCPP_STD_VER<= 1 4 template<class _Alloc> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "function(allocator_arg_t, const _Alloc&)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (} template<class _Alloc> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "function(allocator_arg_t, const _Alloc&, nullptr_t)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (} template<class _Alloc>)",
    "insertText": "function(allocator_arg_t, const _Alloc&, const function&)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (template<class _Alloc>)",
    "insertText": "function(allocator_arg_t, const _Alloc&, function&&)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (template<class _Fp,class _Alloc,class = _EnableIfLValueCallable<_Fp>>)",
    "insertText": "function(allocator_arg_t, const _Alloc& __a, _Fp __f)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# endif function&)",
    "insertText": "operator(const function&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (function&)",
    "insertText": "operator(function&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class _Fp,class = _EnableIfLValueCallable<decay<_Fp>::type>> function&)",
    "insertText": "operator(_Fp&&)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(function&)"
  },
  {
    "label": "assign()",
    "kind": "Method",
    "detail": "Function (# if _LIBCPP_STD_VER<= 1 4 template<class _Fp,class _Alloc> _LIBCPP_INLINE_VISIBILITY void)",
    "insertText": "assign(_Fp&& __f, const _Alloc& __a)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "function(allocator_arg, __a, _VSTD::forward<_Fp>(__f)).swap(*this)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _R2,class . . . _ArgTypes2> bool)",
    "insertText": "operator(const function<_R2(_ArgTypes2...)>&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (public : _Rp)",
    "insertText": "operator()(_ArgTypes...)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (# endif } ; # if _LIBCPP_STD_VER> = 1 7 template<class _Rp,class . . . _Ap>)",
    "insertText": "function(_Rp(*)(_Ap...)) -> function<_Rp(_Ap...)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (template<class _Fp> struct __strip_signature ; template<class _Rp,class _Gp,class . . . _Ap> struct __strip_signature<)",
    "insertText": "_Rp(_Gp::*) (_Ap...)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (using type =)",
    "insertText": "_Rp(_Ap...)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (function<_Stripped>)",
    "insertText": "decltype(&_Fp::operator())>::type> function(_Fp)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (# endif template<class _Rp,class . . . _ArgTypes> function<)",
    "insertText": "_Rp(_ArgTypes...)>::function(const function& __f) : __f_(__f.__f_)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} # if _LIBCPP_STD_VER<= 1 4 template<class _Rp,class . . . _ArgTypes> template<class _Alloc> function<)",
    "insertText": "_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&, const function& __f) : __f_(__f.__f_)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} # endif template<class _Rp,class . . . _ArgTypes> function<)",
    "insertText": "_Rp(_ArgTypes...)>::function(function&& __f) _NOEXCEPT : __f_(_VSTD::move(__f.__f_))"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} # if _LIBCPP_STD_VER<= 1 4 template<class _Rp,class . . . _ArgTypes> template<class _Alloc> function<)",
    "insertText": "_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&, function&& __f) : __f_(_VSTD::move(__f.__f_))"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} # endif template<class _Rp,class . . . _ArgTypes> template<class _Fp,class> function<)",
    "insertText": "_Rp(_ArgTypes...)>::function(_Fp __f) : __f_(_VSTD::move(__f))"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} # if _LIBCPP_STD_VER<= 1 4 template<class _Rp,class . . . _ArgTypes> template<class _Fp,class _Alloc,class> function<)",
    "insertText": "_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc& __a, _Fp __f) : __f_(_VSTD::move(__f), __a)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} # endif template<class _Rp,class . . . _ArgTypes> function<)",
    "insertText": "_Rp(_ArgTypes...)>& function<_Rp(_ArgTypes...)>::operator=(const function& __f)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "function(__f).swap(*this)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (__f_ =)",
    "insertText": "move(__f.__f_)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (__f_ = nullptr ; return* this ; } template<class _Rp,class . . . _ArgTypes> template<class _Fp,class> function<)",
    "insertText": "_Rp(_ArgTypes...)>& function<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "function(_VSTD::forward<_Fp>(__f)).swap(*this)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp,class . . . _ArgTypes> void function<)",
    "insertText": "_Rp(_ArgTypes...)>::swap(function& __f)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (__f_ .)",
    "insertText": "swap(__f.__f_)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp,class . . . _ArgTypes> _Rp function<)",
    "insertText": "_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} # ifndef _LIBCPP_NO_RTTI template<class _Rp,class . . . _ArgTypes> const std::type_info& function<)",
    "insertText": "_Rp(_ArgTypes...)>::target_type()"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp,class . . . _ArgTypes> template<_Tp> _Tp* function<)",
    "insertText": "_Rp(_ArgTypes...)>::target()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif template<class _Rp,class . . . _ArgTypes> _LIBCPP_INLINE_VISIBILITY bool)",
    "insertText": "operator(const function<_Rp(_ArgTypes...)>& __f, nullptr_t)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp,class . . . _ArgTypes> _LIBCPP_INLINE_VISIBILITY bool)",
    "insertText": "operator(nullptr_t, const function<_Rp(_ArgTypes...)>& __f)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp,class . . . _ArgTypes> _LIBCPP_INLINE_VISIBILITY void)",
    "insertText": "swap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # elif)",
    "insertText": "defined(_LIBCPP_ENABLE_CXX03_FUNCTION)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (template<class _Fp> class __base ; template<class _Rp> class __base<)",
    "insertText": "_Rp()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (_Rp)",
    "insertText": "operator()()"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<class _Rp,class _A0> class __base<)",
    "insertText": "_Rp(_A0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (_Rp)",
    "insertText": "operator()(_A0)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<class _Rp,class _A0,class _A1> class __base<)",
    "insertText": "_Rp(_A0, _A1)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (_Rp)",
    "insertText": "operator()(_A0, _A1)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<class _Rp,class _A0,class _A1,class _A2> class __base<)",
    "insertText": "_Rp(_A0, _A1, _A2)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (_Rp)",
    "insertText": "operator()(_A0, _A1, _A2)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<class _FD,class _Alloc,class _FB> class __func ; template<class _Fp,class _Alloc,class _Rp> class __func<_Fp,_Alloc,)",
    "insertText": "_Rp()> : public __base<_Rp()"
  },
  {
    "label": "__func()",
    "kind": "Method",
    "detail": "Function (__compressed_pair<_Fp,_Alloc> __f_ ; public :)",
    "insertText": "__func(_Fp __f) : __f_(_VSTD::move(__f), __default_init_tag())"
  },
  {
    "label": "__func()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "__func(_Fp __f, _Alloc __a) : __f_(_VSTD::move(__f), _VSTD::move(__a))"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} __base<)",
    "insertText": "_Rp()>* __clone()"
  },
  {
    "label": "__clone()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__clone(__base<_Rp()>*)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<class _Fp,class _Alloc,class _Rp> __base<)",
    "insertText": "_Rp()>* __func<_Fp, _Alloc, _Rp()>::__clone()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)__hold.get()) __func(__f_.first(), _Alloc(__a))"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp> void __func<_Fp,_Alloc,)",
    "insertText": "_Rp()>::__clone(__base<_Rp()>* __p)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)__p) __func(__f_.first(), __f_.second())"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp> void __func<_Fp,_Alloc,)",
    "insertText": "_Rp()>::destroy()"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp> void __func<_Fp,_Alloc,)",
    "insertText": "_Rp()>::destroy_deallocate()"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp> _Rp __func<_Fp,_Alloc,)",
    "insertText": "_Rp()>::operator()()"
  },
  {
    "label": "__call()",
    "kind": "Method",
    "detail": "Function (typedef __invoke_void_return_wrapper<_Rp> _Invoker ; return)",
    "insertText": "__call(__f_.first())"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} # ifndef _LIBCPP_NO_RTTI template<class _Fp,class _Alloc,class _Rp> const void* __func<_Fp,_Alloc,)",
    "insertText": "_Rp()>::target(const type_info& __ti)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp> const std::type_info& __func<_Fp,_Alloc,)",
    "insertText": "_Rp()>::target_type()"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} # endif template<class _Fp,class _Alloc,class _Rp,class _A0> class __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0)> : public __base<_Rp(_A0)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} __base<)",
    "insertText": "_Rp(_A0)>* __clone()"
  },
  {
    "label": "__clone()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__clone(__base<_Rp(_A0)>*)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<class _Fp,class _Alloc,class _Rp,class _A0> __base<)",
    "insertText": "_Rp(_A0)>* __func<_Fp, _Alloc, _Rp(_A0)>::__clone()"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class _A0> void __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0)>::__clone(__base<_Rp(_A0)>* __p)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class _A0> void __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0)>::destroy()"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class _A0> void __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0)>::destroy_deallocate()"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class _A0> _Rp __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0)>::operator()(_A0 __a0)"
  },
  {
    "label": "__call()",
    "kind": "Method",
    "detail": "Function (typedef __invoke_void_return_wrapper<_Rp> _Invoker ; return)",
    "insertText": "__call(__f_.first(), __a0)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} # ifndef _LIBCPP_NO_RTTI template<class _Fp,class _Alloc,class _Rp,class _A0> const void* __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0)>::target(const type_info& __ti)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class _A0> const std::type_info& __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0)>::target_type()"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} # endif template<class _Fp,class _Alloc,class _Rp,class _A0,class _A1> class __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0, _A1)> : public __base<_Rp(_A0, _A1)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} __base<)",
    "insertText": "_Rp(_A0, _A1)>* __clone()"
  },
  {
    "label": "__clone()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__clone(__base<_Rp(_A0, _A1)>*)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<class _Fp,class _Alloc,class _Rp,class _A0,class _A1> __base<)",
    "insertText": "_Rp(_A0, _A1)>* __func<_Fp, _Alloc, _Rp(_A0, _A1)>::__clone()"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class _A0,class _A1> void __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0, _A1)>::__clone(__base<_Rp(_A0, _A1)>* __p)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class _A0,class _A1> void __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0, _A1)>::destroy()"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class _A0,class _A1> void __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0, _A1)>::destroy_deallocate()"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class _A0,class _A1> _Rp __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0, _A1)>::operator()(_A0 __a0, _A1 __a1)"
  },
  {
    "label": "__call()",
    "kind": "Method",
    "detail": "Function (typedef __invoke_void_return_wrapper<_Rp> _Invoker ; return)",
    "insertText": "__call(__f_.first(), __a0, __a1)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} # ifndef _LIBCPP_NO_RTTI template<class _Fp,class _Alloc,class _Rp,class _A0,class _A1> const void* __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0, _A1)>::target(const type_info& __ti)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class _A0,class _A1> const std::type_info& __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0, _A1)>::target_type()"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} # endif template<class _Fp,class _Alloc,class _Rp,class _A0,class _A1,class _A2> class __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0, _A1, _A2)> : public __base<_Rp(_A0, _A1, _A2)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} __base<)",
    "insertText": "_Rp(_A0, _A1, _A2)>* __clone()"
  },
  {
    "label": "__clone()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__clone(__base<_Rp(_A0, _A1, _A2)>*)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<class _Fp,class _Alloc,class _Rp,class _A0,class _A1,class _A2> __base<)",
    "insertText": "_Rp(_A0, _A1, _A2)>* __func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::__clone()"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class _A0,class _A1,class _A2> void __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0, _A1, _A2)>::__clone(__base<_Rp(_A0, _A1, _A2)>* __p)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class _A0,class _A1,class _A2> void __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0, _A1, _A2)>::destroy()"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class _A0,class _A1,class _A2> void __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0, _A1, _A2)>::destroy_deallocate()"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class _A0,class _A1,class _A2> _Rp __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0, _A1, _A2)>::operator()(_A0 __a0, _A1 __a1, _A2 __a2)"
  },
  {
    "label": "__call()",
    "kind": "Method",
    "detail": "Function (typedef __invoke_void_return_wrapper<_Rp> _Invoker ; return)",
    "insertText": "__call(__f_.first(), __a0, __a1, __a2)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} # ifndef _LIBCPP_NO_RTTI template<class _Fp,class _Alloc,class _Rp,class _A0,class _A1,class _A2> const void* __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0, _A1, _A2)>::target(const type_info& __ti)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp,class _Alloc,class _Rp,class _A0,class _A1,class _A2> const std::type_info& __func<_Fp,_Alloc,)",
    "insertText": "_Rp(_A0, _A1, _A2)>::target_type()"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (__base* __f_ ; public : typedef _Rp result_type ; _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "function() : __f_(0)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "function(nullptr_t) : __f_(0)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (template<class _Fp>)",
    "insertText": "function(_Fp, typename enable_if<!is_integral<_Fp>::value>::type* = 0)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (template<class _Alloc> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "function(allocator_arg_t, const _Alloc&) : __f_(0)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (} template<class _Alloc> _LIBCPP_INLINE_VISIBILITY)",
    "insertText": "function(allocator_arg_t, const _Alloc&, nullptr_t) : __f_(0)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (template<class _Fp,class _Alloc>)",
    "insertText": "function(allocator_arg_t, const _Alloc& __a, _Fp __f, typename enable_if<!is_integral<_Fp>::value>::type* = 0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class _Fp> enable_if<! is_integral<_Fp>::value,function&>::type)",
    "insertText": "operator(_Fp)"
  },
  {
    "label": "assign()",
    "kind": "Method",
    "detail": "Function (template<class _Fp,class _Alloc> _LIBCPP_INLINE_VISIBILITY void)",
    "insertText": "assign(_Fp __f, const _Alloc& __a)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "function(allocator_arg, __a, __f).swap(*this)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class _R2> bool)",
    "insertText": "operator(const function<_R2()>&)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<class _Rp> function<)",
    "insertText": "_Rp()>::function(const function& __f)"
  },
  {
    "label": "__f_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__f_(__base*)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp> template<class _Alloc> function<)",
    "insertText": "_Rp()>::function(allocator_arg_t, const _Alloc&, const function& __f)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp> template<class _Fp> function<)",
    "insertText": "_Rp()>::function(_Fp __f, typename enable_if<!is_integral<_Fp>::value>::type*) : __f_(0)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)__f_) _FF(__f)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)__hold.get()) _FF(__f, allocator<_Fp>(__a))"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} } } template<class _Rp> template<class _Fp,class _Alloc> function<)",
    "insertText": "_Rp()>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f, typename enable_if<!is_integral<_Fp>::value>::type*) : __f_(0)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)__f_) _FF(__f, __a0)"
  },
  {
    "label": "__a()",
    "kind": "Method",
    "detail": "Function (} else { typedef __rebind_alloc_helper<__alloc_traits,_FF>::type _Ap ; _Ap)",
    "insertText": "__a(__a0)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)__hold.get()) _FF(__f, _Alloc(__a))"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} } } template<class _Rp> function<)",
    "insertText": "_Rp()>& function<_Rp()>::operator=(const function& __f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (__base* __t = __f_ ; __f_ = 0 ;)",
    "insertText": "if(__t == (__base*)&__buf_) __t->destroy()"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "function(_VSTD::move(__f)).swap(*this)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp> void function<)",
    "insertText": "_Rp()>::swap(function& __f)"
  },
  {
    "label": "__t()",
    "kind": "Method",
    "detail": "Function (__base*)",
    "insertText": "__t(__base*)"
  },
  {
    "label": "__clone()",
    "kind": "Method",
    "detail": "Function (__f_ = 0 ; __f . __f_ ->)",
    "insertText": "__clone((__base*)&__buf_)"
  },
  {
    "label": "__clone()",
    "kind": "Method",
    "detail": "Function (__t ->)",
    "insertText": "__clone((__base*)&__f.__buf_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(__f_ == (__base*)&__buf_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(__f.__f_ == (__base*)&__f.__buf_)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp> template<_Tp> _Tp* function<)",
    "insertText": "_Rp()>::target()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class _R2,class _B0> bool)",
    "insertText": "operator(const function<_R2(_B0)>&)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<class _Rp,class _A0> function<)",
    "insertText": "_Rp(_A0)>::function(const function& __f)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp,class _A0> template<class _Alloc> function<)",
    "insertText": "_Rp(_A0)>::function(allocator_arg_t, const _Alloc&, const function& __f)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp,class _A0> template<class _Fp> function<)",
    "insertText": "_Rp(_A0)>::function(_Fp __f, typename enable_if<!is_integral<_Fp>::value>::type*) : __f_(0)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} } } template<class _Rp,class _A0> template<class _Fp,class _Alloc> function<)",
    "insertText": "_Rp(_A0)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f, typename enable_if<!is_integral<_Fp>::value>::type*) : __f_(0)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} } } template<class _Rp,class _A0> function<)",
    "insertText": "_Rp(_A0)>& function<_Rp(_A0)>::operator=(const function& __f)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp,class _A0> void function<)",
    "insertText": "_Rp(_A0)>::swap(function& __f)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp,class _A0> template<_Tp> _Tp* function<)",
    "insertText": "_Rp(_A0)>::target()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class _R2,class _B0,class _B1> bool)",
    "insertText": "operator(const function<_R2(_B0, _B1)>&)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<class _Rp,class _A0,class _A1> function<)",
    "insertText": "_Rp(_A0, _A1)>::function(const function& __f)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp,class _A0,class _A1> template<class _Alloc> function<)",
    "insertText": "_Rp(_A0, _A1)>::function(allocator_arg_t, const _Alloc&, const function& __f)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp,class _A0,class _A1> template<class _Fp> function<)",
    "insertText": "_Rp(_A0, _A1)>::function(_Fp __f, typename enable_if<!is_integral<_Fp>::value>::type*) : __f_(0)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} } } template<class _Rp,class _A0,class _A1> template<class _Fp,class _Alloc> function<)",
    "insertText": "_Rp(_A0, _A1)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f, typename enable_if<!is_integral<_Fp>::value>::type*) : __f_(0)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} } } template<class _Rp,class _A0,class _A1> function<)",
    "insertText": "_Rp(_A0, _A1)>& function<_Rp(_A0, _A1)>::operator=(const function& __f)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp,class _A0,class _A1> void function<)",
    "insertText": "_Rp(_A0, _A1)>::swap(function& __f)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp,class _A0,class _A1> template<_Tp> _Tp* function<)",
    "insertText": "_Rp(_A0, _A1)>::target()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class _R2,class _B0,class _B1,class _B2> bool)",
    "insertText": "operator(const function<_R2(_B0, _B1, _B2)>&)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<class _Rp,class _A0,class _A1,class _A2> function<)",
    "insertText": "_Rp(_A0, _A1, _A2)>::function(const function& __f)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp,class _A0,class _A1,class _A2> template<class _Alloc> function<)",
    "insertText": "_Rp(_A0, _A1, _A2)>::function(allocator_arg_t, const _Alloc&, const function& __f)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp,class _A0,class _A1,class _A2> template<class _Fp> function<)",
    "insertText": "_Rp(_A0, _A1, _A2)>::function(_Fp __f, typename enable_if<!is_integral<_Fp>::value>::type*) : __f_(0)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} } } template<class _Rp,class _A0,class _A1,class _A2> template<class _Fp,class _Alloc> function<)",
    "insertText": "_Rp(_A0, _A1, _A2)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f, typename enable_if<!is_integral<_Fp>::value>::type*) : __f_(0)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} } } template<class _Rp,class _A0,class _A1,class _A2> function<)",
    "insertText": "_Rp(_A0, _A1, _A2)>& function<_Rp(_A0, _A1, _A2)>::operator=(const function& __f)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp,class _A0,class _A1,class _A2> void function<)",
    "insertText": "_Rp(_A0, _A1, _A2)>::swap(function& __f)"
  },
  {
    "label": "_Rp()",
    "kind": "Method",
    "detail": "Function (} template<class _Rp,class _A0,class _A1,class _A2> template<_Tp> _Tp* function<)",
    "insertText": "_Rp(_A0, _A1, _A2)>::target()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif template<class _Fp> _LIBCPP_INLINE_VISIBILITY bool)",
    "insertText": "operator(const function<_Fp>& __f, nullptr_t)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp> _LIBCPP_INLINE_VISIBILITY bool)",
    "insertText": "operator(nullptr_t, const function<_Fp>& __f)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} template<class _Fp> _LIBCPP_INLINE_VISIBILITY void)",
    "insertText": "swap(function<_Fp>& __x, function<_Fp>& __y)"
  }
]