[
  {
    "label": "SparseMatrix",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseMatrix"
  },
  {
    "label": "DynamicSparseMatrix",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DynamicSparseMatrix"
  },
  {
    "label": "SparseVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseVector"
  },
  {
    "label": "MappedSparseMatrix",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MappedSparseMatrix"
  },
  {
    "label": "SparseSelfAdjointView",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseSelfAdjointView"
  },
  {
    "label": "SparseDiagonalProduct",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseDiagonalProduct"
  },
  {
    "label": "SparseView",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseView"
  },
  {
    "label": "SparseSparseProduct",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseSparseProduct"
  },
  {
    "label": "SparseTimeDenseProduct",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseTimeDenseProduct"
  },
  {
    "label": "DenseTimeSparseProduct",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DenseTimeSparseProduct"
  },
  {
    "label": "SparseDenseOuterProduct",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseDenseOuterProduct"
  },
  {
    "label": "SparseSparseProductReturnType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SparseSparseProductReturnType"
  },
  {
    "label": "DenseSparseProductReturnType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DenseSparseProductReturnType"
  },
  {
    "label": "SparseDenseProductReturnType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SparseDenseProductReturnType"
  },
  {
    "label": "SparseSymmetricPermutationProduct",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseSymmetricPermutationProduct"
  },
  {
    "label": "sparse_eval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "sparse_eval"
  },
  {
    "label": "eval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "eval"
  },
  {
    "label": "plain_matrix_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "plain_matrix_type"
  },
  {
    "label": "plain_object_eval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "plain_object_eval"
  },
  {
    "label": "solve_traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "solve_traits"
  },
  {
    "label": "generic_xpr_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "generic_xpr_base"
  },
  {
    "label": "SparseTriangularShape",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SparseTriangularShape"
  },
  {
    "label": "SparseSelfAdjointShape",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SparseSelfAdjointShape"
  },
  {
    "label": "glue_shapes",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "glue_shapes"
  },
  {
    "label": "LowerBoundIndex",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LowerBoundIndex"
  },
  {
    "label": "Triplet",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Triplet"
  },
  {
    "label": "EIGEN_DBG_SPARSE()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_SPARSEUTIL_H # define EIGEN_SPARSEUTIL_H namespace Eigen { # ifdef NDEBUG # define)",
    "insertText": "EIGEN_DBG_SPARSE(X) #else #define EIGEN_DBG_SPARSE(X) X #endif #define EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATOR(Derived, Op) \\ template<typename OtherDerived> \\ EIGEN_STRONG_INLINE Derived& operator Op(const Eigen::SparseMatrixBase<OtherDerived>& other)"
  },
  {
    "label": "Op()",
    "kind": "Method",
    "detail": "Function (\\ return Base::operator)",
    "insertText": "Op(other.derived())"
  },
  {
    "label": "Op()",
    "kind": "Method",
    "detail": "Function (\\ } \\ EIGEN_STRONG_INLINE Derived& operator)",
    "insertText": "Op(const Derived& other)"
  },
  {
    "label": "Op()",
    "kind": "Method",
    "detail": "Function (\\ return Base::operator)",
    "insertText": "Op(other)"
  },
  {
    "label": "EIGEN_SPARSE_INHERIT_SCALAR_ASSIGNMENT_OPERATOR()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "EIGEN_SPARSE_INHERIT_SCALAR_ASSIGNMENT_OPERATOR(Derived, Op) \\ template<typename Other> \\ EIGEN_STRONG_INLINE Derived& operator Op(const Other& scalar)"
  },
  {
    "label": "Op()",
    "kind": "Method",
    "detail": "Function (\\ return Base::operator)",
    "insertText": "Op(scalar)"
  },
  {
    "label": "EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATORS()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATORS(Derived) \\ EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATOR(Derived, =) #define EIGEN_SPARSE_PUBLIC_INTERFACE(Derived) \\ EIGEN_GENERIC_PUBLIC_INTERFACE(Derived)"
  },
  {
    "label": "EIGEN_SIZE_MIN_PREFER_FIXED()",
    "kind": "Method",
    "detail": "Function (const int InnerRandomAccessPattern = 0 x2 | CoherentAccessPattern ; const int OuterRandomAccessPattern = 0 x4 | CoherentAccessPattern ; const int RandomAccessPattern = 0 x8 | OuterRandomAccessPattern | InnerRandomAccessPattern ; template<_Scalar,int _Flags = 0,_StorageIndex = int> class SparseMatrix ; template<_Scalar,int _Flags = 0,_StorageIndex = int> class DynamicSparseMatrix ; template<_Scalar,int _Flags = 0,_StorageIndex = int> class SparseVector ; template<_Scalar,int _Flags = 0,_StorageIndex = int> class MappedSparseMatrix ; template<MatrixType,unsigned int UpLo> class SparseSelfAdjointView ; template<Lhs,Rhs> class SparseDiagonalProduct ; template<MatrixType> class SparseView ; template<Lhs,Rhs> class SparseSparseProduct ; template<Lhs,Rhs> class SparseTimeDenseProduct ; template<Lhs,Rhs> class DenseTimeSparseProduct ; template<Lhs,Rhs,bool Transpose> class SparseDenseOuterProduct ; template<Lhs,Rhs> struct SparseSparseProductReturnType ; template<Lhs,Rhs,int InnerSize =)",
    "insertText": "EIGEN_SIZE_MIN_PREFER_FIXED(internal::traits<Lhs>::ColsAtCompileTime,internal::traits<Rhs>::RowsAtCompileTime)"
  },
  {
    "label": "_Options()",
    "kind": "Method",
    "detail": "Function (template<MatrixType,int UpLo> class SparseSymmetricPermutationProduct ; namespace internal { template<T,int Rows,int Cols,int Flags> struct sparse_eval ; template<T> struct eval<T,Sparse> : sparse_eval<T,traits<T>::RowsAtCompileTime,traits<T>::ColsAtCompileTime,traits<T>::Flags> { } ; template<T,int Cols,int Flags> struct sparse_eval<T,1,Cols,Flags> { typedef traits<T>::Scalar _Scalar ; typedef traits<T>::StorageIndex _StorageIndex ; public : typedef SparseVector<_Scalar,RowMajor,_StorageIndex> type ; } ; template<T,int Rows,int Flags> struct sparse_eval<T,Rows,1,Flags> { typedef traits<T>::Scalar _Scalar ; typedef traits<T>::StorageIndex _StorageIndex ; public : typedef SparseVector<_Scalar,ColMajor,_StorageIndex> type ; } ; template<T,int Rows,int Cols,int Flags> struct sparse_eval { typedef traits<T>::Scalar _Scalar ; typedef traits<T>::StorageIndex _StorageIndex ; enum {)",
    "insertText": "_Options((Flags&RowMajorBit)==RowMajorBit)"
  },
  {
    "label": "_Options()",
    "kind": "Method",
    "detail": "Function (public : typedef SparseMatrix<_Scalar,_Options,_StorageIndex> type ; } ; template<T,int Flags> struct sparse_eval<T,1,1,Flags> { typedef traits<T>::Scalar _Scalar ; public : typedef Matrix<_Scalar,1,1> type ; } ; template<T> struct plain_matrix_type<T,Sparse> { typedef traits<T>::Scalar _Scalar ; typedef traits<T>::StorageIndex _StorageIndex ; enum {)",
    "insertText": "_Options((evaluator<T>::Flags&RowMajorBit)==RowMajorBit)"
  },
  {
    "label": "debugName()",
    "kind": "Method",
    "detail": "Function (public : typedef SparseMatrix<_Scalar,_Options,_StorageIndex> type ; } ; template<T> struct plain_object_eval<T,Sparse> : sparse_eval<T,traits<T>::RowsAtCompileTime,traits<T>::ColsAtCompileTime,evaluator<T>::Flags> { } ; template<Decomposition,RhsType> struct solve_traits<Decomposition,RhsType,Sparse> { typedef sparse_eval<RhsType,RhsType::RowsAtCompileTime,RhsType::ColsAtCompileTime,traits<RhsType>::Flags>::type PlainObject ; } ; template<Derived> struct generic_xpr_base<Derived,MatrixXpr,Sparse> { typedef SparseMatrixBase<Derived> type ; } ; struct SparseTriangularShape { std::string)",
    "insertText": "debugName()"
  },
  {
    "label": "LowerBoundIndex()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "LowerBoundIndex(Index val, bool ok) : value(val), found(ok)"
  },
  {
    "label": "Triplet()",
    "kind": "Method",
    "detail": "Function (} Index value ; bool found ; } ; } template<Scalar,StorageIndex = SparseMatrix<Scalar>::StorageIndex> class Triplet { public :)",
    "insertText": "Triplet() : m_row(0), m_col(0), m_value(0)"
  },
  {
    "label": "Triplet()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Triplet(const StorageIndex& i, const StorageIndex& j, const Scalar& v = Scalar(0)) : m_row(i), m_col(j), m_value(v)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (} const StorageIndex&)",
    "insertText": "row()"
  }
]