[
  {
    "label": "FrameSchedulingReceiver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FrameSchedulingReceiver"
  },
  {
    "label": "VideoStreamBufferController",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VideoStreamBufferController"
  },
  {
    "label": "FrameSchedulingReceiver()",
    "kind": "Method",
    "detail": "Function (# ifndef VIDEO_VIDEO_STREAM_BUFFER_CONTROLLER_H_ # define VIDEO_VIDEO_STREAM_BUFFER_CONTROLLER_H_ # include<memory> # include \" api / field_trials_view . h \" # include \" api / task_queue / task_queue_base . h \" # include \" api / video / encoded_frame . h \" # include \" api / video / frame_buffer . h \" # include \" modules / video_coding / include / video_coding_defines . h \" # include \" modules / video_coding / timing / inter_frame_delay . h \" # include \" modules / video_coding / timing / jitter_estimator . h \" # include \" modules / video_coding / timing / timing . h \" # include \" rtc_base / experiments / rtt_mult_experiment . h \" # include \" system_wrappers / include / clock . h \" # include \" video / decode_synchronizer . h \" # include \" video / video_receive_stream_timeout_tracker . h \" namespace webrtc { class FrameSchedulingReceiver { public : ~)",
    "insertText": "FrameSchedulingReceiver()"
  },
  {
    "label": "OnEncodedFrame()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnEncodedFrame(std::unique_ptr<EncodedFrame> frame)"
  },
  {
    "label": "OnDecodableFrameTimeout()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnDecodableFrameTimeout(TimeDelta wait_time)"
  },
  {
    "label": "VideoStreamBufferController()",
    "kind": "Method",
    "detail": "Function (} ; class VideoStreamBufferController { public :)",
    "insertText": "VideoStreamBufferController(Clock* clock, TaskQueueBase* worker_queue, VCMTiming* timing, VCMReceiveStatisticsCallback* stats_proxy, FrameSchedulingReceiver* receiver, TimeDelta max_wait_for_keyframe, TimeDelta max_wait_for_frame, std::unique_ptr<FrameDecodeScheduler> frame_decode_scheduler, const FieldTrialsView& field_trials)"
  },
  {
    "label": "VideoStreamBufferController()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "VideoStreamBufferController()"
  },
  {
    "label": "Stop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Stop()"
  },
  {
    "label": "SetProtectionMode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetProtectionMode(VCMVideoProtection protection_mode)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Clear()"
  },
  {
    "label": "InsertFrame()",
    "kind": "Method",
    "detail": "Function (absl::optional<int64_t>)",
    "insertText": "InsertFrame(std::unique_ptr<EncodedFrame> frame)"
  },
  {
    "label": "UpdateRtt()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateRtt(int64_t max_rtt_ms)"
  },
  {
    "label": "SetMaxWaits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMaxWaits(TimeDelta max_wait_for_keyframe, TimeDelta max_wait_for_frame)"
  },
  {
    "label": "StartNextDecode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StartNextDecode(bool keyframe_required)"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "Size()"
  },
  {
    "label": "OnFrameReady()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "OnFrameReady(absl::InlinedVector<std::unique_ptr<EncodedFrame>, 4> frames, Timestamp render_time)"
  },
  {
    "label": "OnTimeout()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnTimeout(TimeDelta delay)"
  },
  {
    "label": "FrameReadyForDecode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FrameReadyForDecode(uint32_t rtp_timestamp, Timestamp render_time)"
  },
  {
    "label": "UpdateDroppedFrames()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateDroppedFrames() RTC_RUN_ON(&worker_sequence_checker_)"
  },
  {
    "label": "UpdateJitterDelay()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateJitterDelay()"
  },
  {
    "label": "UpdateTimingFrameInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateTimingFrameInfo()"
  },
  {
    "label": "IsTooManyFramesQueued()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsTooManyFramesQueued() const RTC_RUN_ON(&worker_sequence_checker_)"
  },
  {
    "label": "ForceKeyFrameReleaseImmediately()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ForceKeyFrameReleaseImmediately() RTC_RUN_ON(&worker_sequence_checker_)"
  },
  {
    "label": "MaybeScheduleFrameForRelease()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MaybeScheduleFrameForRelease() RTC_RUN_ON(&worker_sequence_checker_)"
  },
  {
    "label": "GetRttMultValue()",
    "kind": "Method",
    "detail": "Function (RTC_NO_UNIQUE_ADDRESS SequenceChecker worker_sequence_checker_ ; const FieldTrialsView& field_trials_ ; const absl::optional<RttMultExperiment::Settings> rtt_mult_settings_ =)",
    "insertText": "GetRttMultValue()"
  },
  {
    "label": "RTC_GUARDED_BY()",
    "kind": "Method",
    "detail": "Function (Clock* const clock_ ; VCMReceiveStatisticsCallback* const stats_proxy_ ; FrameSchedulingReceiver* const receiver_ ; VCMTiming* const timing_ ; const std::unique_ptr<FrameDecodeScheduler> frame_decode_scheduler_)",
    "insertText": "RTC_GUARDED_BY(&worker_sequence_checker_)"
  }
]