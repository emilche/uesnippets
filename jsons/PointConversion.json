[
  {
    "label": "is",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "is"
  },
  {
    "label": "PointAttributeVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PointAttributeVector"
  },
  {
    "label": "ConversionTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ConversionTraits"
  },
  {
    "label": "ConversionTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ConversionTraits"
  },
  {
    "label": "PopulateAttributeOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PopulateAttributeOp"
  },
  {
    "label": "ConvertPointDataGridPositionOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ConvertPointDataGridPositionOp"
  },
  {
    "label": "ConvertPointDataGridAttributeOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ConvertPointDataGridAttributeOp"
  },
  {
    "label": "ConvertPointDataGridGroupOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ConvertPointDataGridGroupOp"
  },
  {
    "label": "CalculatePositionBounds",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CalculatePositionBounds"
  },
  {
    "label": "Local",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Local"
  },
  {
    "label": "createPointDataGrid()",
    "kind": "Method",
    "detail": "Function (PointDataGridT::Ptr)",
    "insertText": "createPointDataGrid(const PointIndexGridT& pointIndexGrid,\n                    const PositionArrayT& positions,\n                    const math::Transform& xform,\n                    const Metadata* positionDefaultValue = nullptr)"
  },
  {
    "label": "createPointDataGrid()",
    "kind": "Method",
    "detail": "Function (PointDataGridT::Ptr)",
    "insertText": "createPointDataGrid(const std::vector<ValueT>& positions,\n                    const math::Transform& xform,\n                    const Metadata* positionDefaultValue = nullptr)"
  },
  {
    "label": "populateAttribute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "populateAttribute(  PointDataTreeT& tree,\n                    const PointIndexTreeT& pointIndexTree,\n                    const openvdb::Name& attributeName,\n                    const PointArrayT& data,\n                    const Index stride = 1,\n                    const bool insertMetadata = true)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (ValueType)",
    "insertText": "static_assert(VecTraits<ValueType>::Size == 3 &&\n                      std::is_floating_point<typename ValueType::ValueType>::value,\n                      \"ValueType is not Vec3f\")"
  },
  {
    "label": "pHandle()",
    "kind": "Method",
    "detail": "Function (HandleT)",
    "insertText": "pHandle(mAttribute)"
  },
  {
    "label": "pHandle()",
    "kind": "Method",
    "detail": "Function (HandleT)",
    "insertText": "pHandle(mAttribute)"
  },
  {
    "label": "BBoxd()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "BBoxd(mMin, mMax)"
  },
  {
    "label": "leafManager()",
    "kind": "Method",
    "detail": "Function (LeafManagerT)",
    "insertText": "leafManager(*treePtr)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (leaf)",
    "insertText": "for(auto iter = pointIndexLeaf->cbeginValueOn()"
  },
  {
    "label": "positionVoxelSpace()",
    "kind": "Method",
    "detail": "Function (Vec3f)",
    "insertText": "positionVoxelSpace(positionIndexSpace - positionCellCenter)"
  },
  {
    "label": "pointList()",
    "kind": "Method",
    "detail": "Function (PointAttributeVector<ValueT>)",
    "insertText": "pointList(positions)"
  },
  {
    "label": "leafManager()",
    "kind": "Method",
    "detail": "Function (tree::LeafManager<PointDataTreeT>)",
    "insertText": "leafManager(tree)"
  },
  {
    "label": "populate()",
    "kind": "Method",
    "detail": "Function (PointArrayT>)",
    "insertText": "populate(pointIndexTree, data, index, stride)"
  },
  {
    "label": "leafManager()",
    "kind": "Method",
    "detail": "Function (LeafManagerT)",
    "insertText": "leafManager(tree)"
  },
  {
    "label": "leafManager()",
    "kind": "Method",
    "detail": "Function (LeafManagerT)",
    "insertText": "leafManager(tree)"
  },
  {
    "label": "convert()",
    "kind": "Method",
    "detail": "Function (FilterT>)",
    "insertText": "convert(\n                        attribute, pointOffsets, startOffset, arrayIndex, stride,\n                        filter, inCoreOnly)"
  },
  {
    "label": "leafManager()",
    "kind": "Method",
    "detail": "Function (LeafManagerT)",
    "insertText": "leafManager(tree)"
  },
  {
    "label": "convert()",
    "kind": "Method",
    "detail": "Function (FilterT>)",
    "insertText": "convert(\n                    group, pointOffsets, startOffset, index,\n                    filter, inCoreOnly)"
  },
  {
    "label": "minimumVoxelVolume()",
    "kind": "Method",
    "detail": "Function (double)",
    "insertText": "minimumVoxelVolume(3e-15)"
  },
  {
    "label": "voxelSize()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "voxelSize(0.1f)"
  },
  {
    "label": "range()",
    "kind": "Method",
    "detail": "Function (tbb::blocked_range<size_t>)",
    "insertText": "range(0, numPoints)"
  },
  {
    "label": "calculateBounds()",
    "kind": "Method",
    "detail": "Function (CalculatePositionBounds<PositionWrapper>)",
    "insertText": "calculateBounds(positions, inverseTransform)"
  },
  {
    "label": "previousVoxelCount()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "previousVoxelCount(0)"
  },
  {
    "label": "voxelCount()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "voxelCount(1)"
  },
  {
    "label": "matrix()",
    "kind": "Method",
    "detail": "Function (math::Mat4d)",
    "insertText": "matrix(transform)"
  },
  {
    "label": "pointMaskOp()",
    "kind": "Method",
    "detail": "Function (InterrupterT>)",
    "insertText": "pointMaskOp(*mask, interrupter)"
  }
]