[
  {
    "label": "FPointIntersection",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPointIntersection"
  },
  {
    "label": "FSegmentIntersection",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSegmentIntersection"
  },
  {
    "label": "FPolygonIntersection",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPolygonIntersection"
  },
  {
    "label": "FIntersectionsQueryResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FIntersectionsQueryResult"
  },
  {
    "label": "TriangleMeshType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TriangleMeshType"
  },
  {
    "label": "TFastWindingTree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TFastWindingTree"
  },
  {
    "label": "TMeshAABBTree3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TMeshAABBTree3"
  },
  {
    "label": "FTreeTraversal",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTreeTraversal"
  },
  {
    "label": "FBoxesSet",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBoxesSet"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Util / DynamicVector . h \" # include \" Intersection / IntrRay3AxisAlignedBox3 . h \" # include \" Intersection / IntrTriangle3Triangle3 . h \" # include \" Intersection / IntersectionUtil . h \" # include \" MeshQueries . h \" # include \" Spatial / SpatialInterfaces . h \" # include \" Distance / DistTriangle3Triangle3 . h \" namespace MeshIntersection { using namespace UE::Geometry ; struct FPointIntersection { int TriangleID [ 2 ] ; FVector3d Point ; } ; struct FSegmentIntersection { int TriangleID [ 2 ] ; FVector3d Point [ 2 ] ; } ; struct FPolygonIntersection { int TriangleID [ 2 ] ; FVector3d Point [ 6 ] ; int Quantity ; } ; struct FIntersectionsQueryResult { TArray<FPointIntersection> Points ; TArray<FSegmentIntersection> Segments ; TArray<FPolygonIntersection> Polygons ; } ; } namespace UE { namespace Geometry { using namespace UE::Math ; template<class TriangleMeshType> class TFastWindingTree ; template<class TriangleMeshType> class TMeshAABBTree3 : public IMeshSpatial { class TFastWindingTree<TriangleMeshType> ; public : using MeshType = TriangleMeshType ; using GetSplitAxisFunc = TUniqueFunction<)",
    "insertText": "int(int Depth, const FAxisAlignedBox3d& Box)"
  },
  {
    "label": "MakeDefaultSplitAxisFunc()",
    "kind": "Method",
    "detail": "Function (protected : const TriangleMeshType* Mesh ; uint64 MeshChangeStamp = 0 ; int TopDownLeafMaxTriCount = 3 ; GetSplitAxisFunc)",
    "insertText": "MakeDefaultSplitAxisFunc()"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (public : double DOUBLE_MAX = TNumericLimits<double)",
    "insertText": "Max()"
  },
  {
    "label": "TMeshAABBTree3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TMeshAABBTree3()"
  },
  {
    "label": "TMeshAABBTree3()",
    "kind": "Method",
    "detail": "Function (Mesh = nullptr ; })",
    "insertText": "TMeshAABBTree3(const TriangleMeshType* SourceMesh, bool bAutoBuild = true)"
  },
  {
    "label": "SetMesh()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMesh(SourceMesh, bAutoBuild)"
  },
  {
    "label": "SetMesh()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetMesh(const TriangleMeshType* SourceMesh, bool bAutoBuild = true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Mesh = SourceMesh ; MeshChangeStamp = 0 ;)",
    "insertText": "if(bAutoBuild)"
  },
  {
    "label": "Build()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Build()"
  },
  {
    "label": "GetMesh()",
    "kind": "Method",
    "detail": "Function (} } const TriangleMeshType*)",
    "insertText": "GetMesh()"
  },
  {
    "label": "SetBuildOptions()",
    "kind": "Method",
    "detail": "Function (} return true ; } void)",
    "insertText": "SetBuildOptions(int32 MaxBoxTriCount, GetSplitAxisFunc&& GetSplitAxisIn = MakeDefaultSplitAxisFunc())"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (TopDownLeafMaxTriCount = MaxBoxTriCount ; GetSplitAxis =)",
    "insertText": "MoveTemp(GetSplitAxisIn)"
  },
  {
    "label": "BuildTopDown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BuildTopDown(false)"
  },
  {
    "label": "GetChangeStamp()",
    "kind": "Method",
    "detail": "Function (MeshChangeStamp = Mesh ->)",
    "insertText": "GetChangeStamp()"
  },
  {
    "label": "Build()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Build(const TArray<int32>& TriangleList)"
  },
  {
    "label": "BuildTopDown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BuildTopDown(false, TriangleList, TriangleList.Num())"
  },
  {
    "label": "SupportsNearestTriangle()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "SupportsNearestTriangle()"
  },
  {
    "label": "find_nearest_tri()",
    "kind": "Method",
    "detail": "Function (int tNearID = IndexConstants::InvalidID ;)",
    "insertText": "find_nearest_tri(RootIndex, P, NearestDistSqr, tNearID, Options)"
  },
  {
    "label": "GetBox()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "GetBox(RootIndex)"
  },
  {
    "label": "FindNearestPoint()",
    "kind": "Method",
    "detail": "Function (} } FVector3d)",
    "insertText": "FindNearestPoint(const FVector3d& Point, const FQueryOptions& Options = FQueryOptions())"
  },
  {
    "label": "TriangleDistance()",
    "kind": "Method",
    "detail": "Function (FDistPoint3Triangle3d Query = TMeshQueries<TriangleMeshType)",
    "insertText": "TriangleDistance(*Mesh, NearTriID, Point)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int idx = BoxToIndex [ IBox ] ;)",
    "insertText": "if(idx < TrianglesEnd)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int num_tris = IndexList [ idx ] ;)",
    "insertText": "for(int i = 1; i <= num_tris; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int ti = IndexList [ idx + i ] ;)",
    "insertText": "if(Options.TriangleFilterF != nullptr && Options.TriangleFilterF(ti) == false)"
  },
  {
    "label": "TriDistanceSqr()",
    "kind": "Method",
    "detail": "Function (continue ; } double fTriDistSqr = TMeshQueries<TriangleMeshType)",
    "insertText": "TriDistanceSqr(*Mesh, ti, P)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (NearestDistSqr = fTriDistSqr ; TID = ti ; if)",
    "insertText": "constexpr(bEarlyStop)"
  },
  {
    "label": "iChild1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "iChild1(-iChild1)"
  },
  {
    "label": "bEarlyStop()",
    "kind": "Method",
    "detail": "Function (bool bFoundEarly = find_nearest_tri<)",
    "insertText": "bEarlyStop(iChild1, P, NearestDistSqr, TID, Options)"
  },
  {
    "label": "bEarlyStop()",
    "kind": "Method",
    "detail": "Function (bool bFoundEarly2 = find_nearest_tri<)",
    "insertText": "bEarlyStop(iChild2, P, NearestDistSqr, TID, Options)"
  },
  {
    "label": "find_nearest_vertex()",
    "kind": "Method",
    "detail": "Function (int NearestVertexID = IndexConstants::InvalidID ;)",
    "insertText": "find_nearest_vertex(RootIndex, P, NearestDistSqr, NearestVertexID, Options)"
  },
  {
    "label": "GetTriangle()",
    "kind": "Method",
    "detail": "Function (continue ; } FIndex3i Triangle = Mesh ->)",
    "insertText": "GetTriangle(ti)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NearestDistSqr = VertexDistSqr ; NearestVertexID = Triangle [ j ] ; } } } } else { int iChild1 = IndexList [ idx ] ;)",
    "insertText": "if(iChild1 < 0)"
  },
  {
    "label": "find_nearest_vertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "find_nearest_vertex(iChild1, P, NearestDistSqr, NearestVertexID, Options)"
  },
  {
    "label": "BoxDistanceSqr()",
    "kind": "Method",
    "detail": "Function (} } else { iChild1 = iChild1 - 1 ; int iChild2 = IndexList [ idx + 1 ] - 1 ; double fChild1DistSqr =)",
    "insertText": "BoxDistanceSqr(iChild1, P)"
  },
  {
    "label": "find_nearest_vertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "find_nearest_vertex(iChild2, P, NearestDistSqr, NearestVertexID, Options)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } else {)",
    "insertText": "if(fChild2DistSqr < NearestDistSqr)"
  },
  {
    "label": "SupportsTriangleRayIntersection()",
    "kind": "Method",
    "detail": "Function (} } } } } } public : bool)",
    "insertText": "SupportsTriangleRayIntersection()"
  },
  {
    "label": "FindNearestHitTriangle()",
    "kind": "Method",
    "detail": "Function (FVector3d BaryCoords ; return)",
    "insertText": "FindNearestHitTriangle(Ray, NearestT, TID, BaryCoords, Options)"
  },
  {
    "label": "FindNearestHitTriangle()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "FindNearestHitTriangle(const FRay3d& Ray, double& NearestT, int& TID, FVector3d& BaryCoords, const FQueryOptions& Options = FQueryOptions())"
  },
  {
    "label": "Zero()",
    "kind": "Method",
    "detail": "Function (TID = IndexConstants::InvalidID ; BaryCoords =)",
    "insertText": "Zero()"
  },
  {
    "label": "NearestT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NearestT(Options.MaxDistance < TNumericLimits<float>::Max()) ? Options.MaxDistance : TNumericLimits<float>::Max()"
  },
  {
    "label": "GetTriVertices()",
    "kind": "Method",
    "detail": "Function (continue ; } Mesh ->)",
    "insertText": "GetTriVertices(ti, Triangle.V[0], Triangle.V[1], Triangle.V[2])"
  },
  {
    "label": "FIntrRay3Triangle3d()",
    "kind": "Method",
    "detail": "Function (FIntrRay3Triangle3d Query =)",
    "insertText": "FIntrRay3Triangle3d(Ray, Triangle)"
  },
  {
    "label": "FindHitTriangle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindHitTriangle(iChild1, Ray, NearestT, TID, BaryCoords, Options)"
  },
  {
    "label": "box_ray_intersect_t()",
    "kind": "Method",
    "detail": "Function (} } else { iChild1 = iChild1 - 1 ; int iChild2 = IndexList [ idx + 1 ] - 1 ; double fChild1T =)",
    "insertText": "box_ray_intersect_t(iChild1, Ray)"
  },
  {
    "label": "FindHitTriangle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindHitTriangle(iChild2, Ray, NearestT, TID, BaryCoords, Options)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } else {)",
    "insertText": "if(fChild2T <= NearestT + e)"
  },
  {
    "label": "FindHitTriangles()",
    "kind": "Method",
    "detail": "Function (} } } } } } void)",
    "insertText": "FindHitTriangles(int IBox, const FRay3d& Ray, TArray<MeshIntersection::FHitIntersectionResult>& Intersections, const FQueryOptions& Options = FQueryOptions())"
  },
  {
    "label": "MaxDistance()",
    "kind": "Method",
    "detail": "Function (const double)",
    "insertText": "MaxDistance(Options.MaxDistance < TNumericLimits<float>::Max()) ? Options.MaxDistance : TNumericLimits<float>::Max()"
  },
  {
    "label": "NewIntersection()",
    "kind": "Method",
    "detail": "Function (MeshIntersection::FHitIntersectionResult)",
    "insertText": "NewIntersection({ti, Query.RayParameter, Query.TriangleBaryCoords})"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (Intersections .)",
    "insertText": "Emplace(MoveTemp(NewIntersection))"
  },
  {
    "label": "FindHitTriangles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindHitTriangles(iChild1, Ray, Intersections, Options)"
  },
  {
    "label": "FindHitTriangles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindHitTriangles(iChild2, Ray, Intersections, Options)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } else {)",
    "insertText": "if(fChild2T <= MaxDistance + e)"
  },
  {
    "label": "TestAnyHitTriangle()",
    "kind": "Method",
    "detail": "Function (} } } } } } public : bool)",
    "insertText": "TestAnyHitTriangle(const FRay3d& Ray, const FQueryOptions& Options = FQueryOptions())"
  },
  {
    "label": "TestAnyHitTriangle()",
    "kind": "Method",
    "detail": "Function (int32 HitTID = IndexConstants::InvalidID ; bool bFoundHit =)",
    "insertText": "TestAnyHitTriangle(RootIndex, Ray, HitTID, MaxDistance, Options)"
  },
  {
    "label": "GetTriVertices()",
    "kind": "Method",
    "detail": "Function (continue ; } Mesh ->)",
    "insertText": "GetTriVertices(ti, A, B, C)"
  },
  {
    "label": "FIntrRay3Triangle3d()",
    "kind": "Method",
    "detail": "Function (FIntrRay3Triangle3d Query =)",
    "insertText": "FIntrRay3Triangle3d(Ray, FTriangle3d(A,B,C))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} double NearestSqr = FMathd::MaxReal ;)",
    "insertText": "if(Options.MaxDistance < FMathd::MaxReal)"
  },
  {
    "label": "Invalid()",
    "kind": "Method",
    "detail": "Function (NearestSqr = Options . MaxDistance* Options . MaxDistance ; } FIndex2i NearestPair =)",
    "insertText": "Invalid()"
  },
  {
    "label": "find_nearest_triangles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "find_nearest_triangles(RootIndex, OtherTree, TransformF, OtherTree.RootIndex, 0, NearestSqr, NearestPair, Options, OtherTreeOptions)"
  },
  {
    "label": "Distance()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Distance(NearestSqr < FMathd::MaxReal) ? FMathd::Sqrt(NearestSqr)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} ; TFunction<)",
    "insertText": "void(int)> NextTriangleF = [](int TriangleID)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} ; TFunction<)",
    "insertText": "void(int)> EndBoxTrianglesF = [](int BoxID)"
  },
  {
    "label": "DoTraversal()",
    "kind": "Method",
    "detail": "Function (} ; } ; void)",
    "insertText": "DoTraversal(FTreeTraversal& Traversal, const FQueryOptions& Options = FQueryOptions())"
  },
  {
    "label": "TreeTraversalImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TreeTraversalImpl(RootIndex, 0, Traversal, Options)"
  },
  {
    "label": "TreeTraversalImpl()",
    "kind": "Method",
    "detail": "Function (} } protected : void)",
    "insertText": "TreeTraversalImpl(int IBox, int Depth, FTreeTraversal& Traversal, const FQueryOptions& Options)"
  },
  {
    "label": "BeginBoxTrianglesF()",
    "kind": "Method",
    "detail": "Function (Traversal .)",
    "insertText": "BeginBoxTrianglesF(IBox, Depth)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int n = IndexList [ idx ] ;)",
    "insertText": "for(int i = 1; i <= n; ++i)"
  },
  {
    "label": "NextTriangleF()",
    "kind": "Method",
    "detail": "Function (continue ; } Traversal .)",
    "insertText": "NextTriangleF(ti)"
  },
  {
    "label": "EndBoxTrianglesF()",
    "kind": "Method",
    "detail": "Function (} Traversal .)",
    "insertText": "EndBoxTrianglesF(IBox)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { int i0 = IndexList [ idx ] ;)",
    "insertText": "if(i0 < 0)"
  },
  {
    "label": "i0()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "i0(-i0)"
  },
  {
    "label": "TreeTraversalImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TreeTraversalImpl(i0, Depth + 1, Traversal, Options)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else { i0 = i0 - 1 ;)",
    "insertText": "if(Traversal.NextBoxF(GetBox(i0), Depth + 1))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} int i1 = IndexList [ idx + 1 ] - 1 ;)",
    "insertText": "if(Traversal.NextBoxF(GetBox(i1), Depth + 1))"
  },
  {
    "label": "TreeTraversalImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TreeTraversalImpl(i1, Depth + 1, Traversal, Options)"
  },
  {
    "label": "TestIntersection()",
    "kind": "Method",
    "detail": "Function (} } } } public : bool)",
    "insertText": "TestIntersection(const TriangleMeshType* TestMesh, FAxisAlignedBox3d TestMeshBounds = FAxisAlignedBox3d::Empty(), const TFunction<FVector3d(const FVector3d&)>& TransformF = nullptr, const FQueryOptions& Options = FQueryOptions())"
  },
  {
    "label": "FAxisAlignedBox3d()",
    "kind": "Method",
    "detail": "Function (TestMeshBounds =)",
    "insertText": "FAxisAlignedBox3d(TestMeshBounds, [&](const FVector3d& P) { return TransformF(P); })"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(box_box_intersect(RootIndex, TestMeshBounds) == false)"
  },
  {
    "label": "GetTriangle()",
    "kind": "Method",
    "detail": "Function (FIndex3i Tri = TestMesh ->)",
    "insertText": "GetTriangle(TID)"
  },
  {
    "label": "TransformF()",
    "kind": "Method",
    "detail": "Function (TestTri . V [ 0 ] =)",
    "insertText": "TransformF(TestMesh->GetVertex(Tri.A))"
  },
  {
    "label": "TransformF()",
    "kind": "Method",
    "detail": "Function (TestTri . V [ 1 ] =)",
    "insertText": "TransformF(TestMesh->GetVertex(Tri.B))"
  },
  {
    "label": "TransformF()",
    "kind": "Method",
    "detail": "Function (TestTri . V [ 2 ] =)",
    "insertText": "TransformF(TestMesh->GetVertex(Tri.C))"
  },
  {
    "label": "GetTriVertices()",
    "kind": "Method",
    "detail": "Function (} else { TestMesh ->)",
    "insertText": "GetTriVertices(TID, TestTri.V[0], TestTri.V[1], TestTri.V[2])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(TestIntersection(TestTri, Options))"
  },
  {
    "label": "find_any_intersection()",
    "kind": "Method",
    "detail": "Function (int interTri =)",
    "insertText": "find_any_intersection(RootIndex, Triangle, triBounds, [](const FTriangle3d& A, const FTriangle3d& B) { return TMeshAABBTree3<TriangleMeshType>::TriangleIntersectionFilter(A, B); }, Options)"
  },
  {
    "label": "FindAllIntersections()",
    "kind": "Method",
    "detail": "Function (} MeshIntersection::FIntersectionsQueryResult)",
    "insertText": "FindAllIntersections(const TMeshAABBTree3& OtherTree, const TFunction<FVector3d(const FVector3d&)>& TransformF = nullptr, const FQueryOptions& Options = FQueryOptions(), const FQueryOptions& OtherTreeOptions = FQueryOptions(), TFunction<bool(FIntrTriangle3Triangle3d&)> IntersectionFn = nullptr)"
  },
  {
    "label": "IntersectionFn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IntersectionFn(FIntrTriangle3Triangle3d& Intr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} ; } MeshIntersection::FIntersectionsQueryResult result ;)",
    "insertText": "if(ensure(IsValid(Options.bAllowUnsafeModifiedMeshQueries)) == false)"
  },
  {
    "label": "GetBox()",
    "kind": "Method",
    "detail": "Function (} protected : FAxisAlignedBox3d)",
    "insertText": "GetBox(int IBox)"
  },
  {
    "label": "FAxisAlignedBox3d()",
    "kind": "Method",
    "detail": "Function (const FVector3d& c = BoxCenters [ IBox ] ; const FVector3d& e = BoxExtents [ IBox ] ; FVector3d Min = c - e,Max = c + e ; return)",
    "insertText": "FAxisAlignedBox3d(Min, Max)"
  },
  {
    "label": "GetBox()",
    "kind": "Method",
    "detail": "Function (} FAxisAlignedBox3d)",
    "insertText": "GetBox(int iBox, const TFunction<FVector3d(const FVector3d&)>& TransformF)"
  },
  {
    "label": "GetBox()",
    "kind": "Method",
    "detail": "Function (FAxisAlignedBox3d box =)",
    "insertText": "GetBox(iBox)"
  },
  {
    "label": "GetBoxEps()",
    "kind": "Method",
    "detail": "Function (} } FAxisAlignedBox3d)",
    "insertText": "GetBoxEps(int IBox, double Epsilon = FMathd::ZeroTolerance)"
  },
  {
    "label": "SetTolerance()",
    "kind": "Method",
    "detail": "Function (} protected : double BoxEps = FMathd::ZeroTolerance ; public : void)",
    "insertText": "SetTolerance(double Tolerance)"
  },
  {
    "label": "BoxDistanceSqr()",
    "kind": "Method",
    "detail": "Function (BoxEps = Tolerance ; } double)",
    "insertText": "BoxDistanceSqr(int IBox, const FVector3d& V)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (const FVector3d& c = BoxCenters [ IBox ] ; const FVector3d& e = BoxExtents [ IBox ] ; double dx =)",
    "insertText": "Max(fabs(V.X - c.X) - e.X, 0.0)"
  },
  {
    "label": "GetBoxEps()",
    "kind": "Method",
    "detail": "Function (FAxisAlignedBox3d Box =)",
    "insertText": "GetBoxEps(IBox, BoxEps)"
  },
  {
    "label": "box_ray_intersect_t()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "box_ray_intersect_t(int IBox, const FRay3d& Ray)"
  },
  {
    "label": "Box()",
    "kind": "Method",
    "detail": "Function (const FVector3d& c = BoxCenters [ IBox ] ; FVector3d e = BoxExtents [ IBox ] + BoxEps ; FAxisAlignedBox3d)",
    "insertText": "Box(c - e, c + e)"
  },
  {
    "label": "box_box_intersect()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "box_box_intersect(int IBox, const FAxisAlignedBox3d& TestBox)"
  },
  {
    "label": "FBoxesSet()",
    "kind": "Method",
    "detail": "Function (} TDynamicVector<int> BoxToIndex ; TDynamicVector<FVector3d> BoxCenters ; TDynamicVector<FVector3d> BoxExtents ; TDynamicVector<int> IndexList ; int TrianglesEnd = - 1 ; int RootIndex = - 1 ; struct FBoxesSet { TDynamicVector<int> BoxToIndex ; TDynamicVector<FVector3d> BoxCenters ; TDynamicVector<FVector3d> BoxExtents ; TDynamicVector<int> IndexList ; int IBoxCur ; int IIndicesCur ;)",
    "insertText": "FBoxesSet()"
  },
  {
    "label": "BuildTopDown()",
    "kind": "Method",
    "detail": "Function (IBoxCur = 0 ; IIndicesCur = 0 ; } } ; void)",
    "insertText": "BuildTopDown(bool bSorted)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (TArray<int> Triangles ; Triangles .)",
    "insertText": "Reserve(Mesh->TriangleCount())"
  },
  {
    "label": "GetTriCentroid()",
    "kind": "Method",
    "detail": "Function (continue ; } FVector3d centroid = TMeshQueries<TriangleMeshType)",
    "insertText": "GetTriCentroid(*Mesh, ti)"
  },
  {
    "label": "IsNaN()",
    "kind": "Method",
    "detail": "Function (bool bInvalid =)",
    "insertText": "IsNaN(d2) || (FMathd::IsFinite(d2) == false)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Triangles .)",
    "insertText": "Add(ti)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Centers .)",
    "insertText": "Add(TMeshQueries<TriangleMeshType>::GetTriCentroid(*Mesh, ti))"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "checkSlow(Triangles.Num() == Centers.Num())"
  },
  {
    "label": "BuildTopDown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BuildTopDown(Triangles, Centers, Triangles.Num())"
  },
  {
    "label": "BuildTopDown()",
    "kind": "Method",
    "detail": "Function (} template<TriIndexEnumerable> void)",
    "insertText": "BuildTopDown(bool bSorted, TriIndexEnumerable TriangleList, int32 NumTriangles)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (TArray<int32> Triangles ; Triangles .)",
    "insertText": "Reserve(NumTriangles)"
  },
  {
    "label": "BuildTopDown()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "BuildTopDown(TArray<int>& Triangles, TArray<FVector3d>& Centers, int32 NumTriangles)"
  },
  {
    "label": "SplitTriSetMidpoint()",
    "kind": "Method",
    "detail": "Function (FBoxesSet Tris ; FBoxesSet Nodes ; FAxisAlignedBox3d rootBox ; int rootnode =)",
    "insertText": "SplitTriSetMidpoint(Triangles, Centers, 0, NumTriangles, 0, TopDownLeafMaxTriCount, Tris, Nodes, rootBox)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (BoxToIndex = Tris . BoxToIndex ; BoxCenters = Tris . BoxCenters ; BoxExtents = Tris . BoxExtents ; IndexList = Tris . IndexList ; TrianglesEnd = Tris . IIndicesCur ; int iIndexShift = TrianglesEnd ; int iBoxShift = Tris . IBoxCur ;)",
    "insertText": "for(int32 i = 0; i < Nodes.IBoxCur; ++i)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (FVector3d NodeBoxCenter = Nodes . BoxCenters [ i ] ; BoxCenters .)",
    "insertText": "InsertAt(NodeBoxCenter, iBoxShift + i)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (FVector3d NodeBoxExtents = Nodes . BoxExtents [ i ] ; BoxExtents .)",
    "insertText": "InsertAt(NodeBoxExtents, iBoxShift + i)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (int NodeBoxIndex = Nodes . BoxToIndex [ i ] ; BoxToIndex .)",
    "insertText": "InsertAt(iIndexShift + NodeBoxIndex, iBoxShift + i)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int32 i = 0; i < Nodes.IIndicesCur; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int child_box = Nodes . IndexList [ i ] ;)",
    "insertText": "if(child_box < 0)"
  },
  {
    "label": "child_box()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "child_box(-child_box)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (} else { child_box + = iBoxShift ; } child_box = child_box + 1 ; IndexList .)",
    "insertText": "InsertAt(child_box, iIndexShift + i)"
  },
  {
    "label": "SplitTriSetMidpoint()",
    "kind": "Method",
    "detail": "Function (} RootIndex = rootnode + iBoxShift ; } int)",
    "insertText": "SplitTriSetMidpoint(TArray<int>& Triangles, TArray<FVector3d>& Centers, int IStart, int ICount, int Depth, int MinTriCount, FBoxesSet& Tris, FBoxesSet& Nodes, FAxisAlignedBox3d& Box)"
  },
  {
    "label": "Box()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Box(Triangles.Num() > 0) ? FAxisAlignedBox3d::Empty() : FAxisAlignedBox3d(FVector3d::Zero(), 0.0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int IBox = - 1 ;)",
    "insertText": "if(ICount <= MinTriCount)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (IBox = Tris . IBoxCur + + ; Tris . BoxToIndex .)",
    "insertText": "InsertAt(Tris.IIndicesCur, IBox)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (Tris . IndexList .)",
    "insertText": "InsertAt(ICount, Tris.IIndicesCur++)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (Tris . IndexList .)",
    "insertText": "InsertAt(Triangles[IStart + i], Tris.IIndicesCur++)"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (Box .)",
    "insertText": "Contain(TMeshQueries<TriangleMeshType>::GetTriBounds(*Mesh, Triangles[IStart + i]))"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (} Tris . BoxCenters .)",
    "insertText": "InsertAt(Box.Center(), IBox)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (Tris . BoxExtents .)",
    "insertText": "InsertAt(Box.Extents(), IBox)"
  },
  {
    "label": "GetSplitAxis()",
    "kind": "Method",
    "detail": "Function (} int axis =)",
    "insertText": "GetSplitAxis(Depth, Box)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (FInterval1d interval =)",
    "insertText": "Empty()"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (interval .)",
    "insertText": "Contain(Centers[IStart + i][axis])"
  },
  {
    "label": "Center()",
    "kind": "Method",
    "detail": "Function (} double midpoint = interval .)",
    "insertText": "Center()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int n0,n1 ;)",
    "insertText": "if(interval.Length() > FMathd::ZeroTolerance)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int l = 0 ; int r = ICount - 1 ;)",
    "insertText": "while(l < r)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (l + + ; })",
    "insertText": "while(Centers[IStart + r][axis] > midpoint)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (r - - ; })",
    "insertText": "if(l >= r)"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (break ; } FVector3d tmpc = Centers [ IStart + l ] ; Centers [ IStart + l ] = Centers [ IStart + r ] ; Centers [ IStart + r ] = tmpc ; int tmpt = Triangles [ IStart + l ] ; Triangles [ IStart + l ] = Triangles [ IStart + r ] ; Triangles [ IStart + r ] = tmpt ; } n0 = l ; n1 = ICount - n0 ;)",
    "insertText": "checkSlow(n0 >= 1 && n1 >= 1)"
  },
  {
    "label": "SplitTriSetMidpoint()",
    "kind": "Method",
    "detail": "Function (} else { n0 = ICount / 2 ; n1 = ICount - n0 ; } FAxisAlignedBox3d box1 ; int child0 =)",
    "insertText": "SplitTriSetMidpoint(Triangles, Centers, IStart, n0, Depth + 1, MinTriCount, Tris, Nodes, Box)"
  },
  {
    "label": "SplitTriSetMidpoint()",
    "kind": "Method",
    "detail": "Function (int child1 =)",
    "insertText": "SplitTriSetMidpoint(Triangles, Centers, IStart + n0, n1, Depth + 1, MinTriCount, Tris, Nodes, box1)"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (Box .)",
    "insertText": "Contain(box1)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (IBox = Nodes . IBoxCur + + ; Nodes . BoxToIndex .)",
    "insertText": "InsertAt(Nodes.IIndicesCur, IBox)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (Nodes . IndexList .)",
    "insertText": "InsertAt(child0, Nodes.IIndicesCur++)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (Nodes . IndexList .)",
    "insertText": "InsertAt(child1, Nodes.IIndicesCur++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int idx = BoxToIndex [ iBox ] ; int odx = OtherTree . BoxToIndex [ oBox ] ;)",
    "insertText": "if(idx < TrianglesEnd && odx < OtherTree.TrianglesEnd)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FTriangle3d Tri,otri ; int num_tris = IndexList [ idx ],onum_tris = OtherTree . IndexList [ odx ] ; FDistTriangle3Triangle3d dist ;)",
    "insertText": "for(int j = 1; j <= onum_tris; ++j)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int tj = OtherTree . IndexList [ odx + j ] ;)",
    "insertText": "if(OtherTreeOptions.TriangleFilterF != nullptr && OtherTreeOptions.TriangleFilterF(tj) == false)"
  },
  {
    "label": "GetTriVertices()",
    "kind": "Method",
    "detail": "Function (continue ; } OtherTree . Mesh ->)",
    "insertText": "GetTriVertices(tj, otri.V[0], otri.V[1], otri.V[2])"
  },
  {
    "label": "TransformF()",
    "kind": "Method",
    "detail": "Function (otri . V [ 0 ] =)",
    "insertText": "TransformF(otri.V[0])"
  },
  {
    "label": "TransformF()",
    "kind": "Method",
    "detail": "Function (otri . V [ 1 ] =)",
    "insertText": "TransformF(otri.V[1])"
  },
  {
    "label": "TransformF()",
    "kind": "Method",
    "detail": "Function (otri . V [ 2 ] =)",
    "insertText": "TransformF(otri.V[2])"
  },
  {
    "label": "SetTriangle()",
    "kind": "Method",
    "detail": "Function (} dist .)",
    "insertText": "SetTriangle(0, otri)"
  },
  {
    "label": "GetTriVertices()",
    "kind": "Method",
    "detail": "Function (continue ; } Mesh ->)",
    "insertText": "GetTriVertices(ti, Tri.V[0], Tri.V[1], Tri.V[2])"
  },
  {
    "label": "SetTriangle()",
    "kind": "Method",
    "detail": "Function (dist .)",
    "insertText": "SetTriangle(1, Tri)"
  },
  {
    "label": "FIndex2i()",
    "kind": "Method",
    "detail": "Function (nearest_sqr = dist_sqr ; nearest_pair =)",
    "insertText": "FIndex2i(ti, tj)"
  },
  {
    "label": "bDescendOther()",
    "kind": "Method",
    "detail": "Function (} } } return ; } bool)",
    "insertText": "bDescendOther(idx < TrianglesEnd || depth % 2 == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bDescendOther = false ; })",
    "insertText": "if(bDescendOther)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int oChild1 = OtherTree . IndexList [ odx ] ;)",
    "insertText": "if(oChild1 < 0)"
  },
  {
    "label": "oChild1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "oChild1(-oChild1)"
  },
  {
    "label": "GetBox()",
    "kind": "Method",
    "detail": "Function (FAxisAlignedBox3d oChild1Box = OtherTree .)",
    "insertText": "GetBox(oChild1, TransformF)"
  },
  {
    "label": "find_nearest_triangles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "find_nearest_triangles(iBox, OtherTree, TransformF, oChild1, depth + 1, nearest_sqr, nearest_pair, Options, OtherTreeOptions)"
  },
  {
    "label": "GetBox()",
    "kind": "Method",
    "detail": "Function (FAxisAlignedBox3d oChild2Box = OtherTree .)",
    "insertText": "GetBox(oChild2, TransformF)"
  },
  {
    "label": "find_nearest_triangles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "find_nearest_triangles(iBox, OtherTree, TransformF, oChild2, depth + 1, nearest_sqr, nearest_pair, Options, OtherTreeOptions)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(d1Sqr < nearest_sqr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(d2Sqr < nearest_sqr)"
  },
  {
    "label": "GetBox()",
    "kind": "Method",
    "detail": "Function (} } } } else { FAxisAlignedBox3d oBounds = OtherTree .)",
    "insertText": "GetBox(oBox, TransformF)"
  },
  {
    "label": "find_nearest_triangles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "find_nearest_triangles(iChild1, OtherTree, TransformF, oBox, depth + 1, nearest_sqr, nearest_pair, Options, OtherTreeOptions)"
  },
  {
    "label": "box_box_distsqr()",
    "kind": "Method",
    "detail": "Function (} } else { iChild1 = iChild1 - 1 ; int iChild2 = IndexList [ idx + 1 ] - 1 ; double d1Sqr =)",
    "insertText": "box_box_distsqr(iChild1, oBounds)"
  },
  {
    "label": "find_nearest_triangles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "find_nearest_triangles(iChild2, OtherTree, TransformF, oBox, depth + 1, nearest_sqr, nearest_pair, Options, OtherTreeOptions)"
  },
  {
    "label": "box_box_distsqr()",
    "kind": "Method",
    "detail": "Function (} } } } } double)",
    "insertText": "box_box_distsqr(int iBox, const FAxisAlignedBox3d& testBox)"
  },
  {
    "label": "GetBoxEps()",
    "kind": "Method",
    "detail": "Function (FAxisAlignedBox3d box =)",
    "insertText": "GetBoxEps(iBox, BoxEps)"
  },
  {
    "label": "TriangleIntersectionFilter()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "TriangleIntersectionFilter(const FTriangle3d& A, const FTriangle3d& B)"
  },
  {
    "label": "TriangleIntersection()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "TriangleIntersection(FIntrTriangle3Triangle3d& Intr)"
  },
  {
    "label": "Test()",
    "kind": "Method",
    "detail": "Function (bool bFound = Intr .)",
    "insertText": "Test()"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (Intr .)",
    "insertText": "Find()"
  },
  {
    "label": "GetTriVertices()",
    "kind": "Method",
    "detail": "Function (continue ; } Mesh ->)",
    "insertText": "GetTriVertices(ti, box_tri.V[0], box_tri.V[1], box_tri.V[2])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else { iChild1 = iChild1 - 1 ; int iChild2 = IndexList [ idx + 1 ] - 1 ; int interTri = - 1 ;)",
    "insertText": "if(box_box_intersect(iChild1, triBounds))"
  },
  {
    "label": "find_any_intersection()",
    "kind": "Method",
    "detail": "Function (interTri =)",
    "insertText": "find_any_intersection(iChild1, Triangle, triBounds, TriangleIntersectionTest, Options)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(interTri == -1 && box_box_intersect(iChild2, triBounds))"
  },
  {
    "label": "find_any_intersection()",
    "kind": "Method",
    "detail": "Function (interTri =)",
    "insertText": "find_any_intersection(iChild2, Triangle, triBounds, TriangleIntersectionTest, Options)"
  },
  {
    "label": "find_any_intersection()",
    "kind": "Method",
    "detail": "Function (} return interTri ; } } return - 1 ; } bool)",
    "insertText": "find_any_intersection(int iBox, const TMeshAABBTree3& OtherTree, const TFunction<FVector3d(const FVector3d&)>& TransformF, int oBox, int depth, TFunctionRef<bool(const FTriangle3d & A, const FTriangle3d & B)> TriangleIntersectionTest, const FQueryOptions& Options, const FQueryOptions& OtherTreeOptions)"
  },
  {
    "label": "find_any_intersection()",
    "kind": "Method",
    "detail": "Function (intersects =)",
    "insertText": "find_any_intersection(iBox, OtherTree, TransformF, oChild1, depth + 1, TriangleIntersectionTest, Options, OtherTreeOptions)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(intersects == false)"
  },
  {
    "label": "find_any_intersection()",
    "kind": "Method",
    "detail": "Function (intersects =)",
    "insertText": "find_any_intersection(iBox, OtherTree, TransformF, oChild2, depth + 1, TriangleIntersectionTest, Options, OtherTreeOptions)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else { iChild1 = iChild1 - 1 ; int iChild2 = IndexList [ idx + 1 ] - 1 ; bool intersects = false ;)",
    "insertText": "if(box_box_intersect(iChild1, oBounds))"
  },
  {
    "label": "find_any_intersection()",
    "kind": "Method",
    "detail": "Function (intersects =)",
    "insertText": "find_any_intersection(iChild1, OtherTree, TransformF, oBox, depth + 1, TriangleIntersectionTest, Options, OtherTreeOptions)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(intersects == false && box_box_intersect(iChild2, oBounds))"
  },
  {
    "label": "find_any_intersection()",
    "kind": "Method",
    "detail": "Function (intersects =)",
    "insertText": "find_any_intersection(iChild2, OtherTree, TransformF, oBox, depth + 1, TriangleIntersectionTest, Options, OtherTreeOptions)"
  },
  {
    "label": "find_self_intersections_acrossboxes()",
    "kind": "Method",
    "detail": "Function (} return intersects ; } } return false ; } bool)",
    "insertText": "find_self_intersections_acrossboxes(int Box1, int Box2, MeshIntersection::FIntersectionsQueryResult* Result, bool bIgnoreTopoConnected, int depth, TFunctionRef<bool(FIntrTriangle3Triangle3d&)> IntersectFn, const FQueryOptions& Options)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bFound = false ;)",
    "insertText": "if(Box1 < 0)"
  },
  {
    "label": "find_tri_tri_intersections()",
    "kind": "Method",
    "detail": "Function (int TID_A = IndexList [ IdxA ] ; bFound =)",
    "insertText": "find_tri_tri_intersections(TID_A, Box2Idx + 1, Box2Idx + 1 + IndexList[Box2Idx], Result, bIgnoreTopoConnected, IntersectFn, Options)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(Box1, Box2)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(Box1Idx, Box2Idx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Box2 > -1)"
  },
  {
    "label": "GetBox()",
    "kind": "Method",
    "detail": "Function (FAxisAlignedBox3d Box2Box =)",
    "insertText": "GetBox(Box2)"
  },
  {
    "label": "find_self_intersections_acrossboxes()",
    "kind": "Method",
    "detail": "Function (bFound =)",
    "insertText": "find_self_intersections_acrossboxes(iChild1, Box2, Result, bIgnoreTopoConnected, depth + 1, IntersectFn, Options)"
  },
  {
    "label": "find_self_intersections_acrossboxes()",
    "kind": "Method",
    "detail": "Function (bFound =)",
    "insertText": "find_self_intersections_acrossboxes(iChild2, Box2, Result, bIgnoreTopoConnected, depth + 1, IntersectFn, Options)"
  },
  {
    "label": "find_self_intersections_acrossboxes()",
    "kind": "Method",
    "detail": "Function (bFound =)",
    "insertText": "find_self_intersections_acrossboxes(iChild1, -1, Result, bIgnoreTopoConnected, depth + 1, IntersectFn, Options)"
  },
  {
    "label": "find_self_intersections_acrossboxes()",
    "kind": "Method",
    "detail": "Function (bFound =)",
    "insertText": "find_self_intersections_acrossboxes(iChild1, iChild2, Result, bIgnoreTopoConnected, depth + 1, IntersectFn, Options)"
  },
  {
    "label": "SetTriangle0()",
    "kind": "Method",
    "detail": "Function (FIntrTriangle3Triangle3d Intr ; Intr .)",
    "insertText": "SetTriangle0(TriA)"
  },
  {
    "label": "GetTriangle()",
    "kind": "Method",
    "detail": "Function (FIndex3i TriA_VID = Mesh ->)",
    "insertText": "GetTriangle(TID_A)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int TID_B = IndexList [ IdxB ] ;)",
    "insertText": "if(Options.TriangleFilterF != nullptr && Options.TriangleFilterF(TID_B) == false)"
  },
  {
    "label": "GetTriangle()",
    "kind": "Method",
    "detail": "Function (continue ; } FIndex3i TriB_VID = Mesh ->)",
    "insertText": "GetTriangle(TID_B)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bTopoConnected = false ;)",
    "insertText": "for(int AIdx = 0; AIdx < 3 && !bTopoConnected; AIdx++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int VID_A = TriA_VID [ AIdx ] ;)",
    "insertText": "for(int BIdx = 0; BIdx < 3; BIdx++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bTopoConnected = true ; break ; } } })",
    "insertText": "if(bTopoConnected)"
  },
  {
    "label": "GetTriVertices()",
    "kind": "Method",
    "detail": "Function (continue ; } } Mesh ->)",
    "insertText": "GetTriVertices(TID_B, TriB.V[0], TriB.V[1], TriB.V[2])"
  },
  {
    "label": "SetTriangle1()",
    "kind": "Method",
    "detail": "Function (Intr .)",
    "insertText": "SetTriangle1(TriB)"
  },
  {
    "label": "IntersectFn()",
    "kind": "Method",
    "detail": "Function (bFound =)",
    "insertText": "IntersectFn(Intr)"
  },
  {
    "label": "AddTriTriIntersectionResult()",
    "kind": "Method",
    "detail": "Function (} } } return bFound ; } void)",
    "insertText": "AddTriTriIntersectionResult(const FIntrTriangle3Triangle3d& Intr, int TID_A, int TID_B, MeshIntersection::FIntersectionsQueryResult& Result)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Result . Points .)",
    "insertText": "Add(MeshIntersection::FPointIntersection{ {TID_A, TID_B}, Intr.Points[0] })"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Intr.Quantity == 2)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Result . Segments .)",
    "insertText": "Add(MeshIntersection::FSegmentIntersection{ {TID_A, TID_B}, {Intr.Points[0], Intr.Points[1]} })"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Intr.Quantity > 2)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Result . Segments .)",
    "insertText": "Add(MeshIntersection::FSegmentIntersection{ {TID_A, TID_B}, {Intr.Points[2], Intr.Points[3]} })"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Result . Segments .)",
    "insertText": "Add(MeshIntersection::FSegmentIntersection{ {TID_A, TID_B}, {Intr.Points[4], Intr.Points[5]} })"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} } else { Result . Polygons .)",
    "insertText": "Add(MeshIntersection::FPolygonIntersection{ {TID_A, TID_B}, {Intr.Points[0],Intr.Points[1],Intr.Points[2],Intr.Points[3],Intr.Points[4],Intr.Points[5]}, Intr.Quantity })"
  },
  {
    "label": "find_self_intersections()",
    "kind": "Method",
    "detail": "Function (} } } bool)",
    "insertText": "find_self_intersections(MeshIntersection::FIntersectionsQueryResult* Result, bool bIgnoreTopoConnected, TFunctionRef<bool(FIntrTriangle3Triangle3d&)> IntersectFn, const FQueryOptions & Options)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bFound = false ;)",
    "insertText": "for(int StartIdx = 0; StartIdx < TrianglesEnd;)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int NumTris = IndexList [ StartIdx ] ; int EndIdx = StartIdx + NumTris + 1 ;)",
    "insertText": "for(int IdxA = StartIdx + 1; IdxA + 1 < EndIdx; IdxA++)"
  },
  {
    "label": "find_tri_tri_intersections()",
    "kind": "Method",
    "detail": "Function (int TID_A = IndexList [ IdxA ] ; bFound =)",
    "insertText": "find_tri_tri_intersections(TID_A, IdxA + 1, EndIdx, Result, bIgnoreTopoConnected, IntersectFn, Options)"
  },
  {
    "label": "find_intersections()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "find_intersections(int iBox, const TMeshAABBTree3& OtherTree, const TFunction<FVector3d(const FVector3d&)>& TransformF, int oBox, int depth, MeshIntersection::FIntersectionsQueryResult& result, TFunctionRef<bool(FIntrTriangle3Triangle3d&)> IntersectFn, const FQueryOptions& Options, const FQueryOptions& OtherTreeOptions)"
  },
  {
    "label": "SetTriangle0()",
    "kind": "Method",
    "detail": "Function (} Intr .)",
    "insertText": "SetTriangle0(otri)"
  },
  {
    "label": "SetTriangle1()",
    "kind": "Method",
    "detail": "Function (Intr .)",
    "insertText": "SetTriangle1(Tri)"
  },
  {
    "label": "AddTriTriIntersectionResult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTriTriIntersectionResult(Intr, ti, tj, result)"
  },
  {
    "label": "find_intersections()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "find_intersections(iBox, OtherTree, TransformF, oChild1, depth + 1, result, IntersectFn, Options, OtherTreeOptions)"
  },
  {
    "label": "find_intersections()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "find_intersections(iBox, OtherTree, TransformF, oChild2, depth + 1, result, IntersectFn, Options, OtherTreeOptions)"
  },
  {
    "label": "find_intersections()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "find_intersections(iChild1, OtherTree, TransformF, oBox, depth + 1, result, IntersectFn, Options, OtherTreeOptions)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} int iChild2 = IndexList [ idx + 1 ] - 1 ;)",
    "insertText": "if(box_box_intersect(iChild2, oBounds))"
  },
  {
    "label": "find_intersections()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "find_intersections(iChild2, OtherTree, TransformF, oBox, depth + 1, result, IntersectFn, Options, OtherTreeOptions)"
  },
  {
    "label": "TestCoverage()",
    "kind": "Method",
    "detail": "Function (} } } } public : void)",
    "insertText": "TestCoverage()"
  },
  {
    "label": "SetNumZeroed()",
    "kind": "Method",
    "detail": "Function (TArray<int> tri_counts ; tri_counts .)",
    "insertText": "SetNumZeroed(Mesh->MaxTriangleID())"
  },
  {
    "label": "SetNumZeroed()",
    "kind": "Method",
    "detail": "Function (TArray<int> parent_indices ; parent_indices .)",
    "insertText": "SetNumZeroed(BoxToIndex.GetLength())"
  },
  {
    "label": "test_coverage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "test_coverage(tri_counts, parent_indices, RootIndex)"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "checkSlow(tri_counts[ti] == 1)"
  },
  {
    "label": "TotalVolume()",
    "kind": "Method",
    "detail": "Function (} } double)",
    "insertText": "TotalVolume()"
  },
  {
    "label": "Volume()",
    "kind": "Method",
    "detail": "Function (volSum + = Box .)",
    "insertText": "Volume()"
  },
  {
    "label": "debug_check_child_tris_in_box()",
    "kind": "Method",
    "detail": "Function (int idx = BoxToIndex [ IBox ] ;)",
    "insertText": "debug_check_child_tris_in_box(IBox)"
  },
  {
    "label": "GetBoxEps()",
    "kind": "Method",
    "detail": "Function (int n = IndexList [ idx ] ; FAxisAlignedBox3d Box =)",
    "insertText": "GetBoxEps(IBox)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (FVector3d V = Mesh ->)",
    "insertText": "GetVertex(tv[j])"
  },
  {
    "label": "test_coverage()",
    "kind": "Method",
    "detail": "Function (parent_indices [ i0 ] = IBox ;)",
    "insertText": "test_coverage(tri_counts, parent_indices, i0)"
  },
  {
    "label": "test_coverage()",
    "kind": "Method",
    "detail": "Function (int i1 = IndexList [ idx + 1 ] ; i1 = i1 - 1 ; parent_indices [ i1 ] = IBox ;)",
    "insertText": "test_coverage(tri_counts, parent_indices, i1)"
  },
  {
    "label": "debug_check_child_tri_distances()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "debug_check_child_tri_distances(int IBox, const FVector3d& P)"
  },
  {
    "label": "NextTriangleF()",
    "kind": "Method",
    "detail": "Function (FTreeTraversal t ; t .)",
    "insertText": "NextTriangleF(int TID)"
  },
  {
    "label": "TreeTraversalImpl()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "TreeTraversalImpl(IBox, 0, t, FQueryOptions())"
  },
  {
    "label": "debug_check_child_tris_in_box()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "debug_check_child_tris_in_box(int IBox)"
  }
]