[
  {
    "label": "SetVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SetVector"
  },
  {
    "label": "TestAndEraseFromSet",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TestAndEraseFromSet"
  },
  {
    "label": "SmallSetVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SmallSetVector"
  },
  {
    "label": "SetVector()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_ADT_SETVECTOR_H # define LLVM_ADT_SETVECTOR_H # include \" llvm / ADT / SmallSet . h \" # include<algorithm> # include<cassert> # include<vector> namespace llvm { template<T,Vector = std::vector<T>,Set = SmallSet<T,1 6>> class SetVector { public : typedef T value_type ; typedef T key_type ; typedef T& reference ; typedef const T& const_reference ; typedef Set set_type ; typedef Vector vector_type ; typedef vector_type::const_iterator iterator ; typedef vector_type::const_iterator const_iterator ; typedef vector_type::size_type size_type ;)",
    "insertText": "SetVector()"
  },
  {
    "label": "SetVector()",
    "kind": "Method",
    "detail": "Function (} template<It>)",
    "insertText": "SetVector(It Start, It End)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insert(Start, End)"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "size()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (} const T&)",
    "insertText": "back()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!empty() && \"Cannot call back() on empty SetVector!\")"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const_reference)",
    "insertText": "operator(size_type n)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(n < vector_.size() && \"SetVector access out of range!\")"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (bool result = set_ .)",
    "insertText": "insert(X)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "remove(const value_type& X)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (vector_type::iterator I =)",
    "insertText": "find(vector_.begin(), vector_.end(), X)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(I != vector_.end() && \"Corrupted SetVector instances!\")"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (vector_ .)",
    "insertText": "erase(I)"
  },
  {
    "label": "remove_if()",
    "kind": "Method",
    "detail": "Function (vector_type::iterator I =)",
    "insertText": "remove_if(vector_.begin(), vector_.end(), TestAndEraseFromSet<UnaryPredicate>(P, set_))"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (vector_ .)",
    "insertText": "erase(I, vector_.end())"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "clear()"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "pop_back()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!empty() && \"Cannot remove an element from an empty SetVector!\")"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (set_ .)",
    "insertText": "erase(back())"
  },
  {
    "label": "pop_back_val()",
    "kind": "Method",
    "detail": "Function (} T LLVM_ATTRIBUTE_UNUSED_RESULT)",
    "insertText": "pop_back_val()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<ArgumentT> bool)",
    "insertText": "operator()(const ArgumentT &Arg)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (set_ .)",
    "insertText": "erase(Arg)"
  },
  {
    "label": "SmallSetVector()",
    "kind": "Method",
    "detail": "Function (} template<It>)",
    "insertText": "SmallSetVector(It Start, It End)"
  }
]