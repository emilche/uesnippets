[
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "CpuScopeFlags",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "CpuScopeFlags"
  },
  {
    "label": "TraceCpuScope",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TraceCpuScope"
  },
  {
    "label": "Lane",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Lane"
  },
  {
    "label": "ScopeBuffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScopeBuffer"
  },
  {
    "label": "ThreadBuffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ThreadBuffer"
  },
  {
    "label": "ArgPacker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ArgPacker"
  },
  {
    "label": "TypeId",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TypeId"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (# if PLATFORM_WINDOWS # pragma)",
    "insertText": "warning(pop)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(TRACE_HAS_ANALYSIS) inline void SerializeToCborImpl(TArray<uint8>&, const IAnalyzer::FEventData&, uint32)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # endif } # if PLATFORM_WINDOWS # if)",
    "insertText": "defined(UNICODE) || defined(_UNICODE) # undef TEXT # undef TCHAR # define TEXT(x)"
  },
  {
    "label": "TRACE_PRIVATE_CONCAT_()",
    "kind": "Method",
    "detail": "Function (using namespace UE::Trace ; namespace detail { using namespace UE::Trace::Private ; } } # define)",
    "insertText": "TRACE_PRIVATE_CONCAT_(x, y) x##y #define TRACE_PRIVATE_CONCAT(x, y) TRACE_PRIVATE_CONCAT_(x, y) #define TRACE_PRIVATE_UNIQUE_VAR(name) TRACE_PRIVATE_CONCAT($trace_##name, __LINE__)"
  },
  {
    "label": "DescribeSession()",
    "kind": "Method",
    "detail": "Function (enum class Build { Unknown,Debug,DebugGame,Development,Shipping,Test } ; void)",
    "insertText": "DescribeSession(const std::string_view& AppName, Build Variant=Build::Unknown, const std::string_view& CommandLine=\"\", const std::string_view& BuildVersion=\"unknown_ver\")"
  },
  {
    "label": "TRACE_EVENT_BEGIN()",
    "kind": "Method",
    "detail": "Function (} # if TRACE_IMPLEMENT namespace trace { namespace detail {)",
    "insertText": "TRACE_EVENT_BEGIN(Diagnostics, Session2, NoSync|Important) TRACE_EVENT_FIELD(uint8, ConfigurationType) TRACE_EVENT_FIELD(trace::AnsiString, AppName) TRACE_EVENT_FIELD(trace::AnsiString, BuildVersion) TRACE_EVENT_FIELD(trace::AnsiString, Platform) TRACE_EVENT_FIELD(trace::AnsiString, CommandLine) TRACE_EVENT_END() } void DescribeSession( const std::string_view& AppName, Build Variant, const std::string_view& CommandLine, const std::string_view& BuildVersion)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (using namespace detail ; using namespace std::literals ; std::string_view Platform ; # if PLATFORM_WINDOWS Platform = \" Windows \" sv ; # elif PLATFORM_UNIX Platform = \" Linux \" sv ; # elif PLATFORM_MAC Platform = \" Mac \" sv ; # else Platform = \" Unknown \" sv ; # endif int32 DataSize = 0 ; DataSize + =)",
    "insertText": "int32(AppName.size())"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (DataSize + =)",
    "insertText": "int32(BuildVersion.size())"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (DataSize + =)",
    "insertText": "int32(Platform.size())"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (DataSize + =)",
    "insertText": "int32(CommandLine.size())"
  },
  {
    "label": "TRACE_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_LOG(Diagnostics, Session2, true, DataSize) << Session2.AppName(AppName.data(), int32(AppName.size())) << Session2.BuildVersion(BuildVersion.data(), int32(BuildVersion.size())) << Session2.Platform(Platform.data(), int32(Platform.size())) << Session2.CommandLine(CommandLine.data(), int32(CommandLine.size())) << Session2.ConfigurationType(uint8(Variant))"
  },
  {
    "label": "TRACE_CHANNEL_EXTERN()",
    "kind": "Method",
    "detail": "Function (} } # endif)",
    "insertText": "TRACE_CHANNEL_EXTERN(CpuChannel)"
  },
  {
    "label": "TraceCpuScope()",
    "kind": "Method",
    "detail": "Function (enum CpuScopeFlags : int32 { CpuFlush = 1<<0,} ; struct TraceCpuScope { ~)",
    "insertText": "TraceCpuScope()"
  },
  {
    "label": "Enter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Enter(int32 ScopeId, int32 Flags=0)"
  },
  {
    "label": "ScopeNew()",
    "kind": "Method",
    "detail": "Function (int32 _ScopeId = 0 ; } ; int32)",
    "insertText": "ScopeNew(const std::string_view& Name)"
  },
  {
    "label": "LaneIsTracing()",
    "kind": "Method",
    "detail": "Function (class Lane ; bool)",
    "insertText": "LaneIsTracing()"
  },
  {
    "label": "LaneNew()",
    "kind": "Method",
    "detail": "Function (Lane*)",
    "insertText": "LaneNew(const std::string_view& Name)"
  },
  {
    "label": "LaneDelete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LaneDelete(Lane* Handle)"
  },
  {
    "label": "LaneEnter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LaneEnter(Lane* Handle, int32 ScopeId)"
  },
  {
    "label": "LaneLeave()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LaneLeave()"
  },
  {
    "label": "TRACE_CPU_SCOPE()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "TRACE_CPU_SCOPE(name, ...) \\ trace::TraceCpuScope TRACE_PRIVATE_UNIQUE_VAR(cpu_scope)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(CpuChannel)"
  },
  {
    "label": "TRACE_PRIVATE_UNIQUE_VAR()",
    "kind": "Method",
    "detail": "Function (\\ using namespace std::literals ; \\ int32)",
    "insertText": "TRACE_PRIVATE_UNIQUE_VAR(scope_id)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(0 == TRACE_PRIVATE_UNIQUE_VAR(scope_id)) \\ TRACE_PRIVATE_UNIQUE_VAR(scope_id) = trace::ScopeNew(name##sv)"
  },
  {
    "label": "TRACE_PRIVATE_UNIQUE_VAR()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "TRACE_PRIVATE_UNIQUE_VAR(cpu_scope).Enter(TRACE_PRIVATE_UNIQUE_VAR(scope_id), ##__VA_ARGS__)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ } \\ do { })",
    "insertText": "while(0) #if TRACE_IMPLEMENT TRACE_CHANNEL_DEFINE(CpuChannel)"
  },
  {
    "label": "TRACE_EVENT_BEGIN()",
    "kind": "Method",
    "detail": "Function (namespace detail {)",
    "insertText": "TRACE_EVENT_BEGIN(CpuProfiler, EventSpec, NoSync|Important) TRACE_EVENT_FIELD(uint32, Id) TRACE_EVENT_FIELD(trace::AnsiString, Name) TRACE_EVENT_END() TRACE_EVENT_BEGIN(CpuProfiler, NextBatchContext, NoSync) TRACE_EVENT_FIELD(uint16, ThreadId) TRACE_EVENT_END() TRACE_EVENT_BEGIN(CpuProfiler, EventBatch, NoSync) TRACE_EVENT_FIELD(uint8[], Data) TRACE_EVENT_END() static int32 encode32_7bit(int32 value, void* __restrict out)"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (int32 length = 1 ;)",
    "insertText": "length(value >= (1 << 7))"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "length(value >= (1 << 14))"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "length(value >= (1 << 21))"
  },
  {
    "label": "ret()",
    "kind": "Method",
    "detail": "Function (int32 ret = value ;)",
    "insertText": "ret(ret & 0x0000'3fff) | ((ret & 0x0fff'c000) << 2)"
  },
  {
    "label": "ret()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ret(ret & 0x007f'007f) | ((ret & 0x3f80'3f80) << 1)"
  },
  {
    "label": "continuations()",
    "kind": "Method",
    "detail": "Function (int32 continuations = 0 x0080 ' 8 0 8 0 ;)",
    "insertText": "continuations(sizeof(value) - length)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (ret | = continuations)",
    "insertText": "memcpy(out, &ret, sizeof(value))"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (uint32 length = 1 ;)",
    "insertText": "length(value >= (1ll << 7))"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "length(value >= (1ll << 14))"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "length(value >= (1ll << 21))"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "length(value >= (1ll << 28))"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "length(value >= (1ll << 35))"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "length(value >= (1ll << 42))"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "length(value >= (1ll << 49))"
  },
  {
    "label": "ret()",
    "kind": "Method",
    "detail": "Function (int64 ret = value ;)",
    "insertText": "ret(ret & 0x0000'0000'0fff'ffffull) | ((ret & 0x00ff'ffff'f000'0000ull) << 4)"
  },
  {
    "label": "ret()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ret(ret & 0x0000'3fff'0000'3fffull) | ((ret & 0x0fff'c000'0fff'c000ull) << 2)"
  },
  {
    "label": "ret()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ret(ret & 0x007f'007f'007f'007full) | ((ret & 0x3f80'3f80'3f80'3f80ull) << 1)"
  },
  {
    "label": "Flush()",
    "kind": "Method",
    "detail": "Function (ThreadIdOverride = Value ; } void)",
    "insertText": "Flush(bool Force)"
  },
  {
    "label": "Enter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Enter(uint64 Timestamp, uint32 ScopeId, int32 Flag=0)"
  },
  {
    "label": "Leave()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Leave(uint64 Timestamp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using namespace detail ;)",
    "insertText": "if(Cursor == Buffer)"
  },
  {
    "label": "TRACE_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_LOG(CpuProfiler, EventBatch, true) << EventBatch.Data(Buffer, uint32(ptrdiff_t(Cursor - Buffer)))"
  },
  {
    "label": "Enter()",
    "kind": "Method",
    "detail": "Function (PrevTimestamp = 0 ; Cursor = Buffer ; } void)",
    "insertText": "Enter(uint64 Timestamp, uint32 ScopeId, int32 Flags)"
  },
  {
    "label": "encode64_7bit()",
    "kind": "Method",
    "detail": "Function (Timestamp - = PrevTimestamp ; PrevTimestamp + = Timestamp ; Cursor + =)",
    "insertText": "encode64_7bit((Timestamp) << 1 | EnterLsb, Cursor)"
  },
  {
    "label": "encode32_7bit()",
    "kind": "Method",
    "detail": "Function (Cursor + =)",
    "insertText": "encode32_7bit(ScopeId, Cursor)"
  },
  {
    "label": "ShouldFlush()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldFlush(Flags & CpuScopeFlags::CpuFlush)"
  },
  {
    "label": "Flush()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Flush(ShouldFlush)"
  },
  {
    "label": "encode64_7bit()",
    "kind": "Method",
    "detail": "Function (Timestamp - = PrevTimestamp ; PrevTimestamp + = Timestamp ; Cursor + =)",
    "insertText": "encode64_7bit((Timestamp << 1) | LeaveLsb, Cursor)"
  },
  {
    "label": "Flush()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Flush(false)"
  },
  {
    "label": "ThreadBuffer()",
    "kind": "Method",
    "detail": "Function (private : ~)",
    "insertText": "ThreadBuffer()"
  },
  {
    "label": "Enter()",
    "kind": "Method",
    "detail": "Function (TlsInstance . Inner .)",
    "insertText": "Enter(Timestamp, ScopeId, Flags)"
  },
  {
    "label": "Leave()",
    "kind": "Method",
    "detail": "Function (TlsInstance . Inner .)",
    "insertText": "Leave(Timestamp)"
  },
  {
    "label": "Flush()",
    "kind": "Method",
    "detail": "Function (Inner .)",
    "insertText": "Flush(true)"
  },
  {
    "label": "Lane()",
    "kind": "Method",
    "detail": "Function (} class Lane { public :)",
    "insertText": "Lane(const std::string_view& Name)"
  },
  {
    "label": "Lane()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "Lane()"
  },
  {
    "label": "Enter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Enter(int32 ScopeId)"
  },
  {
    "label": "Leave()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Leave()"
  },
  {
    "label": "Lane()",
    "kind": "Method",
    "detail": "Function (private : ScopeBuffer Buffer ; uint32 Id ; } ;)",
    "insertText": "Lane(const std::string_view& Name) : Id(ScopeNew(Name))"
  },
  {
    "label": "SetThreadId()",
    "kind": "Method",
    "detail": "Function (Buffer .)",
    "insertText": "SetThreadId(Id)"
  },
  {
    "label": "TimeGetTimestamp()",
    "kind": "Method",
    "detail": "Function (uint64 Timestamp =)",
    "insertText": "TimeGetTimestamp()"
  },
  {
    "label": "Enter()",
    "kind": "Method",
    "detail": "Function (Buffer .)",
    "insertText": "Enter(Timestamp, ScopeId)"
  },
  {
    "label": "AtomicAddRelaxed()",
    "kind": "Method",
    "detail": "Function (using namespace detail ; int32 volatile NextSpecId = 1 ; int32 SpecId =)",
    "insertText": "AtomicAddRelaxed(&NextSpecId, 1)"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (uint32 NameSize =)",
    "insertText": "uint32(Name.size())"
  },
  {
    "label": "TRACE_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_LOG(CpuProfiler, EventSpec, true, NameSize) << EventSpec.Id(uint32(SpecId)) << EventSpec.Name(Name.data(), NameSize)"
  },
  {
    "label": "Enter()",
    "kind": "Method",
    "detail": "Function (Handle ->)",
    "insertText": "Enter(ScopeId)"
  },
  {
    "label": "LaneLeave()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "LaneLeave(Lane* Handle)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using namespace detail ;)",
    "insertText": "if(!_ScopeId)"
  },
  {
    "label": "Enter()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Enter(int32 ScopeId, int32 Flags)"
  },
  {
    "label": "ArgPacker()",
    "kind": "Method",
    "detail": "Function (} } # endif namespace trace::detail { template<T> concept IsIntegral = std::is_integral<T>::value ; template<T> concept IsFloat = std::is_floating_point<T>::value ; class ArgPacker { public : template<. . . Types>)",
    "insertText": "ArgPacker(Types... Args)"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (const uint8*)",
    "insertText": "GetData()"
  },
  {
    "label": "PackValue()",
    "kind": "Method",
    "detail": "Function (} private : template<T> struct TypeId { } ; template<T> requires IsIntegral<T> struct TypeId<T> { enum { Value = 1<<6 } ; } ; template<T> requires IsFloat<T> struct TypeId<T> { enum { Value = 2<<6 } ; } ; enum { BufferSize = 5 1 2,TypeIdStr = 3<<6,} ; template<Type> uint32)",
    "insertText": "PackValue(Type&& Value)"
  },
  {
    "label": "Pack()",
    "kind": "Method",
    "detail": "Function (template<Type,. . . U> void)",
    "insertText": "Pack(Type&& Value, U... Next)"
  },
  {
    "label": "Pack()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Pack()"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (uint32 Size =)",
    "insertText": "sizeof(Type)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(Cursor, &Value, sizeof(Type))"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (int32 ArgCount =)",
    "insertText": "sizeof(Args)"
  },
  {
    "label": "uint8()",
    "kind": "Method",
    "detail": "Function (* Cursor =)",
    "insertText": "uint8(ArgCount)"
  },
  {
    "label": "Pack()",
    "kind": "Method",
    "detail": "Function (Cursor + = ArgCount + 1 ;)",
    "insertText": "Pack(std::forward<Types>(Args)...)"
  },
  {
    "label": "Pack()",
    "kind": "Method",
    "detail": "Function (} template<T,. . . U> void)",
    "insertText": "Pack(T&& Value, U... Next)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (uint8* TypeCursor = Buffer + Buffer [ 0 ] -)",
    "insertText": "sizeof(Next)"
  },
  {
    "label": "TRACE_CHANNEL_EXTERN()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "TRACE_CHANNEL_EXTERN(LogChannel)"
  },
  {
    "label": "LogMessageImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LogMessageImpl(int32 Id, const uint8* ParamBuffer, int32 ParamSize)"
  },
  {
    "label": "LogMessageNew()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "LogMessageNew(const std::string_view& Format, const std::string_view& File, int32 Line)"
  },
  {
    "label": "LogMessage()",
    "kind": "Method",
    "detail": "Function (template<. . . Types> void)",
    "insertText": "LogMessage(int32 Id, Types&&... Args)"
  },
  {
    "label": "Packer()",
    "kind": "Method",
    "detail": "Function (ArgPacker)",
    "insertText": "Packer(std::forward<Types>(Args)...)"
  },
  {
    "label": "LogMessageImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LogMessageImpl(Id, Packer.GetData(), Packer.GetSize())"
  },
  {
    "label": "TRACE_LOG_MESSAGE()",
    "kind": "Method",
    "detail": "Function (} } # define)",
    "insertText": "TRACE_LOG_MESSAGE(format, ...) \\ if (LogChannel)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\ using namespace std::literals ; \\ int32 message_id ; \\)",
    "insertText": "if(message_id == 0) \\ message_id = trace::detail::LogMessageNew( \\ format##sv, \\ TRACE_PRIVATE_CONCAT(__FILE__, sv), \\ __LINE__)"
  },
  {
    "label": "LogMessage()",
    "kind": "Method",
    "detail": "Function (\\ trace::)",
    "insertText": "LogMessage(message_id, ##__VA_ARGS__)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ } \\ do { })",
    "insertText": "while(0) #if TRACE_IMPLEMENT TRACE_CHANNEL_DEFINE(LogChannel)"
  },
  {
    "label": "TRACE_EVENT_BEGIN()",
    "kind": "Method",
    "detail": "Function (# if 0)",
    "insertText": "TRACE_EVENT_BEGIN(Logging, LogCategory, NoSync|Important) TRACE_EVENT_FIELD(const void*, CategoryPointer) TRACE_EVENT_FIELD(uint8, DefaultVerbosity) TRACE_EVENT_FIELD(trace::AnsiString, Name) TRACE_EVENT_END() #endif TRACE_EVENT_BEGIN(Logging, LogMessageSpec, NoSync|Important) TRACE_EVENT_FIELD(uint32, LogPoint) TRACE_EVENT_FIELD(uint16, Line) TRACE_EVENT_FIELD(trace::AnsiString, FileName) TRACE_EVENT_FIELD(trace::AnsiString, FormatString) TRACE_EVENT_END() TRACE_EVENT_BEGIN(Logging, LogMessage, NoSync) TRACE_EVENT_FIELD(uint32, LogPoint) TRACE_EVENT_FIELD(uint64, Cycle) TRACE_EVENT_FIELD(uint8[], FormatArgs) TRACE_EVENT_END() void LogMessageImpl(int32 Id, const uint8* ParamBuffer, int32 ParamSize)"
  },
  {
    "label": "TRACE_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_LOG(Logging, LogMessage, true) << LogMessage.LogPoint(Id) << LogMessage.Cycle(Timestamp) << LogMessage.FormatArgs(ParamBuffer, ParamSize)"
  },
  {
    "label": "AtomicAddRelaxed()",
    "kind": "Method",
    "detail": "Function (int32 volatile NextId = 1 ; int32 Id =)",
    "insertText": "AtomicAddRelaxed(&NextId, 1)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (int32 DataSize = 0 ; DataSize + =)",
    "insertText": "int32(Format.size())"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (DataSize + =)",
    "insertText": "int32(File.size())"
  },
  {
    "label": "TRACE_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_LOG(Logging, LogMessageSpec, true, DataSize) << LogMessageSpec.LogPoint(Id) << LogMessageSpec.Line(uint16(Line)) << LogMessageSpec.FileName(File.data(), int32(File.size())) << LogMessageSpec.FormatString(Format.data(), int32(Format.size()))"
  },
  {
    "label": "BookmarkNew()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "BookmarkNew(const std::string_view& Format, const std::string_view& File, uint32 Line)"
  },
  {
    "label": "Bookmark()",
    "kind": "Method",
    "detail": "Function (template<. . . Types> void)",
    "insertText": "Bookmark(uint32 Id, Types&&... Args)"
  },
  {
    "label": "BookmarkImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BookmarkImpl(Id, Packer.GetData(), Packer.GetSize())"
  },
  {
    "label": "TRACE_BOOKMARK()",
    "kind": "Method",
    "detail": "Function (} } # define)",
    "insertText": "TRACE_BOOKMARK(format, ...) \\ if (LogChannel)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\ using namespace std::literals ; \\ int32 bookmark_id ; \\)",
    "insertText": "if(bookmark_id == 0) \\ bookmark_id = trace::detail::BookmarkNew( \\ format##sv, \\ TRACE_PRIVATE_CONCAT(__FILE__, sv), \\ __LINE__)"
  },
  {
    "label": "Bookmark()",
    "kind": "Method",
    "detail": "Function (\\ trace::)",
    "insertText": "Bookmark(bookmark_id, ##__VA_ARGS__)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ } \\ do { })",
    "insertText": "while(0)"
  },
  {
    "label": "TRACE_EVENT_BEGIN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_EVENT_BEGIN(Misc, BookmarkSpec, NoSync|Important) TRACE_EVENT_FIELD(uint32, BookmarkPoint) TRACE_EVENT_FIELD(int32, Line) TRACE_EVENT_FIELD(trace::AnsiString, FormatString) TRACE_EVENT_FIELD(trace::AnsiString, FileName) TRACE_EVENT_END() TRACE_EVENT_BEGIN(Misc, Bookmark, NoSync) TRACE_EVENT_FIELD(uint64, Cycle) TRACE_EVENT_FIELD(uint32, BookmarkPoint) TRACE_EVENT_FIELD(uint8[], FormatArgs) TRACE_EVENT_END() void BookmarkImpl(uint32 Id, const uint8* ParamBuffer, uint32 ParamSize)"
  },
  {
    "label": "TRACE_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_LOG(Misc, Bookmark, true) << Bookmark.Cycle(Timestamp) << Bookmark.BookmarkPoint(Id) << Bookmark.FormatArgs(ParamBuffer, ParamSize)"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (uint32 Id =)",
    "insertText": "uint32(uintptr_t(Format.data()) >> 2)"
  },
  {
    "label": "TRACE_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_LOG(Misc, BookmarkSpec, true, DataSize) << BookmarkSpec.BookmarkPoint(Id) << BookmarkSpec.Line(uint16(Line)) << BookmarkSpec.FormatString(Format.data(), int32(Format.size())) << BookmarkSpec.FileName(File.data(), int32(File.size()))"
  }
]