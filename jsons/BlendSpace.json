[
  {
    "label": "UCachedAnalysisProperties",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UCachedAnalysisProperties"
  },
  {
    "label": "UBlendSpace",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UBlendSpace"
  },
  {
    "label": "UAnalysisProperties",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAnalysisProperties"
  },
  {
    "label": "EBlendSpaceAxis",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EBlendSpaceAxis"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FBlendSpaceBlendProfile",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBlendSpaceBlendProfile"
  },
  {
    "label": "FInterpolationParameter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FInterpolationParameter"
  },
  {
    "label": "FBlendParameter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBlendParameter"
  },
  {
    "label": "FBlendSample",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBlendSample"
  },
  {
    "label": "UAnimSequence",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAnimSequence"
  },
  {
    "label": "FBlendSpaceSegment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBlendSpaceSegment"
  },
  {
    "label": "FBlendSpaceTriangleEdgeInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBlendSpaceTriangleEdgeInfo"
  },
  {
    "label": "FBlendSpaceTriangle",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBlendSpaceTriangle"
  },
  {
    "label": "FWeightedBlendSample",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FWeightedBlendSample"
  },
  {
    "label": "FBlendSpaceData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBlendSpaceData"
  },
  {
    "label": "FEditorElement",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEditorElement"
  },
  {
    "label": "FGridBlendSample",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGridBlendSample"
  },
  {
    "label": "FPerBoneInterpolation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPerBoneInterpolation"
  },
  {
    "label": "Type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Type"
  },
  {
    "label": "FBlendSpaceDetails",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FBlendSpaceDetails"
  },
  {
    "label": "FBlendSampleDetails",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FBlendSampleDetails"
  },
  {
    "label": "UAnimGraphNode_BlendSpaceGraphBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAnimGraphNode_BlendSpaceGraphBase"
  },
  {
    "label": "FPropertyChangedEvent",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPropertyChangedEvent"
  },
  {
    "label": "FAnimNotifyQueue",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimNotifyQueue"
  },
  {
    "label": "UCLASS()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" UObject / ObjectMacros . h \" # include \" BoneContainer . h \" # include \" Animation / AnimationAsset . h \" # include \" AnimationRuntime . h \" # include \" AnimNodeBase . h \" # include \" Containers / ArrayView . h \" # include \" Animation / BoneSocketReference . h \" # include \" BlendSpace . generated . h \" class UCachedAnalysisProperties ; class UBlendSpace ;)",
    "insertText": "UCLASS(MinimalAPI, config=Engine)"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() public: virtual void InitializeFromCache(TObjectPtr<UCachedAnalysisProperties> Cache)"
  },
  {
    "label": "MakeCache()",
    "kind": "Method",
    "detail": "Function (} ; void)",
    "insertText": "MakeCache(TObjectPtr<UCachedAnalysisProperties>& Cache, UBlendSpace* BlendSpace)"
  },
  {
    "label": "UENUM()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "UENUM()"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (BSA_None)",
    "insertText": "UMETA(DisplayName = \"None\"), BSA_X UMETA(DisplayName = \"Horizontal (X) Axis\"), BSA_Y UMETA(DisplayName = \"Vertical (Y) Axis\")"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (None)",
    "insertText": "UMETA(DisplayName = \"None\", ToolTip = \"None\"), Tangential UMETA(DisplayName = \"Tangential\", ToolTip = \"When there is ambiguity, rectangles will be split so that the inserted edge tends to not point towards the origin\"), Radial UMETA(DisplayName = \"Radial\", ToolTip = \"When there is ambiguity, rectangles will be split so that the inserted edge tends to point towards the origin\")"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (ManualPerBoneOverride)",
    "insertText": "UMETA(DisplayName = \"Manual Per Bone Override\", ToolTip = \"Manually specify the bones and their smoothing interpolation times.\"), BlendProfile UMETA(DisplayName = \"Blend Profile\", ToolTip = \"Use a blend profile to specify the bone smoothing interpolation times.\")"
  },
  {
    "label": "USTRUCT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "USTRUCT()"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() UPROPERTY(EditAnywhere, Category = SampleSmoothing, meta = (DisplayName = \"Blend Profile\", UseAsBlendMask = true, EditConditionHides))"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() UPROPERTY(EditAnywhere, DisplayName = \"Smoothing Time\", Category=Parameter, meta = (ClampMin = \"0\"))"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() UPROPERTY(EditAnywhere, DisplayName = \"Name\", Category=BlendParameter)"
  },
  {
    "label": "FBlendParameter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBlendParameter() : DisplayName(TEXT(\"None\")) , Min(0.f) , Max(100.f) , GridNum(4) , bSnapToGrid(false) , bWrapInput(false)"
  },
  {
    "label": "GetRange()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GetRange()"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() UPROPERTY(EditAnywhere, Category=BlendSample)"
  },
  {
    "label": "FBlendSample()",
    "kind": "Method",
    "detail": "Function (int32 CachedMarkerDataUpdateCounter ; # endif)",
    "insertText": "FBlendSample() : Animation(nullptr) , SampleValue(0.f) , RateScale(1.0f) #if WITH_EDITORONLY_DATA , bIncludeInAnalyseAll(true) , bIsValid(false) , CachedMarkerDataUpdateCounter(INDEX_NONE)"
  },
  {
    "label": "FBlendSample()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FBlendSample(class UAnimSequence* InAnim, FVector InValue, bool bInIsSnapped, bool bInIsValid) : Animation(InAnim) , SampleValue(InValue) , RateScale(1.0f) #if WITH_EDITORONLY_DATA , bIncludeInAnalyseAll(true) , bIsValid(bInIsValid) , CachedMarkerDataUpdateCounter(INDEX_NONE)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FBlendSample& Other)"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY()"
  },
  {
    "label": "FVector2D()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FVector2D(0.f), FVector2D(0.f), FVector2D(0.f)"
  },
  {
    "label": "FWeightedBlendSample()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "FWeightedBlendSample(int32 Index = INDEX_NONE, float Weight = 0) : SampleIndex(Index), SampleWeight(Weight)"
  },
  {
    "label": "GetSamples()",
    "kind": "Method",
    "detail": "Function (public : void)",
    "insertText": "GetSamples(TArray<FWeightedBlendSample>& OutWeightedSamples, const TArray<int32>& InDimensionIndices, const FVector& InSamplePosition, int32& InOutTriangulationIndex)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "GetSamples1D()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "GetSamples1D(TArray<FWeightedBlendSample>& OutWeightedSamples, const TArray<int32>& InDimensionIndices, const FVector& InSamplePosition, int32& InOutSegmentIndex)"
  },
  {
    "label": "GetSamples2D()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetSamples2D(TArray<FWeightedBlendSample>& OutWeightedSamples, const TArray<int32>& InDimensionIndices, const FVector& InSamplePosition, int32& InOutTriangleIndex)"
  },
  {
    "label": "FEditorElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FEditorElement()"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() UPROPERTY()"
  },
  {
    "label": "FGridBlendSample()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FGridBlendSample() : BlendWeight(0)"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() UPROPERTY(EditAnywhere, Category=FPerBoneInterpolation)"
  },
  {
    "label": "FPerBoneInterpolation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPerBoneInterpolation() : InterpolationSpeedPerSec(6.f)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Initialize(const USkeleton* Skeleton)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (BoneReference .)",
    "insertText": "Initialize(Skeleton)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (enum Type : int { AllAnimations)",
    "insertText": "UMETA(DisplayName=\"All Animations\"), HighestWeightedAnimation UMETA(DisplayName=\"Highest Weighted Animation\")"
  },
  {
    "label": "UCLASS()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UCLASS(config=Engine, hidecategories=Object, MinimalAPI, BlueprintType)"
  },
  {
    "label": "GENERATED_UCLASS_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_UCLASS_BODY()"
  },
  {
    "label": "PostLoad()",
    "kind": "Method",
    "detail": "Function (class FBlendSampleDetails ; class UAnimGraphNode_BlendSpaceGraphBase ; void)",
    "insertText": "PostLoad()"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Serialize(FArchive& Ar)"
  },
  {
    "label": "PreEditChange()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR void)",
    "insertText": "PreEditChange(FProperty* PropertyAboutToChange)"
  },
  {
    "label": "PostEditChangeProperty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent)"
  },
  {
    "label": "GetResourceSizeEx()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "GetResourceSizeEx(FResourceSizeEx& CumulativeResourceSize)"
  },
  {
    "label": "TickAssetPlayer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TickAssetPlayer(FAnimTickRecord& Instance, struct FAnimNotifyQueue& NotifyQueue, FAnimAssetTickContext& Context)"
  },
  {
    "label": "GetPlayLength()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetPlayLength()"
  },
  {
    "label": "IsValidAdditive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsValidAdditive()"
  },
  {
    "label": "GetAllAnimationSequencesReferred()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR bool)",
    "insertText": "GetAllAnimationSequencesReferred(TArray<UAnimationAsset*>& AnimationAssets, bool bRecursive = true)"
  },
  {
    "label": "ReplaceReferredAnimations()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReplaceReferredAnimations(const TMap<UAnimationAsset*, UAnimationAsset*>& ReplacementMap)"
  },
  {
    "label": "GetMarkerUpdateCounter()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetMarkerUpdateCounter()"
  },
  {
    "label": "RuntimeValidateMarkerData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RuntimeValidateMarkerData()"
  },
  {
    "label": "GetPerBoneInterpolationData()",
    "kind": "Method",
    "detail": "Function (# endif TSharedPtr<IInterpolationIndexProvider::FPerBoneInterpolationData>)",
    "insertText": "GetPerBoneInterpolationData(const USkeleton* Skeleton)"
  },
  {
    "label": "GetPerBoneInterpolationIndex()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetPerBoneInterpolationIndex(const FCompactPoseBoneIndex& InCompactPoseBoneIndex, const FBoneContainer& RequiredBones, const IInterpolationIndexProvider::FPerBoneInterpolationData* Data)"
  },
  {
    "label": "GetPerBoneInterpolationIndex()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetPerBoneInterpolationIndex(const FSkeletonPoseBoneIndex InSkeletonBoneIndex, const USkeleton* TargetSkeleton, const IInterpolationIndexProvider::FPerBoneInterpolationData* Data)"
  },
  {
    "label": "IsValidAdditiveType()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsValidAdditiveType(EAdditiveAnimationType AdditiveType)"
  },
  {
    "label": "GetAnimationPose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetAnimationPose(TArray<FBlendSampleData>& BlendSampleDataCache, const FAnimExtractContext& ExtractionContext, FAnimationPoseData& OutAnimationPoseData)"
  },
  {
    "label": "GetAnimationPose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetAnimationPose(TArray<FBlendSampleData>& BlendSampleDataCache, TArrayView<FPoseLink> InPoseLinks, const FAnimExtractContext& ExtractionContext, FPoseContext& Output)"
  },
  {
    "label": "GetBlendParameter()",
    "kind": "Method",
    "detail": "Function (const FBlendParameter&)",
    "insertText": "GetBlendParameter(const int32 Index)"
  },
  {
    "label": "GetBlendSamples()",
    "kind": "Method",
    "detail": "Function (const TArray<struct FBlendSample>&)",
    "insertText": "GetBlendSamples()"
  },
  {
    "label": "GetSamplesFromBlendInput()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetSamplesFromBlendInput(const FVector &BlendInput, TArray<FBlendSampleData> & OutSampleDataList, int32& InOutCachedTriangulationIndex, bool bCombineAnimations)"
  },
  {
    "label": "GetAnimationLengthFromSampleData()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetAnimationLengthFromSampleData(const TArray<FBlendSampleData>& SampleDataList)"
  },
  {
    "label": "InitializeFilter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeFilter(FBlendFilter* Filter, int NumDimensions = 2)"
  },
  {
    "label": "UpdateFilterParams()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateFilterParams(FBlendFilter* Filter)"
  },
  {
    "label": "GetClampedAndWrappedBlendInput()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetClampedAndWrappedBlendInput(const FVector& BlendInput)"
  },
  {
    "label": "UpdateBlendSamples()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "UpdateBlendSamples(const FVector& InBlendSpacePosition, float InDeltaTime, TArray<FBlendSampleData>& InOutSampleDataCache, int32& InOutCachedTriangulationIndex)"
  },
  {
    "label": "ResetBlendSamples()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetBlendSamples(TArray<FBlendSampleData>& InOutSampleDataCache, float InNormalizedCurrentTime, bool bLooping, bool bMatchSyncPhases = true)"
  },
  {
    "label": "ForEachImmutableSample()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ForEachImmutableSample(const TFunctionRef<void(const FBlendSample&)> Func)"
  },
  {
    "label": "FilterInput()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "FilterInput(FBlendFilter* Filter, const FVector& BlendInput, float DeltaTime)"
  },
  {
    "label": "UpdateBlendSpacesUsingAnimSequence()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR void)",
    "insertText": "UpdateBlendSpacesUsingAnimSequence(UAnimSequenceBase* Sequence)"
  },
  {
    "label": "ValidateSampleData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ValidateSampleData()"
  },
  {
    "label": "AddSample()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "AddSample(const FVector& SampleValue)"
  },
  {
    "label": "AddSample()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "AddSample(UAnimSequence* AnimationSequence, const FVector& SampleValue)"
  },
  {
    "label": "ExpandRangeForSample()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpandRangeForSample(const FVector& SampleValue)"
  },
  {
    "label": "EditSampleValue()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "EditSampleValue(const int32 BlendSampleIndex, const FVector& NewValue)"
  },
  {
    "label": "ReplaceSampleAnimation()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ReplaceSampleAnimation(const int32 BlendSampleIndex, UAnimSequence* AnimationSequence)"
  },
  {
    "label": "DeleteSample()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "DeleteSample(const int32 BlendSampleIndex)"
  },
  {
    "label": "GetNumberOfBlendSamples()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumberOfBlendSamples()"
  },
  {
    "label": "IsValidBlendSampleIndex()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValidBlendSampleIndex(const int32 SampleIndex)"
  },
  {
    "label": "GetGridSamples()",
    "kind": "Method",
    "detail": "Function (const TArray<FEditorElement>&)",
    "insertText": "GetGridSamples()"
  },
  {
    "label": "GetGridPosition()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetGridPosition(int32 GridIndex)"
  },
  {
    "label": "GetGridPosition()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetGridPosition(int32 GridX, int32 GridY)"
  },
  {
    "label": "GetBlendSpaceData()",
    "kind": "Method",
    "detail": "Function (const FBlendSpaceData&)",
    "insertText": "GetBlendSpaceData()"
  },
  {
    "label": "ResampleData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResampleData()"
  },
  {
    "label": "SetBlendSpaceData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetBlendSpaceData(const TArray<FBlendSpaceSegment>& Segments)"
  },
  {
    "label": "ValidateAnimationSequence()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ValidateAnimationSequence(const UAnimSequence* AnimationSequence)"
  },
  {
    "label": "DoesAnimationMatchExistingSamples()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "DoesAnimationMatchExistingSamples(const UAnimSequence* AnimationSequence)"
  },
  {
    "label": "ShouldAnimationBeAdditive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldAnimationBeAdditive()"
  },
  {
    "label": "IsAnimationCompatibleWithSkeleton()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsAnimationCompatibleWithSkeleton(const UAnimSequence* AnimationSequence)"
  },
  {
    "label": "IsAnimationCompatible()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsAnimationCompatible(const UAnimSequence* AnimationSequence)"
  },
  {
    "label": "ValidateSampleValue()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ValidateSampleValue(const FVector& SampleValue, int32 OriginalIndex = INDEX_NONE)"
  },
  {
    "label": "IsSampleWithinBounds()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSampleWithinBounds(const FVector &SampleValue)"
  },
  {
    "label": "IsTooCloseToExistingSamplePoint()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsTooCloseToExistingSamplePoint(const FVector& SampleValue, int32 OriginalIndex)"
  },
  {
    "label": "GetRawSamplesFromBlendInput()",
    "kind": "Method",
    "detail": "Function (# endif protected : void)",
    "insertText": "GetRawSamplesFromBlendInput(const FVector& BlendInput, TArray<FGridBlendSample, TInlineAllocator<4> >& OutBlendSamples)"
  },
  {
    "label": "GetAxisToScale()",
    "kind": "Method",
    "detail": "Function (EBlendSpaceAxis)",
    "insertText": "GetAxisToScale()"
  },
  {
    "label": "TickFollowerSamples()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TickFollowerSamples(TArray<FBlendSampleData> &SampleDataList, const int32 HighestWeightIndex, FAnimAssetTickContext &Context, bool bResetMarkerDataOnFollowers, bool bLooping, const UMirrorDataTable* MirrorDataTable = nullptr)"
  },
  {
    "label": "GetClampedBlendInput()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetClampedBlendInput(const FVector& BlendInput)"
  },
  {
    "label": "ConvertBlendInputToGridSpace()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "ConvertBlendInputToGridSpace(const FVector& BlendInput)"
  },
  {
    "label": "GetNormalizedBlendInput()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetNormalizedBlendInput(const FVector& BlendInput)"
  },
  {
    "label": "GetGridSampleInternal()",
    "kind": "Method",
    "detail": "Function (const FEditorElement*)",
    "insertText": "GetGridSampleInternal(int32 Index)"
  },
  {
    "label": "InterpolateWeightOfSampleData()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "InterpolateWeightOfSampleData(float DeltaTime, const TArray<FBlendSampleData> & OldSampleDataList, const TArray<FBlendSampleData> & NewSampleDataList, TArray<FBlendSampleData> & FinalSampleDataList)"
  },
  {
    "label": "ContainsMatchingSamples()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ContainsMatchingSamples(EAdditiveAnimationType AdditiveType)"
  },
  {
    "label": "IsSameSamplePoint()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSameSamplePoint(const FVector& SamplePointA, const FVector& SamplePointB)"
  },
  {
    "label": "ContainsNonAdditiveSamples()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR bool)",
    "insertText": "ContainsNonAdditiveSamples()"
  },
  {
    "label": "UpdatePreviewBasePose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdatePreviewBasePose()"
  },
  {
    "label": "SnapSamplesToClosestGridPoint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SnapSamplesToClosestGridPoint()"
  },
  {
    "label": "GetAnimationPose_Internal()",
    "kind": "Method",
    "detail": "Function (# endif private : void)",
    "insertText": "GetAnimationPose_Internal(TArray<FBlendSampleData>& BlendSampleDataCache, TArrayView<FPoseLink> InPoseLinks, FAnimInstanceProxy* InProxy, bool bInExpectsAdditivePose, const FAnimExtractContext& ExtractionContext, FAnimationPoseData& OutAnimationPoseData)"
  },
  {
    "label": "UpdateBlendSamples_Internal()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "UpdateBlendSamples_Internal(const FVector& InBlendSpacePosition, float InDeltaTime, TArray<FBlendSampleData>& InOutOldSampleDataList, TArray<FBlendSampleData>& InOutSampleDataCache, int32& InOutCachedTriangulationIndex)"
  },
  {
    "label": "ResetToRefPose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetToRefPose(FCompactPose& OutPose)"
  },
  {
    "label": "GetRawSamplesFromBlendInput1D()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR private : int32 MarkerDataUpdateCounter ; protected : FVector PreviousAxisMinMaxValues [ 3 ] ; float PreviousGridSpacings [ 3 ] ; # endif private : void)",
    "insertText": "GetRawSamplesFromBlendInput1D(const FVector& BlendInput, TArray<FGridBlendSample, TInlineAllocator<4> >& OutBlendSamples)"
  },
  {
    "label": "GetRawSamplesFromBlendInput2D()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetRawSamplesFromBlendInput2D(const FVector& BlendInput, TArray<FGridBlendSample, TInlineAllocator<4> >& OutBlendSamples)"
  },
  {
    "label": "FillupGridElements()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FillupGridElements(const TArray<FEditorElement>& GridElements, const TArray<int32>& InDimensionIndices)"
  },
  {
    "label": "EmptyGridElements()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EmptyGridElements()"
  },
  {
    "label": "ClearBlendSpaceData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearBlendSpaceData()"
  },
  {
    "label": "SetBlendSpaceData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetBlendSpaceData(const TArray<FBlendSpaceTriangle>& Triangles)"
  },
  {
    "label": "ResampleData1D()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResampleData1D()"
  },
  {
    "label": "ResampleData2D()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResampleData2D()"
  },
  {
    "label": "GetEditorElement()",
    "kind": "Method",
    "detail": "Function (const FEditorElement*)",
    "insertText": "GetEditorElement(int32 XIndex, int32 YIndex)"
  }
]