[
  {
    "label": "FArchive",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FArchive"
  },
  {
    "label": "FModuleManager",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FModuleManager"
  },
  {
    "label": "FOutputDevice",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FOutputDevice"
  },
  {
    "label": "UClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UClass"
  },
  {
    "label": "UWorld",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UWorld"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FModuleStatus",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FModuleStatus"
  },
  {
    "label": "FModuleDiskInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FModuleDiskInfo"
  },
  {
    "label": "FPrivateToken",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPrivateToken"
  },
  {
    "label": "FModuleInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FModuleInfo"
  },
  {
    "label": "FModuleManagerLibraryTracker",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FModuleManagerLibraryTracker"
  },
  {
    "label": "ModuleClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ModuleClass"
  },
  {
    "label": "FStaticallyLinkedModuleRegistrant",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FStaticallyLinkedModuleRegistrant"
  },
  {
    "label": "FModuleInitializerEntry",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FModuleInitializerEntry"
  },
  {
    "label": "FDefaultModuleImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDefaultModuleImpl"
  },
  {
    "label": "FDefaultGameModuleImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDefaultGameModuleImpl"
  },
  {
    "label": "FSigningKeyRegistration",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSigningKeyRegistration"
  },
  {
    "label": "FEncryptionKeyRegistration",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEncryptionKeyRegistration"
  },
  {
    "label": "FTargetNameRegistration",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTargetNameRegistration"
  },
  {
    "label": "FAutoSet",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAutoSet"
  },
  {
    "label": "IReload",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IReload"
  },
  {
    "label": "GetClassesToReinstanceForHotReload()",
    "kind": "Method",
    "detail": "Function (# endif # if WITH_ENGINE TMap<UClass*,UClass*>&)",
    "insertText": "GetClassesToReinstanceForHotReload()"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (# endif enum class EModuleLoadResult { Success,FileNotFound,FileIncompatible,CouldNotBeLoadedByOS,FailedToInitialize,NotLoadedByGameThread } ; enum class EModuleUnloadResult { Success,UnloadNotSupported } ; enum class EModuleChangeReason { ModuleLoaded,ModuleUnloaded,PluginDirectoryChanged } ; enum class ECheckModuleCompatibilityFlags { None = 0 x00,DisplayUpToDateModules = 0 x01 } ;)",
    "insertText": "ENUM_CLASS_FLAGS(ECheckModuleCompatibilityFlags)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (None = 0 x0,LogFailures = 1<<0,} ;)",
    "insertText": "ENUM_CLASS_FLAGS(ELoadModuleFlags)"
  },
  {
    "label": "FModuleStatus()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FModuleStatus() : bIsLoaded(false) , bIsGameModule(false)"
  },
  {
    "label": "GetModuleManagerSingleton()",
    "kind": "Method",
    "detail": "Function (} FString Name ; FString FilePath ; bool bIsLoaded ; bool bIsGameModule ; } ; struct FModuleDiskInfo { FName Name ; FString FilePath ; } ; namespace UE::Core::Private { TOptional<FModuleManager>&)",
    "insertText": "GetModuleManagerSingleton()"
  },
  {
    "label": "FModuleManager()",
    "kind": "Method",
    "detail": "Function (} class FModuleManager : private FSelfRegisteringExec { public : ~)",
    "insertText": "FModuleManager()"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (FModuleManager&)",
    "insertText": "Get()"
  },
  {
    "label": "TearDown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TearDown()"
  },
  {
    "label": "AbandonModule()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AbandonModule(const FName InModuleName)"
  },
  {
    "label": "AddModule()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddModule(const FName InModuleName)"
  },
  {
    "label": "RefreshModuleFilenameFromManifest()",
    "kind": "Method",
    "detail": "Function (# if ! IS_MONOLITHIC void)",
    "insertText": "RefreshModuleFilenameFromManifest(const FName InModuleName)"
  },
  {
    "label": "GetModule()",
    "kind": "Method",
    "detail": "Function (# endif IModuleInterface*)",
    "insertText": "GetModule(const FName InModuleName)"
  },
  {
    "label": "IsModuleLoaded()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsModuleLoaded(const FName InModuleName)"
  },
  {
    "label": "LoadModule()",
    "kind": "Method",
    "detail": "Function (IModuleInterface*)",
    "insertText": "LoadModule(const FName InModuleName, ELoadModuleFlags InLoadModuleFlags = ELoadModuleFlags::None)"
  },
  {
    "label": "LoadModuleChecked()",
    "kind": "Method",
    "detail": "Function (IModuleInterface&)",
    "insertText": "LoadModuleChecked(const FName InModuleName)"
  },
  {
    "label": "LoadModuleWithCallback()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "LoadModuleWithCallback(const FName InModuleName, FOutputDevice &Ar)"
  },
  {
    "label": "LoadModuleWithFailureReason()",
    "kind": "Method",
    "detail": "Function (IModuleInterface*)",
    "insertText": "LoadModuleWithFailureReason(const FName InModuleName, EModuleLoadResult& OutFailureReason, ELoadModuleFlags InLoadModuleFlags = ELoadModuleFlags::None)"
  },
  {
    "label": "QueryModule()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "QueryModule(const FName InModuleName, FModuleStatus& OutModuleStatus)"
  },
  {
    "label": "QueryModules()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "QueryModules(TArray<FModuleStatus>& OutModuleStatuses)"
  },
  {
    "label": "UnloadModule()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "UnloadModule(const FName InModuleName, bool bIsShutdown = false, bool bAllowUnloadCode = true)"
  },
  {
    "label": "UnloadOrAbandonModuleWithCallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnloadOrAbandonModuleWithCallback(const FName InModuleName, FOutputDevice &Ar)"
  },
  {
    "label": "AbandonModuleWithCallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AbandonModuleWithCallback(const FName InModuleName)"
  },
  {
    "label": "AddExtraBinarySearchPaths()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddExtraBinarySearchPaths()"
  },
  {
    "label": "GetModuleChecked()",
    "kind": "Method",
    "detail": "Function (template<TModuleInterface> TModuleInterface&)",
    "insertText": "GetModuleChecked(const FName ModuleName)"
  },
  {
    "label": "GetModulePtr_Internal()",
    "kind": "Method",
    "detail": "Function (} private : IModuleInterface*)",
    "insertText": "GetModulePtr_Internal(FName ModuleName)"
  },
  {
    "label": "GetOrLoadModule()",
    "kind": "Method",
    "detail": "Function (IModuleInterface*)",
    "insertText": "GetOrLoadModule(const FName InModuleName, EModuleLoadResult& OutFailureReason, ELoadModuleFlags InLoadModuleFlags = ELoadModuleFlags::None)"
  },
  {
    "label": "GetModulePtr()",
    "kind": "Method",
    "detail": "Function (public : template<TModuleInterface> TModuleInterface*)",
    "insertText": "GetModulePtr(const FName ModuleName)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (IModuleInterface& ModuleInterface =)",
    "insertText": "Get().LoadModuleChecked(InModuleName)"
  },
  {
    "label": "LoadModulePtr()",
    "kind": "Method",
    "detail": "Function (} template<TModuleInterface> TModuleInterface*)",
    "insertText": "LoadModulePtr(const FName InModuleName)"
  },
  {
    "label": "FindModules()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "FindModules(const TCHAR* WildcardWithoutExtension, TArray<FName>& OutModules)"
  },
  {
    "label": "FindModules()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindModules(const TCHAR* WildcardWithoutExtension, TArray<FModuleDiskInfo>& OutModules)"
  },
  {
    "label": "ModuleExists()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ModuleExists(const TCHAR* ModuleName, FString* OutModuleFilePath = nullptr)"
  },
  {
    "label": "GetModuleCount()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetModuleCount()"
  },
  {
    "label": "UnloadModulesAtShutdown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnloadModulesAtShutdown()"
  },
  {
    "label": "DECLARE_DELEGATE_RetVal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_DELEGATE_RetVal(IModuleInterface*, FInitializeStaticallyLinkedModule ) void RegisterStaticallyLinkedModule( const FLazyName InModuleName, const FInitializeStaticallyLinkedModule& InInitializerDelegate)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (PendingStaticallyLinkedModuleInitializers .)",
    "insertText": "Emplace(InModuleName, InInitializerDelegate)"
  },
  {
    "label": "StartProcessingNewlyLoadedObjects()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "StartProcessingNewlyLoadedObjects()"
  },
  {
    "label": "AddBinariesDirectory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddBinariesDirectory(const TCHAR *InDirectory, bool bIsGameDirectory)"
  },
  {
    "label": "LoadModuleBinaryOnly()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LoadModuleBinaryOnly(FName ModuleName)"
  },
  {
    "label": "SetGameBinariesDirectory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetGameBinariesDirectory(const TCHAR* InDirectory)"
  },
  {
    "label": "GetGameBinariesDirectory()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "GetGameBinariesDirectory()"
  },
  {
    "label": "IsModuleUpToDate()",
    "kind": "Method",
    "detail": "Function (# if ! IS_MONOLITHIC bool)",
    "insertText": "IsModuleUpToDate(const FName InModuleName)"
  },
  {
    "label": "DoesLoadedModuleHaveUObjects()",
    "kind": "Method",
    "detail": "Function (# endif bool)",
    "insertText": "DoesLoadedModuleHaveUObjects(const FName ModuleName)"
  },
  {
    "label": "GetUBTConfiguration()",
    "kind": "Method",
    "detail": "Function (const TCHAR*)",
    "insertText": "GetUBTConfiguration()"
  },
  {
    "label": "GetModuleFilename()",
    "kind": "Method",
    "detail": "Function (# if ! IS_MONOLITHIC FString)",
    "insertText": "GetModuleFilename(FName ModuleName)"
  },
  {
    "label": "SetModuleFilename()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetModuleFilename(FName ModuleName, const FString& Filename)"
  },
  {
    "label": "HasAnyOverridenModuleFilename()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasAnyOverridenModuleFilename()"
  },
  {
    "label": "SaveCurrentStateForBootstrap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SaveCurrentStateForBootstrap(const TCHAR* Filename)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (TTSMulticastDelegateRegistration<)",
    "insertText": "void(FName ModuleName, EModuleChangeReason ChangeReason)>& OnModulesChanged()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (TMulticastDelegateRegistration<)",
    "insertText": "void(FName, bool)>& OnProcessLoadedObjectsCallback()"
  },
  {
    "label": "IsPackageLoadedCallback()",
    "kind": "Method",
    "detail": "Function (FIsPackageLoadedCallback&)",
    "insertText": "IsPackageLoadedCallback()"
  },
  {
    "label": "FPrivateToken()",
    "kind": "Method",
    "detail": "Function (struct FPrivateToken {)",
    "insertText": "FPrivateToken()"
  },
  {
    "label": "FModuleManager()",
    "kind": "Method",
    "detail": "Function (} ; public :)",
    "insertText": "FModuleManager(FPrivateToken)"
  },
  {
    "label": "FModuleManager()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FModuleManager(const FModuleManager&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FModuleManager&)",
    "insertText": "operator(const FModuleManager&)"
  },
  {
    "label": "FModuleInfo()",
    "kind": "Method",
    "detail": "Function (private : class FModuleInfo { public : FString OriginalFilename ; FString Filename ; void* Handle ; TUniquePtr<IModuleInterface> Module ; bool bWasUnloadedAtShutdown ; TAtomic<bool> bIsReady ; int32 LoadOrder ; int32 CurrentLoadOrder ; public :)",
    "insertText": "FModuleInfo() : Handle(nullptr) , bWasUnloadedAtShutdown(false) , bIsReady(false) , LoadOrder(CurrentLoadOrder++)"
  },
  {
    "label": "FModuleInfo()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FModuleInfo()"
  },
  {
    "label": "MakeUniqueModuleFilename()",
    "kind": "Method",
    "detail": "Function (} } ; typedef TSharedPtr<FModuleInfo,ESPMode::ThreadSafe> ModuleInfoPtr ; typedef TSharedRef<FModuleInfo,ESPMode::ThreadSafe> ModuleInfoRef ; typedef TMap<FName,ModuleInfoRef> FModuleMap ; public : void)",
    "insertText": "MakeUniqueModuleFilename(const FName InModuleName, FString& UniqueSuffix, FString& UniqueModuleFileName)"
  },
  {
    "label": "AddModuleToModulesList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddModuleToModulesList(const FName InModuleName, FModuleManager::ModuleInfoRef& ModuleInfo)"
  },
  {
    "label": "ResetModulePathsCache()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetModulePathsCache()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FArchive&)",
    "insertText": "operator(FArchive& Ar, FModuleManager& ModuleManager)"
  },
  {
    "label": "WarnIfItWasntSafeToLoadHere()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "WarnIfItWasntSafeToLoadHere(const FName InModuleName)"
  },
  {
    "label": "FindModule()",
    "kind": "Method",
    "detail": "Function (ModuleInfoPtr)",
    "insertText": "FindModule(FName InModuleName)"
  },
  {
    "label": "FindModuleChecked()",
    "kind": "Method",
    "detail": "Function (ModuleInfoRef)",
    "insertText": "FindModuleChecked(FName InModuleName)"
  },
  {
    "label": "FindModulePaths()",
    "kind": "Method",
    "detail": "Function (} # if ! IS_MONOLITHIC void)",
    "insertText": "FindModulePaths(const TCHAR *NamePattern, TMap<FName, FString> &OutModulePaths)"
  },
  {
    "label": "FindModulePathsInDirectory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindModulePathsInDirectory(const FString &DirectoryName, bool bIsGameDirectory, TMap<FName, FString> &OutModulePaths)"
  },
  {
    "label": "SerializeStateForBootstrap_Impl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SerializeStateForBootstrap_Impl(FArchive& Ar)"
  },
  {
    "label": "RefreshModuleFilenameFromManifestImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefreshModuleFilenameFromManifestImpl(const FName InModuleName, FModuleInfo& ModuleInfo)"
  },
  {
    "label": "InternalLoadLibrary()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "InternalLoadLibrary(FName ModuleName, const FString& ModuleFileToLoad)"
  },
  {
    "label": "InternalFreeLibrary()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InternalFreeLibrary(FName ModuleName, void* Handle)"
  },
  {
    "label": "ProcessPendingStaticallyLinkedModuleInitializers()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "ProcessPendingStaticallyLinkedModuleInitializers()"
  },
  {
    "label": "FModuleManagerLibraryTracker()",
    "kind": "Method",
    "detail": "Function (private : FModuleMap Modules ; # if UE_MERGED_MODULES struct FModuleManagerLibraryTracker {)",
    "insertText": "FModuleManagerLibraryTracker() : Handle(nullptr) , Users()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} void* Handle ; TArray<FName> Users ; } ; TMap<FString,FModuleManagerLibraryTracker> LoadedDynamicLibraries ; # endif TArray<TPair<FLazyName,FInitializeStaticallyLinkedModule>,TInlineAllocator<1 6>> PendingStaticallyLinkedModuleInitializers ; TMap<FName,FInitializeStaticallyLinkedModule> StaticallyLinkedModuleInitializers ; bool bCanProcessNewlyLoadedObjects ; bool bExtraBinarySearchPathsAdded ; TMap<FName,FString> ModulePathsCache ; TTSMulticastDelegate<)",
    "insertText": "void(FName ModuleName, EModuleChangeReason ChangeReason)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (TMulticastDelegate<)",
    "insertText": "void(FName, bool)"
  },
  {
    "label": "FStaticallyLinkedModuleRegistrant()",
    "kind": "Method",
    "detail": "Function (FIsPackageLoadedCallback IsPackageLoaded ; TArray<FString> EngineBinariesDirectories ; TArray<FString> PendingEngineBinariesDirectories ; TArray<FString> GameBinariesDirectories ; TArray<FString> PendingGameBinariesDirectories ; TOptional<FString> BuildId ; FCriticalSection ModulesCriticalSection ; } ; template<class ModuleClass> class FStaticallyLinkedModuleRegistrant { public :)",
    "insertText": "FStaticallyLinkedModuleRegistrant(FLazyName InModuleName)"
  },
  {
    "label": "CreateRaw()",
    "kind": "Method",
    "detail": "Function (FModuleManager::FInitializeStaticallyLinkedModule InitializerDelegate = FModuleManager::)",
    "insertText": "CreateRaw(this, &FStaticallyLinkedModuleRegistrant<ModuleClass>::InitializeModule)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Get().RegisterStaticallyLinkedModule( InModuleName, InitializerDelegate)"
  },
  {
    "label": "InitializeModule()",
    "kind": "Method",
    "detail": "Function (} IModuleInterface*)",
    "insertText": "InitializeModule()"
  },
  {
    "label": "IModuleInterface()",
    "kind": "Method",
    "detail": "Function (} } ; typedef)",
    "insertText": "IModuleInterface(*FInitializeModuleFunctionPtr )( void)"
  },
  {
    "label": "FModuleInitializerEntry()",
    "kind": "Method",
    "detail": "Function (class FModuleInitializerEntry { public :)",
    "insertText": "FModuleInitializerEntry(const TCHAR* InName, FInitializeModuleFunctionPtr InFunction, const TCHAR* InName2 = nullptr)"
  },
  {
    "label": "FModuleInitializerEntry()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FModuleInitializerEntry()"
  },
  {
    "label": "FindModule()",
    "kind": "Method",
    "detail": "Function (FInitializeModuleFunctionPtr)",
    "insertText": "FindModule(const TCHAR* Name)"
  },
  {
    "label": "IsGameModule()",
    "kind": "Method",
    "detail": "Function (private : FModuleInitializerEntry* Prev ; FModuleInitializerEntry* Next ; const TCHAR* Name ; const TCHAR* Name2 ; FInitializeModuleFunctionPtr Function ; } ; class FDefaultModuleImpl : public IModuleInterface { } ; class FDefaultGameModuleImpl : public FDefaultModuleImpl { bool)",
    "insertText": "IsGameModule()"
  },
  {
    "label": "ModuleName()",
    "kind": "Method",
    "detail": "Function (\\ \\ \" C \" void IMPLEMENT_MODULE_ # #)",
    "insertText": "ModuleName()"
  },
  {
    "label": "UE_STATIC_ASSERT_WARN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UE_STATIC_ASSERT_WARN(UE::Core::Private::ModuleNameEquals(#ModuleName, UE_MODULE_NAME ), \"Module name mismatch (\" #ModuleName \" != \" UE_MODULE_NAME \"). Please ensure module name passed to IMPLEMENT_MODULE is \" UE_MODULE_NAME \" to avoid runtime errors in monolithic builds.\")"
  },
  {
    "label": "PER_MODULE_BOILERPLATE_ANYLINK()",
    "kind": "Method",
    "detail": "Function (} \\)",
    "insertText": "PER_MODULE_BOILERPLATE_ANYLINK(ModuleImplClass, ModuleName) #else #define IMPLEMENT_MODULE( ModuleImplClass, ModuleName ) \\ \\ \\ \\ \\ \\ \\ static IModuleInterface* Initialize##ModuleName##Module()"
  },
  {
    "label": "ModuleImplClass()",
    "kind": "Method",
    "detail": "Function (\\ return new)",
    "insertText": "ModuleImplClass()"
  },
  {
    "label": "InitializerEntry()",
    "kind": "Method",
    "detail": "Function (\\ } \\ FModuleInitializerEntry ModuleName # #)",
    "insertText": "InitializerEntry(TEXT(#ModuleName), Initialize##ModuleName##Module, TEXT(UE_MODULE_NAME))"
  },
  {
    "label": "PER_MODULE_BOILERPLATE_ANYLINK()",
    "kind": "Method",
    "detail": "Function (} \\)",
    "insertText": "PER_MODULE_BOILERPLATE_ANYLINK(ModuleImplClass, ModuleName) #endif #define IMPLEMENT_GAME_MODULE( ModuleImplClass, ModuleName ) \\ IMPLEMENT_MODULE( ModuleImplClass, ModuleName ) #if PLATFORM_DESKTOP #ifdef UE_ENGINE_DIRECTORY #define IMPLEMENT_FOREIGN_ENGINE_DIR() const TCHAR *GForeignEngineDir = TEXT( UE_ENGINE_DIRECTORY)"
  },
  {
    "label": "IMPLEMENT_FOREIGN_ENGINE_DIR()",
    "kind": "Method",
    "detail": "Function (# else # define)",
    "insertText": "IMPLEMENT_FOREIGN_ENGINE_DIR()"
  },
  {
    "label": "IMPLEMENT_FOREIGN_ENGINE_DIR()",
    "kind": "Method",
    "detail": "Function (# endif # else # define)",
    "insertText": "IMPLEMENT_FOREIGN_ENGINE_DIR() #endif #define UE_LIST_ARGUMENT(...) __VA_ARGS__ #define UE_REGISTER_SIGNING_KEY(ExponentValue, ModulusValue)"
  },
  {
    "label": "FSigningKeyRegistration()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "FSigningKeyRegistration()"
  },
  {
    "label": "RegisterSigningKeyCallback()",
    "kind": "Method",
    "detail": "Function (\\ void)",
    "insertText": "RegisterSigningKeyCallback(void (*)(TArray<uint8>&, TArray<uint8>&))"
  },
  {
    "label": "RegisterSigningKeyCallback()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "RegisterSigningKeyCallback(&Callback)"
  },
  {
    "label": "Callback()",
    "kind": "Method",
    "detail": "Function (\\ } \\ void)",
    "insertText": "Callback(TArray<uint8>& OutExponent, TArray<uint8>& OutModulus)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (\\ const uint8 Exponent [ ] = { ExponentValue } ; \\ const uint8 Modulus [ ] = { ModulusValue } ; \\ OutExponent .)",
    "insertText": "SetNum(UE_ARRAY_COUNT(Exponent))"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (\\ OutModulus .)",
    "insertText": "SetNum(UE_ARRAY_COUNT(Modulus))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "for(int ByteIdx = 0; ByteIdx < UE_ARRAY_COUNT(Exponent); ByteIdx++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (\\ OutExponent [ ByteIdx ] = Exponent [ ByteIdx ] ; \\ } \\)",
    "insertText": "for(int ByteIdx = 0; ByteIdx < UE_ARRAY_COUNT(Modulus); ByteIdx++)"
  },
  {
    "label": "UE_REGISTER_ENCRYPTION_KEY()",
    "kind": "Method",
    "detail": "Function (\\ OutModulus [ ByteIdx ] = Modulus [ ByteIdx ] ; \\ } \\ } \\ } GSigningKeyRegistration ; # define)",
    "insertText": "UE_REGISTER_ENCRYPTION_KEY(...)"
  },
  {
    "label": "FEncryptionKeyRegistration()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "FEncryptionKeyRegistration()"
  },
  {
    "label": "RegisterEncryptionKeyCallback()",
    "kind": "Method",
    "detail": "Function (\\ void)",
    "insertText": "RegisterEncryptionKeyCallback(void (*)(unsigned char OutKey[32]))"
  },
  {
    "label": "RegisterEncryptionKeyCallback()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "RegisterEncryptionKeyCallback(&Callback)"
  },
  {
    "label": "Callback()",
    "kind": "Method",
    "detail": "Function (\\ } \\ void)",
    "insertText": "Callback(unsigned char OutKey[32])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (\\ const unsigned char Key [ 3 2 ] = { __VA_ARGS__ } ; \\)",
    "insertText": "for(int ByteIdx = 0; ByteIdx < 32; ByteIdx++)"
  },
  {
    "label": "IMPLEMENT_TARGET_NAME_REGISTRATION()",
    "kind": "Method",
    "detail": "Function (\\ OutKey [ ByteIdx ] = Key [ ByteIdx ] ; \\ } \\ } \\ } GEncryptionKeyRegistration ; # define)",
    "insertText": "IMPLEMENT_TARGET_NAME_REGISTRATION()"
  },
  {
    "label": "FTargetNameRegistration()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "FTargetNameRegistration()"
  },
  {
    "label": "SetUBTTargetName()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "SetUBTTargetName(TEXT(PREPROCESSOR_TO_STRING(UE_TARGET_NAME)))"
  },
  {
    "label": "IMPLEMENT_APPLICATION()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } GTargetNameRegistration ; # if IS_PROGRAM # if IS_MONOLITHIC # define)",
    "insertText": "IMPLEMENT_APPLICATION(ModuleName, GameName ) \\ \\ TCHAR GInternalProjectName[64] = TEXT( GameName)"
  },
  {
    "label": "IMPLEMENT_FOREIGN_ENGINE_DIR()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "IMPLEMENT_FOREIGN_ENGINE_DIR() \\ IMPLEMENT_SIGNING_KEY_REGISTRATION() \\ IMPLEMENT_ENCRYPTION_KEY_REGISTRATION() \\ IMPLEMENT_GAME_MODULE(FDefaultGameModuleImpl, ModuleName)"
  },
  {
    "label": "IMPLEMENT_APPLICATION()",
    "kind": "Method",
    "detail": "Function (# else # define)",
    "insertText": "IMPLEMENT_APPLICATION(ModuleName, GameName)"
  },
  {
    "label": "Strncpy()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "Strncpy(GInternalProjectName, TEXT( GameName ), UE_ARRAY_COUNT(GInternalProjectName))"
  },
  {
    "label": "PER_MODULE_BOILERPLATE_ANYLINK()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } AutoSet # # ModuleName ; \\)",
    "insertText": "PER_MODULE_BOILERPLATE_ANYLINK(FDefaultGameModuleImpl, ModuleName)"
  },
  {
    "label": "IMPLEMENT_PRIMARY_GAME_MODULE()",
    "kind": "Method",
    "detail": "Function (# endif # else # if IS_MONOLITHIC # if PLATFORM_DESKTOP # define)",
    "insertText": "IMPLEMENT_PRIMARY_GAME_MODULE(ModuleImplClass, ModuleName, DEPRECATED_GameName ) \\ \\ TCHAR GInternalProjectName[64] = TEXT( PREPROCESSOR_TO_STRING(UE_PROJECT_NAME))"
  },
  {
    "label": "IMPLEMENT_FOREIGN_ENGINE_DIR()",
    "kind": "Method",
    "detail": "Function (\\ \\ bool GIsGameAgnosticExe = false ; \\)",
    "insertText": "IMPLEMENT_FOREIGN_ENGINE_DIR() \\ IMPLEMENT_SIGNING_KEY_REGISTRATION() \\ IMPLEMENT_ENCRYPTION_KEY_REGISTRATION() \\ IMPLEMENT_TARGET_NAME_REGISTRATION() \\ IMPLEMENT_GAME_MODULE( ModuleImplClass, ModuleName ) \\ PER_MODULE_BOILERPLATE #else #define IMPLEMENT_PRIMARY_GAME_MODULE( ModuleImplClass, ModuleName, DEPRECATED_GameName ) \\ \\ TCHAR GInternalProjectName[64] = TEXT( PREPROCESSOR_TO_STRING(UE_PROJECT_NAME))"
  },
  {
    "label": "IMPLEMENT_FOREIGN_ENGINE_DIR()",
    "kind": "Method",
    "detail": "Function (\\ PER_MODULE_BOILERPLATE \\)",
    "insertText": "IMPLEMENT_FOREIGN_ENGINE_DIR() \\ IMPLEMENT_SIGNING_KEY_REGISTRATION() \\ IMPLEMENT_ENCRYPTION_KEY_REGISTRATION() \\ IMPLEMENT_TARGET_NAME_REGISTRATION() \\ IMPLEMENT_GAME_MODULE( ModuleImplClass, ModuleName)"
  },
  {
    "label": "IMPLEMENT_PRIMARY_GAME_MODULE()",
    "kind": "Method",
    "detail": "Function (# endif # else # define)",
    "insertText": "IMPLEMENT_PRIMARY_GAME_MODULE(ModuleImplClass, ModuleName, GameName ) \\ \\ IMPLEMENT_SIGNING_KEY_REGISTRATION() \\ IMPLEMENT_ENCRYPTION_KEY_REGISTRATION() \\ IMPLEMENT_TARGET_NAME_REGISTRATION() \\ IMPLEMENT_GAME_MODULE( ModuleImplClass, ModuleName)"
  },
  {
    "label": "GetActiveReloadType()",
    "kind": "Method",
    "detail": "Function (None,Reinstancing,# if WITH_HOT_RELOAD HotReload,# endif # if WITH_LIVE_CODING LiveCoding,# endif } ; class IReload ; # if WITH_RELOAD EActiveReloadType)",
    "insertText": "GetActiveReloadType()"
  },
  {
    "label": "GetActiveReloadInterface()",
    "kind": "Method",
    "detail": "Function (IReload*)",
    "insertText": "GetActiveReloadInterface()"
  },
  {
    "label": "IsReloadActive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsReloadActive()"
  },
  {
    "label": "BeginReload()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BeginReload(EActiveReloadType ActiveReloadType, IReload& Interface)"
  },
  {
    "label": "EndReload()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EndReload()"
  }
]