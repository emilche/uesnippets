[
  {
    "label": "BuildOptimizationHelper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BuildOptimizationHelper"
  },
  {
    "label": "FIndexAndZ",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FIndexAndZ"
  },
  {
    "label": "FCompareIndexAndZ",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCompareIndexAndZ"
  },
  {
    "label": "FMeshEdge",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMeshEdge"
  },
  {
    "label": "FMeshEdgeBuilder",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMeshEdgeBuilder"
  },
  {
    "label": "FIndexAndZ()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" CoreTypes . h \" # include \" Components . h \" # include \" StaticMeshResources . h \" # include \" ThirdPartyBuildOptimizationHelper . h \" class BuildOptimizationHelper { public : struct FIndexAndZ { float Z ; int32 Index ;)",
    "insertText": "FIndexAndZ()"
  },
  {
    "label": "FIndexAndZ()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FIndexAndZ(int32 InIndex, FVector V)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Z = 0 . 3 0 f* V . X + 0 . 3 3 f* V . Y + 0 . 3 7 f* V . Z ; Index = InIndex ; } } ; struct FCompareIndexAndZ { bool)",
    "insertText": "operator()(FIndexAndZ const& A, FIndexAndZ const& B)"
  },
  {
    "label": "MultiFind()",
    "kind": "Method",
    "detail": "Function (FMeshEdge* Edge = nullptr ; TArray<FMeshEdge*> EdgeList ; VertexToEdgeList .)",
    "insertText": "MultiFind((FVector)Vertices.Position[Index2], EdgeList)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FMeshEdge* OtherEdge = EdgeList [ EdgeIndex ] ;)",
    "insertText": "if(OtherEdge != nullptr && DoesEdgeMatch(Index1, Index2, OtherEdge))"
  },
  {
    "label": "AddEdge()",
    "kind": "Method",
    "detail": "Function (Edge = OtherEdge ; } } return Edge ; } void)",
    "insertText": "AddEdge(int32 Index1, int32 Index2, int32 Triangle)"
  },
  {
    "label": "FindOppositeEdge()",
    "kind": "Method",
    "detail": "Function (FMeshEdge* OtherEdge =)",
    "insertText": "FindOppositeEdge(Index1, Index2)"
  },
  {
    "label": "AddZeroed()",
    "kind": "Method",
    "detail": "Function (int32 EdgeIndex = Edges .)",
    "insertText": "AddZeroed()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Edges [ EdgeIndex ] . Vertices [ 0 ] = Index1 ; Edges [ EdgeIndex ] . Vertices [ 1 ] = Index2 ; Edges [ EdgeIndex ] . Faces [ 0 ] = Triangle ; Edges [ EdgeIndex ] . Faces [ 1 ] = INDEX_NONE ; VertexToEdgeList .)",
    "insertText": "Add((FVector)Vertices.Position[Index1], &Edges[EdgeIndex])"
  },
  {
    "label": "FMeshEdgeBuilder()",
    "kind": "Method",
    "detail": "Function (} else { OtherEdge -> Faces [ 1 ] = Triangle ; } } public :)",
    "insertText": "FMeshEdgeBuilder(const TArray<uint32>& InIndices, const FConstMeshBuildVertexView& InVertices, TArray<FMeshEdge>& OutEdges ) : Indices(InIndices), Vertices(InVertices), Edges(OutEdges)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (Edges .)",
    "insertText": "Empty(Indices.Num())"
  },
  {
    "label": "FMeshEdgeBuilder()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FMeshEdgeBuilder()"
  },
  {
    "label": "FindEdges()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "FindEdges(void)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (int32 TriangleCount = Indices .)",
    "insertText": "Num()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 EdgeCount = 0 ;)",
    "insertText": "for(int32 Triangle = 0; Triangle < TriangleCount; Triangle++)"
  },
  {
    "label": "AddEdge()",
    "kind": "Method",
    "detail": "Function (int32 TriangleIndex = Triangle* 3 ; int32 Index1 = Indices [ TriangleIndex ] ; int32 Index2 = Indices [ TriangleIndex + 1 ] ; int32 Index3 = Indices [ TriangleIndex + 2 ] ;)",
    "insertText": "AddEdge(Index1, Index2, Triangle)"
  },
  {
    "label": "AddEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddEdge(Index2, Index3, Triangle)"
  },
  {
    "label": "AddEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddEdge(Index3, Index1, Triangle)"
  },
  {
    "label": "DoesEdgeMatch()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "DoesEdgeMatch(int32 Index1, int32 Index2, FMeshEdge* OtherEdge)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (OutDepthIndices .)",
    "insertText": "Empty()"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (VertIndexAndZ .)",
    "insertText": "Emplace(VertIndex, FVector(InVertices.Position[VertIndex]))"
  },
  {
    "label": "Sort()",
    "kind": "Method",
    "detail": "Function (} VertIndexAndZ .)",
    "insertText": "Sort(FCompareIndexAndZ())"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (TArray<uint32> IndexMap ; IndexMap .)",
    "insertText": "AddUninitialized(NumVertices)"
  },
  {
    "label": "Memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memset(IndexMap.GetData(), 0xFF, NumVertices * sizeof(uint32))"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (uint32 SrcIndex = VertIndexAndZ [ i ] . Index ; float Z = VertIndexAndZ [ i ] . Z ; IndexMap [ SrcIndex ] =)",
    "insertText": "Min(IndexMap[SrcIndex], SrcIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uint32 OtherIndex = VertIndexAndZ [ j ] . Index ;)",
    "insertText": "if(InVertices.Position[SrcIndex].Equals(InVertices.Position[OtherIndex], 0.0f))"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (IndexMap [ SrcIndex ] =)",
    "insertText": "Min(IndexMap[SrcIndex], OtherIndex)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (IndexMap [ OtherIndex ] =)",
    "insertText": "Min(IndexMap[OtherIndex], SrcIndex)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const FStaticMeshSection& Section = InSections [ SectionIndex ] ; int32 FirstIndex = Section . FirstIndex ; int32 LastIndex = FirstIndex + Section . NumTriangles* 3 ;)",
    "insertText": "for(int32 SrcIndex = FirstIndex; SrcIndex < LastIndex; ++SrcIndex)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (uint32 VertIndex = InIndices [ SrcIndex ] ; OutDepthIndices .)",
    "insertText": "Add(IndexMap[VertIndex])"
  },
  {
    "label": "CacheOptimizeVertexAndIndexBuffer()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "CacheOptimizeVertexAndIndexBuffer(FMeshBuildVertexData& Vertices, TArray<TArray<uint32> >& PerSectionIndices, TArray<int32>& WedgeMap)"
  },
  {
    "label": "Memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memset(IndexCache.GetData(), INDEX_NONE, IndexCache.Num() * IndexCache.GetTypeSize())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 NextAvailableIndex = 0 ;)",
    "insertText": "for(int32 SectionIndex = 0; SectionIndex < PerSectionIndices.Num(); SectionIndex++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<uint32>& Indices = PerSectionIndices [ SectionIndex ] ;)",
    "insertText": "if(Indices.Num())"
  },
  {
    "label": "CacheOptimizeIndexBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CacheOptimizeIndexBuffer(Indices)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TArray<uint32> OriginalIndices = Indices ;)",
    "insertText": "for(int32 Index = 0; Index < Indices.Num(); Index++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int32 CachedIndex = IndexCache [ OriginalIndices [ Index ] ] ;)",
    "insertText": "if(CachedIndex == INDEX_NONE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Indices [ Index ] = NextAvailableIndex ; IndexCache [ OriginalIndices [ Index ] ] = NextAvailableIndex ; NextAvailableIndex + + ; } else { Indices [ Index ] = CachedIndex ; } Vertices . Position [ Indices [ Index ] ] = OriginalVertices . Position [ OriginalIndices [ Index ] ] ; Vertices . TangentX [ Indices [ Index ] ] = OriginalVertices . TangentX [ OriginalIndices [ Index ] ] ; Vertices . TangentY [ Indices [ Index ] ] = OriginalVertices . TangentY [ OriginalIndices [ Index ] ] ; Vertices . TangentZ [ Indices [ Index ] ] = OriginalVertices . TangentZ [ OriginalIndices [ Index ] ] ;)",
    "insertText": "if(Vertices.Color.Num() > 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Vertices . Color [ Indices [ Index ] ] = OriginalVertices . Color [ OriginalIndices [ Index ] ] ; })",
    "insertText": "for(int32 TexCoord = 0; TexCoord < Vertices.UVs.Num(); ++TexCoord)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Vertices . UVs [ TexCoord ] [ Indices [ Index ] ] = OriginalVertices . UVs [ TexCoord ] [ OriginalIndices [ Index ] ] ; } } } })",
    "insertText": "for(int32 WedgeIndex = 0; WedgeIndex < WedgeMap.Num(); ++WedgeIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int32 MappedIndex = WedgeMap [ WedgeIndex ] ;)",
    "insertText": "if(MappedIndex != INDEX_NONE)"
  }
]