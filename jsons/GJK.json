[
  {
    "label": "FGeomGJKHelperSIMD",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGeomGJKHelperSIMD"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TGJKSimplexData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TGJKSimplexData"
  },
  {
    "label": "FGeomGJKHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGeomGJKHelper"
  },
  {
    "label": "FAHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAHelper"
  },
  {
    "label": "FBHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBHelper"
  },
  {
    "label": "SupportBAtOriginHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SupportBAtOriginHelper"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "CHAOS_COLLISIONERROR_LOG_ENABLED()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Box . h \" # include \" Chaos / Capsule . h \" # include \" Chaos / EPA . h \" # include \" Chaos / GJKShape . h \" # include \" Chaos / ImplicitObjectScaled . h \" # include \" Chaos / Simplex . h \" # include \" Chaos / Sphere . h \" # include \" Math / VectorRegister . h \" # include \" Chaos / VectorUtility . h \" # include \" Chaos / SimplexVectorized . h \" # include \" Chaos / EPAVectorized . h \" # include \" ChaosCheck . h \" # include \" ChaosLog . h \" # define)",
    "insertText": "CHAOS_COLLISIONERROR_LOG_ENABLED((!UE_BUILD_TEST && !UE_BUILD_SHIPPING) && 0) #define CHAOS_COLLISIONERROR_ENSURE_ENABLED ((!UE_BUILD_TEST && !UE_BUILD_SHIPPING) && 1) #if CHAOS_COLLISIONERROR_LOG_ENABLED #define CHAOS_COLLISIONERROR_CLOG(Condition, Fmt, ...) UE_CLOG((Condition), LogChaos, Error, Fmt, __VA_ARGS__) #else #define CHAOS_COLLISIONERROR_CLOG(Condition, Fmt, ...) #endif #if CHAOS_COLLISIONERROR_ENSURE_ENABLED #define CHAOS_COLLISIONERROR_ENSURE(X) ensure(X) #else #define CHAOS_COLLISIONERROR_ENSURE(X)"
  },
  {
    "label": "VectorRegister4Float()",
    "kind": "Method",
    "detail": "Function (struct FGeomGJKHelperSIMD { typedef)",
    "insertText": "VectorRegister4Float(*SupportFunc)(const void* Geom, FRealSingle Margin, const VectorRegister4Float V)"
  },
  {
    "label": "FGeomGJKHelperSIMD()",
    "kind": "Method",
    "detail": "Function (const void* Geometry ; FRealSingle Margin ; FRealSingle Radius ; SupportFunc Func ; template<class T>)",
    "insertText": "FGeomGJKHelperSIMD(const T& Geom) : Geometry(&Geom), Margin((FRealSingle)Geom.GetMargin()), Radius((FRealSingle)Geom.GetRadius()), Func(&SupportCoreSimd<T>)"
  },
  {
    "label": "GetRadius()",
    "kind": "Method",
    "detail": "Function (} FRealSingle)",
    "insertText": "GetRadius()"
  },
  {
    "label": "SupportFunction()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "SupportFunction(const VectorRegister4Float V)"
  },
  {
    "label": "SupportFunction()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "SupportFunction(const VectorRegister4Float V, FRealSingle InMargin)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "operator()(const VectorRegister4Float AToBRotation, const VectorRegister4Float BToARotation, const VectorRegister4Float V)"
  },
  {
    "label": "SupportFunction()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "SupportFunction(const VectorRegister4Float AToBRotation, const VectorRegister4Float BToARotation, const VectorRegister4Float V)"
  },
  {
    "label": "VectorQuaternionRotateVector()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float VInB =)",
    "insertText": "VectorQuaternionRotateVector(AToBRotation, V)"
  },
  {
    "label": "Func()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float SupportBLocal =)",
    "insertText": "Func(Geometry, Margin, VInB)"
  },
  {
    "label": "SupportCoreSimd()",
    "kind": "Method",
    "detail": "Function (} private : template<class T> VectorRegister4Float)",
    "insertText": "SupportCoreSimd(const void* Geom, FRealSingle InMargin, const VectorRegister4Float V)"
  },
  {
    "label": "CheckGJKIterationLimit()",
    "kind": "Method",
    "detail": "Function (} } ; template<ConvexTypeA,ConvexTypeB> bool)",
    "insertText": "CheckGJKIterationLimit(const int32 NumIterations, const ConvexTypeA& A, const ConvexTypeB& B)"
  },
  {
    "label": "bLimitExceeded()",
    "kind": "Method",
    "detail": "Function (const int32 MaxIterations = 3 2 ; const bool)",
    "insertText": "bLimitExceeded(NumIterations >= MaxIterations)"
  },
  {
    "label": "CHAOS_COLLISIONERROR_CLOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CHAOS_COLLISIONERROR_CLOG(bLimitExceeded, TEXT(\"GJK hit iteration limit with shapes:\\n A: %s\\n B: %s\"), *A.ToString(), *B.ToString())"
  },
  {
    "label": "CHAOS_COLLISIONERROR_ENSURE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CHAOS_COLLISIONERROR_ENSURE(!bLimitExceeded)"
  },
  {
    "label": "GetMargin()",
    "kind": "Method",
    "detail": "Function (const bool bHasRadiusA = RadiusA> 0 ; const bool bHasRadiusB = RadiusB> 0 ; const T SweepMarginScale = 0 . 0 5 f ; const bool bAIsSmallest = A .)",
    "insertText": "GetMargin() < B.GetMargin()"
  },
  {
    "label": "SweepMarginA()",
    "kind": "Method",
    "detail": "Function (const T)",
    "insertText": "SweepMarginA(bHasRadiusA || bHasRadiusB) ? 0.0f : (bAIsSmallest ? SweepMarginScale * A.GetMargin() : 0.0f)"
  },
  {
    "label": "SweepMarginB()",
    "kind": "Method",
    "detail": "Function (const T)",
    "insertText": "SweepMarginB(bHasRadiusA || bHasRadiusB) ? 0.0f : (bAIsSmallest ? 0.0f : SweepMarginScale * B.GetMargin())"
  },
  {
    "label": "GJKIntersection()",
    "kind": "Method",
    "detail": "Function (outMarginA = RadiusA + SweepMarginA ; outMarginB = RadiusB + SweepMarginB ; } template<T,TGeometryA,TGeometryB> bool)",
    "insertText": "GJKIntersection(const TGeometryA& RESTRICT A, const TGeometryB& RESTRICT B, const TRigidTransform<T, 3>& BToATM, const T InThicknessA = 0, const TVector<T, 3>& InitialDir = TVector<T, 3>(1, 0, 0))"
  },
  {
    "label": "FReal()",
    "kind": "Method",
    "detail": "Function (const FReal EpsilonScale = FMath::Max<)",
    "insertText": "FReal(A.TGeometryA::BoundingBox().Extents().Max(), B.TGeometryB::BoundingBox().Extents().Max())"
  },
  {
    "label": "GJKIntersection()",
    "kind": "Method",
    "detail": "Function (} template<T> bool)",
    "insertText": "GJKIntersection(const FGeomGJKHelperSIMD& RESTRICT A, const FGeomGJKHelperSIMD& RESTRICT B, FReal EpsilonScale, const TRigidTransform<T, 3>& BToATM, const T InThicknessA = 0, const TVector<T, 3>& InitialDir = TVector<T, 3>(1, 0, 0))"
  },
  {
    "label": "GetRotation()",
    "kind": "Method",
    "detail": "Function (const UE::Math::TQuat<T>& RotationDouble = BToATM .)",
    "insertText": "GetRotation()"
  },
  {
    "label": "MakeVectorRegisterFloatFromDouble()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float RotationSimd =)",
    "insertText": "MakeVectorRegisterFloatFromDouble(MakeVectorRegister(RotationDouble.X, RotationDouble.Y, RotationDouble.Z, RotationDouble.W))"
  },
  {
    "label": "GetTranslation()",
    "kind": "Method",
    "detail": "Function (const UE::Math::TVector<T>& TranslationDouble = BToATM .)",
    "insertText": "GetTranslation()"
  },
  {
    "label": "MakeVectorRegisterFloatFromDouble()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float TranslationSimd =)",
    "insertText": "MakeVectorRegisterFloatFromDouble(MakeVectorRegister(TranslationDouble.X, TranslationDouble.Y, TranslationDouble.Z, 0.0))"
  },
  {
    "label": "VectorNormalizeSafe()",
    "kind": "Method",
    "detail": "Function (RotationSimd =)",
    "insertText": "VectorNormalizeSafe(RotationSimd, GlobalVectorConstants::Float0001)"
  },
  {
    "label": "MakeVectorRegisterFloatFromDouble()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float InitialDirSimd =)",
    "insertText": "MakeVectorRegisterFloatFromDouble(MakeVectorRegister(InitialDir[0], InitialDir[1], InitialDir[2], 0.0))"
  },
  {
    "label": "GJKIntersectionSimd()",
    "kind": "Method",
    "detail": "Function (} template<TGeometryA,TGeometryB> bool)",
    "insertText": "GJKIntersectionSimd(const TGeometryA& RESTRICT A, const TGeometryB& RESTRICT B, const VectorRegister4Float& Translation, const VectorRegister4Float& Rotation, FReal InThicknessA, const VectorRegister4Float& InitialDir)"
  },
  {
    "label": "GJKIntersectionSimd()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "GJKIntersectionSimd(const FGeomGJKHelperSIMD& RESTRICT A, const FGeomGJKHelperSIMD& RESTRICT B, FReal EpsilonScale, const VectorRegister4Float& Translation, const VectorRegister4Float& Rotation, FReal InThicknessA, const VectorRegister4Float& InitialDir)"
  },
  {
    "label": "VectorNegate()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float V =)",
    "insertText": "VectorNegate(InitialDir)"
  },
  {
    "label": "VectorNormalizeSafe()",
    "kind": "Method",
    "detail": "Function (V =)",
    "insertText": "VectorNormalizeSafe(V, MakeVectorRegisterFloatConstant(-1.f, 0.f, 0.f, 0.f))"
  },
  {
    "label": "VectorQuaternionInverse()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float AToBRotation =)",
    "insertText": "VectorQuaternionInverse(Rotation)"
  },
  {
    "label": "MakeVectorRegisterFloatConstant()",
    "kind": "Method",
    "detail": "Function (bool bTerminate ; bool bNearZero = false ; int NumIterations = 0 ; VectorRegister4Float PrevDist2Simd =)",
    "insertText": "MakeVectorRegisterFloatConstant(FLT_MAX, FLT_MAX, FLT_MAX, FLT_MAX)"
  },
  {
    "label": "VectorZeroFloat()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float SimplexSimd [ 4 ] = {)",
    "insertText": "VectorZeroFloat(), VectorZeroFloat(), VectorZeroFloat(), VectorZeroFloat()"
  },
  {
    "label": "CalculateQueryMargins()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float BarycentricSimd ; int32 NumVerts = 0 ; FReal ThicknessA ; FReal ThicknessB ;)",
    "insertText": "CalculateQueryMargins(A, B, ThicknessA, ThicknessB)"
  },
  {
    "label": "FReal()",
    "kind": "Method",
    "detail": "Function (ThicknessA + = InThicknessA ; EpsilonScale = FMath::Min<)",
    "insertText": "FReal(EpsilonScale, 1e5)"
  },
  {
    "label": "VectorSet1()",
    "kind": "Method",
    "detail": "Function (const FReal InflationReal = ThicknessA + ThicknessB + 1 e - 6* EpsilonScale ; const VectorRegister4Float Inflation =)",
    "insertText": "VectorSet1(static_cast<FRealSingle>(InflationReal))"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float Inflation2 =)",
    "insertText": "VectorMultiply(Inflation, Inflation)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 VertexIndexA = INDEX_NONE,VertexIndexB = INDEX_NONE ; do {)",
    "insertText": "if(!ensure(NumIterations++ < 32))"
  },
  {
    "label": "VectorNegate()",
    "kind": "Method",
    "detail": "Function (break ; } const VectorRegister4Float NegVSimd =)",
    "insertText": "VectorNegate(V)"
  },
  {
    "label": "SupportFunction()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float SupportASimd = A .)",
    "insertText": "SupportFunction(NegVSimd, (FRealSingle)ThicknessA)"
  },
  {
    "label": "SupportFunction()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float SupportBLocalSimd = B .)",
    "insertText": "SupportFunction(VInBSimd, (FRealSingle)ThicknessB)"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float SupportBSimd =)",
    "insertText": "VectorAdd(VectorQuaternionRotateVector(Rotation, SupportBLocalSimd), Translation)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float WSimd =)",
    "insertText": "VectorSubtract(SupportASimd, SupportBSimd)"
  },
  {
    "label": "VectorDot3()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float NewDist2Simd =)",
    "insertText": "VectorDot3(V, V)"
  },
  {
    "label": "VectorMaskBits()",
    "kind": "Method",
    "detail": "Function (bNearZero =)",
    "insertText": "VectorMaskBits(VectorCompareLT(NewDist2Simd, Inflation2))"
  },
  {
    "label": "VectorMaskBits()",
    "kind": "Method",
    "detail": "Function (bool bMadeProgress =)",
    "insertText": "VectorMaskBits(VectorCompareLT(NewDist2Simd, PrevDist2Simd))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bTerminate = bNearZero | | ! bMadeProgress ; PrevDist2Simd = NewDist2Simd ;)",
    "insertText": "if(!bTerminate)"
  },
  {
    "label": "VectorDivide()",
    "kind": "Method",
    "detail": "Function (V =)",
    "insertText": "VectorDivide(V, VectorSqrt(NewDist2Simd))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "while(!bTerminate)"
  },
  {
    "label": "VectorZero()",
    "kind": "Method",
    "detail": "Function (FSimplex SimplexIDs ; VectorRegister4Float Simplex [ 4 ] = {)",
    "insertText": "VectorZero(), VectorZero(), VectorZero(), VectorZero()"
  },
  {
    "label": "VectorZero()",
    "kind": "Method",
    "detail": "Function (int32 NumVerts = 0 ; VectorRegister4Float Barycentric =)",
    "insertText": "VectorZero()"
  },
  {
    "label": "VectorSet1()",
    "kind": "Method",
    "detail": "Function (ThicknessA + = InThicknessA ; const FReal Inflation = ThicknessA + ThicknessB + 1 e - 3 ; const FReal Inflation2 = Inflation* Inflation ; VectorRegister4Float InflationSimd =)",
    "insertText": "VectorSet1(static_cast<FRealSingle>(Inflation))"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Inflation2Simd =)",
    "insertText": "VectorMultiply(InflationSimd, InflationSimd)"
  },
  {
    "label": "SupportCoreSimd()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float SupportA = A .)",
    "insertText": "SupportCoreSimd(NegV, ThicknessA)"
  },
  {
    "label": "SupportCoreSimd()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float VInB = V ; const VectorRegister4Float SupportB = B .)",
    "insertText": "SupportCoreSimd(VInB, ThicknessB)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float W =)",
    "insertText": "VectorSubtract(SupportA, SupportB)"
  },
  {
    "label": "VectorDot3()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float VDotW =)",
    "insertText": "VectorDot3(V, W)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (bNearZero = static_cast<)",
    "insertText": "bool(VectorMaskBits(VectorCompareGT(Inflation2Simd, NewDist2)))"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (const bool bMadeProgress = static_cast<)",
    "insertText": "bool(VectorMaskBits(VectorCompareGT(PrevDist2, NewDist2)))"
  },
  {
    "label": "VectorDivide()",
    "kind": "Method",
    "detail": "Function (V =)",
    "insertText": "VectorDivide(V, VectorSqrt(NewDist2))"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset()"
  },
  {
    "label": "Save()",
    "kind": "Method",
    "detail": "Function (NumVerts = 0 ; } void)",
    "insertText": "Save(const FSimplex InSimplexIDs)"
  },
  {
    "label": "Restore()",
    "kind": "Method",
    "detail": "Function (NumVerts = InSimplexIDs . NumVerts ; } void)",
    "insertText": "Restore(const TRigidTransform<T, 3>& BToATM, FSimplex& OutSimplexIDs, TVec3<T> OutSimplex[], TVec3<T>& OutV, T& OutDistance, const T Epsilon)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (OutSimplexIDs . NumVerts = NumVerts ;)",
    "insertText": "for(int32 VertIndex = 0; VertIndex < NumVerts; ++VertIndex)"
  },
  {
    "label": "TransformPositionNoScale()",
    "kind": "Method",
    "detail": "Function (OutSimplexIDs . Idxs [ VertIndex ] = VertIndex ; OutSimplex [ VertIndex ] = As [ VertIndex ] - BToATM .)",
    "insertText": "TransformPositionNoScale(Bs[VertIndex])"
  },
  {
    "label": "SimplexFindClosestToOrigin()",
    "kind": "Method",
    "detail": "Function (} const TVec3<T> V =)",
    "insertText": "SimplexFindClosestToOrigin(OutSimplex, OutSimplexIDs, Barycentric, As, Bs)"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (const T Distance = V .)",
    "insertText": "Size()"
  },
  {
    "label": "Restore2()",
    "kind": "Method",
    "detail": "Function (OutV = V / Distance ; OutDistance = Distance ; } else { OutSimplexIDs . NumVerts = 0 ; } } } void)",
    "insertText": "Restore2(const TRigidTransform<T, 3>& BToATM, int32& OutNumVerts, TVec3<T> OutSimplex[], TVec3<T>& OutV, T& OutDistance, const T Epsilon)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OutNumVerts = 0 ;)",
    "insertText": "if(NumVerts > 0)"
  },
  {
    "label": "SimplexFindClosestToOrigin2()",
    "kind": "Method",
    "detail": "Function (} const TVec3<T> V =)",
    "insertText": "SimplexFindClosestToOrigin2(OutSimplex, NumVerts, Barycentric, As, Bs)"
  },
  {
    "label": "SizeSquared()",
    "kind": "Method",
    "detail": "Function (const T DistanceSq = V .)",
    "insertText": "SizeSquared()"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (const T Distance =)",
    "insertText": "Sqrt(DistanceSq)"
  },
  {
    "label": "FVector()",
    "kind": "Method",
    "detail": "Function (OutNumVerts = NumVerts ; OutV = V / Distance ; OutDistance = Distance ; } } } const int32 MaxSimplexVerts = 4 ; TVec3<T> As [ MaxSimplexVerts ] ; TVec3<T> Bs [ MaxSimplexVerts ] ; T Barycentric [ MaxSimplexVerts ] ; int32 NumVerts ; } ; using FGJKSimplexData = TGJKSimplexData<FReal> ; struct FGeomGJKHelper { typedef)",
    "insertText": "FVector(*SupportFunc)(const void* Geom, const FVec3& Direction, FReal* OutSupportDelta, int32& VertexIndex)"
  },
  {
    "label": "FGeomGJKHelper()",
    "kind": "Method",
    "detail": "Function (const void* Geometry ; SupportFunc Func ; FReal Margin ; template<class T>)",
    "insertText": "FGeomGJKHelper(const T& Geom) : Geometry(&Geom), Func(&SupportCore<T>), Margin(Geom.GetMargin())"
  },
  {
    "label": "SupportFunction()",
    "kind": "Method",
    "detail": "Function (} FVector)",
    "insertText": "SupportFunction(const FVec3& V, int32& VertexIndex)"
  },
  {
    "label": "SupportFunction()",
    "kind": "Method",
    "detail": "Function (} FVector)",
    "insertText": "SupportFunction(const FVec3& V, FReal* OutSupportDelta, int32& VertexIndex)"
  },
  {
    "label": "SupportFunction()",
    "kind": "Method",
    "detail": "Function (} FVector)",
    "insertText": "SupportFunction(const FRotation3& AToBRotation, const FVec3& V, FReal* OutSupportDelta, int32& VertexIndex)"
  },
  {
    "label": "Func()",
    "kind": "Method",
    "detail": "Function (const FVec3 VInB = AToBRotation* V ; return)",
    "insertText": "Func(Geometry, VInB, OutSupportDelta, VertexIndex)"
  },
  {
    "label": "SupportFunction()",
    "kind": "Method",
    "detail": "Function (} FVector)",
    "insertText": "SupportFunction(const FRigidTransform3& BToATM, const FRotation3& AToBRotation, const FVec3& V, int32& VertexIndex)"
  },
  {
    "label": "Func()",
    "kind": "Method",
    "detail": "Function (const FVector VInB = AToBRotation* V ; const FVector SupportBLocal =)",
    "insertText": "Func(Geometry, VInB, nullptr, VertexIndex)"
  },
  {
    "label": "SupportFunction()",
    "kind": "Method",
    "detail": "Function (} FVector)",
    "insertText": "SupportFunction(const FRigidTransform3& BToATM, const FRotation3& AToBRotation, const FVec3& V, FReal* OutSupportDelta, int32& VertexIndex)"
  },
  {
    "label": "GetMargin()",
    "kind": "Method",
    "detail": "Function (} FReal)",
    "insertText": "GetMargin()"
  },
  {
    "label": "Geometry()",
    "kind": "Method",
    "detail": "Function (const T*)",
    "insertText": "Geometry(const T*)"
  },
  {
    "label": "GJKPenetrationWarmStartable()",
    "kind": "Method",
    "detail": "Function (} } ; template<T,TGeometryA,TGeometryB> bool)",
    "insertText": "GJKPenetrationWarmStartable(const TGeometryA& A, const TGeometryB& B, const TRigidTransform<T, 3>& BToATM, T& OutPenetration, TVec3<T>& OutClosestA, TVec3<T>& OutClosestB, TVec3<T>& OutNormalA, TVec3<T>& OutNormalB, int32& OutVertexA, int32& OutVertexB, TGJKSimplexData<T>& InOutSimplexData, T& OutMaxSupportDelta, const T Epsilon = T(1.e-3), const T EPAEpsilon = T(1.e-2))"
  },
  {
    "label": "VertexIndexA()",
    "kind": "Method",
    "detail": "Function (T SupportDeltaA = 0 ; T SupportDeltaB = 0 ; T MaxSupportDelta = 0 ; int32& VertexIndexA = OutVertexA ; int32& VertexIndexB = OutVertexB ; auto SupportAFunc = [& A,& SupportDeltaA,&)",
    "insertText": "VertexIndexA(const TVec3<T>& V)"
  },
  {
    "label": "GetRotation()",
    "kind": "Method",
    "detail": "Function (} ; const TRotation<T,3> AToBRotation = BToATM .)",
    "insertText": "GetRotation().Inverse()"
  },
  {
    "label": "VertexIndexB()",
    "kind": "Method",
    "detail": "Function (auto SupportBFunc = [& B,& AToBRotation,& SupportDeltaB,&)",
    "insertText": "VertexIndexB(const TVec3<T>& V)"
  },
  {
    "label": "SupportCore()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> VInB = AToBRotation* V ; return B .)",
    "insertText": "SupportCore(VInB, B.GetMargin(), &SupportDeltaB, VertexIndexB)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} ; TVec3<T> V = TVec3<)",
    "insertText": "T(-1, 0, 0)"
  },
  {
    "label": "Restore()",
    "kind": "Method",
    "detail": "Function (TVec3<T> Simplex [ 4 ] ; FSimplex SimplexIDs ; T Distance = FLT_MAX ; InOutSimplexData .)",
    "insertText": "Restore(BToATM, SimplexIDs, Simplex, V, Distance, Epsilon)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const T SeparatedDistance = ThicknessA + ThicknessB + Epsilon ;)",
    "insertText": "while(!bIsContact && !bIsDegenerate)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + NumIterations ;)",
    "insertText": "if(CheckGJKIterationLimit(NumIterations, A, B))"
  },
  {
    "label": "SupportAFunc()",
    "kind": "Method",
    "detail": "Function (break ; } const TVec3<T> NegV = - V ; const TVec3<T> SupportA =)",
    "insertText": "SupportAFunc(NegV)"
  },
  {
    "label": "SupportBFunc()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> SupportB =)",
    "insertText": "SupportBFunc(V)"
  },
  {
    "label": "TransformPositionNoScale()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> SupportBInA = BToATM .)",
    "insertText": "TransformPositionNoScale(SupportB)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> W = SupportA - SupportBInA ; MaxSupportDelta =)",
    "insertText": "Max(SupportDeltaA, SupportDeltaB)"
  },
  {
    "label": "ConvergedDistance()",
    "kind": "Method",
    "detail": "Function (const T ConvergenceTolerance = 1 . e - 4 f ; const T)",
    "insertText": "ConvergedDistance(1.0f - ConvergenceTolerance)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const T VW = TVec3<T)",
    "insertText": "DotProduct(V, W)"
  },
  {
    "label": "SimplexFindClosestToOrigin()",
    "kind": "Method",
    "detail": "Function (InOutSimplexData . As [ SimplexIDs . NumVerts ] = SupportA ; InOutSimplexData . Bs [ SimplexIDs . NumVerts ] = SupportB ; SimplexIDs [ SimplexIDs . NumVerts ] = SimplexIDs . NumVerts ; Simplex [ SimplexIDs . NumVerts + + ] = W ; V =)",
    "insertText": "SimplexFindClosestToOrigin(Simplex, SimplexIDs, InOutSimplexData.Barycentric, InOutSimplexData.As, InOutSimplexData.Bs)"
  },
  {
    "label": "bIsContact()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bIsContact(NewDistance < Epsilon)"
  },
  {
    "label": "bIsDegenerate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bIsDegenerate(NewDistance >= Distance)"
  },
  {
    "label": "Save()",
    "kind": "Method",
    "detail": "Function (V / = NewDistance ; Normal = - V ; } Distance = NewDistance ; } InOutSimplexData .)",
    "insertText": "Save(SimplexIDs)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (TArray<TVec3<T>> VertsA ; TArray<TVec3<T>> VertsB ; VertsA .)",
    "insertText": "Reserve(8)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertsA .)",
    "insertText": "Add(InOutSimplexData.As[i])"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertsB .)",
    "insertText": "Add(BToATM.TransformPositionNoScale(InOutSimplexData.Bs[i]))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} ; T Penetration ; TVec3<T> MTD,ClosestA,ClosestBInA ; const EEPAResult EPAResult = EPA<)",
    "insertText": "T(VertsA, VertsB, SupportAFunc, SupportBInAFunc, Penetration, MTD, ClosestA, ClosestBInA, EPAEpsilon)"
  },
  {
    "label": "InverseTransformPositionNoScale()",
    "kind": "Method",
    "detail": "Function (OutPenetration = Penetration + ThicknessA + ThicknessB ; OutClosestA = ClosestA + MTD* ThicknessA ; OutClosestB = BToATM .)",
    "insertText": "InverseTransformPositionNoScale(ClosestBInA - MTD * ThicknessB)"
  },
  {
    "label": "ClosestA()",
    "kind": "Method",
    "detail": "Function (OutMaxSupportDelta = MaxSupportDelta ; return true ; case EEPAResult::BadInitialSimplex : Normal = MTD ; Distance = - Penetration ; break ; case EEPAResult::Degenerate : break ; } } { TVec3<T>)",
    "insertText": "ClosestA(0)"
  },
  {
    "label": "ClosestB()",
    "kind": "Method",
    "detail": "Function (TVec3<T>)",
    "insertText": "ClosestB(0)"
  },
  {
    "label": "InverseTransformVectorNoScale()",
    "kind": "Method",
    "detail": "Function (ClosestA + = InOutSimplexData . As [ i ]* InOutSimplexData . Barycentric [ i ] ; ClosestB + = InOutSimplexData . Bs [ i ]* InOutSimplexData . Barycentric [ i ] ; } OutNormalA = Normal ; OutNormalB = BToATM .)",
    "insertText": "InverseTransformVectorNoScale(Normal)"
  },
  {
    "label": "GJKPenetrationWarmStartable2()",
    "kind": "Method",
    "detail": "Function (T Penetration = ThicknessA + ThicknessB - Distance ; OutPenetration = Penetration ; OutClosestA = ClosestA + OutNormalA* ThicknessA ; OutClosestB = ClosestB - OutNormalB* ThicknessB ; OutMaxSupportDelta = MaxSupportDelta ; return true ; } } template<T,TGeometryA,TGeometryB> bool)",
    "insertText": "GJKPenetrationWarmStartable2(const TGeometryA& A, const TGeometryB& B, const TRigidTransform<T, 3>& BToATM, T& OutPenetration, TVec3<T>& OutClosestA, TVec3<T>& OutClosestB, TVec3<T>& OutNormalA, TVec3<T>& OutNormalB, int32& OutVertexA, int32& OutVertexB, TGJKSimplexData<T>& InOutSimplexData, T& OutMaxSupportDelta, const T Epsilon = T(1.e-3), const T EPAEpsilon = T(1.e-2))"
  },
  {
    "label": "Restore2()",
    "kind": "Method",
    "detail": "Function (TVec3<T> Simplex [ 4 ] ; int32 NumVerts = 0 ; T Distance = FLT_MAX ; InOutSimplexData .)",
    "insertText": "Restore2(BToATM, NumVerts, Simplex, V, Distance, Epsilon)"
  },
  {
    "label": "SimplexFindClosestToOrigin2()",
    "kind": "Method",
    "detail": "Function (InOutSimplexData . As [ NumVerts ] = SupportA ; InOutSimplexData . Bs [ NumVerts ] = SupportB ; Simplex [ NumVerts + + ] = W ; V =)",
    "insertText": "SimplexFindClosestToOrigin2(Simplex, NumVerts, InOutSimplexData.Barycentric, InOutSimplexData.As, InOutSimplexData.Bs)"
  },
  {
    "label": "bIsResult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bIsResult(NewDistance >= (Distance - Epsilon))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (V / = NewDistance ; Normal = - V ; } Distance = NewDistance ; } InOutSimplexData . NumVerts = NumVerts ;)",
    "insertText": "if(bIsContact)"
  },
  {
    "label": "GJKPenetrationSameSpace()",
    "kind": "Method",
    "detail": "Function (T Penetration = ThicknessA + ThicknessB - Distance ; OutPenetration = Penetration ; OutClosestA = ClosestA + OutNormalA* ThicknessA ; OutClosestB = ClosestB - OutNormalB* ThicknessB ; OutMaxSupportDelta = MaxSupportDelta ; return true ; } } template<T,TGeometryA,TGeometryB> bool)",
    "insertText": "GJKPenetrationSameSpace(const TGeometryA& A, const TGeometryB& B, T& OutPenetration, TVec3<T>& OutClosestA, TVec3<T>& OutClosestB, TVec3<T>& OutNormal, int32& OutVertexA, int32& OutVertexB, T& OutMaxSupportDelta, const TVec3<T>& InitialDir, const T Epsilon = T(1.e-3), const T EPAEpsilon = T(1.e-2))"
  },
  {
    "label": "SimplexFindClosestToOrigin()",
    "kind": "Method",
    "detail": "Function (SimplexData . As [ SimplexIDs . NumVerts ] = SupportA ; SimplexData . Bs [ SimplexIDs . NumVerts ] = SupportB ; SimplexIDs [ SimplexIDs . NumVerts ] = SimplexIDs . NumVerts ; Simplex [ SimplexIDs . NumVerts + + ] = W ; V =)",
    "insertText": "SimplexFindClosestToOrigin(Simplex, SimplexIDs, SimplexData.Barycentric, SimplexData.As, SimplexData.Bs)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertsA .)",
    "insertText": "Add(SimplexData.As[i])"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertsB .)",
    "insertText": "Add(SimplexData.Bs[i])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} T Penetration ; TVec3<T> MTD,ClosestA,ClosestB ; const EEPAResult EPAResult = EPA<)",
    "insertText": "T(VertsA, VertsB, SupportAFunc, SupportBFunc, Penetration, MTD, ClosestA, ClosestB, EPAEpsilon)"
  },
  {
    "label": "GJKPenetrationSameSpace2()",
    "kind": "Method",
    "detail": "Function (ClosestA + = SimplexData . As [ i ]* SimplexData . Barycentric [ i ] ; ClosestB + = SimplexData . Bs [ i ]* SimplexData . Barycentric [ i ] ; } OutPenetration = ThicknessA + ThicknessB - Distance ; OutClosestA = ClosestA + Normal* ThicknessA ; OutClosestB = ClosestB - Normal* ThicknessB ; OutNormal = Normal ; OutMaxSupportDelta = MaxSupportDelta ; return true ; } } template<T,TGeometryA,TGeometryB> bool)",
    "insertText": "GJKPenetrationSameSpace2(const TGeometryA& A, const TGeometryB& B, T& OutPenetration, TVec3<T>& OutClosestA, TVec3<T>& OutClosestB, TVec3<T>& OutNormal, int32& OutVertexA, int32& OutVertexB, T& OutMaxSupportDelta, const TVec3<T>& InitialDir, const T Epsilon = T(1.e-3), const T EPAEpsilon = T(1.e-2))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const T SeparatedDistance = ThicknessA + ThicknessB + Epsilon ;)",
    "insertText": "while(!bIsContact && !bIsResult)"
  },
  {
    "label": "SimplexFindClosestToOrigin2()",
    "kind": "Method",
    "detail": "Function (SimplexData . As [ NumVerts ] = SupportA ; SimplexData . Bs [ NumVerts ] = SupportB ; Simplex [ NumVerts + + ] = W ; V =)",
    "insertText": "SimplexFindClosestToOrigin2(Simplex, NumVerts, SimplexData.Barycentric, SimplexData.As, SimplexData.Bs)"
  },
  {
    "label": "CHAOS_COLLISIONERROR_CLOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CHAOS_COLLISIONERROR_CLOG(V.ContainsNaN(), TEXT(\"SimplexFindClosestToOrigin2 NaN, NumVerts: %d, Simplex: [[%f, %f, %f], [%f %f %f], [%f %f %f], [%f %f %f]]\"), NumVerts, Simplex[0].X, Simplex[0].Y, Simplex[0].Z, Simplex[1].X, Simplex[1].Y, Simplex[1].Z, Simplex[2].X, Simplex[2].Y, Simplex[2].Z, Simplex[3].X, Simplex[3].Y, Simplex[3].Z)"
  },
  {
    "label": "CHAOS_COLLISIONERROR_ENSURE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CHAOS_COLLISIONERROR_ENSURE(!V.ContainsNaN())"
  },
  {
    "label": "GJKPenetrationImpl()",
    "kind": "Method",
    "detail": "Function (ClosestA + = SimplexData . As [ i ]* SimplexData . Barycentric [ i ] ; ClosestB + = SimplexData . Bs [ i ]* SimplexData . Barycentric [ i ] ; } OutPenetration = ThicknessA + ThicknessB - Distance ; OutClosestA = ClosestA + Normal* ThicknessA ; OutClosestB = ClosestB - Normal* ThicknessB ; OutNormal = Normal ; OutMaxSupportDelta = MaxSupportDelta ; return true ; } } template<bool bNegativePenetrationAllowed = false,T> bool)",
    "insertText": "GJKPenetrationImpl(const FGeomGJKHelper& A, const FGeomGJKHelper& B, const TRigidTransform<T, 3>& BToATM, T& OutPenetration, TVec3<T>& OutClosestA, TVec3<T>& OutClosestB, TVec3<T>& OutNormal, int32& OutClosestVertexIndexA, int32& OutClosestVertexIndexB, const T InThicknessA = 0.0f, const T InThicknessB = 0.0f, const TVector<T, 3>& InitialDir = TVector<T, 3>(1, 0, 0), const T Epsilon = 1.e-3f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TVector<T,3> V = - InitialDir ;)",
    "insertText": "if(V.SafeNormalize() == 0)"
  },
  {
    "label": "SupportFunction()",
    "kind": "Method",
    "detail": "Function (break ; } const TVector<T,3> NegV = - V ; const TVector<T,3> SupportA = A .)",
    "insertText": "SupportFunction(NegV, VertexIndexA)"
  },
  {
    "label": "SupportFunction()",
    "kind": "Method",
    "detail": "Function (const TVector<T,3> SupportB = B .)",
    "insertText": "SupportFunction(BToATM, AToBRotation, V, VertexIndexB)"
  },
  {
    "label": "SimplexFindClosestToOrigin()",
    "kind": "Method",
    "detail": "Function (break ; } SimplexIDs [ SimplexIDs . NumVerts ] = SimplexIDs . NumVerts ; As [ SimplexIDs . NumVerts ] = SupportA ; Bs [ SimplexIDs . NumVerts ] = SupportB ; Simplex [ SimplexIDs . NumVerts + + ] = W ; V =)",
    "insertText": "SimplexFindClosestToOrigin(Simplex, SimplexIDs, Barycentric, As, Bs)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertsA .)",
    "insertText": "Add(As[i])"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertsB .)",
    "insertText": "Add(Bs[i])"
  },
  {
    "label": "FAHelper()",
    "kind": "Method",
    "detail": "Function (} struct FAHelper { const FGeomGJKHelper& Geom ; int32* VertexIndex ;)",
    "insertText": "FAHelper(const FGeomGJKHelper& Geom, int32& VertexIndex) : Geom(Geom), VertexIndex(&VertexIndex)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TVec3<T>)",
    "insertText": "operator()(const TVec3<T>& V)"
  },
  {
    "label": "AHelper()",
    "kind": "Method",
    "detail": "Function (} } ; FAHelper)",
    "insertText": "AHelper(A, VertexIndexA)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (FBHelper BHelper = { B,& VertexIndexB,BToATM,AToBRotation } ; T Penetration ; TVec3<T> MTD,ClosestA,ClosestBInA ; const EEPAResult EPAResult = EPA<)",
    "insertText": "T(VertsA, VertsB, AHelper, BHelper, Penetration, MTD, ClosestA, ClosestBInA)"
  },
  {
    "label": "ClosestBInA()",
    "kind": "Method",
    "detail": "Function (TVector<T,3>)",
    "insertText": "ClosestBInA(0)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (ClosestA + = As [ i ]* Barycentric [ i ] ; ClosestBInA + = Bs [ i ]* Barycentric [ i ] ; } OutNormal = Normal ; T Penetration = ThicknessA + ThicknessB - Distance ; OutPenetration = Penetration ; OutClosestA = ClosestA + Normal* ThicknessA ; OutClosestB = ClosestBInA - Normal* ThicknessB ; OutClosestVertexIndexA = VertexIndexA ; OutClosestVertexIndexB = VertexIndexB ;)",
    "insertText": "return(bNegativePenetrationAllowed || (Penetration >= 0.0f))"
  },
  {
    "label": "GJKPenetration()",
    "kind": "Method",
    "detail": "Function (} } template<bool bNegativePenetrationAllowed = false,T,TGeometryA,TGeometryB> bool)",
    "insertText": "GJKPenetration(const TGeometryA& A, const TGeometryB& B, const TRigidTransform<T, 3>& BToATM, T& OutPenetration, TVec3<T>& OutClosestA, TVec3<T>& OutClosestB, TVec3<T>& OutNormal, int32& OutClosestVertexIndexA, int32& OutClosestVertexIndexB, const T InThicknessA = 0.0f, const T InThicknessB = 0.0f, const TVector<T, 3>& InitialDir = TVector<T, 3>(1, 0, 0), const T Epsilon = 1.e-3f)"
  },
  {
    "label": "GJKRaycast()",
    "kind": "Method",
    "detail": "Function (} template<T,TGeometryA,TGeometryB> bool)",
    "insertText": "GJKRaycast(const TGeometryA& A, const TGeometryB& B, const TRigidTransform<T, 3>& StartTM, const TVector<T, 3>& RayDir, const T RayLength, T& OutTime, TVector<T, 3>& OutPosition, TVector<T, 3>& OutNormal, const T ThicknessA = 0, const TVector<T, 3>& InitialDir = TVector<T, 3>(1, 0, 0), const T ThicknessB = 0)"
  },
  {
    "label": "GetLocation()",
    "kind": "Method",
    "detail": "Function (const TVector<T,3> StartPoint = StartTM .)",
    "insertText": "GetLocation()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (int32 VertexIndexA = INDEX_NONE ; int32 VertexIndexB = INDEX_NONE ; TVector<T,3> Simplex [ 4 ] = { TVector<)",
    "insertText": "T(0), TVector<T,3>(0), TVector<T,3>(0), TVector<T,3>(0)"
  },
  {
    "label": "Inverse()",
    "kind": "Method",
    "detail": "Function (const TRotation<T,3> AToBRotation = BToARotation .)",
    "insertText": "Inverse()"
  },
  {
    "label": "Support()",
    "kind": "Method",
    "detail": "Function (TVector<T,3> SupportA = A .)",
    "insertText": "Support(InitialDir, ThicknessA, VertexIndexA)"
  },
  {
    "label": "AToBRotation()",
    "kind": "Method",
    "detail": "Function (As [ 0 ] = SupportA ; const TVector<T,3> InitialDirInB =)",
    "insertText": "AToBRotation(-InitialDir)"
  },
  {
    "label": "Support()",
    "kind": "Method",
    "detail": "Function (const TVector<T,3> InitialSupportBLocal = B .)",
    "insertText": "Support(InitialDirInB, ThicknessB, VertexIndexB)"
  },
  {
    "label": "Normal()",
    "kind": "Method",
    "detail": "Function (TVector<T,3> SupportB = BToARotation* InitialSupportBLocal ; Bs [ 0 ] = SupportB ; T Lambda = 0 ; TVector<T,3> X = StartPoint ; TVector<T,3>)",
    "insertText": "Normal(0)"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (TVector<T,3> V =)",
    "insertText": "X(SupportA - SupportB)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (bool bTerminate ; bool bNearZero = false ; bool bDegenerate = false ; int NumIterations = 0 ; T GJKPreDist2 = TNumericLimits<T)",
    "insertText": "Max()"
  },
  {
    "label": "Support()",
    "kind": "Method",
    "detail": "Function (break ; } SupportA = A .)",
    "insertText": "Support(V, ThicknessA, VertexIndexA)"
  },
  {
    "label": "AToBRotation()",
    "kind": "Method",
    "detail": "Function (const TVector<T,3> VInB =)",
    "insertText": "AToBRotation(-V)"
  },
  {
    "label": "Support()",
    "kind": "Method",
    "detail": "Function (const TVector<T,3> SupportBLocal = B .)",
    "insertText": "Support(VInB, ThicknessB, VertexIndexB)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const T VDotRayDir = TVector<T,3)",
    "insertText": "DotProduct(V, RayDir)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OutTime = Lambda ;)",
    "insertText": "if(Lambda > 0)"
  },
  {
    "label": "GetUnsafeNormal()",
    "kind": "Method",
    "detail": "Function (OutNormal = Normal .)",
    "insertText": "GetUnsafeNormal()"
  },
  {
    "label": "GJKRaycast2ImplSimd()",
    "kind": "Method",
    "detail": "Function (ClosestB + = Bs [ i ]* Barycentric [ i ] ; } const TVector<T,3> ClosestLocal = ClosestB ; OutPosition = StartPoint + RayDir* Lambda + ClosestLocal ; } return true ; } template<T> bool)",
    "insertText": "GJKRaycast2ImplSimd(const FGeomGJKHelperSIMD& RESTRICT A, const FGeomGJKHelperSIMD& RESTRICT B, const T& BToARotation, const T& StartPoint, const T& RayDir, FRealSingle RayLength, FRealSingle& OutTime, T& OutPosition, T& OutNormal, bool bComputeMTD, const T& InitialDir)"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (const FRealSingle RadiusA = static_cast<)",
    "insertText": "FRealSingle(A.GetRadius())"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (const FRealSingle RadiusB = static_cast<)",
    "insertText": "FRealSingle(B.GetRadius())"
  },
  {
    "label": "SweepMarginA()",
    "kind": "Method",
    "detail": "Function (const FRealSingle)",
    "insertText": "SweepMarginA(bHasRadiusA || bHasRadiusB) ? 0.0f : (bAIsSmallest ? SweepMarginScale * static_cast<FRealSingle>(A.GetMargin()) : 0.0f)"
  },
  {
    "label": "SweepMarginB()",
    "kind": "Method",
    "detail": "Function (const FRealSingle)",
    "insertText": "SweepMarginB(bHasRadiusA || bHasRadiusB) ? 0.0f : (bAIsSmallest ? 0.0f : SweepMarginScale * static_cast<FRealSingle>(B.GetMargin()))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (A . Margin = RadiusA + SweepMarginA ; B . Margin = RadiusB + SweepMarginB ; const T MarginASimd =)",
    "insertText": "T(VectorLoadFloat1(&A.Margin))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T MarginBSimd =)",
    "insertText": "T(VectorLoadFloat1(&B.Margin))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T Simplex [ 4 ] = { TVectorZero<)",
    "insertText": "T(), TVectorZero<T>(), TVectorZero<T>(), TVectorZero<T>()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T Barycentric = TVectorZero<)",
    "insertText": "T()"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (T Inflation =)",
    "insertText": "VectorAdd(MarginASimd, MarginBSimd)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T Eps2Simd = TMakeVectorRegister<)",
    "insertText": "T(1e-6f, 1e-6f, 1e-6f, 1e-6f)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (const T Inflation2Simd =)",
    "insertText": "VectorMultiplyAdd(Inflation, Inflation, Eps2Simd)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T RayLengthSimd = TMakeVectorRegister<)",
    "insertText": "T(RayLength, RayLength, RayLength, RayLength)"
  },
  {
    "label": "VectorQuaternionInverse()",
    "kind": "Method",
    "detail": "Function (int32 NumVerts = 0 ; T AToBRotation =)",
    "insertText": "VectorQuaternionInverse(BToARotation)"
  },
  {
    "label": "SupportFunction()",
    "kind": "Method",
    "detail": "Function (T SupportA = A .)",
    "insertText": "SupportFunction(TMakeVectorRegisterFloatFromDouble<T>(InitialDir))"
  },
  {
    "label": "SupportFunction()",
    "kind": "Method",
    "detail": "Function (As [ 0 ] = SupportA ; T SupportB = B .)",
    "insertText": "SupportFunction(TMakeVectorRegisterFloatFromDouble<T>(AToBRotation), TMakeVectorRegisterFloatFromDouble<T>(BToARotation), TMakeVectorRegisterFloatFromDouble<T>(VectorNegate(InitialDir)))"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (T X = StartPoint ; T V =)",
    "insertText": "VectorSubtract(X, VectorSubtract(SupportA, SupportB))"
  },
  {
    "label": "MakeVectorRegisterFloat()",
    "kind": "Method",
    "detail": "Function (T Normal =)",
    "insertText": "MakeVectorRegisterFloat(0.f, 0.f, 1.f, 0.f)"
  },
  {
    "label": "VectorStoreFloat1()",
    "kind": "Method",
    "detail": "Function (FRealSingle InitialPreDist2 ;)",
    "insertText": "VectorStoreFloat1(InitialPreDist2Simd, &InitialPreDist2)"
  },
  {
    "label": "VectorStoreFloat1()",
    "kind": "Method",
    "detail": "Function (FRealSingle Inflation2 ;)",
    "insertText": "VectorStoreFloat1(Inflation2Simd, &Inflation2)"
  },
  {
    "label": "Inflation2()",
    "kind": "Method",
    "detail": "Function (FRealSingle Eps2 = 1 e - 6 f ; bool bCloseEnough = InitialPreDist2<)",
    "insertText": "Inflation2(!bComputeMTD || InitialPreDist2 < Eps2)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (bool bDegenerate = false ; bool bTerminate = bCloseEnough ; bool bInflatedCloseEnough = bCloseEnough ; int NumIterations = 0 ; T LimitMax = TMakeVectorRegisterConstant<)",
    "insertText": "T(TNumericLimits<FRealSingle>::Max(), TNumericLimits<FRealSingle>::Max(), TNumericLimits<FRealSingle>::Max(), TNumericLimits<FRealSingle>::Max())"
  },
  {
    "label": "VectorNormalizeAccurate()",
    "kind": "Method",
    "detail": "Function (break ; } V =)",
    "insertText": "VectorNormalizeAccurate(V)"
  },
  {
    "label": "SupportFunction()",
    "kind": "Method",
    "detail": "Function (SupportA = A .)",
    "insertText": "SupportFunction(TMakeVectorRegisterFloatFromDouble<T>(V))"
  },
  {
    "label": "SupportFunction()",
    "kind": "Method",
    "detail": "Function (SupportB = B .)",
    "insertText": "SupportFunction(TMakeVectorRegisterFloatFromDouble<T>(AToBRotation), TMakeVectorRegisterFloatFromDouble<T>(BToARotation), TMakeVectorRegisterFloatFromDouble<T>(VectorNegate(V)))"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (T W =)",
    "insertText": "VectorSubtract(X, P)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (T VDotWGTInflationSimd =)",
    "insertText": "VectorCompareGT(VDotW, Inflation)"
  },
  {
    "label": "VectorDot3()",
    "kind": "Method",
    "detail": "Function (const T VDotRayDir =)",
    "insertText": "VectorDot3(V, RayDir)"
  },
  {
    "label": "VectorCompareGE()",
    "kind": "Method",
    "detail": "Function (T VDotRayDirGEZero =)",
    "insertText": "VectorCompareGE(VDotRayDir, TVectorZero<T>())"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (T LambdaGTPreLambda =)",
    "insertText": "VectorCompareGT(Lambda, PreLambda)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (T LambdaGTRayLength =)",
    "insertText": "VectorCompareGT(Lambda, RayLengthSimd)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (Normal = V ; T XMinusOldX =)",
    "insertText": "VectorSubtract(X, OldX)"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (Simplex [ 0 ] =)",
    "insertText": "VectorAdd(Simplex[0], XMinusOldX)"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (Simplex [ 1 ] =)",
    "insertText": "VectorAdd(Simplex[1], XMinusOldX)"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (Simplex [ 2 ] =)",
    "insertText": "VectorAdd(Simplex[2], XMinusOldX)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (GJKPreDist2 = LimitMax ; bInflatedCloseEnough = false ; } } else { Simplex [ NumVerts + + ] = W ; })",
    "insertText": "if(bInflatedCloseEnough && VectorMaskBits(VectorCompareGE(VDotW, TVectorZero<T>())))"
  },
  {
    "label": "VectorDot3()",
    "kind": "Method",
    "detail": "Function (const T VDotW2 =)",
    "insertText": "VectorDot3(VDotW, VDotW)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (bCloseEnough = static_cast<)",
    "insertText": "bool(VectorMaskBits(VectorCompareGE(VectorAdd(Eps2Simd, VDotW), GJKPreDist2)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!bCloseEnough)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (V = VectorSimplexFindClosestToOrigin<)",
    "insertText": "T(Simplex, NumVerts, Barycentric, As, Bs)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (bDegenerate = static_cast<)",
    "insertText": "bool(VectorMaskBits(VectorCompareGE(NewDist2, GJKPreDist2)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (GJKPreDist2 = NewDist2 ;)",
    "insertText": "if(bComputeMTD && bCloseEnough)"
  },
  {
    "label": "VectorCompareEQ()",
    "kind": "Method",
    "detail": "Function (const T LambdaEqZero =)",
    "insertText": "VectorCompareEQ(Lambda, TVectorZero<T>())"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (const T InGJKPreDist2GTEps2 =)",
    "insertText": "VectorCompareGT(GJKPreDist2, Eps2Simd)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (const T Inflation22GTEps2 =)",
    "insertText": "VectorCompareGT(Inflation2Simd, Eps2Simd)"
  },
  {
    "label": "VectorBitwiseAnd()",
    "kind": "Method",
    "detail": "Function (const bool Is4GTNumVerts = 4> NumVerts ; const T IsInflatCloseEnough =)",
    "insertText": "VectorBitwiseAnd(LambdaEqZero, VectorBitwiseAnd(InGJKPreDist2GTEps2, Inflation22GTEps2))"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (bInflatedCloseEnough = static_cast<)",
    "insertText": "bool(VectorMaskBits(IsInflatCloseEnough))"
  },
  {
    "label": "VectorStoreFloat1()",
    "kind": "Method",
    "detail": "Function (} bTerminate = bCloseEnough | | bDegenerate ; })",
    "insertText": "VectorStoreFloat1(Lambda, &OutTime)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (T Barycentrics [ 4 ] ; Barycentrics [ 0 ] =)",
    "insertText": "VectorSwizzle(Barycentric, 0, 0, 0, 0)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (Barycentrics [ 1 ] =)",
    "insertText": "VectorSwizzle(Barycentric, 1, 1, 1, 1)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (Barycentrics [ 2 ] =)",
    "insertText": "VectorSwizzle(Barycentric, 2, 2, 2, 2)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (Barycentrics [ 3 ] =)",
    "insertText": "VectorSwizzle(Barycentric, 3, 3, 3, 3)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (const T ClosestB1 =)",
    "insertText": "VectorMultiplyAdd(Bs[0], Barycentrics[0], ClosestB)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (const T ClosestB2 =)",
    "insertText": "VectorMultiplyAdd(Bs[1], Barycentrics[1], ClosestB1)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (const T ClosestB3 =)",
    "insertText": "VectorMultiplyAdd(Bs[2], Barycentrics[2], ClosestB2)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (const T ClosestB4 =)",
    "insertText": "VectorMultiplyAdd(Bs[3], Barycentrics[3], ClosestB3)"
  },
  {
    "label": "VectorNegateMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (ClosestB = NumVerts = = 0 ? ClosestB : ClosestB4 ; ClosestB = NumVerts = = 1 ? ClosestB1 : ClosestB ; ClosestB = NumVerts = = 2 ? ClosestB2 : ClosestB ; ClosestB = NumVerts = = 3 ? ClosestB3 : ClosestB ; const T ClosestLocal =)",
    "insertText": "VectorNegateMultiplyAdd(Normal, MarginBSimd, ClosestB)"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (OutPosition =)",
    "insertText": "VectorAdd(VectorMultiplyAdd(RayDir, Lambda, StartPoint), ClosestLocal)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(bComputeMTD)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (T InflationGTZero =)",
    "insertText": "VectorCompareGT(Inflation, TVectorZero<T>())"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (T LimitMaxGTInGJKPreDist2 =)",
    "insertText": "VectorCompareGT(LimitMax, GJKPreDist2)"
  },
  {
    "label": "VectorBitwiseAnd()",
    "kind": "Method",
    "detail": "Function (T IsDone =)",
    "insertText": "VectorBitwiseAnd(InflationGTZero, VectorBitwiseAnd(InGJKPreDist2GTEps2, LimitMaxGTInGJKPreDist2))"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (GJKClosestA =)",
    "insertText": "VectorMultiplyAdd(As[i], Barycentrics[i], GJKClosestA)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (GJKClosestB =)",
    "insertText": "VectorMultiplyAdd(Bs[i], Barycentrics[i], GJKClosestB)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else { GJKClosestA = As [ 0 ] ; GJKClosestB = Bs [ 0 ] ; })",
    "insertText": "if(VectorMaskBits(IsDone))"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (const T ClosestBInA =)",
    "insertText": "VectorAdd(StartPoint, GJKClosestB)"
  },
  {
    "label": "VectorSqrt()",
    "kind": "Method",
    "detail": "Function (const T InGJKPreDist =)",
    "insertText": "VectorSqrt(GJKPreDist2)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (T Penetration =)",
    "insertText": "VectorSubtract(VectorAdd(MarginASimd, MarginBSimd), InGJKPreDist)"
  },
  {
    "label": "VectorMin()",
    "kind": "Method",
    "detail": "Function (Penetration =)",
    "insertText": "VectorMin(Penetration, LimitMax)"
  },
  {
    "label": "VectorMax()",
    "kind": "Method",
    "detail": "Function (Penetration =)",
    "insertText": "VectorMax(Penetration, TVectorZero<T>())"
  },
  {
    "label": "VectorNegateMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (const T ClosestLocal =)",
    "insertText": "VectorNegateMultiplyAdd(OutNormal, MarginBSimd, GJKClosestB)"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (OutPosition =)",
    "insertText": "VectorAdd(VectorMultiplyAdd(OutNormal, Penetration, StartPoint), ClosestLocal)"
  },
  {
    "label": "VectorNegate()",
    "kind": "Method",
    "detail": "Function (Penetration =)",
    "insertText": "VectorNegate(Penetration)"
  },
  {
    "label": "VectorStoreFloat1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreFloat1(Penetration, &OutTime)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(NumIterations)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertsA .)",
    "insertText": "Add(TMakeVectorRegisterFloatFromDouble<T>(As[i]))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertsB .)",
    "insertText": "Add(TMakeVectorRegisterFloatFromDouble<T>(VectorAdd(Bs[i], X)))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} struct SupportBAtOriginHelper { const FGeomGJKHelperSIMD& B ; const VectorRegister4Float AToBRotation ; const VectorRegister4Float BToARotation ; const VectorRegister4Float StartPoint ; VectorRegister4Float)",
    "insertText": "operator()(const VectorRegister4Float& V)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} } ; SupportBAtOriginHelper SupportBAtOrigin = { B,TMakeVectorRegisterFloatFromDouble<)",
    "insertText": "T(AToBRotation), TMakeVectorRegisterFloatFromDouble<T>(BToARotation), TMakeVectorRegisterFloatFromDouble<T>(StartPoint)"
  },
  {
    "label": "VectorEPA()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Penetration ; VectorRegister4Float MTD,ClosestA,ClosestBInA ; const EEPAResult EPAResult =)",
    "insertText": "VectorEPA(VertsA, VertsB, A, SupportBAtOrigin, Penetration, MTD, ClosestA, ClosestBInA)"
  },
  {
    "label": "OutTime()",
    "kind": "Method",
    "detail": "Function (OutTime = -)",
    "insertText": "OutTime(A.Margin + B.Margin)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OutPosition = ClosestA ; } else)",
    "insertText": "if(EPAResult == EEPAResult::BadInitialSimplex)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (OutPosition =)",
    "insertText": "VectorMultiplyAdd(OutNormal, MarginASimd, GJKClosestA)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(EPAResult == EEPAResult::Degenerate)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (OutNormal = TMakeVectorRegister<)",
    "insertText": "T(0.0f, 0.0f, 1.0f, 0.0f)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (OutPosition =)",
    "insertText": "VectorMultiplyAdd(OutNormal, MarginASimd, As[0])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (OutPosition = TMakeVectorRegister<)",
    "insertText": "T(0.0f, 0.0f, 0.0f, 0.0f)"
  },
  {
    "label": "GJKRaycast2Impl()",
    "kind": "Method",
    "detail": "Function (} return true ; } bool)",
    "insertText": "GJKRaycast2Impl(const FGeomGJKHelperSIMD& A, const FGeomGJKHelperSIMD& B, const TRigidTransform<FReal, 3>& StartTM, const TVector<FReal, 3>& RayDir, const FReal RayLength, FReal& OutTime, TVector<FReal, 3>& OutPosition, TVector<FReal, 3>& OutNormal, const FReal GivenThicknessA, bool bComputeMTD, const TVector<FReal, 3>& InitialDir, const FReal GivenThicknessB)"
  },
  {
    "label": "VectorNormalizeSafe()",
    "kind": "Method",
    "detail": "Function (Rotation =)",
    "insertText": "VectorNormalizeSafe(Rotation, GlobalVectorConstants::Float0001)"
  },
  {
    "label": "MakeVectorRegisterFloatFromDouble()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float RayDirSimd =)",
    "insertText": "MakeVectorRegisterFloatFromDouble(MakeVectorRegister(RayDir[0], RayDir[1], RayDir[2], 0.0))"
  },
  {
    "label": "VectorRegister4Float()",
    "kind": "Method",
    "detail": "Function (FRealSingle OutTimeFloat = 0 . 0 f ; VectorRegister4Float OutPositionSimd,OutNormalSimd ; const bool Result = GJKRaycast2ImplSimd<)",
    "insertText": "VectorRegister4Float(A, B, Rotation, Translation, RayDirSimd, static_cast<FRealSingle>(RayLength), OutTimeFloat, OutPositionSimd, OutNormalSimd, bComputeMTD, InitialDirSimd)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (OutTime = static_cast<)",
    "insertText": "double(OutTimeFloat)"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "alignas(16)"
  },
  {
    "label": "VectorStoreAligned()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreAligned(OutNormalSimd, OutFloat)"
  },
  {
    "label": "VectorStoreAligned()",
    "kind": "Method",
    "detail": "Function (OutNormal . X = OutFloat [ 0 ] ; OutNormal . Y = OutFloat [ 1 ] ; OutNormal . Z = OutFloat [ 2 ] ;)",
    "insertText": "VectorStoreAligned(OutPositionSimd, OutFloat)"
  },
  {
    "label": "GJKRaycast2()",
    "kind": "Method",
    "detail": "Function (OutPosition . X = OutFloat [ 0 ] ; OutPosition . Y = OutFloat [ 1 ] ; OutPosition . Z = OutFloat [ 2 ] ; return Result ; } template<T = FReal,TGeometryA,TGeometryB> bool)",
    "insertText": "GJKRaycast2(const TGeometryA& A, const TGeometryB& B, const TRigidTransform<T, 3>& StartTM, const TVector<T, 3>& RayDir, const T RayLength, T& OutTime, TVector<T, 3>& OutPosition, TVector<T, 3>& OutNormal, const T GivenThicknessA = 0, bool bComputeMTD = false, const TVector<T, 3>& InitialDir = TVector<T, 3>(1, 0, 0), const T GivenThicknessB = 0)"
  },
  {
    "label": "GJKDistanceInitialVFromRelativeTransform()",
    "kind": "Method",
    "detail": "Function (} template<T,TGeometryA,TGeometryB> TVector<T,3>)",
    "insertText": "GJKDistanceInitialVFromRelativeTransform(const TGeometryA& A, const TGeometryB& B, const TRigidTransform<T, 3>& BToATM)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Direction = TVec3<)",
    "insertText": "T(1, 0, 0)"
  },
  {
    "label": "SupportCore()",
    "kind": "Method",
    "detail": "Function (int32 UnusedVertexIndex = INDEX_NONE ; const TVector<T,3> SupportA = A .)",
    "insertText": "SupportCore(Direction, A.GetMargin(), nullptr, UnusedVertexIndex)"
  },
  {
    "label": "SupportCore()",
    "kind": "Method",
    "detail": "Function (const TVector<T,3> SupportBLocal = B .)",
    "insertText": "SupportCore(-DirectionInB, B.GetMargin(), nullptr, UnusedVertexIndex)"
  },
  {
    "label": "TransformPositionNoScale()",
    "kind": "Method",
    "detail": "Function (const TVector<T,3> SupportB = BToATM .)",
    "insertText": "TransformPositionNoScale(SupportBLocal)"
  },
  {
    "label": "SupportCore()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> SupportB = B .)",
    "insertText": "SupportCore(-Direction, B.GetMargin(), nullptr, UnusedVertexIndex)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int32 VertexIndexA = INDEX_NONE,VertexIndexB = INDEX_NONE ; int32 It = 0 ;)",
    "insertText": "while(VLen > Epsilon)"
  },
  {
    "label": "SupportCore()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> SupportA = A .)",
    "insertText": "SupportCore(-V, AMargin, nullptr, VertexIndexA)"
  },
  {
    "label": "SupportCore()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> SupportB = B .)",
    "insertText": "SupportCore(V, BMargin, nullptr, VertexIndexB)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (Mu =)",
    "insertText": "Max(Mu, D)"
  },
  {
    "label": "bCloseEnough()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "bCloseEnough((VLen - Mu) < Epsilon)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (OutNearestA = SupportA ; OutNearestB = SupportB ; } else { OutNearestA = TVec3<)",
    "insertText": "T(0, 0, 0)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (int32 WIndex = SimplexIDs [ VertIndex ] ;)",
    "insertText": "check(Barycentric[WIndex] >= (T)0)"
  },
  {
    "label": "VLen()",
    "kind": "Method",
    "detail": "Function (OutNearestA + = Barycentric [ WIndex ]* SimplexA [ WIndex ] ; OutNearestB + = Barycentric [ WIndex ]* SimplexB [ WIndex ] ; } } const TVec3<T> NormalA = - V / VLen ; OutDistance =)",
    "insertText": "VLen(AMargin + BMargin)"
  },
  {
    "label": "InverseTransformPositionNoScale()",
    "kind": "Method",
    "detail": "Function (OutNearestA + = AMargin* NormalA ; OutNearestB - = BMargin* NormalA ; OutNormalA = NormalA ; OutNearestB = B .)",
    "insertText": "InverseTransformPositionNoScale(OutNearestB)"
  },
  {
    "label": "SimplexFindClosestToOrigin()",
    "kind": "Method",
    "detail": "Function (} SimplexIDs [ SimplexIDs . NumVerts ] = SimplexIDs . NumVerts ; Simplex [ SimplexIDs . NumVerts ] = W ; SimplexA [ SimplexIDs . NumVerts ] = SupportA ; SimplexB [ SimplexIDs . NumVerts ] = SupportB ; + + SimplexIDs . NumVerts ; V =)",
    "insertText": "SimplexFindClosestToOrigin(Simplex, SimplexIDs, Barycentric, SimplexA, SimplexB)"
  }
]