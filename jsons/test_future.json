[
  {
    "label": "TestFuture",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TestFuture"
  },
  {
    "label": "TestFuture()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_TEST_TEST_FUTURE_H_ # define BASE_TEST_TEST_FUTURE_H_ # include<memory> # include<string> # include \" base / bind . h \" # include \" base / callback_forward . h \" # include \" base / check . h \" # include \" base / memory / weak_ptr . h \" # include \" base / run_loop . h \" # include \" base / sequence_checker . h \" # include \" base / test / test_future_internal . h \" # include \" base / thread_annotations . h \" # include \" third_party / abseil - cpp / absl / types / optional . h \" namespace base::test { template<. . . Types> class TestFuture { public : using TupleType = std::tuple<std::decay_t<Types> . . .> ; using FirstType = std::tuple_element<0,TupleType>::type ;)",
    "insertText": "TestFuture()"
  },
  {
    "label": "TestFuture()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TestFuture(const TestFuture&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TestFuture&)",
    "insertText": "operator(const TestFuture&)"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] bool)",
    "insertText": "Wait()"
  },
  {
    "label": "DCHECK_CALLED_ON_VALID_SEQUENCE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (run_loop_ .)",
    "insertText": "Run()"
  },
  {
    "label": "IsReady()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsReady()"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} template<std::size_t I> const auto&)",
    "insertText": "Get()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} template<. . . CallbackArgumentsTypes> base::OnceCallback<)",
    "insertText": "void(CallbackArgumentsTypes...)> GetCallback()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} base::OnceCallback<)",
    "insertText": "void(Types...)> GetCallback()"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetValue(Types... values)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(!values_.has_value())"
  },
  {
    "label": "make_tuple()",
    "kind": "Method",
    "detail": "Function (values_ =)",
    "insertText": "make_tuple(std::forward<Types>(values)...)"
  },
  {
    "label": "Quit()",
    "kind": "Method",
    "detail": "Function (run_loop_ .)",
    "insertText": "Quit()"
  },
  {
    "label": "Take()",
    "kind": "Method",
    "detail": "Function (} template<T = TupleType,internal::EnableIfSingleValue<T> = true> [ [ nodiscard ] ] FirstType)",
    "insertText": "Take()"
  },
  {
    "label": "GetTuple()",
    "kind": "Method",
    "detail": "Function (} private : [ [ nodiscard ] ] const TupleType&)",
    "insertText": "GetTuple()"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(success)"
  },
  {
    "label": "TakeTuple()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] TupleType)",
    "insertText": "TakeTuple()"
  },
  {
    "label": "SEQUENCE_CHECKER()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SEQUENCE_CHECKER(sequence_checker_)"
  },
  {
    "label": "GUARDED_BY_CONTEXT()",
    "kind": "Method",
    "detail": "Function (base::RunLoop run_loop_)",
    "insertText": "GUARDED_BY_CONTEXT(sequence_checker_)"
  }
]