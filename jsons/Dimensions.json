[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "BaseDimensions",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BaseDimensions"
  },
  {
    "label": "Y",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Y"
  },
  {
    "label": "BaseDimensions()",
    "kind": "Method",
    "detail": "Function (# ifndef Alembic_Util_Dimensions_h # define Alembic_Util_Dimensions_h # include<Alembic / Util / Foundation . h> # include<Alembic / Util / PlainOldDataType . h> namespace Alembic { namespace Util { namespace ALEMBIC_VERSION_NS { template<class T> class BaseDimensions { private : typedef std::vector<T> SizeVec ; SizeVec m_vector ; public :)",
    "insertText": "BaseDimensions() : m_vector()"
  },
  {
    "label": "BaseDimensions()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "BaseDimensions(const T& t ) : m_vector( 1, t)"
  },
  {
    "label": "BaseDimensions()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "BaseDimensions(const BaseDimensions &copy ) : m_vector( copy.m_vector)"
  },
  {
    "label": "BaseDimensions()",
    "kind": "Method",
    "detail": "Function (} template<class Y>)",
    "insertText": "BaseDimensions(const BaseDimensions<Y> &copy)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_vector .)",
    "insertText": "resize(copy.rank())"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Y val = copy [ i ] ; m_vector [ i ] = static_cast<)",
    "insertText": "T(val)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } BaseDimensions&)",
    "insertText": "operator(const BaseDimensions &copy)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (m_vector = copy . m_vector ; return* this ; } template<class Y> BaseDimensions&)",
    "insertText": "operator(const BaseDimensions<Y> &copy)"
  },
  {
    "label": "rank()",
    "kind": "Method",
    "detail": "Function (} return* this ; } size_t)",
    "insertText": "rank()"
  },
  {
    "label": "setRank()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setRank(size_t r)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (size_t oldSize = m_vector .)",
    "insertText": "size()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_vector .)",
    "insertText": "resize(r)"
  },
  {
    "label": "s()",
    "kind": "Method",
    "detail": "Function (m_vector [)",
    "insertText": "s(T)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } T&)",
    "insertText": "operator(size_t i)"
  },
  {
    "label": "rootPtr()",
    "kind": "Method",
    "detail": "Function (} const T*)",
    "insertText": "rootPtr()"
  },
  {
    "label": "numPoints()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "numPoints()"
  },
  {
    "label": "npoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "npoints(size_t)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return npoints ; } } } ; template<class T,class Y> bool)",
    "insertText": "operator(const BaseDimensions<T> &a, const BaseDimensions<Y> &b)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class T> std::ostream&)",
    "insertText": "operator(std::ostream &ostr, const BaseDimensions<T> &a)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (ostr<<\" { \" ;)",
    "insertText": "for(size_t i = 0; i < a.rank(); ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ostr<<a [ i ] ;)",
    "insertText": "if(i != a.rank()-1)"
  }
]