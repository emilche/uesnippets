[
  {
    "label": "SparseLUImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseLUImpl"
  },
  {
    "label": "column_dfs_traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "column_dfs_traits"
  },
  {
    "label": "column_dfs_traits()",
    "kind": "Method",
    "detail": "Function (# ifndef SPARSELU_COLUMN_DFS_H # define SPARSELU_COLUMN_DFS_H template<Scalar,StorageIndex> class SparseLUImpl ; namespace Eigen { namespace internal { template<IndexVector,ScalarVector> struct column_dfs_traits : no_assignment_operator { typedef ScalarVector::Scalar Scalar ; typedef IndexVector::Scalar StorageIndex ;)",
    "insertText": "column_dfs_traits(Index jcol, Index& jsuper, typename SparseLUImpl<Scalar, StorageIndex>::GlobalLU_t& glu, SparseLUImpl<Scalar, StorageIndex>& luImpl) : m_jcol(jcol), m_jsuper_ref(jsuper), m_glu(glu), m_luImpl(luImpl)"
  },
  {
    "label": "update_segrep()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "update_segrep(Index , Index)"
  },
  {
    "label": "column_dfs()",
    "kind": "Method",
    "detail": "Function (} enum { ExpandMem = true } ; Index m_jcol ; Index& m_jsuper_ref ; SparseLUImpl<Scalar,StorageIndex>::GlobalLU_t& m_glu ; SparseLUImpl<Scalar,StorageIndex>& m_luImpl ; } ; template<Scalar,StorageIndex> Index SparseLUImpl<Scalar,StorageIndex)",
    "insertText": "column_dfs(const Index m, const Index jcol, IndexVector& perm_r, Index maxsuper, Index& nseg, BlockIndexVector lsub_col, IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu)"
  },
  {
    "label": "supno()",
    "kind": "Method",
    "detail": "Function (Index jsuper = glu .)",
    "insertText": "supno(jcol)"
  },
  {
    "label": "xlsub()",
    "kind": "Method",
    "detail": "Function (Index nextl = glu .)",
    "insertText": "xlsub(jcol)"
  },
  {
    "label": "marker2()",
    "kind": "Method",
    "detail": "Function (VectorBlock<IndexVector>)",
    "insertText": "marker2(marker, 2*m, m)"
  },
  {
    "label": "traits()",
    "kind": "Method",
    "detail": "Function (column_dfs_traits<IndexVector,ScalarVector>)",
    "insertText": "traits(jcol, jsuper, glu, *this)"
  },
  {
    "label": "lsub_col()",
    "kind": "Method",
    "detail": "Function (Index krow =)",
    "insertText": "lsub_col(k)"
  },
  {
    "label": "marker2()",
    "kind": "Method",
    "detail": "Function (Index kmark =)",
    "insertText": "marker2(krow)"
  },
  {
    "label": "dfs_kernel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dfs_kernel(StorageIndex(jcol), perm_r, nseg, glu.lsub, segrep, repfnz, xprune, marker2, parent, xplore, glu, nextl, krow, traits)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (StorageIndex jcolp1 =)",
    "insertText": "StorageIndex(jcol)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index jcolm1 = jcol - 1 ;)",
    "insertText": "if(jcol == 0)"
  },
  {
    "label": "supno()",
    "kind": "Method",
    "detail": "Function (nsuper = glu .)",
    "insertText": "supno(0)"
  },
  {
    "label": "xsup()",
    "kind": "Method",
    "detail": "Function (} else { fsupc = glu .)",
    "insertText": "xsup(nsuper)"
  },
  {
    "label": "xlsub()",
    "kind": "Method",
    "detail": "Function (StorageIndex jm1ptr = glu .)",
    "insertText": "xlsub(jcolm1)"
  },
  {
    "label": "xlsub()",
    "kind": "Method",
    "detail": "Function (StorageIndex ito = glu .)",
    "insertText": "xlsub(fsupc+1)"
  },
  {
    "label": "xprune()",
    "kind": "Method",
    "detail": "Function (StorageIndex istop = ito + jptr - jm1ptr ;)",
    "insertText": "xprune(jcolm1)"
  },
  {
    "label": "xsup()",
    "kind": "Method",
    "detail": "Function (} } glu .)",
    "insertText": "xsup(nsuper+1)"
  },
  {
    "label": "supno()",
    "kind": "Method",
    "detail": "Function (glu .)",
    "insertText": "supno(jcolp1)"
  },
  {
    "label": "xprune()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "xprune(jcol) = StorageIndex(nextl)"
  },
  {
    "label": "xlsub()",
    "kind": "Method",
    "detail": "Function (glu .)",
    "insertText": "xlsub(jcolp1) = StorageIndex(nextl)"
  }
]