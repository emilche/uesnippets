[
  {
    "label": "TCurveSamplerAbstract",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TCurveSamplerAbstract"
  },
  {
    "label": "TSamplingPoint",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TSamplingPoint"
  },
  {
    "label": "TSamplingPoint()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Core / Types . h \" # include \" Geo / GeoEnum . h \" # include \" Geo / Surfaces / Surface . h \" # include \" Geo / Curves / Curve . h \" # include \" Math / Boundary . h \" # include \" Math / Point . h \" namespace UE::CADKernel { template<PolylineType,PointType> class TCurveSamplerAbstract { public : struct TSamplingPoint { const PolylineType* Sampling ; const PolylineType* Polyline ; int32 Index ;)",
    "insertText": "TSamplingPoint(const PolylineType& InSampling) : Sampling(&InSampling)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Set(const PolylineType& InPolyline, int32 InIndex)"
  },
  {
    "label": "IsCandidatePoint()",
    "kind": "Method",
    "detail": "Function (Polyline =& InPolyline ; Index = InIndex ; } bool)",
    "insertText": "IsCandidatePoint()"
  },
  {
    "label": "TCurveSamplerAbstract()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TCurveSamplerAbstract()"
  },
  {
    "label": "Sample()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Sample()"
  },
  {
    "label": "SamplingInitalizing()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SamplingInitalizing()"
  },
  {
    "label": "RunSampling()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RunSampling()"
  },
  {
    "label": "EvaluatesNewCandidatePoints()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "EvaluatesNewCandidatePoints()"
  },
  {
    "label": "CheckSamplingError()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "CheckSamplingError(int32 FirstIndex, int32 EndIndex)"
  },
  {
    "label": "GetNotDerivableCoordinates()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetNotDerivableCoordinates(TArray<double>& OutNotDerivableCoordinates)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (IsOptimalSegments .)",
    "insertText": "Empty(100)"
  },
  {
    "label": "GetNotDerivableCoordinates()",
    "kind": "Method",
    "detail": "Function (int32 ComplementaryPointOffset = 0 ; { TArray<double> NotDerivableCoordinates ;)",
    "insertText": "GetNotDerivableCoordinates(NotDerivableCoordinates)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (NotDerivableCoordinates .)",
    "insertText": "Insert(Boundary.Min, 0)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (NotDerivableCoordinates .)",
    "insertText": "Add(Boundary.Max)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (ComplementaryPointOffset = NotDerivableCoordinates .)",
    "insertText": "Num()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (NextCoordinates .)",
    "insertText": "Empty(NotDerivableCoordinates.Num() * (ComplementaryPointOffset + 1))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (NextCoordinates .)",
    "insertText": "Add(Boundary.Min)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (NextCoordinates .)",
    "insertText": "Add(NotDerivableCoordinates[Index + 1])"
  },
  {
    "label": "SwapCoordinates()",
    "kind": "Method",
    "detail": "Function (} } } CandidatePoints .)",
    "insertText": "SwapCoordinates(NextCoordinates)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (ComplementaryPointOffset + + ;)",
    "insertText": "for(int32 Index = 0, ISampling = 0; Index < CandidatePoints.Size(); Index += ComplementaryPointOffset, ++ISampling)"
  },
  {
    "label": "EmplaceAt()",
    "kind": "Method",
    "detail": "Function (Sampling .)",
    "insertText": "EmplaceAt(ISampling, CandidatePoints, Index)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (IsOptimalSegments .)",
    "insertText": "Add(false)"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (} IsOptimalSegments .)",
    "insertText": "Pop()"
  },
  {
    "label": "RemoveComplementaryPoints()",
    "kind": "Method",
    "detail": "Function (CandidatePoints .)",
    "insertText": "RemoveComplementaryPoints(ComplementaryPointOffset)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (NextCoordinates .)",
    "insertText": "Empty()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (StartSamplingSegmentIndex = 0 ; EndStudySegment . Index = 0 ; int32 FirstCandidateIndex = 0 ; int32 LastCandidateIndex = 1 ; int32 SegmentIndex = 0 ; do {)",
    "insertText": "if(IsOptimalSegments[StartSamplingSegmentIndex])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (StartSamplingSegmentIndex + + ; continue ; } EndSamplingSegmentIndex = StartSamplingSegmentIndex + 1 ; do {)",
    "insertText": "if((LastCandidateIndex < CandidatePointsCount && TmpPolylineCoordinates[LastCandidateIndex] < Sampling.Coordinates[EndSamplingSegmentIndex]))"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (EndStudySegment .)",
    "insertText": "Set(CandidatePoints, LastCandidateIndex)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} else { EndStudySegment .)",
    "insertText": "Set(Sampling, EndSamplingSegmentIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if((FirstCandidateIndex >= CandidatePointsCount) || (FirstCandidateIndex < CandidatePointsCount && TmpPolylineCoordinates[FirstCandidateIndex] > EndStudySegment.Polyline->Coordinates[EndStudySegment.Index]))"
  },
  {
    "label": "AddIntermediateCoordinates()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddIntermediateCoordinates(Sampling.Coordinates[StartSamplingSegmentIndex], Sampling.Coordinates[EndSamplingSegmentIndex], 1)"
  },
  {
    "label": "CheckSamplingError()",
    "kind": "Method",
    "detail": "Function (StartSamplingSegmentIndex = EndSamplingSegmentIndex ; break ; } int32 NeededPointNum =)",
    "insertText": "CheckSamplingError(FirstCandidateIndex, LastCandidateIndex)"
  },
  {
    "label": "CompletesPolyline()",
    "kind": "Method",
    "detail": "Function (IsOptimalSegments [ StartSamplingSegmentIndex ] = true ; } else { LastCandidateIndex + + ; continue ; } } else {)",
    "insertText": "CompletesPolyline(NeededPointNum, LastCandidateIndex - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(EndStudySegment.IsSamplingPoint())"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (StartSamplingSegmentIndex = EndSamplingSegmentIndex ; FirstCandidateIndex = LastCandidateIndex ; LastCandidateIndex + + ; } else { StartSamplingSegmentIndex = EndSamplingSegmentIndex - 1 ; FirstCandidateIndex = LastCandidateIndex + 1 ; LastCandidateIndex + = 2 ; } })",
    "insertText": "while(EndStudySegment.IsCandidatePoint())"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(StartSamplingSegmentIndex < IsOptimalSegments.Num() && EndStudySegment.Index < Sampling.Coordinates.Num() - 1)"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (CandidatePointsCount = CandidatePoints .)",
    "insertText": "Size()"
  },
  {
    "label": "DisplaySampling()",
    "kind": "Method",
    "detail": "Function (# ifdef DEBUG_CURVE_SAMPLING)",
    "insertText": "DisplaySampling(CurveIndex == CurveToDisplay, 0)"
  },
  {
    "label": "CheckResult()",
    "kind": "Method",
    "detail": "Function (# endif } # ifdef CHECK_RESULT_MAKE_ISO_POLYLINE)",
    "insertText": "CheckResult()"
  },
  {
    "label": "AddIntermediateCoordinates()",
    "kind": "Method",
    "detail": "Function (# endif } bool)",
    "insertText": "AddIntermediateCoordinates(double UMin, double UMax, int32 PointNum)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (UCoord + = DeltaCoord ; NextCoordinates .)",
    "insertText": "Add(UCoord)"
  },
  {
    "label": "CompletesPolyline()",
    "kind": "Method",
    "detail": "Function (} return true ; } ; void)",
    "insertText": "CompletesPolyline(int32 NeededPointNumber, int32 IntermediateIndex)"
  },
  {
    "label": "GetCoordinates()",
    "kind": "Method",
    "detail": "Function (NeededPointNumber = 5 0 ; } const TArray<double>& CandidateCoordinates = CandidatePoints .)",
    "insertText": "GetCoordinates()"
  },
  {
    "label": "EmplaceAt()",
    "kind": "Method",
    "detail": "Function (Sampling .)",
    "insertText": "EmplaceAt(EndSamplingSegmentIndex, CandidatePoints, IntermediateIndex)"
  },
  {
    "label": "EmplaceAt()",
    "kind": "Method",
    "detail": "Function (IsOptimalSegments .)",
    "insertText": "EmplaceAt(EndSamplingSegmentIndex - 1, NeededPointNumber == 2 ? true : false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (EndSamplingSegmentIndex + + ; })",
    "insertText": "if(EndStudySegment.IsCandidatePoint())"
  },
  {
    "label": "EmplaceAt()",
    "kind": "Method",
    "detail": "Function (Sampling .)",
    "insertText": "EmplaceAt(EndSamplingSegmentIndex, CandidatePoints, EndStudySegment.Index)"
  },
  {
    "label": "EmplaceAt()",
    "kind": "Method",
    "detail": "Function (IsOptimalSegments .)",
    "insertText": "EmplaceAt(EndSamplingSegmentIndex - 1, NeededPointNumber <= 2 ? true : false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (EndSamplingSegmentIndex + + ; } else { EndStudySegment . Index = EndSamplingSegmentIndex ;)",
    "insertText": "if(NeededPointNumber <= 2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (IsOptimalSegments [ EndSamplingSegmentIndex - 1 ] = true ; } })",
    "insertText": "if(NeededPointNumber > 2)"
  },
  {
    "label": "AddIntermediateCoordinates()",
    "kind": "Method",
    "detail": "Function (NeededPointNumber - = 2 ;)",
    "insertText": "AddIntermediateCoordinates(Sampling.Coordinates[StartSamplingSegmentIndex], CandidateCoordinates[IntermediateIndex], NeededPointNumber)"
  },
  {
    "label": "AddIntermediateCoordinates()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddIntermediateCoordinates(CandidateCoordinates[IntermediateIndex], EndStudySegment.Polyline->Coordinates[EndStudySegment.Index], NeededPointNumber)"
  },
  {
    "label": "GetFirstNeighbor()",
    "kind": "Method",
    "detail": "Function (} } ; int32)",
    "insertText": "GetFirstNeighbor(int32 NeighborIndex, const double StartCoordinate, const PolylineType& Points, const int32 Increment, double& NeighborCoordinate)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NeighborCoordinate = Points . Coordinates [ NeighborIndex ] ;)",
    "insertText": "if(FMath::IsNearlyEqual(NeighborCoordinate, StartCoordinate) && Points.Coordinates.IsValidIndex(NeighborIndex + Increment))"
  },
  {
    "label": "CountOfNeededPointsToRespectChordError()",
    "kind": "Method",
    "detail": "Function (NeighborIndex + = Increment ; NeighborCoordinate = Points . Coordinates [ NeighborIndex ] ; ; } return NeighborIndex ; } ; int32)",
    "insertText": "CountOfNeededPointsToRespectChordError(const PointType& PointA, const PointType& PointB, double ChordError)"
  },
  {
    "label": "CheckTangentError()",
    "kind": "Method",
    "detail": "Function (} ; int32)",
    "insertText": "CheckTangentError(const PointType& APoint, double ACoordinate, const PointType& BPoint, double BCoordinate, int32 FirstIndex, int32 EndIndex, int32 InStartSamplingSegmentIndex)"
  },
  {
    "label": "GetPoints()",
    "kind": "Method",
    "detail": "Function (PointType Middle = CandidatePoints .)",
    "insertText": "GetPoints()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 CountOfNeededPoints = 2 ;)",
    "insertText": "if(FirstIndex > 0 && InStartSamplingSegmentIndex > 0)"
  },
  {
    "label": "GetPoints()",
    "kind": "Method",
    "detail": "Function (const PointType& PreviousPoint = PreviousSampingCoordinate> PreviousCandidateCoordinate ? Sampling .)",
    "insertText": "GetPoints()[PreviousSampingIndex] : CandidatePoints.GetPoints()"
  },
  {
    "label": "CountOfNeededPointsToRespectChordError()",
    "kind": "Method",
    "detail": "Function (CountOfNeededPoints =)",
    "insertText": "CountOfNeededPointsToRespectChordError(APoint, PreviousPoint, ChordA)"
  },
  {
    "label": "GetPoints()",
    "kind": "Method",
    "detail": "Function (const PointType& NextPoint = NextSampingCoordinate<NextCandidateCoordinate ? Sampling .)",
    "insertText": "GetPoints()[NextSampingIndex] : CandidatePoints.GetPoints()"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (CountOfNeededPoints =)",
    "insertText": "Max(CountOfNeededPointsToRespectChordError(BPoint, NextPoint, ChordB), CountOfNeededPoints)"
  },
  {
    "label": "DisplaySampling()",
    "kind": "Method",
    "detail": "Function (} } return CountOfNeededPoints ; } ; protected : FLinearBoundary Boundary ; PolylineType& Sampling ; PolylineType CandidatePoints ; const TArray<double>& TmpPolylineCoordinates ; const TArray<double>& SamplingCoordinates ; TArray<char> IsOptimalSegments ; int32 StartSamplingSegmentIndex ; int32 EndSamplingSegmentIndex ; TSamplingPoint EndStudySegment ; TArray<double> NextCoordinates ; double DesiredChordError ; # ifdef DEBUG_CURVE_SAMPLING public : int32 CurveIndex = 0 ; int32 CurveToDisplay = 1 ; void)",
    "insertText": "DisplaySampling(bool bDisplay, int32 Step)"
  },
  {
    "label": "G()",
    "kind": "Method",
    "detail": "Function ({ int32 Index = 0 ; F3DDebugSession)",
    "insertText": "G(FString::Printf(TEXT(\"Curve %d\"), Step))"
  },
  {
    "label": "DisplayPoint()",
    "kind": "Method",
    "detail": "Function (UE::)",
    "insertText": "DisplayPoint(Point, EVisuProperty::BluePoint, Index++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int32 Index = 0; Index < Sampling.GetPoints().Num() - 1; ++Index)"
  },
  {
    "label": "DisplaySegment()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisplaySegment(Sampling.GetPoints()[Index], Sampling.GetPoints()[Index + 1], Index, EVisuProperty::BlueCurve)"
  },
  {
    "label": "DisplaySegment()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "DisplaySegment(Sampling.GetPoints()[Index], Sampling.GetPoints()[Index + 1], Index, EVisuProperty::YellowCurve)"
  },
  {
    "label": "G()",
    "kind": "Method",
    "detail": "Function (} } } { int32 Index = 0 ; F3DDebugSession)",
    "insertText": "G(FString::Printf(TEXT(\"Next Point Tmp %d\"), Step))"
  },
  {
    "label": "DisplayPoint()",
    "kind": "Method",
    "detail": "Function (UE::)",
    "insertText": "DisplayPoint(Point, EVisuProperty::YellowPoint, Index++)"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "Wait()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (NextCoordinates .)",
    "insertText": "Empty(Sampling.Coordinates.Num())"
  },
  {
    "label": "AddIntermediateCoordinates()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddIntermediateCoordinates(Sampling.Coordinates[Index], Sampling.Coordinates[Index + 1], 1)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (MinError [ 0 ] =)",
    "insertText": "Min(MinError[0], ChordError)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (MaxError [ 0 ] =)",
    "insertText": "Max(MaxError[0], ChordError)"
  },
  {
    "label": "Square()",
    "kind": "Method",
    "detail": "Function (ErrorSum [ 0 ] + = ChordError ; SquareErrorSum [ 0 ] + =)",
    "insertText": "Square(ChordError)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (MinError [ 1 ] =)",
    "insertText": "Min(MinError[1], ParametrizationError)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (MaxError [ 1 ] =)",
    "insertText": "Max(MaxError[1], ParametrizationError)"
  },
  {
    "label": "Square()",
    "kind": "Method",
    "detail": "Function (ErrorSum [ 1 ] + = ParametrizationError ; SquareErrorSum [ 1 ] + =)",
    "insertText": "Square(ParametrizationError)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (} double ChordMed = ErrorSum [ 0 ] / EvaluationCount ; double ChordStandartDeviation =)",
    "insertText": "sqrt(SquareErrorSum[0] / EvaluationCount - FMath::Square(ChordMed))"
  },
  {
    "label": "Printf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Printf(EVerboseLevel::Log, TEXT(\"Chord Desired Med Sd Min Max %f %f %f %f %f\"), MaxError, ChordMed, ChordStandartDeviation, MinError[0], MaxError[0])"
  },
  {
    "label": "Printf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Printf(EVerboseLevel::Log, TEXT(\"Param Desired Med Sd Min Max %f %f %f %f %f\"), MaxError, ParamMed, ParamStandartDeviation, MinError[1], MaxError[1])"
  }
]