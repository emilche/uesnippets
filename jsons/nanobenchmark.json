[
  {
    "label": "Params",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Params"
  },
  {
    "label": "Result",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Result"
  },
  {
    "label": "Closure",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Closure"
  },
  {
    "label": "FuncOutput()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_RANDOM_INTERNAL_NANOBENCHMARK_H_ # define ABSL_RANDOM_INTERNAL_NANOBENCHMARK_H_ # include<stddef . h> # include<stdint . h> # include \" absl / base / config . h \" namespace absl { ABSL_NAMESPACE_BEGIN namespace random_internal_nanobenchmark { using FuncInput = size_t ; using FuncOutput = uint64_t ; using Func =)",
    "insertText": "FuncOutput(*)(const void*, FuncInput)"
  },
  {
    "label": "PinThreadToCPU()",
    "kind": "Method",
    "detail": "Function (struct Params { size_t kTimerSamples = 2 5 6 ; size_t precision_divisor = 1 0 2 4 ; size_t subset_ratio = 2 ; double seconds_per_eval = 4 E - 3 ; size_t min_samples_per_eval = 7 ; size_t min_mode_samples = 6 4 ; double target_rel_mad = 0 . 0 0 2 ; size_t max_evals = 9 ; size_t max_measure_retries = 2 ; bool verbose = true ; } ; struct Result { FuncInput input ; float ticks ; float variability ; } ; void)",
    "insertText": "PinThreadToCPU(const int cpu = -1)"
  },
  {
    "label": "Measure()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "Measure(const Func func, const void* arg, const FuncInput* inputs, const size_t num_inputs, Result* results, const Params& p = Params())"
  },
  {
    "label": "CallClosure()",
    "kind": "Method",
    "detail": "Function (template<class Closure> FuncOutput)",
    "insertText": "CallClosure(const void* f, const FuncInput input)"
  },
  {
    "label": "MeasureClosure()",
    "kind": "Method",
    "detail": "Function (} template<class Closure> size_t)",
    "insertText": "MeasureClosure(const Closure& closure, const FuncInput* inputs, const size_t num_inputs, Result* results, const Params& p = Params())"
  }
]