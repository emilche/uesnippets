[
  {
    "label": "AssumptionCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AssumptionCache"
  },
  {
    "label": "Constant",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Constant"
  },
  {
    "label": "DataLayout",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DataLayout"
  },
  {
    "label": "DominatorTree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DominatorTree"
  },
  {
    "label": "Instruction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Instruction"
  },
  {
    "label": "TargetLibraryInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetLibraryInfo"
  },
  {
    "label": "Value",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Value"
  },
  {
    "label": "LazyValueInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LazyValueInfo"
  },
  {
    "label": "Tristate",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Tristate"
  },
  {
    "label": "LazyValueInfo()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_ANALYSIS_LAZYVALUEINFO_H # define LLVM_ANALYSIS_LAZYVALUEINFO_H # include \" llvm / Pass . h \" namespace llvm { class AssumptionCache ; class Constant ; class DataLayout ; class DominatorTree ; class Instruction ; class TargetLibraryInfo ; class Value ; class LazyValueInfo : public FunctionPass { AssumptionCache* AC ; class TargetLibraryInfo* TLI ; DominatorTree* DT ; void* PImpl ;)",
    "insertText": "LazyValueInfo(const LazyValueInfo&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(const LazyValueInfo&)"
  },
  {
    "label": "LazyValueInfo()",
    "kind": "Method",
    "detail": "Function (public : char ID ;)",
    "insertText": "LazyValueInfo() : FunctionPass(ID), PImpl(nullptr)"
  },
  {
    "label": "initializeLazyValueInfoPass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "initializeLazyValueInfoPass(*PassRegistry::getPassRegistry())"
  },
  {
    "label": "LazyValueInfo()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "LazyValueInfo()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!PImpl && \"releaseMemory not called\")"
  },
  {
    "label": "getPredicateOnEdge()",
    "kind": "Method",
    "detail": "Function (} enum Tristate { Unknown = - 1,False = 0,True = 1 } ; Tristate)",
    "insertText": "getPredicateOnEdge(unsigned Pred, Value *V, Constant *C, BasicBlock *FromBB, BasicBlock *ToBB, Instruction *CxtI = nullptr)"
  },
  {
    "label": "getPredicateAt()",
    "kind": "Method",
    "detail": "Function (Tristate)",
    "insertText": "getPredicateAt(unsigned Pred, Value *V, Constant *C, Instruction *CxtI)"
  },
  {
    "label": "getConstant()",
    "kind": "Method",
    "detail": "Function (Constant*)",
    "insertText": "getConstant(Value *V, BasicBlock *BB, Instruction *CxtI = nullptr)"
  },
  {
    "label": "getConstantOnEdge()",
    "kind": "Method",
    "detail": "Function (Constant*)",
    "insertText": "getConstantOnEdge(Value *V, BasicBlock *FromBB, BasicBlock *ToBB, Instruction *CxtI = nullptr)"
  },
  {
    "label": "threadEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "threadEdge(BasicBlock *PredBB, BasicBlock *OldSucc, BasicBlock *NewSucc)"
  },
  {
    "label": "eraseBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eraseBlock(BasicBlock *BB)"
  },
  {
    "label": "getAnalysisUsage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getAnalysisUsage(AnalysisUsage &AU)"
  },
  {
    "label": "releaseMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "releaseMemory()"
  },
  {
    "label": "runOnFunction()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "runOnFunction(Function &F)"
  }
]