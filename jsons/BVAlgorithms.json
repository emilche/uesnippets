[
  {
    "label": "intersector_helper1",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "intersector_helper1"
  },
  {
    "label": "intersector_helper2",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "intersector_helper2"
  },
  {
    "label": "minimizer_helper1",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "minimizer_helper1"
  },
  {
    "label": "minimizer_helper2",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "minimizer_helper2"
  },
  {
    "label": "intersect_helper()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_BVALGORITHMS_H # define EIGEN_BVALGORITHMS_H namespace Eigen { namespace internal { # ifndef EIGEN_PARSED_BY_DOXYGEN template<BVH,Intersector> bool)",
    "insertText": "intersect_helper(const BVH &tree, Intersector &intersector, typename BVH::Index root)"
  },
  {
    "label": "VolIter()",
    "kind": "Method",
    "detail": "Function (typedef BVH::Index Index ; typedef BVH::VolumeIterator VolIter ; typedef BVH::ObjectIterator ObjIter ; VolIter vBegin =)",
    "insertText": "VolIter(), vEnd = VolIter()"
  },
  {
    "label": "ObjIter()",
    "kind": "Method",
    "detail": "Function (ObjIter oBegin =)",
    "insertText": "ObjIter(), oEnd = ObjIter()"
  },
  {
    "label": "todo()",
    "kind": "Method",
    "detail": "Function (std::vector<Index>)",
    "insertText": "todo(1, root)"
  },
  {
    "label": "getChildren()",
    "kind": "Method",
    "detail": "Function (tree .)",
    "insertText": "getChildren(todo.back(), vBegin, vEnd, oBegin, oEnd)"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (todo .)",
    "insertText": "pop_back()"
  },
  {
    "label": "intersector_helper1()",
    "kind": "Method",
    "detail": "Function (} return false ; } # endif template<Volume1,Object1,Object2,Intersector> struct intersector_helper1 {)",
    "insertText": "intersector_helper1(const Object2 &inStored, Intersector &in) : stored(inStored), intersector(in)"
  },
  {
    "label": "intersectVolume()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "intersectVolume(const Volume1 &vol)"
  },
  {
    "label": "intersectObject()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "intersectObject(const Object1 &obj)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Object2 stored ; Intersector& intersector ; private : intersector_helper1&)",
    "insertText": "operator(const intersector_helper1&)"
  },
  {
    "label": "intersector_helper2()",
    "kind": "Method",
    "detail": "Function (} ; template<Volume2,Object2,Object1,Intersector> struct intersector_helper2 {)",
    "insertText": "intersector_helper2(const Object1 &inStored, Intersector &in) : stored(inStored), intersector(in)"
  },
  {
    "label": "intersectVolume()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "intersectVolume(const Volume2 &vol)"
  },
  {
    "label": "intersectObject()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "intersectObject(const Object2 &obj)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Object1 stored ; Intersector& intersector ; private : intersector_helper2&)",
    "insertText": "operator(const intersector_helper2&)"
  },
  {
    "label": "BVIntersect()",
    "kind": "Method",
    "detail": "Function (} ; } template<BVH,Intersector> void)",
    "insertText": "BVIntersect(const BVH &tree, Intersector &intersector)"
  },
  {
    "label": "intersect_helper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "intersect_helper(tree, intersector, tree.getRootIndex())"
  },
  {
    "label": "BVIntersect()",
    "kind": "Method",
    "detail": "Function (} template<BVH1,BVH2,Intersector> void)",
    "insertText": "BVIntersect(const BVH1 &tree1, const BVH2 &tree2, Intersector &intersector)"
  },
  {
    "label": "VolIter1()",
    "kind": "Method",
    "detail": "Function (typedef BVH1::Index Index1 ; typedef BVH2::Index Index2 ; typedef internal::intersector_helper1<BVH1::Volume,BVH1::Object,BVH2::Object,Intersector> Helper1 ; typedef internal::intersector_helper2<BVH2::Volume,BVH2::Object,BVH1::Object,Intersector> Helper2 ; typedef BVH1::VolumeIterator VolIter1 ; typedef BVH1::ObjectIterator ObjIter1 ; typedef BVH2::VolumeIterator VolIter2 ; typedef BVH2::ObjectIterator ObjIter2 ; VolIter1 vBegin1 =)",
    "insertText": "VolIter1(), vEnd1 = VolIter1()"
  },
  {
    "label": "ObjIter1()",
    "kind": "Method",
    "detail": "Function (ObjIter1 oBegin1 =)",
    "insertText": "ObjIter1(), oEnd1 = ObjIter1()"
  },
  {
    "label": "VolIter2()",
    "kind": "Method",
    "detail": "Function (VolIter2 vBegin2 =)",
    "insertText": "VolIter2(), vEnd2 = VolIter2(), vCur2 = VolIter2()"
  },
  {
    "label": "ObjIter2()",
    "kind": "Method",
    "detail": "Function (ObjIter2 oBegin2 =)",
    "insertText": "ObjIter2(), oEnd2 = ObjIter2(), oCur2 = ObjIter2()"
  },
  {
    "label": "todo()",
    "kind": "Method",
    "detail": "Function (std::vector<std::pair<Index1,Index2>>)",
    "insertText": "todo(1, std::make_pair(tree1.getRootIndex(), tree2.getRootIndex()))"
  },
  {
    "label": "getChildren()",
    "kind": "Method",
    "detail": "Function (tree1 .)",
    "insertText": "getChildren(todo.back().first, vBegin1, vEnd1, oBegin1, oEnd1)"
  },
  {
    "label": "getChildren()",
    "kind": "Method",
    "detail": "Function (tree2 .)",
    "insertText": "getChildren(todo.back().second, vBegin2, vEnd2, oBegin2, oEnd2)"
  },
  {
    "label": "getVolume()",
    "kind": "Method",
    "detail": "Function (const BVH1::Volume& vol1 = tree1 .)",
    "insertText": "getVolume(*vBegin1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(oCur2 = oBegin2; oCur2 != oEnd2; ++oCur2)"
  },
  {
    "label": "helper()",
    "kind": "Method",
    "detail": "Function (Helper1)",
    "insertText": "helper(*oCur2, intersector)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(; oBegin1 != oEnd1; ++oBegin1)"
  },
  {
    "label": "helper()",
    "kind": "Method",
    "detail": "Function (Helper2)",
    "insertText": "helper(*oBegin1, intersector)"
  },
  {
    "label": "minimize_helper()",
    "kind": "Method",
    "detail": "Function (} } } } namespace internal { # ifndef EIGEN_PARSED_BY_DOXYGEN template<BVH,Minimizer> Minimizer::Scalar)",
    "insertText": "minimize_helper(const BVH &tree, Minimizer &minimizer, typename BVH::Index root, typename Minimizer::Scalar minimum)"
  },
  {
    "label": "push()",
    "kind": "Method",
    "detail": "Function (std::priority_queue<QueueElement,std::vector<QueueElement>,std::greater<QueueElement>> todo ; todo .)",
    "insertText": "push(std::make_pair(Scalar(), root))"
  },
  {
    "label": "getChildren()",
    "kind": "Method",
    "detail": "Function (tree .)",
    "insertText": "getChildren(todo.top().second, vBegin, vEnd, oBegin, oEnd)"
  },
  {
    "label": "pop()",
    "kind": "Method",
    "detail": "Function (todo .)",
    "insertText": "pop()"
  },
  {
    "label": "minimumOnVolume()",
    "kind": "Method",
    "detail": "Function (Scalar val = minimizer .)",
    "insertText": "minimumOnVolume(tree.getVolume(*vBegin))"
  },
  {
    "label": "minimizer_helper1()",
    "kind": "Method",
    "detail": "Function (} } return minimum ; } # endif template<Volume1,Object1,Object2,Minimizer> struct minimizer_helper1 { typedef Minimizer::Scalar Scalar ;)",
    "insertText": "minimizer_helper1(const Object2 &inStored, Minimizer &m) : stored(inStored), minimizer(m)"
  },
  {
    "label": "minimumOnVolume()",
    "kind": "Method",
    "detail": "Function (} Scalar)",
    "insertText": "minimumOnVolume(const Volume1 &vol)"
  },
  {
    "label": "minimumOnObject()",
    "kind": "Method",
    "detail": "Function (} Scalar)",
    "insertText": "minimumOnObject(const Object1 &obj)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Object2 stored ; Minimizer& minimizer ; private : minimizer_helper1&)",
    "insertText": "operator(const minimizer_helper1&)"
  },
  {
    "label": "minimizer_helper2()",
    "kind": "Method",
    "detail": "Function (} ; template<Volume2,Object2,Object1,Minimizer> struct minimizer_helper2 { typedef Minimizer::Scalar Scalar ;)",
    "insertText": "minimizer_helper2(const Object1 &inStored, Minimizer &m) : stored(inStored), minimizer(m)"
  },
  {
    "label": "minimumOnVolume()",
    "kind": "Method",
    "detail": "Function (} Scalar)",
    "insertText": "minimumOnVolume(const Volume2 &vol)"
  },
  {
    "label": "minimumOnObject()",
    "kind": "Method",
    "detail": "Function (} Scalar)",
    "insertText": "minimumOnObject(const Object2 &obj)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Object1 stored ; Minimizer& minimizer ; private : minimizer_helper2&)",
    "insertText": "operator(const minimizer_helper2&)"
  },
  {
    "label": "BVMinimize()",
    "kind": "Method",
    "detail": "Function (} ; } template<BVH,Minimizer> Minimizer::Scalar)",
    "insertText": "BVMinimize(const BVH &tree, Minimizer &minimizer)"
  },
  {
    "label": "BVMinimize()",
    "kind": "Method",
    "detail": "Function (} template<BVH1,BVH2,Minimizer> Minimizer::Scalar)",
    "insertText": "BVMinimize(const BVH1 &tree1, const BVH2 &tree2, Minimizer &minimizer)"
  },
  {
    "label": "minimum()",
    "kind": "Method",
    "detail": "Function (std::priority_queue<QueueElement,std::vector<QueueElement>,std::greater<QueueElement>> todo ; Scalar)",
    "insertText": "minimum(std::numeric_limits<Scalar>::max)()"
  },
  {
    "label": "push()",
    "kind": "Method",
    "detail": "Function (todo .)",
    "insertText": "push(std::make_pair(Scalar(), std::make_pair(tree1.getRootIndex(), tree2.getRootIndex())))"
  },
  {
    "label": "getChildren()",
    "kind": "Method",
    "detail": "Function (tree1 .)",
    "insertText": "getChildren(todo.top().second.first, vBegin1, vEnd1, oBegin1, oEnd1)"
  },
  {
    "label": "getChildren()",
    "kind": "Method",
    "detail": "Function (tree2 .)",
    "insertText": "getChildren(todo.top().second.second, vBegin2, vEnd2, oBegin2, oEnd2)"
  },
  {
    "label": "minimum()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "minimum(std::min)(minimum, minimizer.minimumOnObjectObject(*oBegin1, *oCur2))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(vCur2 = vBegin2; vCur2 != vEnd2; ++vCur2)"
  },
  {
    "label": "helper()",
    "kind": "Method",
    "detail": "Function (Helper2)",
    "insertText": "helper(*oBegin1, minimizer)"
  },
  {
    "label": "minimum()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "minimum(std::min)(minimum, internal::minimize_helper(tree2, helper, *vCur2, minimum))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(; vBegin1 != vEnd1; ++vBegin1)"
  },
  {
    "label": "helper()",
    "kind": "Method",
    "detail": "Function (Helper1)",
    "insertText": "helper(*oCur2, minimizer)"
  },
  {
    "label": "minimum()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "minimum(std::min)(minimum, internal::minimize_helper(tree1, helper, *vBegin1, minimum))"
  },
  {
    "label": "minimumOnVolumeVolume()",
    "kind": "Method",
    "detail": "Function (Scalar val = minimizer .)",
    "insertText": "minimumOnVolumeVolume(vol1, tree2.getVolume(*vCur2))"
  }
]