[
  {
    "label": "FUObjectAnnotationSparse",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FUObjectAnnotationSparse"
  },
  {
    "label": "FUObjectAnnotationSparseSearchable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FUObjectAnnotationSparseSearchable"
  },
  {
    "label": "FBoolAnnotation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBoolAnnotation"
  },
  {
    "label": "TIsPODType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsPODType"
  },
  {
    "label": "FUObjectAnnotationSparseBool",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FUObjectAnnotationSparseBool"
  },
  {
    "label": "FUObjectAnnotationChunked",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FUObjectAnnotationChunked"
  },
  {
    "label": "TAnnotationChunk",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TAnnotationChunk"
  },
  {
    "label": "FUObjectAnnotationDense",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FUObjectAnnotationDense"
  },
  {
    "label": "FUObjectAnnotationDenseBool",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FUObjectAnnotationDenseBool"
  },
  {
    "label": "NotifyUObjectDeleted()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" UObject / UObjectArray . h \" # include \" Misc / TransactionallySafeRWLock . h \" # include \" Misc / TransactionallySafeRWScopeLock . h \" template<TAnnotation,bool bAutoRemove> class FUObjectAnnotationSparse : public FUObjectArray::FUObjectDeleteListener { public : void)",
    "insertText": "NotifyUObjectDeleted(const UObjectBase *Object, int32 Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (#)",
    "insertText": "if(UE_BUILD_SHIPPING || UE_BUILD_TEST) if (!bAutoRemove)"
  },
  {
    "label": "AnnotationMapLock()",
    "kind": "Method",
    "detail": "Function (FTransactionallySafeScopeLock)",
    "insertText": "AnnotationMapLock(&AnnotationMapCritical)"
  },
  {
    "label": "RemoveAnnotation()",
    "kind": "Method",
    "detail": "Function (} else # endif {)",
    "insertText": "RemoveAnnotation(Object)"
  },
  {
    "label": "OnUObjectArrayShutdown()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "OnUObjectArrayShutdown()"
  },
  {
    "label": "RemoveAllAnnotations()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAllAnnotations()"
  },
  {
    "label": "RemoveUObjectDeleteListener()",
    "kind": "Method",
    "detail": "Function (GUObjectArray .)",
    "insertText": "RemoveUObjectDeleteListener(this)"
  },
  {
    "label": "FUObjectAnnotationSparse()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FUObjectAnnotationSparse() : AnnotationCacheKey(NULL)"
  },
  {
    "label": "FUObjectAnnotationSparse()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FUObjectAnnotationSparse()"
  },
  {
    "label": "AddAnnotationInternal()",
    "kind": "Method",
    "detail": "Function (} private : template<T> void)",
    "insertText": "AddAnnotationInternal(const UObjectBase* Object, T&& Annotation)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (TAnnotation LocalAnnotation = Forward<)",
    "insertText": "T(Annotation)"
  },
  {
    "label": "bWasEmpty()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "bWasEmpty(AnnotationMap.Num() == 0)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (AnnotationCacheKey = Object ; AnnotationCacheValue =)",
    "insertText": "MoveTemp(LocalAnnotation)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (AnnotationMap .)",
    "insertText": "Add(AnnotationCacheKey, AnnotationCacheValue)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} else { AnnotationMap .)",
    "insertText": "Add(Object, LocalAnnotation)"
  },
  {
    "label": "TAnnotation()",
    "kind": "Method",
    "detail": "Function (AnnotationCacheKey = nullptr ; AnnotationCacheValue =)",
    "insertText": "TAnnotation()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bWasEmpty)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (#)",
    "insertText": "if(UE_BUILD_SHIPPING || UE_BUILD_TEST) if (bAutoRemove)"
  },
  {
    "label": "AddUObjectDeleteListener()",
    "kind": "Method",
    "detail": "Function (UE_AUTORTFM_OPEN { GUObjectArray .)",
    "insertText": "AddUObjectDeleteListener(this)"
  },
  {
    "label": "UE_AUTORTFM_ONABORT()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "UE_AUTORTFM_ONABORT(this)"
  },
  {
    "label": "AddAnnotation()",
    "kind": "Method",
    "detail": "Function (} ; } } } } public : void)",
    "insertText": "AddAnnotation(const UObjectBase* Object, TAnnotation&& Annotation)"
  },
  {
    "label": "AddAnnotationInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddAnnotationInternal(Object, MoveTemp(Annotation))"
  },
  {
    "label": "AddAnnotation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddAnnotation(const UObjectBase* Object, const TAnnotation& Annotation)"
  },
  {
    "label": "AddAnnotationInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddAnnotationInternal(Object, Annotation)"
  },
  {
    "label": "GetAndRemoveAnnotation()",
    "kind": "Method",
    "detail": "Function (} TAnnotation)",
    "insertText": "GetAndRemoveAnnotation(const UObjectBase *Object)"
  },
  {
    "label": "bHadElements()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bHadElements(AnnotationMap.Num() > 0)"
  },
  {
    "label": "RemoveAndCopyValue()",
    "kind": "Method",
    "detail": "Function (AnnotationMap .)",
    "insertText": "RemoveAndCopyValue(AnnotationCacheKey, Result)"
  },
  {
    "label": "bIsNowEmpty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bIsNowEmpty(AnnotationMap.Num() == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bHadElements && bIsNowEmpty)"
  },
  {
    "label": "RemoveAnnotation()",
    "kind": "Method",
    "detail": "Function (} } return Result ; } void)",
    "insertText": "RemoveAnnotation(const UObjectBase *Object)"
  },
  {
    "label": "UE_AUTORTFM_ONCOMMIT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UE_AUTORTFM_ONCOMMIT(this, Object)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (AnnotationMap .)",
    "insertText": "Remove(AnnotationCacheKey)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (AnnotationMap .)",
    "insertText": "Empty()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bHadElements)"
  },
  {
    "label": "GetAnnotation()",
    "kind": "Method",
    "detail": "Function (} } } TAnnotation)",
    "insertText": "GetAnnotation(const UObjectBase *Object)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (AnnotationCacheKey = Object ; TAnnotation* Entry = AnnotationMap .)",
    "insertText": "Find(AnnotationCacheKey)"
  },
  {
    "label": "GetAnnotationMap()",
    "kind": "Method",
    "detail": "Function (} } return AnnotationCacheValue ; } const TMap<const UObjectBase*,TAnnotation>&)",
    "insertText": "GetAnnotationMap()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (AnnotationMap .)",
    "insertText": "Empty(ExpectedNumElements)"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (} SIZE_T)",
    "insertText": "GetAllocatedSize()"
  },
  {
    "label": "FUObjectAnnotationSparseSearchable()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FUObjectAnnotationSparseSearchable()"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (} UObject*)",
    "insertText": "Find(const TAnnotation& Annotation)"
  },
  {
    "label": "InverseAnnotationMapLock()",
    "kind": "Method",
    "detail": "Function (FTransactionallySafeScopeLock)",
    "insertText": "InverseAnnotationMapLock(&InverseAnnotationMapCritical)"
  },
  {
    "label": "GetAnnotation()",
    "kind": "Method",
    "detail": "Function (} else { TAnnotation ExistingAnnotation = this ->)",
    "insertText": "GetAnnotation(Object)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (int32 NumExistingRemoved = InverseAnnotationMap .)",
    "insertText": "Remove(ExistingAnnotation)"
  },
  {
    "label": "AddAnnotation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddAnnotation(Object, Annotation)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (int32 NumRemoved = InverseAnnotationMap .)",
    "insertText": "Remove(Annotation)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (InverseAnnotationMap .)",
    "insertText": "Add(Forward<T>(Annotation), Object)"
  },
  {
    "label": "GetAndRemoveAnnotation()",
    "kind": "Method",
    "detail": "Function (TAnnotation Annotation = this ->)",
    "insertText": "GetAndRemoveAnnotation(Object)"
  },
  {
    "label": "FBoolAnnotation()",
    "kind": "Method",
    "detail": "Function (} private : TMap<TAnnotation,const UObjectBase*> InverseAnnotationMap ; FTransactionallySafeCriticalSection InverseAnnotationMapCritical ; } ; struct FBoolAnnotation {)",
    "insertText": "FBoolAnnotation() : Mark(false)"
  },
  {
    "label": "FBoolAnnotation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FBoolAnnotation(bool InMark) : Mark(InMark)"
  },
  {
    "label": "IsDefault()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsDefault()"
  },
  {
    "label": "AddAnnotation()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "AddAnnotation(Object,FBoolAnnotation(true))"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Clear(const UObjectBase *Object)"
  },
  {
    "label": "ClearAll()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ClearAll()"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Get(const UObjectBase *Object)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reserve(int32 ExpectedNumElements)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (FUObjectAnnotationSparse<FBoolAnnotation,true)",
    "insertText": "Reserve(ExpectedNumElements)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Num()"
  },
  {
    "label": "TAnnotationChunk()",
    "kind": "Method",
    "detail": "Function (} } ; template<TAnnotation,bool bAutoRemove,int32 NumAnnotationsPerChunk = 6 4* 1 0 2 4> class FUObjectAnnotationChunked : public FUObjectArray::FUObjectDeleteListener { struct TAnnotationChunk { int32 Num ; TAnnotation* Items ;)",
    "insertText": "TAnnotationChunk() : Num(0) , Items(nullptr)"
  },
  {
    "label": "ExpandChunksToIndex()",
    "kind": "Method",
    "detail": "Function (} } ; TArray<TAnnotationChunk> Chunks ; int32 NumAnnotations ; int32 MaxAnnotations ; uint32 CurrentAllocatedMemory ; uint32 MaxAllocatedMemory ; FTransactionallySafeRWLock AnnotationArrayCritical ; void)",
    "insertText": "ExpandChunksToIndex(int32 Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 ChunkIndex = Index / NumAnnotationsPerChunk ;)",
    "insertText": "if(ChunkIndex >= Chunks.Num())"
  },
  {
    "label": "AddZeroed()",
    "kind": "Method",
    "detail": "Function (Chunks .)",
    "insertText": "AddZeroed(ChunkIndex + 1 - Chunks.Num())"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "check(ChunkIndex < Chunks.Num())"
  },
  {
    "label": "AllocateAnnotation()",
    "kind": "Method",
    "detail": "Function (} TAnnotation&)",
    "insertText": "AllocateAnnotation(int32 Index)"
  },
  {
    "label": "ExpandChunksToIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpandChunksToIndex(Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int32 ChunkIndex = Index / NumAnnotationsPerChunk ; const int32 WithinChunkIndex = Index % NumAnnotationsPerChunk ; TAnnotationChunk& Chunk = Chunks [ ChunkIndex ] ;)",
    "insertText": "if(!Chunk.Items)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (Chunk . Items = new TAnnotation [ NumAnnotationsPerChunk ] ; CurrentAllocatedMemory + = NumAnnotationsPerChunk*)",
    "insertText": "sizeof(TAnnotation)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (MaxAllocatedMemory =)",
    "insertText": "Max(CurrentAllocatedMemory, MaxAllocatedMemory)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Chunk.Items[WithinChunkIndex].IsDefault())"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (Chunk . Num + + ;)",
    "insertText": "check(Chunk.Num <= NumAnnotationsPerChunk)"
  },
  {
    "label": "FreeAnnotation()",
    "kind": "Method",
    "detail": "Function (NumAnnotations + + ; } return Chunk . Items [ WithinChunkIndex ] ; } void)",
    "insertText": "FreeAnnotation(int32 Index)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (Chunk . Num - - ;)",
    "insertText": "check(Chunk.Num >= 0)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (CurrentAllocatedMemory - = ChunkMemory ; } NumAnnotations - - ;)",
    "insertText": "check(NumAnnotations >= 0)"
  },
  {
    "label": "FreeAllAnnotations()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "FreeAllAnnotations()"
  },
  {
    "label": "AddAnnotationInternal()",
    "kind": "Method",
    "detail": "Function (NumAnnotations = 0 ; MaxAnnotations = 0 ; CurrentAllocatedMemory = 0 ; MaxAllocatedMemory = 0 ; } template<T> void)",
    "insertText": "AddAnnotationInternal(int32 Index, T&& Annotation)"
  },
  {
    "label": "FreeAnnotation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeAnnotation(Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(NumAnnotations == 0 && Chunks.Num() == 0)"
  },
  {
    "label": "AllocateAnnotation()",
    "kind": "Method",
    "detail": "Function (} } TAnnotation& NewAnnotation =)",
    "insertText": "AllocateAnnotation(Index)"
  },
  {
    "label": "FUObjectAnnotationChunked()",
    "kind": "Method",
    "detail": "Function (} } public :)",
    "insertText": "FUObjectAnnotationChunked() TSAN_SAFE : NumAnnotations(0) , MaxAnnotations(0) , CurrentAllocatedMemory(0) , MaxAllocatedMemory(0)"
  },
  {
    "label": "FUObjectAnnotationChunked()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FUObjectAnnotationChunked()"
  },
  {
    "label": "AddAnnotation()",
    "kind": "Method",
    "detail": "Function (} public : void)",
    "insertText": "AddAnnotation(const UObjectBase *Object, const TAnnotation& Annotation)"
  },
  {
    "label": "AddAnnotation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddAnnotation(GUObjectArray.ObjectToIndex(Object), Annotation)"
  },
  {
    "label": "AddAnnotation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddAnnotation(GUObjectArray.ObjectToIndex(Object), MoveTemp(Annotation))"
  },
  {
    "label": "AddAnnotation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddAnnotation(int32 Index, const TAnnotation& Annotation)"
  },
  {
    "label": "AnnotationArrayLock()",
    "kind": "Method",
    "detail": "Function (FTransactionallySafeWriteScopeLock)",
    "insertText": "AnnotationArrayLock(AnnotationArrayCritical)"
  },
  {
    "label": "AddAnnotationInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddAnnotationInternal(Index, Annotation)"
  },
  {
    "label": "AddAnnotation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddAnnotation(int32 Index, TAnnotation&& Annotation)"
  },
  {
    "label": "AddAnnotationInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddAnnotationInternal(Index, MoveTemp(Annotation))"
  },
  {
    "label": "AddOrGetAnnotation()",
    "kind": "Method",
    "detail": "Function (} TAnnotation&)",
    "insertText": "AddOrGetAnnotation(const UObjectBase *Object, TFunctionRef<TAnnotation()> NewAnnotationFn)"
  },
  {
    "label": "AddOrGetAnnotation()",
    "kind": "Method",
    "detail": "Function (} TAnnotation&)",
    "insertText": "AddOrGetAnnotation(int32 Index, TFunctionRef<TAnnotation()> NewAnnotationFn)"
  },
  {
    "label": "NewAnnotationFn()",
    "kind": "Method",
    "detail": "Function (NumAnnotations + + ; Chunk . Items [ WithinChunkIndex ] =)",
    "insertText": "NewAnnotationFn()"
  },
  {
    "label": "RemoveAnnotation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAnnotation(GUObjectArray.ObjectToIndex(Object))"
  },
  {
    "label": "RemoveAnnotation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveAnnotation(int32 Index)"
  },
  {
    "label": "GetAnnotation()",
    "kind": "Method",
    "detail": "Function (} TAnnotation)",
    "insertText": "GetAnnotation(int32 Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int32 ChunkIndex = Index / NumAnnotationsPerChunk ;)",
    "insertText": "if(ChunkIndex < Chunks.Num())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int32 WithinChunkIndex = Index % NumAnnotationsPerChunk ; TAnnotationChunk& Chunk = Chunks [ ChunkIndex ] ;)",
    "insertText": "if(Chunk.Items != nullptr)"
  },
  {
    "label": "GetAnnotationCount()",
    "kind": "Method",
    "detail": "Function (Result = Chunk . Items [ WithinChunkIndex ] ; } } } ; return Result ; } int32)",
    "insertText": "GetAnnotationCount()"
  },
  {
    "label": "bHadAnnotations()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "bHadAnnotations(NumAnnotations > 0)"
  },
  {
    "label": "TrimAnnotations()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "TrimAnnotations()"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (delete [ ] Chunk . Items ; Chunk . Items = nullptr ; const uint32 ChunkMemory = NumAnnotationsPerChunk*)",
    "insertText": "sizeof(TAnnotationChunk)"
  },
  {
    "label": "GetMaxAllocatedSize()",
    "kind": "Method",
    "detail": "Function (} } return AllocatedSize ; } uint32)",
    "insertText": "GetMaxAllocatedSize()"
  },
  {
    "label": "RemoveAnnotation()",
    "kind": "Method",
    "detail": "Function (} else # endif {)",
    "insertText": "RemoveAnnotation(Index)"
  },
  {
    "label": "FUObjectAnnotationDense()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FUObjectAnnotationDense()"
  },
  {
    "label": "AnnotationArrayLock()",
    "kind": "Method",
    "detail": "Function (FRWScopeLock)",
    "insertText": "AnnotationArrayLock(AnnotationArrayCritical, SLT_Write)"
  },
  {
    "label": "RemoveAnnotationInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAnnotationInternal(Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(AnnotationArray.Num() == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(Index >= AnnotationArray.Num())"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (int32 Start = AnnotationArray .)",
    "insertText": "AddUninitialized(AddNum)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(AnnotationArray.GetData() + Start++) TAnnotation()"
  },
  {
    "label": "RemoveAnnotationInternal()",
    "kind": "Method",
    "detail": "Function (} private : void)",
    "insertText": "RemoveAnnotationInternal(int32 Index)"
  },
  {
    "label": "bHadElements()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "bHadElements(AnnotationArray.Num() > 0)"
  },
  {
    "label": "AnnotationArrayLock()",
    "kind": "Method",
    "detail": "Function (FRWScopeLock)",
    "insertText": "AnnotationArrayLock(AnnotationArrayCritical, SLT_ReadOnly)"
  },
  {
    "label": "GetAnnotationRef()",
    "kind": "Method",
    "detail": "Function (} TAnnotation&)",
    "insertText": "GetAnnotationRef(const UObjectBase *Object)"
  },
  {
    "label": "GetAnnotationRef()",
    "kind": "Method",
    "detail": "Function (} TAnnotation&)",
    "insertText": "GetAnnotationRef(int32 Index)"
  },
  {
    "label": "AddAnnotationInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddAnnotationInternal(Index, TAnnotation())"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} private : TArray<TAnnotation> AnnotationArray ; FRWLock AnnotationArrayCritical ; } ; class FUObjectAnnotationDenseBool : public FUObjectArray::FUObjectDeleteListener { typedef uint32 TBitType ; enum { BitsPerElement =)",
    "insertText": "sizeof(TBitType)"
  },
  {
    "label": "FUObjectAnnotationDenseBool()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FUObjectAnnotationDenseBool()"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Set(const UObjectBase *Object)"
  },
  {
    "label": "ObjectToIndex()",
    "kind": "Method",
    "detail": "Function (int32 Index = GUObjectArray .)",
    "insertText": "ObjectToIndex(Object)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Index >= AnnotationArray.Num() * BitsPerElement)"
  },
  {
    "label": "AddElements()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "AddElements(AddNum + BitsPerElement - 1)"
  },
  {
    "label": "AddZeroed()",
    "kind": "Method",
    "detail": "Function (AnnotationArray .)",
    "insertText": "AddZeroed(AddElements)"
  },
  {
    "label": "TBitType()",
    "kind": "Method",
    "detail": "Function (} AnnotationArray [ Index / BitsPerElement ] | =)",
    "insertText": "TBitType(TBitType(1) << (Index % BitsPerElement))"
  }
]