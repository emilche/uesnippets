[
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "LevelSetTracker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LevelSetTracker"
  },
  {
    "label": "that",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "that"
  },
  {
    "label": "State",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "State"
  },
  {
    "label": "defined",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "defined"
  },
  {
    "label": "defined",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "defined"
  },
  {
    "label": "to",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "to"
  },
  {
    "label": "Trim",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Trim"
  },
  {
    "label": "to",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "to"
  },
  {
    "label": "Normalizer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Normalizer"
  },
  {
    "label": "template",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "template"
  },
  {
    "label": "template",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "template"
  },
  {
    "label": "LevelSetTracker()",
    "kind": "Method",
    "detail": "Function (set)",
    "insertText": "LevelSetTracker(GridT& grid, InterruptT* interrupt = nullptr)"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "normalize(const MaskType* mask)"
  },
  {
    "label": "track()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "track()"
  },
  {
    "label": "prune()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "prune()"
  },
  {
    "label": "dilate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dilate(int iterations = 1)"
  },
  {
    "label": "erode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "erode(int iterations = 1)"
  },
  {
    "label": "startInterrupter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "startInterrupter(const char* msg)"
  },
  {
    "label": "endInterrupter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "endInterrupter()"
  },
  {
    "label": "checkInterrupter()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "checkInterrupter()"
  },
  {
    "label": "trim()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "trim()"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "normalize()"
  },
  {
    "label": "cook()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cook(const char* msg, int swapBuffer=0)"
  },
  {
    "label": "euler()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "euler(const LeafRange& range, Index phiBuffer, Index resultBuffer)"
  },
  {
    "label": "normalize1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "normalize1(const MaskT* mask)"
  },
  {
    "label": "normalize2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "normalize2(const MaskT* mask)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (default:)",
    "insertText": "OPENVDB_THROW(ValueError, \"Spatial difference scheme not supported!\")"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (default:)",
    "insertText": "OPENVDB_THROW(ValueError, \"Temporal integration scheme not supported!\")"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (MaskT>)",
    "insertText": "tmp(*this, mask)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN)",
    "insertText": "for(auto leafIter = range.begin()"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (default:)",
    "insertText": "OPENVDB_THROW(ValueError, \"Temporal integration scheme not supported!\")"
  }
]