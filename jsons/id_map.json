[
  {
    "label": "IDMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IDMap"
  },
  {
    "label": "ReturnType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ReturnType"
  },
  {
    "label": "Iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Iterator"
  },
  {
    "label": "KeyIterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "KeyIterator"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_CONTAINERS_ID_MAP_H_ # define BASE_CONTAINERS_ID_MAP_H_ # include<stddef . h> # include<stdint . h> # include<iterator> # include<ostream> # include<type_traits> # include<unordered_map> # include<utility> # include \" base / check . h \" # include \" base / check_op . h \" # include \" base / containers / flat_set . h \" # include \" base / memory / raw_ptr . h \" # include \" base / notreached . h \" # include \" base / sequence_checker . h \" namespace base { template<V,K = int32_t> class IDMap final { public : using KeyType = K ; private : using T = std::remove_reference<)",
    "insertText": "decltype(*V())"
  },
  {
    "label": "IDMap()",
    "kind": "Method",
    "detail": "Function (using HashTable = std::unordered_map<KeyType,V> ; public :)",
    "insertText": "IDMap() : iteration_depth_(0), next_id_(1), check_on_null_data_(false)"
  },
  {
    "label": "DETACH_FROM_SEQUENCE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DETACH_FROM_SEQUENCE(sequence_checker_)"
  },
  {
    "label": "IDMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "IDMap(const IDMap&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IDMap&)",
    "insertText": "operator(const IDMap&)"
  },
  {
    "label": "IDMap()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "IDMap()"
  },
  {
    "label": "set_check_on_null_data()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_check_on_null_data(bool value)"
  },
  {
    "label": "AddWithID()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddWithID(V data, KeyType id)"
  },
  {
    "label": "AddWithIDInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddWithIDInternal(std::move(data), id)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Remove(KeyType id)"
  },
  {
    "label": "DCHECK_CALLED_ON_VALID_SEQUENCE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (HashTable::iterator i = data_ .)",
    "insertText": "find(id)"
  },
  {
    "label": "NOTREACHED()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NOTREACHED()"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (data_ .)",
    "insertText": "erase(i)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} else { removed_ids_ .)",
    "insertText": "insert(id)"
  },
  {
    "label": "Replace()",
    "kind": "Method",
    "detail": "Function (} } V)",
    "insertText": "Replace(KeyType id, V new_data)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(!check_on_null_data_ || new_data)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(i != data_.end())"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(!IsRemoved(id))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (using std::swap ;)",
    "insertText": "swap(i->second, new_data)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (data_ .)",
    "insertText": "clear()"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (} else { removed_ids_ .)",
    "insertText": "reserve(data_.size())"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (removed_ids_ .)",
    "insertText": "insert(KeyIterator(data_.begin()), KeyIterator(data_.end()))"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "Lookup()",
    "kind": "Method",
    "detail": "Function (} T*)",
    "insertText": "Lookup(KeyType id)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if)",
    "insertText": "defined(UNIT_TEST) int iteration_depth()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init()"
  },
  {
    "label": "Iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Iterator(const Iterator& iter) : map_(iter.map_), iter_(iter.iter_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const Iterator&)",
    "insertText": "operator(const Iterator& iter)"
  },
  {
    "label": "DCHECK_CALLED_ON_VALID_SEQUENCE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_CALLED_ON_VALID_SEQUENCE(map_->sequence_checker_)"
  },
  {
    "label": "DCHECK_LT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_LT(0, map_->iteration_depth_)"
  },
  {
    "label": "IsAtEnd()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsAtEnd()"
  },
  {
    "label": "GetCurrentKey()",
    "kind": "Method",
    "detail": "Function (} KeyType)",
    "insertText": "GetCurrentKey()"
  },
  {
    "label": "SkipRemovedEntries()",
    "kind": "Method",
    "detail": "Function (+ + iter_ ;)",
    "insertText": "SkipRemovedEntries()"
  },
  {
    "label": "KeyIterator()",
    "kind": "Method",
    "detail": "Function (} raw_ptr<IDMap<V,K>> map_ ; HashTable::const_iterator iter_ ; } ; typedef Iterator<T> iterator ; typedef Iterator<const T> const_iterator ; private : struct KeyIterator { using iterator_category = std::forward_iterator_tag ; using value_type = KeyType ; using difference_type = std::ptrdiff_t ; using pointer = KeyType* ; using reference = KeyType& ; using inner_iterator = HashTable::iterator ; inner_iterator iter_ ;)",
    "insertText": "KeyIterator(inner_iterator iter) : iter_(iter)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} KeyType)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (+ + iter_ ; return* this ; } KeyIterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const KeyIterator& other)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(!check_on_null_data_ || data)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (KeyType this_id = next_id_ ;)",
    "insertText": "DCHECK(data_.find(this_id) == data_.end())"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (data_ [ this_id ] =)",
    "insertText": "move(data)"
  },
  {
    "label": "AddWithIDInternal()",
    "kind": "Method",
    "detail": "Function (next_id_ + + ; return this_id ; } void)",
    "insertText": "AddWithIDInternal(V data, KeyType id)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (removed_ids_ .)",
    "insertText": "erase(id)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "DCHECK(data_.find(id) == data_.end())"
  },
  {
    "label": "IsRemoved()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsRemoved(KeyType key)"
  },
  {
    "label": "Compact()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Compact()"
  },
  {
    "label": "DCHECK_EQ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_EQ(0, iteration_depth_)"
  },
  {
    "label": "SEQUENCE_CHECKER()",
    "kind": "Method",
    "detail": "Function (} int iteration_depth_ ; base::flat_set<KeyType> removed_ids_ ; KeyType next_id_ ; HashTable data_ ; bool check_on_null_data_ ;)",
    "insertText": "SEQUENCE_CHECKER(sequence_checker_)"
  }
]