[
  {
    "label": "LeafNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LeafNode"
  },
  {
    "label": "ValueConverter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValueConverter"
  },
  {
    "label": "SameConfiguration",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SameConfiguration"
  },
  {
    "label": "ValueIter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValueIter"
  },
  {
    "label": "ChildIter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ChildIter"
  },
  {
    "label": "DenseIter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DenseIter"
  },
  {
    "label": "IteratorBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IteratorBase"
  },
  {
    "label": "Local",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Local"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_TREE_LEAF_NODE_BOOL_HAS_BEEN_INCLUDED # define OPENVDB_TREE_LEAF_NODE_BOOL_HAS_BEEN_INCLUDED # include<openvdb / Types . h> # include<openvdb / io / Compression . h> # include<openvdb / math / Math . h> # include<openvdb / util / NodeMasks . h> # include \" LeafNode . h \" # include \" Iterator . h \" # include<iostream> # include<sstream> # include<string> # include<type_traits> # include<vector> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace tree { template<Index Log2Dim> class LeafNode<bool,Log2Dim> { public : using LeafNodeType = LeafNode<bool,Log2Dim> ; using BuildType = bool ; using ValueType = bool ; using Buffer = LeafBuffer<ValueType,Log2Dim> ; using NodeMaskType = util::NodeMask<Log2Dim> ; using Ptr = SharedPtr<LeafNodeType> ; const Index LOG2DIM = Log2Dim ; const Index TOTAL = Log2Dim ; const Index DIM = 1<<TOTAL ; const Index NUM_VALUES = 1<<3* Log2Dim ; const Index NUM_VOXELS = NUM_VALUES ; const Index SIZE = NUM_VALUES ; const Index LEVEL = 0 ; template<ValueType> struct ValueConverter { using Type = LeafNode<ValueType,Log2Dim> ; } ; template<OtherNodeType> struct SameConfiguration { const bool value = SameLeafConfig<LOG2DIM,OtherNodeType>::value ; } ;)",
    "insertText": "LeafNode()"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LeafNode(const Coord& xyz, bool value = false, bool active = false)"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LeafNode(PartialCreate, const Coord& xyz, bool value = false, bool active = false)"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LeafNode(const LeafNode&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (LeafNode&)",
    "insertText": "operator(const LeafNode&)"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (template<OtherValueType>)",
    "insertText": "LeafNode(const LeafNode<OtherValueType, Log2Dim>& other)"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (template<ValueType>)",
    "insertText": "LeafNode(const LeafNode<ValueType, Log2Dim>& other, TopologyCopy)"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (template<ValueType>)",
    "insertText": "LeafNode(const LeafNode<ValueType, Log2Dim>& other, bool offValue, bool onValue, TopologyCopy)"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (template<ValueType>)",
    "insertText": "LeafNode(const LeafNode<ValueType, Log2Dim>& other, bool background, TopologyCopy)"
  },
  {
    "label": "log2dim()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "log2dim()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (dims .)",
    "insertText": "push_back(Log2Dim)"
  },
  {
    "label": "getChildDim()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "getChildDim()"
  },
  {
    "label": "nonLeafCount()",
    "kind": "Method",
    "detail": "Function (} Index32)",
    "insertText": "nonLeafCount()"
  },
  {
    "label": "offVoxelCount()",
    "kind": "Method",
    "detail": "Function (} Index64)",
    "insertText": "offVoxelCount()"
  },
  {
    "label": "onLeafVoxelCount()",
    "kind": "Method",
    "detail": "Function (} Index64)",
    "insertText": "onLeafVoxelCount()"
  },
  {
    "label": "offLeafVoxelCount()",
    "kind": "Method",
    "detail": "Function (} Index64)",
    "insertText": "offLeafVoxelCount()"
  },
  {
    "label": "onTileCount()",
    "kind": "Method",
    "detail": "Function (} Index64)",
    "insertText": "onTileCount()"
  },
  {
    "label": "isDense()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isDense()"
  },
  {
    "label": "isAllocated()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isAllocated()"
  },
  {
    "label": "evalActiveBoundingBox()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalActiveBoundingBox(CoordBBox& bbox, bool visitVoxels = true)"
  },
  {
    "label": "getNodeBoundingBox()",
    "kind": "Method",
    "detail": "Function (CoordBBox)",
    "insertText": "getNodeBoundingBox()"
  },
  {
    "label": "setOrigin()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setOrigin(const Coord& origin)"
  },
  {
    "label": "origin()",
    "kind": "Method",
    "detail": "Function (mOrigin = origin ; } const Coord&)",
    "insertText": "origin()"
  },
  {
    "label": "getOrigin()",
    "kind": "Method",
    "detail": "Function (origin = mOrigin ; } void)",
    "insertText": "getOrigin(Int32& x, Int32& y, Int32& z)"
  },
  {
    "label": "asXYZ()",
    "kind": "Method",
    "detail": "Function (mOrigin .)",
    "insertText": "asXYZ(x, y, z)"
  },
  {
    "label": "coordToOffset()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "coordToOffset(const Coord& xyz)"
  },
  {
    "label": "offsetToLocalCoord()",
    "kind": "Method",
    "detail": "Function (Coord)",
    "insertText": "offsetToLocalCoord(Index n)"
  },
  {
    "label": "offsetToGlobalCoord()",
    "kind": "Method",
    "detail": "Function (Coord)",
    "insertText": "offsetToGlobalCoord(Index n)"
  },
  {
    "label": "str()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "str()"
  },
  {
    "label": "hasSameTopology()",
    "kind": "Method",
    "detail": "Function (template<OtherType,Index OtherLog2Dim> bool)",
    "insertText": "hasSameTopology(const LeafNode<OtherType, OtherLog2Dim>* other)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(Buffer& other)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (mBuffer .)",
    "insertText": "swap(other)"
  },
  {
    "label": "buffer()",
    "kind": "Method",
    "detail": "Function (} const Buffer&)",
    "insertText": "buffer()"
  },
  {
    "label": "writeTopology()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeTopology(std::ostream&, bool toHalf = false)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(std::istream&, bool fromHalf = false)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(std::istream& is, const CoordBBox&, bool fromHalf = false)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeBuffers(std::ostream&, bool toHalf = false)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const bool&)",
    "insertText": "getValue(const Coord& xyz)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const bool&)",
    "insertText": "getValue(Index offset)"
  },
  {
    "label": "probeValue()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "probeValue(const Coord& xyz, bool& val)"
  },
  {
    "label": "getValueLevel()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "getValueLevel(const Coord&)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setActiveState(Index offset, bool on)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(offset<SIZE)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(offset, on)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOnly(const Coord& xyz, bool val)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOnly(Index offset, bool val)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (mBuffer .)",
    "insertText": "setValue(offset,val)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOff(const Coord& xyz)"
  },
  {
    "label": "setOff()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOff(this->coordToOffset(xyz))"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOff(Index offset)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(offset < SIZE)"
  },
  {
    "label": "setOff()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOff(offset)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOff(const Coord& xyz, bool val)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOff(Index offset, bool val)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOn(const Coord& xyz)"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOn(this->coordToOffset(xyz))"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOn(Index offset)"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOn(offset)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOn(const Coord& xyz, bool val)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValue(const Coord& xyz, bool val)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueOn(xyz, val)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOn(Index offset, bool val)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (template<ModifyOp> void)",
    "insertText": "modifyValue(Index offset, const ModifyOp& op)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (template<ModifyOp> void)",
    "insertText": "modifyValue(const Coord& xyz, const ModifyOp& op)"
  },
  {
    "label": "modifyValueAndActiveState()",
    "kind": "Method",
    "detail": "Function (template<ModifyOp> void)",
    "insertText": "modifyValueAndActiveState(const Coord& xyz, const ModifyOp& op)"
  },
  {
    "label": "setValuesOn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValuesOn()"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOn()"
  },
  {
    "label": "setValuesOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValuesOff()"
  },
  {
    "label": "setOff()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOff()"
  },
  {
    "label": "isValueOn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueOn(const Coord& xyz)"
  },
  {
    "label": "isValueOn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueOn(Index offset)"
  },
  {
    "label": "hasActiveTiles()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasActiveTiles()"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(const CoordBBox& bbox, bool value, bool active = true)"
  },
  {
    "label": "denseFill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "denseFill(const CoordBBox& bbox, bool val, bool on = true)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "fill(bbox, val, on)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "fill(const bool& value)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(const bool& value, bool active)"
  },
  {
    "label": "copyToDense()",
    "kind": "Method",
    "detail": "Function (template<DenseT> void)",
    "insertText": "copyToDense(const CoordBBox& bbox, DenseT& dense)"
  },
  {
    "label": "copyFromDense()",
    "kind": "Method",
    "detail": "Function (template<DenseT> void)",
    "insertText": "copyFromDense(const CoordBBox& bbox, const DenseT& dense, bool background, bool tolerance)"
  },
  {
    "label": "getValueAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> const bool&)",
    "insertText": "getValueAndCache(const Coord& xyz, AccessorT&)"
  },
  {
    "label": "isValueOnAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> bool)",
    "insertText": "isValueOnAndCache(const Coord& xyz, AccessorT&)"
  },
  {
    "label": "setValueAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> void)",
    "insertText": "setValueAndCache(const Coord& xyz, bool val, AccessorT&)"
  },
  {
    "label": "setValueOnlyAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> void)",
    "insertText": "setValueOnlyAndCache(const Coord& xyz, bool val, AccessorT&)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueOnly(xyz,val)"
  },
  {
    "label": "setValueOffAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> void)",
    "insertText": "setValueOffAndCache(const Coord& xyz, bool value, AccessorT&)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueOff(xyz, value)"
  },
  {
    "label": "modifyValueAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp,AccessorT> void)",
    "insertText": "modifyValueAndCache(const Coord& xyz, const ModifyOp& op, AccessorT&)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "modifyValue(xyz, op)"
  },
  {
    "label": "modifyValueAndActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp,AccessorT> void)",
    "insertText": "modifyValueAndActiveStateAndCache(const Coord& xyz, const ModifyOp& op, AccessorT&)"
  },
  {
    "label": "modifyValueAndActiveState()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "modifyValueAndActiveState(xyz, op)"
  },
  {
    "label": "setActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> void)",
    "insertText": "setActiveStateAndCache(const Coord& xyz, bool on, AccessorT&)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setActiveState(xyz, on)"
  },
  {
    "label": "probeValueAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> bool)",
    "insertText": "probeValueAndCache(const Coord& xyz, bool& val, AccessorT&)"
  },
  {
    "label": "getValueLevelAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> Index)",
    "insertText": "getValueLevelAndCache(const Coord&, AccessorT&)"
  },
  {
    "label": "medianAll()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "medianAll()"
  },
  {
    "label": "medianOn()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "medianOn(ValueType &value)"
  },
  {
    "label": "medianOff()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "medianOff(ValueType &value)"
  },
  {
    "label": "isInactive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isInactive()"
  },
  {
    "label": "resetBackground()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resetBackground(bool oldBackground, bool newBackground)"
  },
  {
    "label": "negate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "negate()"
  },
  {
    "label": "toggle()",
    "kind": "Method",
    "detail": "Function (mBuffer . mData .)",
    "insertText": "toggle()"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (} template<MergePolicy Policy> void)",
    "insertText": "merge(const LeafNode& other, bool bg = false, bool otherBG = false)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (template<MergePolicy Policy> void)",
    "insertText": "merge(bool tileValue, bool tileActive)"
  },
  {
    "label": "voxelizeActiveTiles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "voxelizeActiveTiles(bool = true)"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (} template<OtherType> void)",
    "insertText": "topologyUnion(const LeafNode<OtherType, Log2Dim>& other, const bool preserveTiles = false)"
  },
  {
    "label": "topologyIntersection()",
    "kind": "Method",
    "detail": "Function (template<OtherType> void)",
    "insertText": "topologyIntersection(const LeafNode<OtherType, Log2Dim>& other, const bool&)"
  },
  {
    "label": "topologyDifference()",
    "kind": "Method",
    "detail": "Function (template<OtherType> void)",
    "insertText": "topologyDifference(const LeafNode<OtherType, Log2Dim>& other, const bool&)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (template<CombineOp> void)",
    "insertText": "combine(const LeafNode& other, CombineOp& op)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (template<CombineOp> void)",
    "insertText": "combine(bool, bool valueIsActive, CombineOp& op)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (template<CombineOp,OtherType> void)",
    "insertText": "combine2(const LeafNode& other, const OtherType&, bool valueIsActive, CombineOp&)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (template<CombineOp,OtherNodeT> void)",
    "insertText": "combine2(bool, const OtherNodeT& other, bool valueIsActive, CombineOp&)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (template<CombineOp,OtherNodeT> void)",
    "insertText": "combine2(const LeafNode& b0, const OtherNodeT& b1, CombineOp&)"
  },
  {
    "label": "visitActiveBBox()",
    "kind": "Method",
    "detail": "Function (template<BBoxOp> void)",
    "insertText": "visitActiveBBox(BBoxOp&)"
  },
  {
    "label": "visit()",
    "kind": "Method",
    "detail": "Function (template<VisitorOp> void)",
    "insertText": "visit(VisitorOp&)"
  },
  {
    "label": "visit2Node()",
    "kind": "Method",
    "detail": "Function (template<OtherLeafNodeType,VisitorOp> void)",
    "insertText": "visit2Node(OtherLeafNodeType& other, VisitorOp&)"
  },
  {
    "label": "visit2()",
    "kind": "Method",
    "detail": "Function (template<IterT,VisitorOp> void)",
    "insertText": "visit2(IterT& otherIter, VisitorOp&, bool otherIsLHS = false)"
  },
  {
    "label": "prune()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "prune(const ValueType& = zeroVal<ValueType>())"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addLeaf(LeafNode*)"
  },
  {
    "label": "addLeafAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> void)",
    "insertText": "addLeafAndCache(LeafNode*, AccessorT&)"
  },
  {
    "label": "stealNode()",
    "kind": "Method",
    "detail": "Function (} template<NodeT> NodeT*)",
    "insertText": "stealNode(const Coord&, const ValueType&, bool)"
  },
  {
    "label": "stealNodes()",
    "kind": "Method",
    "detail": "Function (} template<ArrayT> void)",
    "insertText": "stealNodes(ArrayT&, const ValueType&, bool)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addTile(Index level, const Coord&, bool val, bool active)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addTile(Index offset, bool val, bool active)"
  },
  {
    "label": "addTileAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> void)",
    "insertText": "addTileAndCache(Index level, const Coord&, bool val, bool active, AccessorT&)"
  },
  {
    "label": "touchLeaf()",
    "kind": "Method",
    "detail": "Function (LeafNode*)",
    "insertText": "touchLeaf(const Coord&)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN)",
    "insertText": "if(!(std::is_same<NodeT, LeafNode>::value))"
  },
  {
    "label": "probeLeaf()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_END } const LeafNode*)",
    "insertText": "probeLeaf(const Coord&)"
  },
  {
    "label": "ValueIter()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_END } protected : using MaskOnIter = NodeMaskType::OnIterator ; using MaskOffIter = NodeMaskType::OffIterator ; using MaskDenseIter = NodeMaskType::DenseIterator ; template<MaskIterT,NodeT,ValueT> struct ValueIter : public SparseIteratorBase<MaskIterT,ValueIter<MaskIterT,NodeT,ValueT>,NodeT,ValueT> { using BaseT = SparseIteratorBase<MaskIterT,ValueIter,NodeT,ValueT> ;)",
    "insertText": "ValueIter()"
  },
  {
    "label": "ValueIter()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ValueIter(const MaskIterT& iter, NodeT* parent): BaseT(iter, parent)"
  },
  {
    "label": "getItem()",
    "kind": "Method",
    "detail": "Function (} const bool&)",
    "insertText": "getItem(Index pos)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (} const bool&)",
    "insertText": "getValue()"
  },
  {
    "label": "setItem()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setItem(Index pos, bool value)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "parent().setValueOnly(pos, value)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValue(bool value)"
  },
  {
    "label": "setItem()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setItem(this->pos(), value)"
  },
  {
    "label": "modifyItem()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp> void)",
    "insertText": "modifyItem(Index n, const ModifyOp& op)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "parent().modifyValue(n, op)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp> void)",
    "insertText": "modifyValue(const ModifyOp& op)"
  },
  {
    "label": "modifyItem()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "modifyItem(this->pos(), op)"
  },
  {
    "label": "ChildIter()",
    "kind": "Method",
    "detail": "Function (} } ; template<MaskIterT,NodeT> struct ChildIter : public SparseIteratorBase<MaskIterT,ChildIter<MaskIterT,NodeT>,NodeT,bool> {)",
    "insertText": "ChildIter()"
  },
  {
    "label": "ChildIter()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ChildIter(const MaskIterT& iter, NodeT* parent): SparseIteratorBase< MaskIterT, ChildIter<MaskIterT, NodeT>, NodeT, bool>(iter, parent)"
  },
  {
    "label": "DenseIter()",
    "kind": "Method",
    "detail": "Function (} } ; template<NodeT,ValueT> struct DenseIter : public DenseIteratorBase<MaskDenseIter,DenseIter<NodeT,ValueT>,NodeT,void,ValueT> { using BaseT = DenseIteratorBase<MaskDenseIter,DenseIter,NodeT,void,ValueT> ; using NonConstValueT = BaseT::NonConstValueType ;)",
    "insertText": "DenseIter()"
  },
  {
    "label": "DenseIter()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "DenseIter(const MaskDenseIter& iter, NodeT* parent): BaseT(iter, parent)"
  },
  {
    "label": "getItem()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "getItem(Index pos, void*& child, NonConstValueT& value)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (value = this ->)",
    "insertText": "parent().getValue(pos)"
  },
  {
    "label": "unsetItem()",
    "kind": "Method",
    "detail": "Function (child = nullptr ; return false ; } void)",
    "insertText": "unsetItem(Index pos, const ValueT& val)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "parent().setValueOnly(pos, val)"
  },
  {
    "label": "cbeginValueOn()",
    "kind": "Method",
    "detail": "Function (} } ; public : using ValueOnIter = ValueIter<MaskOnIter,LeafNode,const bool> ; using ValueOnCIter = ValueIter<MaskOnIter,const LeafNode,const bool> ; using ValueOffIter = ValueIter<MaskOffIter,LeafNode,const bool> ; using ValueOffCIter = ValueIter<MaskOffIter,const LeafNode,const bool> ; using ValueAllIter = ValueIter<MaskDenseIter,LeafNode,const bool> ; using ValueAllCIter = ValueIter<MaskDenseIter,const LeafNode,const bool> ; using ChildOnIter = ChildIter<MaskOnIter,LeafNode> ; using ChildOnCIter = ChildIter<MaskOnIter,const LeafNode> ; using ChildOffIter = ChildIter<MaskOffIter,LeafNode> ; using ChildOffCIter = ChildIter<MaskOffIter,const LeafNode> ; using ChildAllIter = DenseIter<LeafNode,bool> ; using ChildAllCIter = DenseIter<const LeafNode,const bool> ; ValueOnCIter)",
    "insertText": "cbeginValueOn()"
  },
  {
    "label": "beginValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnCIter)",
    "insertText": "beginValueOn()"
  },
  {
    "label": "cbeginValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "cbeginValueOff()"
  },
  {
    "label": "beginValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "beginValueOff()"
  },
  {
    "label": "cbeginValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "cbeginValueAll()"
  },
  {
    "label": "beginValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "beginValueAll()"
  },
  {
    "label": "cendValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnCIter)",
    "insertText": "cendValueOn()"
  },
  {
    "label": "endValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnCIter)",
    "insertText": "endValueOn()"
  },
  {
    "label": "cendValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "cendValueOff()"
  },
  {
    "label": "endValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "endValueOff()"
  },
  {
    "label": "cendValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "cendValueAll()"
  },
  {
    "label": "endValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "endValueAll()"
  },
  {
    "label": "cbeginChildOn()",
    "kind": "Method",
    "detail": "Function (} ChildOnCIter)",
    "insertText": "cbeginChildOn()"
  },
  {
    "label": "beginChildOn()",
    "kind": "Method",
    "detail": "Function (} ChildOnCIter)",
    "insertText": "beginChildOn()"
  },
  {
    "label": "cbeginChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "cbeginChildOff()"
  },
  {
    "label": "beginChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "beginChildOff()"
  },
  {
    "label": "cbeginChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "cbeginChildAll()"
  },
  {
    "label": "beginChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "beginChildAll()"
  },
  {
    "label": "cendChildOn()",
    "kind": "Method",
    "detail": "Function (} ChildOnCIter)",
    "insertText": "cendChildOn()"
  },
  {
    "label": "endChildOn()",
    "kind": "Method",
    "detail": "Function (} ChildOnCIter)",
    "insertText": "endChildOn()"
  },
  {
    "label": "cendChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "cendChildOff()"
  },
  {
    "label": "endChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "endChildOff()"
  },
  {
    "label": "cendChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "cendChildAll()"
  },
  {
    "label": "endChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "endChildAll()"
  },
  {
    "label": "isValueMaskOn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueMaskOn(Index n)"
  },
  {
    "label": "isValueMaskOn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueMaskOn()"
  },
  {
    "label": "isValueMaskOff()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueMaskOff(Index n)"
  },
  {
    "label": "isValueMaskOff()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueMaskOff()"
  },
  {
    "label": "getValueMask()",
    "kind": "Method",
    "detail": "Function (} const NodeMaskType&)",
    "insertText": "getValueMask()"
  },
  {
    "label": "isChildMaskOn()",
    "kind": "Method",
    "detail": "Function (mValueMask = mask ; } bool)",
    "insertText": "isChildMaskOn(Index)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(n, on)"
  },
  {
    "label": "setValueMaskOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueMaskOn(Index n)"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOn(n)"
  },
  {
    "label": "setValueMaskOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueMaskOff(Index n)"
  },
  {
    "label": "setOff()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOff(n)"
  },
  {
    "label": "evalNodeOrigin()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "evalNodeOrigin(Coord& xyz)"
  },
  {
    "label": "xyz()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "xyz(DIM - 1)"
  },
  {
    "label": "doVisit()",
    "kind": "Method",
    "detail": "Function (} template<NodeT,VisitorOp,ChildAllIterT> void)",
    "insertText": "doVisit(NodeT&, VisitorOp&)"
  },
  {
    "label": "doVisit2Node()",
    "kind": "Method",
    "detail": "Function (template<NodeT,OtherNodeT,VisitorOp,ChildAllIterT,OtherChildAllIterT> void)",
    "insertText": "doVisit2Node(NodeT& self, OtherNodeT& other, VisitorOp&)"
  },
  {
    "label": "doVisit2()",
    "kind": "Method",
    "detail": "Function (template<NodeT,VisitorOp,ChildAllIterT,OtherChildAllIterT> void)",
    "insertText": "doVisit2(NodeT& self, OtherChildAllIterT&, VisitorOp&, bool otherIsLHS)"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (NodeMaskType mValueMask ; Buffer mBuffer ; Coord mOrigin ; private : template<,Index> class LeafNode ; struct ValueIter<MaskOnIter,LeafNode,bool> ; struct ValueIter<MaskOffIter,LeafNode,bool> ; struct ValueIter<MaskDenseIter,LeafNode,bool> ; struct ValueIter<MaskOnIter,const LeafNode,bool> ; struct ValueIter<MaskOffIter,const LeafNode,bool> ; struct ValueIter<MaskDenseIter,const LeafNode,bool> ; class IteratorBase<MaskOnIter,LeafNode> ; class IteratorBase<MaskOffIter,LeafNode> ; class IteratorBase<MaskDenseIter,LeafNode> ; } ; template<Index Log2Dim> LeafNode<bool,Log2Dim)",
    "insertText": "LeafNode() : mOrigin(0, 0, 0)"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> LeafNode<bool,Log2Dim)",
    "insertText": "LeafNode(const Coord& xyz, bool value, bool active) : mValueMask(active) , mBuffer(value) , mOrigin(xyz & (~(DIM - 1)))"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> LeafNode<bool,Log2Dim)",
    "insertText": "LeafNode(PartialCreate, const Coord& xyz, bool value, bool active) : mValueMask(active) , mBuffer(value) , mOrigin(xyz & (~(DIM - 1)))"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> LeafNode<bool,Log2Dim)",
    "insertText": "LeafNode(const LeafNode &other) : mValueMask(other.valueMask()) , mBuffer(other.mBuffer) , mOrigin(other.mOrigin)"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> template<ValueT> LeafNode<bool,Log2Dim)",
    "insertText": "LeafNode(const LeafNode<ValueT, Log2Dim>& other) : mValueMask(other.valueMask()) , mOrigin(other.origin())"
  },
  {
    "label": "convertValue()",
    "kind": "Method",
    "detail": "Function (struct Local { bool)",
    "insertText": "convertValue(const ValueT& val)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "for(Index i = 0; i < SIZE; ++i)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (mBuffer .)",
    "insertText": "setValue(i, Local::convertValue(other.mBuffer[i]))"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (} } template<Index Log2Dim> template<ValueT> LeafNode<bool,Log2Dim)",
    "insertText": "LeafNode(const LeafNode<ValueT, Log2Dim>& other, bool background, TopologyCopy) : mValueMask(other.valueMask()) , mBuffer(background) , mOrigin(other.origin())"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> template<ValueT> LeafNode<bool,Log2Dim)",
    "insertText": "LeafNode(const LeafNode<ValueT, Log2Dim>& other, TopologyCopy) : mValueMask(other.valueMask()) , mBuffer(other.valueMask()) , mOrigin(other.origin())"
  },
  {
    "label": "LeafNode()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> template<ValueT> LeafNode<bool,Log2Dim)",
    "insertText": "LeafNode(const LeafNode<ValueT, Log2Dim>& other, bool offValue, bool onValue, TopologyCopy) : mValueMask(other.valueMask()) , mBuffer(other.valueMask()) , mOrigin(other.origin())"
  },
  {
    "label": "memUsage()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> Index64 LeafNode<bool,Log2Dim)",
    "insertText": "memUsage()"
  },
  {
    "label": "evalActiveBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> void LeafNode<bool,Log2Dim)",
    "insertText": "evalActiveBoundingBox(CoordBBox& bbox, bool visitVoxels)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (this_bbox .)",
    "insertText": "reset()"
  },
  {
    "label": "translate()",
    "kind": "Method",
    "detail": "Function (this_bbox .)",
    "insertText": "translate(this->origin())"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (} bbox .)",
    "insertText": "expand(this_bbox)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(other)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::ostringstream ostr ; ostr<<\" LeafNode @ \"<<mOrigin<<\" : \" ;)",
    "insertText": "for(Index32 n = 0; n < SIZE; ++n) ostr << (mValueMask.isOn(n) ? '#' : '.')"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((xyz[0] & (DIM-1u)) < DIM && (xyz[1] & (DIM-1u)) < DIM && (xyz[2] & (DIM-1u)) < DIM)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(n < (1 << 3*Log2Dim))"
  },
  {
    "label": "setX()",
    "kind": "Method",
    "detail": "Function (Coord xyz ; xyz .)",
    "insertText": "setX(n >> 2*Log2Dim)"
  },
  {
    "label": "n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "n((1 << 2*Log2Dim) - 1)"
  },
  {
    "label": "setY()",
    "kind": "Method",
    "detail": "Function (xyz .)",
    "insertText": "setY(n >> Log2Dim)"
  },
  {
    "label": "setZ()",
    "kind": "Method",
    "detail": "Function (xyz .)",
    "insertText": "setZ(n & ((1 << Log2Dim) - 1))"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> void LeafNode<bool,Log2Dim)",
    "insertText": "readTopology(std::istream& is, bool)"
  },
  {
    "label": "load()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "load(is)"
  },
  {
    "label": "writeTopology()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> void LeafNode<bool,Log2Dim)",
    "insertText": "writeTopology(std::ostream& os, bool)"
  },
  {
    "label": "save()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "save(os)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> void LeafNode<bool,Log2Dim)",
    "insertText": "readBuffers(std::istream& is, const CoordBBox& clipBBox, bool fromHalf)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "readBuffers(is, fromHalf)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool background = false ;)",
    "insertText": "if(const void* bgPtr = io::getGridBackgroundValuePtr(is))"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (background =* static_cast<const)",
    "insertText": "bool(bgPtr)"
  },
  {
    "label": "clip()",
    "kind": "Method",
    "detail": "Function (} this ->)",
    "insertText": "clip(clipBBox, background)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> void LeafNode<bool,Log2Dim)",
    "insertText": "readBuffers(std::istream& is, bool)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(&mOrigin), sizeof(Coord::ValueType) * 3)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (} else { int8_t numBuffers = 0 ; is .)",
    "insertText": "read(reinterpret_cast<char*>(&numBuffers), sizeof(int8_t))"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<bool [ ]> buf { new bool [ SIZE ] } ; io::readData<)",
    "insertText": "bool(is, buf.get(), SIZE, true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(numBuffers > 1)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (} } } } template<Index Log2Dim> void LeafNode<bool,Log2Dim)",
    "insertText": "writeBuffers(std::ostream& os, bool)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&mOrigin), sizeof(Coord::ValueType) * 3)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> bool LeafNode<bool,Log2Dim)",
    "insertText": "operator(const LeafNode& other)"
  },
  {
    "label": "isConstant()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> bool LeafNode<bool,Log2Dim)",
    "insertText": "isConstant(bool& constValue, bool& state, bool tolerance)"
  },
  {
    "label": "isOn()",
    "kind": "Method",
    "detail": "Function (constValue = mBuffer . mData .)",
    "insertText": "isOn()"
  },
  {
    "label": "countOn()",
    "kind": "Method",
    "detail": "Function (const Index countTrue = mBuffer . mData .)",
    "insertText": "countOn()"
  },
  {
    "label": "medianOn()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> Index LeafNode<bool,Log2Dim)",
    "insertText": "medianOn(bool& state)"
  },
  {
    "label": "countOn()",
    "kind": "Method",
    "detail": "Function (const NodeMaskType tmp = mBuffer . mData& mValueMask ; const Index countTrueOn = tmp .)",
    "insertText": "countOn(), countOn = mValueMask.countOn()"
  },
  {
    "label": "countTrueOn()",
    "kind": "Method",
    "detail": "Function (state =)",
    "insertText": "countTrueOn(NUM_VALUES >> 1)"
  },
  {
    "label": "mData()",
    "kind": "Method",
    "detail": "Function (const NodeMaskType tmp = mBuffer .)",
    "insertText": "mData(!mValueMask)"
  },
  {
    "label": "countOn()",
    "kind": "Method",
    "detail": "Function (const Index countTrueOff = tmp .)",
    "insertText": "countOn(), countOff = mValueMask.countOff()"
  },
  {
    "label": "countTrueOff()",
    "kind": "Method",
    "detail": "Function (state =)",
    "insertText": "countTrueOff(NUM_VALUES >> 1)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "addTile(this->coordToOffset(xyz), val, active)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueOnly(offset, val)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setActiveState(offset, active)"
  },
  {
    "label": "addTileAndCache()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> template<AccessorT> void LeafNode<bool,Log2Dim)",
    "insertText": "addTileAndCache(Index level, const Coord& xyz, bool val, bool active, AccessorT&)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "addTile(level, xyz, val, active)"
  },
  {
    "label": "coordToOffset()",
    "kind": "Method",
    "detail": "Function (const Index offset = this ->)",
    "insertText": "coordToOffset(xyz)"
  },
  {
    "label": "isOn()",
    "kind": "Method",
    "detail": "Function (val = mBuffer . mData .)",
    "insertText": "isOn(offset)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueOn(this->coordToOffset(xyz), val)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mBuffer . mData .)",
    "insertText": "set(offset, val)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueOnly(this->coordToOffset(xyz), val)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> void LeafNode<bool,Log2Dim)",
    "insertText": "setActiveState(const Coord& xyz, bool on)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(this->coordToOffset(xyz), on)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueOff(this->coordToOffset(xyz), val)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(val)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "modifyValue(this->coordToOffset(xyz), op)"
  },
  {
    "label": "isOn()",
    "kind": "Method",
    "detail": "Function (bool val = mBuffer . mData .)",
    "insertText": "isOn(offset), state = mValueMask.isOn(offset)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(val, state)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(offset, state)"
  },
  {
    "label": "bgMask()",
    "kind": "Method",
    "detail": "Function (NodeMaskType)",
    "insertText": "bgMask(mBuffer.mData | mValueMask)"
  },
  {
    "label": "mData()",
    "kind": "Method",
    "detail": "Function (mBuffer .)",
    "insertText": "mData(mBuffer.mData & mValueMask)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (} } template<Index Log2Dim> template<MergePolicy Policy> void LeafNode<bool,Log2Dim)",
    "insertText": "merge(const LeafNode& other, bool , bool)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN)",
    "insertText": "if(Policy == MERGE_NODES)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (const Index n = iter .)",
    "insertText": "pos()"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mBuffer . mData .)",
    "insertText": "set(n, other.mBuffer.mData.isOn(n))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN)",
    "insertText": "if(Policy != MERGE_ACTIVE_STATES_AND_NODES)"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_END } template<Index Log2Dim> template<OtherType> void LeafNode<bool,Log2Dim)",
    "insertText": "topologyUnion(const LeafNode<OtherType, Log2Dim>& other, bool)"
  },
  {
    "label": "valueMask()",
    "kind": "Method",
    "detail": "Function (mValueMask | = other .)",
    "insertText": "valueMask()"
  },
  {
    "label": "clip()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> void LeafNode<bool,Log2Dim)",
    "insertText": "clip(const CoordBBox& clipBBox, bool background)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "fill(nodeBBox, background, false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(clipBBox.isInside(nodeBBox))"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (Coord xyz ; int& x = xyz .)",
    "insertText": "x(), &y = xyz.y(), &z = xyz.z()"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (mask .)",
    "insertText": "setOn(static_cast<Index32>(this->coordToOffset(xyz)))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "for(MaskOffIter maskIter = mask.beginOff(); maskIter; ++maskIter)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueOff(maskIter.pos(), background)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (} } template<Index Log2Dim> void LeafNode<bool,Log2Dim)",
    "insertText": "fill(const CoordBBox& bbox, bool value, bool active)"
  },
  {
    "label": "intersect()",
    "kind": "Method",
    "detail": "Function (clippedBBox .)",
    "insertText": "intersect(bbox)"
  },
  {
    "label": "offsetX()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "offsetX(x & (DIM-1u))"
  },
  {
    "label": "offsetX()",
    "kind": "Method",
    "detail": "Function (const Index offsetXY =)",
    "insertText": "offsetX((y & (DIM-1u))<< Log2Dim)"
  },
  {
    "label": "offsetXY()",
    "kind": "Method",
    "detail": "Function (const Index offset =)",
    "insertText": "offsetXY(z & (DIM-1u))"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(offset, active)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mBuffer . mData .)",
    "insertText": "set(offset, value)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (mBuffer .)",
    "insertText": "fill(value)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(active)"
  },
  {
    "label": "xStride()",
    "kind": "Method",
    "detail": "Function (using DenseValueType = DenseT::ValueType ; const size_t xStride = dense .)",
    "insertText": "xStride(), yStride = dense.yStride(), zStride = dense.zStride()"
  },
  {
    "label": "bbox()",
    "kind": "Method",
    "detail": "Function (const Coord& min = dense .)",
    "insertText": "bbox().min()"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (DenseValueType* t0 = dense .)",
    "insertText": "data() + zStride * (bbox.min()[2] - min[2])"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (const Int32 n0 = bbox .)",
    "insertText": "min()[2] & (DIM-1u)"
  },
  {
    "label": "xStride()",
    "kind": "Method",
    "detail": "Function (DenseValueType* t1 = t0 +)",
    "insertText": "xStride(x - min[0])"
  },
  {
    "label": "n0()",
    "kind": "Method",
    "detail": "Function (const Int32 n1 =)",
    "insertText": "n0((x & (DIM-1u)) << 2*LOG2DIM)"
  },
  {
    "label": "yStride()",
    "kind": "Method",
    "detail": "Function (DenseValueType* t2 = t1 +)",
    "insertText": "yStride(y - min[1])"
  },
  {
    "label": "n1()",
    "kind": "Method",
    "detail": "Function (Int32 n2 =)",
    "insertText": "n1((y & (DIM-1u)) << LOG2DIM)"
  },
  {
    "label": "DenseValueType()",
    "kind": "Method",
    "detail": "Function (* t2 =)",
    "insertText": "DenseValueType(mBuffer.mData.isOn(n2++))"
  },
  {
    "label": "toBool()",
    "kind": "Method",
    "detail": "Function (using DenseValueType = DenseT::ValueType ; struct Local { bool)",
    "insertText": "toBool(const DenseValueType& v)"
  },
  {
    "label": "setOff()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOff(n2)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mBuffer . mData .)",
    "insertText": "set(n2, background)"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (} else { mValueMask .)",
    "insertText": "setOn(n2)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mBuffer . mData .)",
    "insertText": "set(n2, Local::toBool(*s2))"
  },
  {
    "label": "isOn()",
    "kind": "Method",
    "detail": "Function (bool result = false,aVal = mBuffer . mData .)",
    "insertText": "isOn(i), bVal = other.mBuffer.mData.isOn(i)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(args.setARef(aVal) .setAIsActive(mValueMask.isOn(i)) .setBRef(bVal) .setBIsActive(other.valueMask().isOn(i)) .setResultRef(result))"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(i, args.resultIsActive())"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mBuffer . mData .)",
    "insertText": "set(i, result)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (} } template<Index Log2Dim> template<CombineOp> void LeafNode<bool,Log2Dim)",
    "insertText": "combine(bool value, bool valueIsActive, CombineOp& op)"
  },
  {
    "label": "setBRef()",
    "kind": "Method",
    "detail": "Function (CombineArgs<bool> args ; args .)",
    "insertText": "setBRef(value).setBIsActive(valueIsActive)"
  },
  {
    "label": "isOn()",
    "kind": "Method",
    "detail": "Function (bool result = false,aVal = mBuffer . mData .)",
    "insertText": "isOn(i)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(args.setARef(aVal) .setAIsActive(mValueMask.isOn(i)) .setResultRef(result))"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (} } template<Index Log2Dim> template<CombineOp,OtherType> void LeafNode<bool,Log2Dim)",
    "insertText": "combine2(const LeafNode& other, const OtherType& value, bool valueIsActive, CombineOp& op)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(args.setARef(aVal) .setAIsActive(other.valueMask().isOn(i)) .setResultRef(result))"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (} } template<Index Log2Dim> template<CombineOp,OtherNodeT> void LeafNode<bool,Log2Dim)",
    "insertText": "combine2(bool value, const OtherNodeT& other, bool valueIsActive, CombineOp& op)"
  },
  {
    "label": "setARef()",
    "kind": "Method",
    "detail": "Function (CombineArgs<bool,OtherNodeT::ValueType> args ; args .)",
    "insertText": "setARef(value).setAIsActive(valueIsActive)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(args.setBRef(bVal) .setBIsActive(other.valueMask().isOn(i)) .setResultRef(result))"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (} } template<Index Log2Dim> template<CombineOp,OtherNodeT> void LeafNode<bool,Log2Dim)",
    "insertText": "combine2(const LeafNode& b0, const OtherNodeT& b1, CombineOp& op)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(i, b0.valueMask().isOn(i) || b1.valueMask().isOn(i))"
  },
  {
    "label": "isOn()",
    "kind": "Method",
    "detail": "Function (bool result = false,b0Val = b0 . mBuffer . mData .)",
    "insertText": "isOn(i), b1Val = b1.mBuffer.mData.isOn(i)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(args.setARef(b0Val) .setAIsActive(b0.valueMask().isOn(i)) .setBRef(b1Val) .setBIsActive(b1.valueMask().isOn(i)) .setResultRef(result))"
  },
  {
    "label": "visitActiveBBox()",
    "kind": "Method",
    "detail": "Function (} } template<Index Log2Dim> template<BBoxOp> void LeafNode<bool,Log2Dim)",
    "insertText": "visitActiveBBox(BBoxOp& op)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (op . template)",
    "insertText": "operator()<LEVEL>(CoordBBox::createCube(i.getCoord(), 1))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } else { op . template)",
    "insertText": "operator()<LEVEL>(this->getNodeBoundingBox())"
  },
  {
    "label": "visit()",
    "kind": "Method",
    "detail": "Function (} } template<Index Log2Dim> template<VisitorOp> void LeafNode<bool,Log2Dim)",
    "insertText": "visit(VisitorOp& op)"
  },
  {
    "label": "doVisit()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> template<NodeT,VisitorOp,ChildAllIterT> void LeafNode<bool,Log2Dim)",
    "insertText": "doVisit(NodeT& self, VisitorOp& op)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(iter)"
  },
  {
    "label": "visit2Node()",
    "kind": "Method",
    "detail": "Function (} } template<Index Log2Dim> template<OtherLeafNodeType,VisitorOp> void LeafNode<bool,Log2Dim)",
    "insertText": "visit2Node(OtherLeafNodeType& other, VisitorOp& op)"
  },
  {
    "label": "doVisit2Node()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> template<NodeT,OtherNodeT,VisitorOp,ChildAllIterT,OtherChildAllIterT> void LeafNode<bool,Log2Dim)",
    "insertText": "doVisit2Node(NodeT& self, OtherNodeT& other, VisitorOp& op)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(iter, otherIter)"
  },
  {
    "label": "visit2()",
    "kind": "Method",
    "detail": "Function (} } template<Index Log2Dim> template<IterT,VisitorOp> void LeafNode<bool,Log2Dim)",
    "insertText": "visit2(IterT& otherIter, VisitorOp& op, bool otherIsLHS)"
  },
  {
    "label": "doVisit2()",
    "kind": "Method",
    "detail": "Function (} template<Index Log2Dim> template<NodeT,VisitorOp,ChildAllIterT,OtherChildAllIterT> void LeafNode<bool,Log2Dim)",
    "insertText": "doVisit2(NodeT& self, OtherChildAllIterT& otherIter, VisitorOp& op, bool otherIsLHS)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(otherIter, iter)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "for(ChildAllIterT iter = self.beginChildAll(); iter; ++iter)"
  }
]