[
  {
    "label": "MetisOrdering",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MetisOrdering"
  },
  {
    "label": "get_symmetrized_graph()",
    "kind": "Method",
    "detail": "Function (# ifndef METIS_SUPPORT_H # define METIS_SUPPORT_H namespace Eigen { template<StorageIndex> class MetisOrdering { public : typedef PermutationMatrix<Dynamic,Dynamic,StorageIndex> PermutationType ; typedef Matrix<StorageIndex,Dynamic,1> IndexVector ; template<MatrixType> void)",
    "insertText": "get_symmetrized_graph(const MatrixType& A)"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (Index m = A .)",
    "insertText": "cols()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert((A.rows() == A.cols()) && \"ONLY FOR SQUARED MATRICES\")"
  },
  {
    "label": "transpose()",
    "kind": "Method",
    "detail": "Function (MatrixType At = A .)",
    "insertText": "transpose()"
  },
  {
    "label": "visited()",
    "kind": "Method",
    "detail": "Function (Index TotNz = 0 ; IndexVector)",
    "insertText": "visited(m)"
  },
  {
    "label": "setConstant()",
    "kind": "Method",
    "detail": "Function (visited .)",
    "insertText": "setConstant(-1)"
  },
  {
    "label": "visited()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "visited(j)"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (Index idx = it .)",
    "insertText": "index()"
  },
  {
    "label": "visited()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "visited(idx)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (+ + TotNz ; } })",
    "insertText": "for(typename MatrixType::InnerIterator it(At, j); it; ++it)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (+ + TotNz ; } } } m_indexPtr .)",
    "insertText": "resize(m+1)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_innerIndices .)",
    "insertText": "resize(TotNz)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (StorageIndex CurNz = 0 ;)",
    "insertText": "for(StorageIndex j = 0; j < m; j++)"
  },
  {
    "label": "m_indexPtr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_indexPtr(j)"
  },
  {
    "label": "m_innerIndices()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_innerIndices(CurNz)"
  },
  {
    "label": "m_indexPtr()",
    "kind": "Method",
    "detail": "Function (+ + CurNz ; } } })",
    "insertText": "m_indexPtr(m)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<MatrixType> void)",
    "insertText": "operator() (const MatrixType& A, PermutationType& matperm)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (StorageIndex m = internal::convert_index<)",
    "insertText": "StorageIndex(A.cols())"
  },
  {
    "label": "perm()",
    "kind": "Method",
    "detail": "Function (IndexVector)",
    "insertText": "perm(m),iperm(m)"
  },
  {
    "label": "get_symmetrized_graph()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "get_symmetrized_graph(A)"
  },
  {
    "label": "METIS_NodeND()",
    "kind": "Method",
    "detail": "Function (int output_error ; output_error =)",
    "insertText": "METIS_NodeND(&m, m_indexPtr.data(), m_innerIndices.data(), NULL, NULL, perm.data(), iperm.data())"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (std::cerr<<\" ERROR WHILE CALLING THE METIS PACKAGE \\ n \" ; return ; } matperm .)",
    "insertText": "resize(m)"
  }
]