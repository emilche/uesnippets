[
  {
    "label": "opencl_factory",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "opencl_factory"
  },
  {
    "label": "default_opencl_factory",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "default_opencl_factory"
  },
  {
    "label": "opencl_program",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "opencl_program"
  },
  {
    "label": "opencl_device",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "opencl_device"
  },
  {
    "label": "opencl_memory",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "opencl_memory"
  },
  {
    "label": "opencl_buffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "opencl_buffer"
  },
  {
    "label": "opencl_device_list",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "opencl_device_list"
  },
  {
    "label": "callback_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "callback_base"
  },
  {
    "label": "callback",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "callback"
  },
  {
    "label": "opencl_async_msg",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "opencl_async_msg"
  },
  {
    "label": "opencl_buffer_impl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "opencl_buffer_impl"
  },
  {
    "label": "access_type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "access_type"
  },
  {
    "label": "opencl_subbuffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "opencl_subbuffer"
  },
  {
    "label": "is_",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_"
  },
  {
    "label": "opencl_range",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "opencl_range"
  },
  {
    "label": "kernel",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "kernel"
  },
  {
    "label": "finalize_fn",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "finalize_fn"
  },
  {
    "label": "finalize_fn_leaf",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "finalize_fn_leaf"
  },
  {
    "label": "default_device_selector",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "default_device_selector"
  },
  {
    "label": "default_device_filter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "default_device_filter"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "file_reader",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "file_reader"
  },
  {
    "label": "opencl_program_builder",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "opencl_program_builder"
  },
  {
    "label": "opencl_device_filter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "opencl_device_filter"
  },
  {
    "label": "opencl_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "opencl_node"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_flow_graph_opencl_node_H # define __TBB_flow_graph_opencl_node_H # include \" tbb / tbb_config . h \" # if __TBB_PREVIEW_OPENCL_NODE # include \" flow_graph . h \" # include<vector> # include<string> # include<algorithm> # include<iostream> # include<fstream> # include<map> # include<mutex> # ifdef __APPLE__ # include<OpenCL / opencl . h> # else # include<CL / cl . h> # endif namespace tbb { namespace flow { namespace interface10 { template<DeviceFilter> class opencl_factory ; namespace opencl_info { class default_opencl_factory ; } template<Factory> class opencl_program ; void)",
    "insertText": "enforce_cl_retcode(cl_int err, std::string msg)"
  },
  {
    "label": "event_info()",
    "kind": "Method",
    "detail": "Function (std::cerr<<msg<<\" ; error code : \"<<err<<std::endl ; throw msg ; } } template<T> T)",
    "insertText": "event_info(cl_event e, cl_event_info i)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (T res ;)",
    "insertText": "enforce_cl_retcode(clGetEventInfo(e, i, sizeof(res), &res, NULL), \"Failed to get OpenCL event information\")"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (T res ;)",
    "insertText": "enforce_cl_retcode(clGetDeviceInfo(d, i, sizeof(res), &res, NULL), \"Failed to get OpenCL device information\")"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (size_t required ;)",
    "insertText": "enforce_cl_retcode(clGetDeviceInfo(d, i, 0, NULL, &required), \"Failed to get OpenCL device information\")"
  },
  {
    "label": "buff()",
    "kind": "Method",
    "detail": "Function (char*)",
    "insertText": "buff(char*)alloca(required)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clGetDeviceInfo(d, i, required, buff, NULL), \"Failed to get OpenCL device information\")"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (T res ;)",
    "insertText": "enforce_cl_retcode(clGetPlatformInfo(p, i, sizeof(res), &res, NULL), \"Failed to get OpenCL platform information\")"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (size_t required ;)",
    "insertText": "enforce_cl_retcode(clGetPlatformInfo(p, i, 0, NULL, &required), \"Failed to get OpenCL platform information\")"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clGetPlatformInfo(p, i, required, buff, NULL), \"Failed to get OpenCL platform information\")"
  },
  {
    "label": "opencl_device()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "opencl_device() : my_device_id( unknown ), my_cl_device_id( NULL ), my_cl_command_queue( NULL)"
  },
  {
    "label": "opencl_device()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_device(cl_device_id d_id ) : my_device_id( unknown ), my_cl_device_id( d_id ), my_cl_command_queue( NULL)"
  },
  {
    "label": "opencl_device()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_device(cl_device_id cl_d_id, device_id_type device_id ) : my_device_id( device_id ), my_cl_device_id( cl_d_id ), my_cl_command_queue( NULL)"
  },
  {
    "label": "platform_profile()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "platform_profile()"
  },
  {
    "label": "platform_version()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "platform_version()"
  },
  {
    "label": "platform_name()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "platform_name()"
  },
  {
    "label": "platform_vendor()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "platform_vendor()"
  },
  {
    "label": "platform_extensions()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "platform_extensions()"
  },
  {
    "label": "info()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "info(cl_device_info i, T &t)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (t = device_info<)",
    "insertText": "T(my_cl_device_id, i)"
  },
  {
    "label": "version()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "version()"
  },
  {
    "label": "major_version()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "major_version()"
  },
  {
    "label": "sscanf()",
    "kind": "Method",
    "detail": "Function (int major ;)",
    "insertText": "sscanf(version().c_str(), \"OpenCL %d\", &major)"
  },
  {
    "label": "sscanf()",
    "kind": "Method",
    "detail": "Function (int major,minor ;)",
    "insertText": "sscanf(version().c_str(), \"OpenCL %d.%d\", &major, &minor)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if CL_VERSION_2_0)",
    "insertText": "if(major_version() >= 2 ) return (device_info<cl_command_queue_properties>( my_cl_device_id, CL_DEVICE_QUEUE_ON_HOST_PROPERTIES ) & CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE)"
  },
  {
    "label": "out_of_order_exec_mode_on_device_present()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "out_of_order_exec_mode_on_device_present()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if CL_VERSION_2_0)",
    "insertText": "if(major_version() >= 2 ) return (device_info<cl_command_queue_properties>( my_cl_device_id, CL_DEVICE_QUEUE_ON_DEVICE_PROPERTIES ) & CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE)"
  },
  {
    "label": "max_work_group_size()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "max_work_group_size()"
  },
  {
    "label": "built_in_kernel_available()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "built_in_kernel_available(const std::string& k)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (const std::string semi = \" ; \" ;)",
    "insertText": "return(semi + built_in_kernels() + semi).find( semi + k + semi)"
  },
  {
    "label": "built_in_kernels()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "built_in_kernels()"
  },
  {
    "label": "name()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "name()"
  },
  {
    "label": "available()",
    "kind": "Method",
    "detail": "Function (} cl_bool)",
    "insertText": "available()"
  },
  {
    "label": "compiler_available()",
    "kind": "Method",
    "detail": "Function (} cl_bool)",
    "insertText": "compiler_available()"
  },
  {
    "label": "linker_available()",
    "kind": "Method",
    "detail": "Function (} cl_bool)",
    "insertText": "linker_available()"
  },
  {
    "label": "extension_available()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "extension_available(const std::string &ext)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (const std::string space = \" \" ;)",
    "insertText": "return(space + extensions() + space).find( space + ext + space)"
  },
  {
    "label": "extensions()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "extensions()"
  },
  {
    "label": "type()",
    "kind": "Method",
    "detail": "Function (} cl_device_type)",
    "insertText": "type()"
  },
  {
    "label": "vendor()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "vendor()"
  },
  {
    "label": "address_bits()",
    "kind": "Method",
    "detail": "Function (} cl_uint)",
    "insertText": "address_bits()"
  },
  {
    "label": "device_id()",
    "kind": "Method",
    "detail": "Function (} cl_device_id)",
    "insertText": "device_id()"
  },
  {
    "label": "platform_id()",
    "kind": "Method",
    "detail": "Function (my_cl_command_queue = cmd_queue ; } cl_platform_id)",
    "insertText": "platform_id()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} private : device_id_type my_device_id ; cl_device_id my_cl_device_id ; cl_command_queue my_cl_command_queue ; bool)",
    "insertText": "operator(opencl_device d1, opencl_device d2)"
  },
  {
    "label": "opencl_device_list()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_device_list(std::initializer_list<opencl_device> il ) : my_container( il)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "add(opencl_device d)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (my_container .)",
    "insertText": "push_back(d)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "size()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "cbegin()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "cbegin()"
  },
  {
    "label": "cend()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "cend()"
  },
  {
    "label": "find_available_devices()",
    "kind": "Method",
    "detail": "Function (} private : container_type my_container ; } ; namespace internal { opencl_device_list)",
    "insertText": "find_available_devices()"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (opencl_device_list opencl_devices ; cl_uint num_platforms ;)",
    "insertText": "enforce_cl_retcode(clGetPlatformIDs(0, NULL, &num_platforms), \"clGetPlatformIDs failed\")"
  },
  {
    "label": "platforms()",
    "kind": "Method",
    "detail": "Function (std::vector<cl_platform_id>)",
    "insertText": "platforms(num_platforms)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clGetPlatformIDs(num_platforms, platforms.data(), NULL), \"clGetPlatformIDs failed\")"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (cl_uint num_all_devices = 0 ;)",
    "insertText": "while(platforms_it != platforms.end())"
  },
  {
    "label": "clGetDeviceIDs()",
    "kind": "Method",
    "detail": "Function (cl_int err =)",
    "insertText": "clGetDeviceIDs(*platforms_it, CL_DEVICE_TYPE_ALL, 0, NULL, &num_devices)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (platforms_it = platforms .)",
    "insertText": "erase(platforms_it)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "enforce_cl_retcode(err, \"clGetDeviceIDs failed\")"
  },
  {
    "label": "devices()",
    "kind": "Method",
    "detail": "Function (num_all_devices + = num_devices ; + + platforms_it ; } } std::vector<cl_device_id>)",
    "insertText": "devices(num_all_devices)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clGetDeviceIDs((*p), CL_DEVICE_TYPE_ALL, (cl_uint)std::distance(devices_it, devices.end()), &*devices_it, &num_devices), \"clGetDeviceIDs failed\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (devices_it + = num_devices ; })",
    "insertText": "for(auto d = devices.begin(); d != devices.end(); ++d)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (opencl_devices .)",
    "insertText": "add(opencl_device((*d)))"
  },
  {
    "label": "available_devices()",
    "kind": "Method",
    "detail": "Function (} return opencl_devices ; } } namespace opencl_info { const opencl_device_list&)",
    "insertText": "available_devices()"
  },
  {
    "label": "callback_base()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "callback_base()"
  },
  {
    "label": "callback()",
    "kind": "Method",
    "detail": "Function (} } ; template<Callback,T> class callback : public callback_base { Callback my_callback ; T my_data ; public :)",
    "insertText": "callback(Callback c, const T& t ) : my_callback( c ), my_data( t)"
  },
  {
    "label": "call()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "call()"
  },
  {
    "label": "my_callback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "my_callback(my_data)"
  },
  {
    "label": "opencl_async_msg()",
    "kind": "Method",
    "detail": "Function (} } ; template<T,Factory = opencl_info::default_opencl_factory> class opencl_async_msg : public async_msg<T> { public : typedef T value_type ;)",
    "insertText": "opencl_async_msg() : my_callback_flag_ptr( std::make_shared< tbb::atomic<bool>>())"
  },
  {
    "label": "relaxed()",
    "kind": "Method",
    "detail": "Function (my_callback_flag_ptr -> store<)",
    "insertText": "relaxed(false)"
  },
  {
    "label": "opencl_async_msg()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_async_msg(const T& data ) : my_data(data), my_callback_flag_ptr( std::make_shared<tbb::atomic<bool>>())"
  },
  {
    "label": "opencl_async_msg()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_async_msg(const T& data, cl_event event ) : my_data(data), my_event(event), my_is_event(true), my_callback_flag_ptr( std::make_shared<tbb::atomic<bool>>())"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clRetainEvent( my_event ), \"Failed to retain an event\")"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "data(bool wait = true)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clWaitForEvents( 1, &my_event ), \"Failed to wait for an event\")"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clReleaseEvent( my_event ), \"Failed to release an event\")"
  },
  {
    "label": "opencl_async_msg()",
    "kind": "Method",
    "detail": "Function (my_is_event = false ; } return my_data ; })",
    "insertText": "opencl_async_msg(const opencl_async_msg &dmsg ) : async_msg<T>(dmsg), my_data(dmsg.my_data), my_event(dmsg.my_event), my_is_event( dmsg.my_is_event ), my_callback_flag_ptr(dmsg.my_callback_flag_ptr)"
  },
  {
    "label": "opencl_async_msg()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_async_msg(opencl_async_msg &&dmsg ) : async_msg<T>(std::move(dmsg)), my_data(std::move(dmsg.my_data)), my_event(dmsg.my_event), my_is_event(dmsg.my_is_event), my_callback_flag_ptr( std::move(dmsg.my_callback_flag_ptr))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (dmsg . my_is_event = false ; } opencl_async_msg&)",
    "insertText": "operator(const opencl_async_msg &dmsg)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (async_msg<T)",
    "insertText": "operator(dmsg)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (my_data = dmsg . my_data ; my_event = dmsg . my_event ; my_is_event = dmsg . my_is_event ;)",
    "insertText": "if(my_is_event ) enforce_cl_retcode( clRetainEvent( my_event ), \"Failed to retain an event\")"
  },
  {
    "label": "opencl_async_msg()",
    "kind": "Method",
    "detail": "Function (my_callback_flag_ptr = dmsg . my_callback_flag_ptr ; return* this ; } ~)",
    "insertText": "opencl_async_msg()"
  },
  {
    "label": "get_event()",
    "kind": "Method",
    "detail": "Function (} cl_event const*)",
    "insertText": "get_event()"
  },
  {
    "label": "cl_command_queue()",
    "kind": "Method",
    "detail": "Function (cl_command_queue cq = event_info<)",
    "insertText": "cl_command_queue(my_event, CL_EVENT_COMMAND_QUEUE)"
  },
  {
    "label": "clRetainEvent()",
    "kind": "Method",
    "detail": "Function (} my_is_event = true ; my_event = e ;)",
    "insertText": "clRetainEvent(my_event)"
  },
  {
    "label": "clear_event()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "clear_event()"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clFlush( event_info<cl_command_queue>( my_event, CL_EVENT_COMMAND_QUEUE ) ), \"Failed to flush an OpenCL command queue\")"
  },
  {
    "label": "register_callback()",
    "kind": "Method",
    "detail": "Function (} my_is_event = false ; } template<Callback> void)",
    "insertText": "register_callback(Callback c)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_is_event, \"The OpenCL event is not set\")"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clSetEventCallback( my_event, CL_COMPLETE, register_callback_func, new callback<Callback, T>( c, my_data ) ), \"Failed to set an OpenCL callback\")"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "T()"
  },
  {
    "label": "finalize()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "finalize()"
  },
  {
    "label": "receive_if_memory_object()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "receive_if_memory_object(*this)"
  },
  {
    "label": "a()",
    "kind": "Method",
    "detail": "Function (opencl_async_msg)",
    "insertText": "a(*this)"
  },
  {
    "label": "register_callback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "register_callback([a](const T& t) mutable { a.set(t); })"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} else { a .)",
    "insertText": "set(my_data)"
  },
  {
    "label": "register_callback_func()",
    "kind": "Method",
    "detail": "Function (} private : void CL_CALLBACK)",
    "insertText": "register_callback_func(cl_event, cl_int event_command_exec_status, void *data)"
  },
  {
    "label": "suppress_unused_warning()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "suppress_unused_warning(event_command_exec_status)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(event_command_exec_status == CL_COMPLETE, NULL)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(data, NULL)"
  },
  {
    "label": "callback_base()",
    "kind": "Method",
    "detail": "Function (callback_base* c = static_cast<)",
    "insertText": "callback_base(data)"
  },
  {
    "label": "key_from_message()",
    "kind": "Method",
    "detail": "Function (delete c ; } T my_data ; cl_event my_event ; bool my_is_event = false ; std::shared_ptr<tbb::atomic<bool>> my_callback_flag_ptr ; } ; template<K,T,Factory> K)",
    "insertText": "key_from_message(const opencl_async_msg<T, Factory> &dmsg)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (using tbb::flow::key_from_message ; const T& t = dmsg .)",
    "insertText": "data(false)"
  },
  {
    "label": "__TBB_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_STATIC_ASSERT(true, \"\")"
  },
  {
    "label": "opencl_memory()",
    "kind": "Method",
    "detail": "Function (} template<Factory> class opencl_memory { public :)",
    "insertText": "opencl_memory()"
  },
  {
    "label": "opencl_memory()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_memory(Factory &f ) : my_host_ptr( NULL ), my_factory( &f ), my_sending_event_present( false)"
  },
  {
    "label": "devices()",
    "kind": "Method",
    "detail": "Function (my_device_id)",
    "insertText": "devices().begin()"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clReleaseMemObject( my_cl_mem ), \"Failed to release an memory object\")"
  },
  {
    "label": "get_cl_mem()",
    "kind": "Method",
    "detail": "Function (} cl_mem)",
    "insertText": "get_cl_mem()"
  },
  {
    "label": "receive()",
    "kind": "Method",
    "detail": "Function (opencl_async_msg<void*,Factory> d =)",
    "insertText": "receive(NULL)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (d .)",
    "insertText": "data()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(d.data() == my_host_ptr, NULL)"
  },
  {
    "label": "factory()",
    "kind": "Method",
    "detail": "Function (} return my_host_ptr ; } Factory*)",
    "insertText": "factory()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (opencl_async_msg<void*,Factory> d ;)",
    "insertText": "if(e)"
  },
  {
    "label": "Factory()",
    "kind": "Method",
    "detail": "Function (d = opencl_async_msg<void*,)",
    "insertText": "Factory(my_host_ptr, *e)"
  },
  {
    "label": "Factory()",
    "kind": "Method",
    "detail": "Function (} else { d = opencl_async_msg<void*,)",
    "insertText": "Factory(my_host_ptr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(my_curr_device_id.load<tbb::relaxed>() != opencl_device::host)"
  },
  {
    "label": "map_memory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "map_memory(*my_factory->devices().begin(), d)"
  },
  {
    "label": "relaxed()",
    "kind": "Method",
    "detail": "Function (my_curr_device_id . store<)",
    "insertText": "relaxed(opencl_device::host)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(my_sending_event_present)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clReleaseEvent(my_sending_event), \"Failed to release an event\")"
  },
  {
    "label": "send()",
    "kind": "Method",
    "detail": "Function (my_sending_event_present = false ; } return d ; } opencl_async_msg<void*,Factory>)",
    "insertText": "send(opencl_device device, const cl_event *e)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (opencl_device::device_id_type device_id = device . my_device_id ;)",
    "insertText": "if(!my_factory->is_same_context(my_curr_device_id.load<tbb::acquire>(), device_id))"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function ({ tbb::spin_mutex::scoped_lock)",
    "insertText": "lock(my_sending_lock)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_host_ptr, \"The buffer has not been mapped\")"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (opencl_async_msg<void*,Factory>)",
    "insertText": "d(my_host_ptr)"
  },
  {
    "label": "enqueue_unmap_buffer()",
    "kind": "Method",
    "detail": "Function (my_factory ->)",
    "insertText": "enqueue_unmap_buffer(device, *this, d)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (my_sending_event_present = true ;)",
    "insertText": "enforce_cl_retcode(clRetainEvent(my_sending_event), \"Failed to retain an event\")"
  },
  {
    "label": "release()",
    "kind": "Method",
    "detail": "Function (my_host_ptr = NULL ; my_curr_device_id . store<)",
    "insertText": "release(device_id)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "__TBB_ASSERT(my_sending_event_present, NULL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!e && my_sending_event_present)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(!my_host_ptr, \"The buffer has not been unmapped\")"
  },
  {
    "label": "map_memory()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "map_memory(opencl_device, opencl_async_msg<void*, Factory> &)"
  },
  {
    "label": "opencl_buffer_impl()",
    "kind": "Method",
    "detail": "Function (protected : cl_mem my_cl_mem ; tbb::atomic<opencl_device::device_id_type> my_curr_device_id ; void* my_host_ptr ; Factory* my_factory ; tbb::spin_mutex my_sending_lock ; bool my_sending_event_present ; cl_event my_sending_event ; } ; template<Factory> class opencl_buffer_impl : public opencl_memory<Factory> { size_t my_size ; public :)",
    "insertText": "opencl_buffer_impl(size_t size, Factory& f ) : opencl_memory<Factory>( f ), my_size( size)"
  },
  {
    "label": "clCreateBuffer()",
    "kind": "Method",
    "detail": "Function (cl_int err ; this -> my_cl_mem =)",
    "insertText": "clCreateBuffer(this->my_factory->context(), CL_MEM_ALLOC_HOST_PTR, size, NULL, &err)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(err, \"Failed to create an OpenCL buffer\")"
  },
  {
    "label": "opencl_buffer_impl()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_buffer_impl(cl_mem m, size_t index, size_t size, Factory& f ) : opencl_memory<Factory>( f ), my_size( size)"
  },
  {
    "label": "clCreateSubBuffer()",
    "kind": "Method",
    "detail": "Function (cl_int err ; cl_buffer_region region = { index,size } ; this -> my_cl_mem =)",
    "insertText": "clCreateSubBuffer(m, 0, CL_BUFFER_CREATE_TYPE_REGION, &region, &err)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(err, \"Failed to create an OpenCL subbuffer\")"
  },
  {
    "label": "enqueue_map_buffer()",
    "kind": "Method",
    "detail": "Function (this -> my_factory ->)",
    "insertText": "enqueue_map_buffer(device, *this, dmsg)"
  },
  {
    "label": "access()",
    "kind": "Method",
    "detail": "Function (} # if TBB_USE_ASSERT template<,> class opencl_buffer ; # endif } ; enum access_type { read_write,write_only,read_only } ; template<T,Factory = opencl_info::default_opencl_factory> class opencl_subbuffer ; template<T,Factory = opencl_info::default_opencl_factory> class opencl_buffer { public : typedef cl_mem native_object_type ; typedef opencl_buffer memory_object_type ; typedef Factory opencl_factory_type ; template<access_type a> using iterator = T* ; template<access_type a> iterator<a>)",
    "insertText": "access()"
  },
  {
    "label": "ptr()",
    "kind": "Method",
    "detail": "Function (T*)",
    "insertText": "ptr(T*)my_impl->get_host_ptr()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(ptr, NULL)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "operator(ptrdiff_t k)"
  },
  {
    "label": "opencl_buffer()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_buffer()"
  },
  {
    "label": "opencl_buffer()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_buffer(size_t size)"
  },
  {
    "label": "opencl_buffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "opencl_buffer(Factory &f, size_t size ) : my_impl( std::make_shared<impl_type>( size*sizeof(T), f ))"
  },
  {
    "label": "native_object()",
    "kind": "Method",
    "detail": "Function (} cl_mem)",
    "insertText": "native_object()"
  },
  {
    "label": "memory_object()",
    "kind": "Method",
    "detail": "Function (} const opencl_buffer&)",
    "insertText": "memory_object()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(dependency.data( false ) == *this, NULL)"
  },
  {
    "label": "send()",
    "kind": "Method",
    "detail": "Function (opencl_async_msg<void*,Factory> d = my_impl ->)",
    "insertText": "send(device, dependency.get_event())"
  },
  {
    "label": "receive()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "receive(const opencl_async_msg<opencl_buffer, Factory> &dependency)"
  },
  {
    "label": "receive()",
    "kind": "Method",
    "detail": "Function (opencl_async_msg<void*,Factory> d = my_impl ->)",
    "insertText": "receive(dependency.get_event())"
  },
  {
    "label": "subbuffer()",
    "kind": "Method",
    "detail": "Function (} opencl_subbuffer<T,Factory>)",
    "insertText": "subbuffer(size_t index, size_t size)"
  },
  {
    "label": "opencl_buffer()",
    "kind": "Method",
    "detail": "Function (private :)",
    "insertText": "opencl_buffer(Factory &f, cl_mem m, size_t index, size_t size ) : my_impl( std::make_shared<impl_type>( m, index*sizeof(T), size*sizeof(T), f ))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} typedef opencl_buffer_impl<Factory> impl_type ; std::shared_ptr<impl_type> my_impl ; bool)",
    "insertText": "operator(const opencl_buffer<T, Factory> &lhs, const opencl_buffer<T, Factory> &rhs)"
  },
  {
    "label": "opencl_subbuffer()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_subbuffer(const opencl_buffer<T, Factory> &owner, size_t index, size_t size ) : opencl_buffer<T, Factory>( *owner.my_impl->factory(), owner.native_object(), index, size ), my_owner( owner)"
  },
  {
    "label": "is_typedef()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "is_typedef(type)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (\\ template<C> \\ std::true_type)",
    "insertText": "check(typename C::type*)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (\\ template<C> \\ std::false_type)",
    "insertText": "check(...)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (\\ \\ const bool value =)",
    "insertText": "decltype(check<T>(0))"
  },
  {
    "label": "is_typedef()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "is_typedef(native_object_type)"
  },
  {
    "label": "is_typedef()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "is_typedef(memory_object_type)"
  },
  {
    "label": "get_native_object()",
    "kind": "Method",
    "detail": "Function (template<T> std::enable_if<is_native_object_type<T>::value,T::native_object_type>::type)",
    "insertText": "get_native_object(const T &t)"
  },
  {
    "label": "get_native_object()",
    "kind": "Method",
    "detail": "Function (} template<T> std::enable_if<! is_native_object_type<T>::value,T>::type)",
    "insertText": "get_native_object(T t)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (opencl_async_msg<mem_obj_t,Factory>)",
    "insertText": "d(mem_obj)"
  },
  {
    "label": "send()",
    "kind": "Method",
    "detail": "Function (mem_obj .)",
    "insertText": "send(device, d)"
  },
  {
    "label": "send_if_memory_object()",
    "kind": "Method",
    "detail": "Function (} template<T> std::enable_if<is_memory_object_type<T>::value>::type)",
    "insertText": "send_if_memory_object(opencl_device device, T &t)"
  },
  {
    "label": "dmsg()",
    "kind": "Method",
    "detail": "Function (opencl_async_msg<mem_obj_t,mem_obj_t::opencl_factory_type>)",
    "insertText": "dmsg(mem_obj)"
  },
  {
    "label": "send()",
    "kind": "Method",
    "detail": "Function (mem_obj .)",
    "insertText": "send(device, dmsg)"
  },
  {
    "label": "send_if_memory_object()",
    "kind": "Method",
    "detail": "Function (} template<T> std::enable_if<! is_memory_object_type<T>::value>::type)",
    "insertText": "send_if_memory_object(opencl_device, T&)"
  },
  {
    "label": "receive_if_memory_object()",
    "kind": "Method",
    "detail": "Function (} ; template<T,Factory> std::enable_if<is_memory_object_type<T>::value>::type)",
    "insertText": "receive_if_memory_object(const opencl_async_msg<T, Factory> &dmsg)"
  },
  {
    "label": "receive()",
    "kind": "Method",
    "detail": "Function (mem_obj .)",
    "insertText": "receive(d)"
  },
  {
    "label": "receive_if_memory_object()",
    "kind": "Method",
    "detail": "Function (} template<T> std::enable_if<! is_memory_object_type<T>::value>::type)",
    "insertText": "receive_if_memory_object(const T&)"
  },
  {
    "label": "opencl_range()",
    "kind": "Method",
    "detail": "Function (} class opencl_range { public : typedef size_t range_index_type ; typedef std::array<range_index_type,3> nd_range_type ; template<G = std::initializer_list<int>,L = std::initializer_list<int>,= std::enable_if<! std::is_same<std::decay<G>::type,opencl_range>::value>::type>)",
    "insertText": "opencl_range(G&& global_work = std::initializer_list<int>({ 0 }), L&& local_work = std::initializer_list<int>({ 0, 0, 0 }))"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (my_global_work_size = {)",
    "insertText": "size_t(-1), size_t(-1), size_t(-1)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(l_it != local_work.end(), \"global_work & local_work must have same size\")"
  },
  {
    "label": "global_range()",
    "kind": "Method",
    "detail": "Function (my_global_work_size [ s ] =* g_it ; my_local_work_size [ s ] =* l_it ; } } const nd_range_type&)",
    "insertText": "global_range()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t ret_size = 0 ; std::vector<char> kernel_name ;)",
    "insertText": "for(size_t curr_size = 32;; curr_size <<= 1)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (kernel_name .)",
    "insertText": "resize(curr_size <<= 1)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clGetKernelInfo( k.my_cl_kernel, CL_KERNEL_FUNCTION_NAME, curr_size, kernel_name.data(), &ret_size ), \"Failed to get kernel info\")"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (} cl_program program ;)",
    "insertText": "enforce_cl_retcode(clGetKernelInfo( k.my_cl_kernel, CL_KERNEL_PROGRAM, sizeof(program), &program, &ret_size ), \"Failed to get kernel info\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(ret_size == sizeof(program), NULL)"
  },
  {
    "label": "factory_type()",
    "kind": "Method",
    "detail": "Function (my_cl_kernel = opencl_program<)",
    "insertText": "factory_type(my_factory, program ).get_cl_kernel( kernel_name.data())"
  },
  {
    "label": "kernel()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "kernel()"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clReleaseKernel( my_cl_kernel ), \"Failed to release a kernel\")"
  },
  {
    "label": "kernel()",
    "kind": "Method",
    "detail": "Function (} private : typedef opencl_factory<DeviceFilter> factory_type ;)",
    "insertText": "kernel(const cl_kernel& k, factory_type& f ) : my_cl_kernel( k ), my_factory( f)"
  },
  {
    "label": "opencl_factory()",
    "kind": "Method",
    "detail": "Function (} cl_kernel my_cl_kernel ; factory_type& my_factory ; template<DeviceFilter_> class opencl_factory ; template<Factory> class opencl_program ; } ; typedef kernel kernel_type ; typedef opencl_range range_type ;)",
    "insertText": "opencl_factory()"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clReleaseCommandQueue( (*d).my_cl_command_queue ), \"Failed to release a command queue\")"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "enforce_cl_retcode(clReleaseContext( my_cl_context ), \"Failed to release a context\")"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "init(const opencl_device_list &device_list)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (tbb::spin_mutex::scoped_lock)",
    "insertText": "lock(my_devices_mutex)"
  },
  {
    "label": "enqueue_map_buffer()",
    "kind": "Method",
    "detail": "Function (my_devices = device_list ; return true ; } return false ; } private : template<Factory> void)",
    "insertText": "enqueue_map_buffer(opencl_device device, opencl_buffer_impl<Factory> &buffer, opencl_async_msg<void*, Factory>& dmsg)"
  },
  {
    "label": "clEnqueueMapBuffer()",
    "kind": "Method",
    "detail": "Function (cl_event e2 ; cl_int err ; void* ptr =)",
    "insertText": "clEnqueueMapBuffer(device.my_cl_command_queue, buffer.get_cl_mem(), false, CL_MAP_READ | CL_MAP_WRITE, 0, buffer.size(), e1 == NULL ? 0 : 1, e1, &e2, &err)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(err, \"Failed to map a buffer\")"
  },
  {
    "label": "set_event()",
    "kind": "Method",
    "detail": "Function (dmsg .)",
    "insertText": "set_event(e2)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clReleaseEvent( e2 ), \"Failed to release an event\")"
  },
  {
    "label": "enqueue_unmap_buffer()",
    "kind": "Method",
    "detail": "Function (} template<Factory> void)",
    "insertText": "enqueue_unmap_buffer(opencl_device device, opencl_memory<Factory> &memory, opencl_async_msg<void*, Factory>& dmsg)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (cl_event e2 ;)",
    "insertText": "enforce_cl_retcode(clEnqueueUnmapMemObject( device.my_cl_command_queue, memory.get_cl_mem(), memory.get_host_ptr(), e1 == NULL ? 0 : 1, e1, &e2 ), \"Failed to unmap a buffer\")"
  },
  {
    "label": "process_one_arg()",
    "kind": "Method",
    "detail": "Function (} template<size_t NUM_ARGS,T> void)",
    "insertText": "process_one_arg(const kernel_type& kernel, std::array<cl_event, NUM_ARGS>&, int&, int& place, const T& t)"
  },
  {
    "label": "get_native_object()",
    "kind": "Method",
    "detail": "Function (auto p =)",
    "insertText": "get_native_object(t)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clSetKernelArg(kernel.my_cl_kernel, place++, sizeof(p), &p), \"Failed to set a kernel argument\")"
  },
  {
    "label": "process_one_arg()",
    "kind": "Method",
    "detail": "Function (} template<size_t NUM_ARGS,T,F> void)",
    "insertText": "process_one_arg(const kernel_type& kernel, std::array<cl_event, NUM_ARGS>& events, int& num_events, int& place, const opencl_async_msg<T, F>& msg)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT((static_cast<typename std::array<cl_event, NUM_ARGS>::size_type>(num_events) < events.size()), NULL)"
  },
  {
    "label": "process_one_arg()",
    "kind": "Method",
    "detail": "Function (events [ num_events + + ] =* e ; })",
    "insertText": "process_one_arg(kernel, events, num_events, place, msg.data(false))"
  },
  {
    "label": "process_arg_list()",
    "kind": "Method",
    "detail": "Function (} template<size_t NUM_ARGS,T,. . . Rest> void)",
    "insertText": "process_arg_list(const kernel_type& kernel, std::array<cl_event, NUM_ARGS>& events, int& num_events, int& place, const T& t, const Rest&... args)"
  },
  {
    "label": "process_one_arg()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "process_one_arg(kernel, events, num_events, place, t)"
  },
  {
    "label": "process_arg_list()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "process_arg_list(kernel, events, num_events, place, args...)"
  },
  {
    "label": "process_arg_list()",
    "kind": "Method",
    "detail": "Function (} template<size_t NUM_ARGS> void)",
    "insertText": "process_arg_list(const kernel_type&, std::array<cl_event, NUM_ARGS>&, int&, int&)"
  },
  {
    "label": "update_one_arg()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "update_one_arg(cl_event, T&)"
  },
  {
    "label": "update_one_arg()",
    "kind": "Method",
    "detail": "Function (} template<T,F> void)",
    "insertText": "update_one_arg(cl_event e, opencl_async_msg<T, F>& msg)"
  },
  {
    "label": "set_event()",
    "kind": "Method",
    "detail": "Function (msg .)",
    "insertText": "set_event(e)"
  },
  {
    "label": "update_arg_list()",
    "kind": "Method",
    "detail": "Function (} template<T,. . . Rest> void)",
    "insertText": "update_arg_list(cl_event e, T& t, Rest&... args)"
  },
  {
    "label": "update_one_arg()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "update_one_arg(e, t)"
  },
  {
    "label": "update_arg_list()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "update_arg_list(e, args...)"
  },
  {
    "label": "update_arg_list()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "update_arg_list(cl_event)"
  },
  {
    "label": "send_kernel()",
    "kind": "Method",
    "detail": "Function (} public : template<. . . Args> void)",
    "insertText": "send_kernel(opencl_device device, const kernel_type& kernel, const range_type& work_size, Args&... args)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (std::array<cl_event,)",
    "insertText": "sizeof(Args)"
  },
  {
    "label": "send_kernel_impl()",
    "kind": "Method",
    "detail": "Function (const cl_event e =)",
    "insertText": "send_kernel_impl(device, kernel.my_cl_kernel, work_size, num_events, events.data())"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clReleaseEvent(e), \"Failed to release an event\")"
  },
  {
    "label": "send_data()",
    "kind": "Method",
    "detail": "Function (} template<T,. . . Rest> void)",
    "insertText": "send_data(opencl_device device, T& t, Rest&... args)"
  },
  {
    "label": "send_if_memory_object()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "send_if_memory_object(device, t)"
  },
  {
    "label": "send_data()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "send_data(device, args...)"
  },
  {
    "label": "send_data()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "send_data(opencl_device)"
  },
  {
    "label": "send_kernel_impl()",
    "kind": "Method",
    "detail": "Function (} private : cl_event)",
    "insertText": "send_kernel_impl(opencl_device device, const cl_kernel& kernel, const range_type& work_size, cl_uint num_events, cl_event* event_list)"
  },
  {
    "label": "local_range()",
    "kind": "Method",
    "detail": "Function (const range_type::nd_range_type& l_size = work_size .)",
    "insertText": "local_range()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (cl_uint s ;)",
    "insertText": "for(s = 1; s < 3 && g_size[s] != size_t(-1); ++s)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (} cl_event event ;)",
    "insertText": "enforce_cl_retcode(clEnqueueNDRangeKernel( device.my_cl_command_queue, kernel, s, g_offset.data(), g_size.data(), l_size[0] ? l_size.data() : NULL, num_events, num_events ? event_list : NULL, &event ), \"Failed to enqueue a kernel\")"
  },
  {
    "label": "get_event_from_args()",
    "kind": "Method",
    "detail": "Function (e =* e_ptr ; return true ; } return false ; } template<T,. . . Rest> bool)",
    "insertText": "get_event_from_args(cl_event& e, const T& t, const Rest&... args)"
  },
  {
    "label": "get_event_from_args()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "get_event_from_args(cl_event&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator() ()"
  },
  {
    "label": "finalize_fn_leaf()",
    "kind": "Method",
    "detail": "Function (} } ; template<Fn> struct finalize_fn_leaf : public finalize_fn { Fn my_fn ;)",
    "insertText": "finalize_fn_leaf(Fn fn) : my_fn(fn)"
  },
  {
    "label": "my_fn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "my_fn()"
  },
  {
    "label": "finalize_callback()",
    "kind": "Method",
    "detail": "Function (} } ; void CL_CALLBACK)",
    "insertText": "finalize_callback(cl_event, cl_int event_command_exec_status, void *data)"
  },
  {
    "label": "finalize_fn()",
    "kind": "Method",
    "detail": "Function (finalize_fn* const fn_ptr = static_cast<)",
    "insertText": "finalize_fn(data)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(fn_ptr != NULL, \"Invalid finalize function pointer\")"
  },
  {
    "label": "finalize()",
    "kind": "Method",
    "detail": "Function (delete fn_ptr ; } public : template<FinalizeFn,. . . Args> void)",
    "insertText": "finalize(opencl_device device, FinalizeFn fn, Args&... args)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (cl_event e ;)",
    "insertText": "if(get_event_from_args( e, args... ))"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clSetEventCallback( e, CL_COMPLETE, finalize_callback, new finalize_fn_leaf<FinalizeFn>(fn) ), \"Failed to set a callback\")"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "enforce_cl_retcode(clFlush( device.my_cl_command_queue ), \"Failed to flush an OpenCL command queue\")"
  },
  {
    "label": "devices()",
    "kind": "Method",
    "detail": "Function (} const opencl_device_list&)",
    "insertText": "devices()"
  },
  {
    "label": "call_once()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "call_once(my_once_flag, &opencl_factory::init_once, this)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(d1 != opencl_device::unknown && d2 != opencl_device::unknown, NULL)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (opencl_factory&)",
    "insertText": "operator(const opencl_factory&)"
  },
  {
    "label": "context()",
    "kind": "Method",
    "detail": "Function (cl_context)",
    "insertText": "context()"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "enforce_cl_retcode(my_devices.size() ? CL_SUCCESS : CL_INVALID_DEVICE, \"No devices in the device list\")"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (cl_platform_id platform_id = my_devices .)",
    "insertText": "begin()->platform_id()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::vector<cl_device_id> cl_device_ids ;)",
    "insertText": "for(auto d = my_devices.begin(); d != my_devices.end(); ++d)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (cl_device_ids .)",
    "insertText": "push_back((*d).my_cl_device_id)"
  },
  {
    "label": "CL_CONTEXT_PLATFORM()",
    "kind": "Method",
    "detail": "Function (} cl_context_properties context_properties [ 3 ] = {)",
    "insertText": "CL_CONTEXT_PLATFORM(cl_context_properties)platform_id, (cl_context_properties)"
  },
  {
    "label": "clCreateContext()",
    "kind": "Method",
    "detail": "Function (cl_int err ; cl_context ctx =)",
    "insertText": "clCreateContext(context_properties, (cl_uint)cl_device_ids.size(), cl_device_ids.data(), NULL, NULL, &err)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(err, \"Failed to create context\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (my_cl_context = ctx ; size_t device_counter = 0 ;)",
    "insertText": "for(auto d = my_devices.begin(); d != my_devices.end(); d++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (cl_int err2 ; cl_command_queue cq ; # if CL_VERSION_2_0)",
    "insertText": "if((*d).major_version() >= 2)"
  },
  {
    "label": "clCreateCommandQueueWithProperties()",
    "kind": "Method",
    "detail": "Function (cl_queue_properties props [ ] = { CL_QUEUE_PROPERTIES,CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE,0 } ; cq =)",
    "insertText": "clCreateCommandQueueWithProperties(ctx, (*d).my_cl_device_id, props, &err2)"
  },
  {
    "label": "props()",
    "kind": "Method",
    "detail": "Function (} } else # endif { cl_command_queue_properties)",
    "insertText": "props(*d).out_of_order_exec_mode_on_host_present()"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (# if __TBB_GCC_WARNING_SUPPRESSION_PRESENT # pragma GCC diagnostic push # pragma GCC diagnostic ignored \" - Wdeprecated - declarations \" # endif # if _MSC_VER | | __INTEL_COMPILER # pragma)",
    "insertText": "warning(push ) #if __INTEL_COMPILER #pragma warning (disable: 1478) #else #pragma warning (disable: 4996) #endif #endif cq = clCreateCommandQueue(ctx, (*d).my_cl_device_id, props, &err2)"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (# if _MSC_VER | | __INTEL_COMPILER # pragma)",
    "insertText": "warning(pop ) #endif #if __TBB_GCC_WARNING_SUPPRESSION_PRESENT #pragma GCC diagnostic pop #endif } enforce_cl_retcode(err2, \"Failed to create command queue\")"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } std::once_flag my_once_flag ; opencl_device_list my_devices ; cl_context my_cl_context ; tbb::spin_mutex my_devices_mutex ; template<Factory> class opencl_program ; template<Factory> class opencl_buffer_impl ; template<Factory> class opencl_memory ; } ; namespace opencl_info { template<Factory> struct default_device_selector { opencl_device)",
    "insertText": "operator()(Factory& f)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(!f.devices().empty(), \"No available devices\")"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; struct default_device_filter { opencl_device_list)",
    "insertText": "operator()(const opencl_device_list &devices)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (dl .)",
    "insertText": "add(*it)"
  },
  {
    "label": "default_factory()",
    "kind": "Method",
    "detail": "Function (} } return dl ; } } ; class default_opencl_factory : public opencl_factory<default_device_filter>,tbb::internal::no_copy { public : template<T> using async_msg_type = opencl_async_msg<T,default_opencl_factory> ; default_opencl_factory&)",
    "insertText": "default_factory()"
  },
  {
    "label": "default_opencl_factory()",
    "kind": "Method",
    "detail": "Function (private :)",
    "insertText": "default_opencl_factory()"
  },
  {
    "label": "opencl_buffer()",
    "kind": "Method",
    "detail": "Function (default_opencl_factory default_factory ; return default_factory ; } } template<T,Factory> opencl_buffer<T,Factory)",
    "insertText": "opencl_buffer(size_t size ) : my_impl( std::make_shared<impl_type>( size*sizeof(T), opencl_info::default_factory() ))"
  },
  {
    "label": "opencl_program()",
    "kind": "Method",
    "detail": "Function (} enum class opencl_program_type { SOURCE,PRECOMPILED,SPIR } ; template<Factory = opencl_info::default_opencl_factory> class opencl_program : tbb::internal::no_assign { public : typedef Factory::kernel_type kernel_type ;)",
    "insertText": "opencl_program(Factory& factory, opencl_program_type type, const std::string& program_name ) : my_factory( factory ), my_type(type) , my_arg_str( program_name)"
  },
  {
    "label": "opencl_program()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_program(Factory& factory, const char* program_name ) : opencl_program( factory, std::string( program_name ))"
  },
  {
    "label": "opencl_program()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_program(Factory& factory, const std::string& program_name ) : opencl_program( factory, opencl_program_type::SOURCE, program_name)"
  },
  {
    "label": "opencl_program()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_program(opencl_program_type type, const std::string& program_name ) : opencl_program( opencl_info::default_factory(), type, program_name)"
  },
  {
    "label": "opencl_program()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_program(const char* program_name ) : opencl_program( opencl_info::default_factory(), program_name)"
  },
  {
    "label": "opencl_program()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_program(const std::string& program_name ) : opencl_program( opencl_info::default_factory(), program_name)"
  },
  {
    "label": "opencl_program()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_program(opencl_program_type type ) : opencl_program( opencl_info::default_factory(), type)"
  },
  {
    "label": "opencl_program()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_program(const opencl_program &src ) : my_factory( src.my_factory ), my_type( src.type ), my_arg_str( src.my_arg_str ), my_cl_program( src.my_cl_program)"
  },
  {
    "label": "call_once()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "call_once(my_do_once_flag, [](){})"
  },
  {
    "label": "get_kernel()",
    "kind": "Method",
    "detail": "Function (} kernel_type)",
    "insertText": "get_kernel(const std::string& k)"
  },
  {
    "label": "opencl_program()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "opencl_program(Factory& factory, cl_program program ) : my_factory( factory ), my_cl_program( program)"
  },
  {
    "label": "get_cl_kernel()",
    "kind": "Method",
    "detail": "Function (} cl_kernel)",
    "insertText": "get_cl_kernel(const std::string& k)"
  },
  {
    "label": "call_once()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "call_once(my_do_once_flag, [this, &k](){ this->init( k ); })"
  },
  {
    "label": "clCreateKernel()",
    "kind": "Method",
    "detail": "Function (cl_int err ; cl_kernel kernel =)",
    "insertText": "clCreateKernel(my_cl_program, k.c_str(), &err)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(err, std::string( \"Failed to create kernel: \" ) + k)"
  },
  {
    "label": "file_descriptor()",
    "kind": "Method",
    "detail": "Function (std::ifstream)",
    "insertText": "file_descriptor(filepath, std::ifstream::binary)"
  },
  {
    "label": "string()",
    "kind": "Method",
    "detail": "Function (std::string str =)",
    "insertText": "string(\"Could not open file: \")"
  },
  {
    "label": "seekg()",
    "kind": "Method",
    "detail": "Function (std::cerr<<str<<std::endl ; throw str ; } file_descriptor .)",
    "insertText": "seekg(0, file_descriptor.end)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (size_t length =)",
    "insertText": "size_t(file_descriptor.tellg())"
  },
  {
    "label": "seekg()",
    "kind": "Method",
    "detail": "Function (file_descriptor .)",
    "insertText": "seekg(0, file_descriptor.beg)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (my_content .)",
    "insertText": "resize(length)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (file_descriptor .)",
    "insertText": "read(begin, length)"
  },
  {
    "label": "close()",
    "kind": "Method",
    "detail": "Function (file_descriptor .)",
    "insertText": "close()"
  },
  {
    "label": "content()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "content()"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "length()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} private : std::string my_content ; } ; class opencl_program_builder { public : typedef)",
    "insertText": "void(CL_CALLBACK *cl_callback_type)(cl_program, void*)"
  },
  {
    "label": "opencl_program_builder()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "opencl_program_builder(Factory& f, const std::string& name, cl_program program, cl_uint num_devices, cl_device_id* device_list, const char* options, cl_callback_type callback, void* user_data)"
  },
  {
    "label": "clBuildProgram()",
    "kind": "Method",
    "detail": "Function (cl_int err =)",
    "insertText": "clBuildProgram(program, num_devices, device_list, options, callback, user_data)"
  },
  {
    "label": "string()",
    "kind": "Method",
    "detail": "Function (std::string str =)",
    "insertText": "string(\"Failed to build program: \")"
  },
  {
    "label": "device()",
    "kind": "Method",
    "detail": "Function (std::cerr<<\" Build log for)",
    "insertText": "device(*d).name()"
  },
  {
    "label": "clGetProgramBuildInfo()",
    "kind": "Method",
    "detail": "Function (size_t log_size ; cl_int query_err =)",
    "insertText": "clGetProgramBuildInfo(program, (*d).my_cl_device_id, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(query_err, \"Failed to get build log size\")"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (std::vector<char> output ; output .)",
    "insertText": "resize(log_size)"
  },
  {
    "label": "clGetProgramBuildInfo()",
    "kind": "Method",
    "detail": "Function (query_err =)",
    "insertText": "clGetProgramBuildInfo(program, (*d).my_cl_device_id, CL_PROGRAM_BUILD_LOG, output.size(), output.data(), NULL)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(query_err, \"Failed to get build output\")"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (} else { std::cerr<<\" No build log available \"<<std::endl ; } } })",
    "insertText": "enforce_cl_retcode(err, str)"
  },
  {
    "label": "opencl_device_filter()",
    "kind": "Method",
    "detail": "Function (} } ; class opencl_device_filter { public : template<Filter>)",
    "insertText": "opencl_device_filter(cl_uint& num_devices, cl_device_id* device_list, Filter filter, const char* message)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (device_list [ i - - ] = device_list [ - - num_devices ] ; })",
    "insertText": "if(!num_devices ) enforce_cl_retcode( CL_DEVICE_NOT_AVAILABLE, message)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (} } ; void)",
    "insertText": "init(const std::string&)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (cl_uint num_devices ;)",
    "insertText": "enforce_cl_retcode(clGetContextInfo( my_factory.context(), CL_CONTEXT_NUM_DEVICES, sizeof( num_devices ), &num_devices, NULL ), \"Failed to get OpenCL context info\")"
  },
  {
    "label": "device_list()",
    "kind": "Method",
    "detail": "Function (cl_device_id*)",
    "insertText": "device_list(cl_device_id *)alloca( num_devices*sizeof( cl_device_id ))"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(clGetContextInfo( my_factory.context(), CL_CONTEXT_DEVICES, num_devices*sizeof( cl_device_id ), device_list, NULL ), \"Failed to get OpenCL context info\")"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (const char* options = NULL ;)",
    "insertText": "switch(my_type)"
  },
  {
    "label": "clCreateProgramWithSource()",
    "kind": "Method",
    "detail": "Function (cl_int err ; my_cl_program =)",
    "insertText": "clCreateProgramWithSource(my_factory.context(), 1, s, l, &err)"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_cl_retcode(err, std::string( \"Failed to create program: \" ) + my_arg_str)"
  },
  {
    "label": "opencl_device_filter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "opencl_device_filter(num_devices, device_list, []( const opencl_device& d ) -> bool { return !d.compiler_available() || !d.linker_available(); }, \"No one device supports building program from sources\")"
  },
  {
    "label": "opencl_program_builder()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "opencl_program_builder(my_factory, my_arg_str, my_cl_program, num_devices, device_list, options, NULL, NULL)"
  },
  {
    "label": "fr()",
    "kind": "Method",
    "detail": "Function (break ; } case opencl_program_type::SPIR : options = \" - x spir \" ; case opencl_program_type::PRECOMPILED : { file_reader)",
    "insertText": "fr(my_arg_str)"
  },
  {
    "label": "s()",
    "kind": "Method",
    "detail": "Function (std::vector<const unsigned char*>)",
    "insertText": "s(num_devices, reinterpret_cast<const unsigned char*>(fr.content()))"
  },
  {
    "label": "l()",
    "kind": "Method",
    "detail": "Function (std::vector<size_t>)",
    "insertText": "l(num_devices, fr.length())"
  },
  {
    "label": "bin_statuses()",
    "kind": "Method",
    "detail": "Function (std::vector<cl_int>)",
    "insertText": "bin_statuses(num_devices, -1)"
  },
  {
    "label": "clCreateProgramWithBinary()",
    "kind": "Method",
    "detail": "Function (cl_int err ; my_cl_program =)",
    "insertText": "clCreateProgramWithBinary(my_factory.context(), num_devices, device_list, l.data(), s.data(), bin_statuses.data(), &err)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::string statuses_str ;)",
    "insertText": "for(auto st = bin_statuses.begin(); st != bin_statuses.end(); ++st)"
  },
  {
    "label": "to_string()",
    "kind": "Method",
    "detail": "Function (statuses_str + =)",
    "insertText": "to_string((*st))"
  },
  {
    "label": "enforce_cl_retcode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "enforce_cl_retcode(err, std::string( \"Failed to create program, error \" + std::to_string( err ) + \" : \" ) + my_arg_str + std::string( \", binary_statuses = \" ) + statuses_str)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (break ; } default :)",
    "insertText": "__TBB_ASSERT(false, \"Unsupported program type\")"
  },
  {
    "label": "opencl_node()",
    "kind": "Method",
    "detail": "Function (} } Factory& my_factory ; opencl_program_type my_type ; std::string my_arg_str ; cl_program my_cl_program ; std::once_flag my_do_once_flag ; template<DeviceFilter> class opencl_factory ; template<DeviceFilter> class opencl_factory<DeviceFilter>::kernel ; } ; template<. . . Args> class opencl_node ; template<JP,Factory,. . . Ports> class opencl_node<tuple<Ports . . .>,JP,Factory> : public streaming_node<tuple<Ports . . .>,JP,Factory> { typedef streaming_node<tuple<Ports . . .>,JP,Factory> base_type ; public : typedef base_type::kernel_type kernel_type ;)",
    "insertText": "opencl_node(graph &g, const kernel_type& kernel ) : base_type( g, kernel, opencl_info::default_device_selector< opencl_info::default_opencl_factory >(), opencl_info::default_factory())"
  },
  {
    "label": "fgt_multiinput_multioutput_node()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_multiinput_multioutput_node(tbb::internal::FLOW_OPENCL_NODE, this, &this->my_graph)"
  },
  {
    "label": "opencl_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opencl_node(graph &g, const kernel_type& kernel, Factory &f ) : base_type( g, kernel, opencl_info::default_device_selector <Factory >(), f)"
  },
  {
    "label": "opencl_node()",
    "kind": "Method",
    "detail": "Function (} template<DeviceSelector>)",
    "insertText": "opencl_node(graph &g, const kernel_type& kernel, DeviceSelector d, Factory &f) : base_type( g, kernel, d, f)"
  },
  {
    "label": "opencl_node()",
    "kind": "Method",
    "detail": "Function (} template<DeviceSelector>)",
    "insertText": "opencl_node(graph &g, const kernel_type& kernel, DeviceSelector d ) : base_type( g, kernel, d, opencl_info::default_factory())"
  }
]