[
  {
    "label": "AudioSender",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AudioSender"
  },
  {
    "label": "AudioTransportImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AudioTransportImpl"
  },
  {
    "label": "AudioTransportImpl()",
    "kind": "Method",
    "detail": "Function (# ifndef AUDIO_AUDIO_TRANSPORT_IMPL_H_ # define AUDIO_AUDIO_TRANSPORT_IMPL_H_ # include<memory> # include<vector> # include \" api / audio / audio_mixer . h \" # include \" api / scoped_refptr . h \" # include \" common_audio / resampler / include / push_resampler . h \" # include \" modules / async_audio_processing / async_audio_processing . h \" # include \" modules / audio_device / include / audio_device . h \" # include \" modules / audio_processing / include / audio_processing . h \" # include \" rtc_base / synchronization / mutex . h \" # include \" rtc_base / thread_annotations . h \" namespace webrtc { class AudioSender ; class AudioTransportImpl : public AudioTransport { public :)",
    "insertText": "AudioTransportImpl(AudioMixer* mixer, AudioProcessing* audio_processing, AsyncAudioProcessing::Factory* async_audio_processing_factory)"
  },
  {
    "label": "AudioTransportImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AudioTransportImpl()"
  },
  {
    "label": "AudioTransportImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AudioTransportImpl(const AudioTransportImpl&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (AudioTransportImpl&)",
    "insertText": "operator(const AudioTransportImpl&)"
  },
  {
    "label": "RecordedDataIsAvailable()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "RecordedDataIsAvailable(const void* audioSamples, size_t nSamples, size_t nBytesPerSample, size_t nChannels, uint32_t samplesPerSec, uint32_t totalDelayMS, int32_t clockDrift, uint32_t currentMicLevel, bool keyPressed, uint32_t& newMicLevel)"
  },
  {
    "label": "RecordedDataIsAvailable()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "RecordedDataIsAvailable(const void* audioSamples, size_t nSamples, size_t nBytesPerSample, size_t nChannels, uint32_t samplesPerSec, uint32_t totalDelayMS, int32_t clockDrift, uint32_t currentMicLevel, bool keyPressed, uint32_t& newMicLevel, int64_t estimated_capture_time_ns)"
  },
  {
    "label": "NeedMorePlayData()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "NeedMorePlayData(size_t nSamples, size_t nBytesPerSample, size_t nChannels, uint32_t samplesPerSec, void* audioSamples, size_t& nSamplesOut, int64_t* elapsed_time_ms, int64_t* ntp_time_ms)"
  },
  {
    "label": "PullRenderData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PullRenderData(int bits_per_sample, int sample_rate, size_t number_of_channels, size_t number_of_frames, void* audio_data, int64_t* elapsed_time_ms, int64_t* ntp_time_ms)"
  },
  {
    "label": "UpdateAudioSenders()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateAudioSenders(std::vector<AudioSender*> senders, int send_sample_rate_hz, size_t send_num_channels)"
  },
  {
    "label": "SetStereoChannelSwapping()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetStereoChannelSwapping(bool enable)"
  },
  {
    "label": "SendProcessedData()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "SendProcessedData(std::unique_ptr<AudioFrame> audio_frame)"
  },
  {
    "label": "RTC_GUARDED_BY()",
    "kind": "Method",
    "detail": "Function (AudioProcessing* audio_processing_ = nullptr ; const std::unique_ptr<AsyncAudioProcessing> async_audio_processing_ ; Mutex capture_lock_ ; std::vector<AudioSender*> audio_senders_)",
    "insertText": "RTC_GUARDED_BY(capture_lock_)"
  }
]