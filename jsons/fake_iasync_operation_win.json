[
  {
    "label": "FakeIAsyncOperation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FakeIAsyncOperation"
  },
  {
    "label": "FakeIAsyncOperation()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_TEST_FAKE_IASYNC_OPERATION_WIN_H_ # define BASE_TEST_FAKE_IASYNC_OPERATION_WIN_H_ # include<wrl / client . h> # include<wrl / implements . h> # include \" base / notreached . h \" # include \" base / win / winrt_foundation_helpers . h \" # include \" testing / gtest / include / gtest / gtest . h \" namespace base { namespace win { namespace internal { template<T> using AsyncOperationComplex = ABI::Windows::Foundation::IAsyncOperation<T>::TResult_complex ; template<T> using AsyncOperationAbi = AbiType<AsyncOperationComplex<T>> ; template<T> using AsyncOperationOptionalStorage = OptionalStorageType<AsyncOperationComplex<T>> ; template<T> using AsyncOperationStorage = StorageType<AsyncOperationComplex<T>> ; } template<T> class FakeIAsyncOperation final : public Microsoft::WRL::RuntimeClass<Microsoft::WRL::RuntimeClassFlags<Microsoft::WRL::WinRt | Microsoft::WRL::InhibitRoOriginateError>,ABI::Windows::Foundation::IAsyncOperation<T>,ABI::Windows::Foundation::IAsyncInfo> { public :)",
    "insertText": "FakeIAsyncOperation()"
  },
  {
    "label": "FakeIAsyncOperation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FakeIAsyncOperation(const FakeIAsyncOperation&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FakeIAsyncOperation&)",
    "insertText": "operator(const FakeIAsyncOperation&)"
  },
  {
    "label": "EXPECT_EQ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_EQ(nullptr, handler_)"
  },
  {
    "label": "get_Completed()",
    "kind": "Method",
    "detail": "Function (handler_ = handler ; return S_OK ; } IFACEMETHODIMP)",
    "insertText": "get_Completed(ABI::Windows::Foundation::IAsyncOperationCompletedHandler<T>** handler)"
  },
  {
    "label": "NOTREACHED()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NOTREACHED()"
  },
  {
    "label": "ADD_FAILURE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ADD_FAILURE()"
  },
  {
    "label": "get_Id()",
    "kind": "Method",
    "detail": "Function (} IFACEMETHODIMP)",
    "insertText": "get_Id(uint32_t* id)"
  },
  {
    "label": "get_ErrorCode()",
    "kind": "Method",
    "detail": "Function (* status = status_ ; return S_OK ; } IFACEMETHODIMP)",
    "insertText": "get_ErrorCode(HRESULT* error_code)"
  },
  {
    "label": "EXPECT_FALSE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXPECT_FALSE(results_includes_failure_)"
  },
  {
    "label": "Cancel()",
    "kind": "Method",
    "detail": "Function (* error_code = error_code_ ; return S_OK ; } IFACEMETHODIMP)",
    "insertText": "Cancel()"
  },
  {
    "label": "InvokeCompletedHandler()",
    "kind": "Method",
    "detail": "Function (error_code_ = error_code ; status_ = AsyncStatus::Error ;)",
    "insertText": "InvokeCompletedHandler()"
  },
  {
    "label": "CompleteWithErrorResult()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CompleteWithErrorResult(internal::AsyncOperationStorage<T> results)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (error_code_ = S_OK ; results_ =)",
    "insertText": "move(results)"
  },
  {
    "label": "CompleteWithResults()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CompleteWithResults(internal::AsyncOperationStorage<T> results)"
  },
  {
    "label": "ASSERT_FALSE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ASSERT_FALSE(is_complete_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (is_complete_ = true ;)",
    "insertText": "if(handler_) handler_->Invoke(this, status_)"
  }
]