[
  {
    "label": "BMPSet",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BMPSet"
  },
  {
    "label": "ParsePosition",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ParsePosition"
  },
  {
    "label": "RBBIRuleScanner",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RBBIRuleScanner"
  },
  {
    "label": "SymbolTable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SymbolTable"
  },
  {
    "label": "UnicodeSetStringSpan",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UnicodeSetStringSpan"
  },
  {
    "label": "UVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UVector"
  },
  {
    "label": "RuleCharacterIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RuleCharacterIterator"
  },
  {
    "label": "U_COMMON_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "U_COMMON_API"
  },
  {
    "label": "ESerialization",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ESerialization"
  },
  {
    "label": "USetAccess",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "USetAccess"
  },
  {
    "label": "UnicodeSetIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UnicodeSetIterator"
  },
  {
    "label": "isBogus()",
    "kind": "Method",
    "detail": "Function (# ifndef UNICODESET_H # define UNICODESET_H # include \" unicode / ucpmap . h \" # include \" unicode / unifilt . h \" # include \" unicode / unistr . h \" # include \" unicode / uset . h \" U_NAMESPACE_BEGIN class BMPSet ; class ParsePosition ; class RBBIRuleScanner ; class SymbolTable ; class UnicodeSetStringSpan ; class UVector ; class RuleCharacterIterator ; class UnicodeSet U_FINAL : public UnicodeFilter { private : int32_t INITIAL_CAPACITY = 2 5 ; uint8_t kIsBogus = 1 ; UChar32* list = stackList ; int32_t capacity = INITIAL_CAPACITY ; int32_t len = 1 ; uint8_t fFlags = 0 ; BMPSet* bmpSet = nullptr ; UChar32* buffer = nullptr ; int32_t bufferCapacity = 0 ; char16_t* pat = nullptr ; int32_t patLen = 0 ; UVector* strings = nullptr ; UnicodeSetStringSpan* stringSpan = nullptr ; UChar32 stackList [ INITIAL_CAPACITY ] ; public : UBool)",
    "insertText": "isBogus(void)"
  },
  {
    "label": "setToBogus()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setToBogus()"
  },
  {
    "label": "UnicodeSet()",
    "kind": "Method",
    "detail": "Function (public : enum { MIN_VALUE = 0,MAX_VALUE = 0 x10ffff } ; public :)",
    "insertText": "UnicodeSet()"
  },
  {
    "label": "UnicodeSet()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnicodeSet(UChar32 start, UChar32 end)"
  },
  {
    "label": "UnicodeSet()",
    "kind": "Method",
    "detail": "Function (# ifndef enum ESerialization { kSerialized } ;)",
    "insertText": "UnicodeSet(const uint16_t buffer[], int32_t bufferLen, ESerialization serialization, UErrorCode &status)"
  },
  {
    "label": "UnicodeSet()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "UnicodeSet(const UnicodeString& pattern, UErrorCode& status)"
  },
  {
    "label": "UnicodeSet()",
    "kind": "Method",
    "detail": "Function (# ifndef)",
    "insertText": "UnicodeSet(const UnicodeString& pattern, uint32_t options, const SymbolTable* symbols, UErrorCode& status)"
  },
  {
    "label": "UnicodeSet()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "UnicodeSet(const UnicodeString& pattern, ParsePosition& pos, uint32_t options, const SymbolTable* symbols, UErrorCode& status)"
  },
  {
    "label": "UnicodeSet()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnicodeSet(const UnicodeSet& o)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "operator(const UnicodeSet& o)"
  },
  {
    "label": "clone()",
    "kind": "Method",
    "detail": "Function (UnicodeFunctor*)",
    "insertText": "clone()"
  },
  {
    "label": "hashCode()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "hashCode(void)"
  },
  {
    "label": "fromUSet()",
    "kind": "Method",
    "detail": "Function (UnicodeSet*)",
    "insertText": "fromUSet(USet *uset)"
  },
  {
    "label": "fromUSet()",
    "kind": "Method",
    "detail": "Function (const UnicodeSet*)",
    "insertText": "fromUSet(const USet *uset)"
  },
  {
    "label": "toUSet()",
    "kind": "Method",
    "detail": "Function (USet*)",
    "insertText": "toUSet()"
  },
  {
    "label": "isFrozen()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "isFrozen()"
  },
  {
    "label": "freeze()",
    "kind": "Method",
    "detail": "Function (UnicodeFunctor*)",
    "insertText": "freeze()"
  },
  {
    "label": "cloneAsThawed()",
    "kind": "Method",
    "detail": "Function (UnicodeFunctor*)",
    "insertText": "cloneAsThawed()"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "set(UChar32 start, UChar32 end)"
  },
  {
    "label": "resemblesPattern()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "resemblesPattern(const UnicodeString& pattern, int32_t pos)"
  },
  {
    "label": "applyPattern()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "applyPattern(const UnicodeString& pattern, UErrorCode& status)"
  },
  {
    "label": "applyPattern()",
    "kind": "Method",
    "detail": "Function (# ifndef UnicodeSet&)",
    "insertText": "applyPattern(const UnicodeString& pattern, uint32_t options, const SymbolTable* symbols, UErrorCode& status)"
  },
  {
    "label": "applyPattern()",
    "kind": "Method",
    "detail": "Function (# endif UnicodeSet&)",
    "insertText": "applyPattern(const UnicodeString& pattern, ParsePosition& pos, uint32_t options, const SymbolTable* symbols, UErrorCode& status)"
  },
  {
    "label": "toPattern()",
    "kind": "Method",
    "detail": "Function (UnicodeString&)",
    "insertText": "toPattern(UnicodeString& result, UBool escapeUnprintable = FALSE)"
  },
  {
    "label": "applyIntPropertyValue()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "applyIntPropertyValue(UCharProperty prop, int32_t value, UErrorCode& ec)"
  },
  {
    "label": "applyPropertyAlias()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "applyPropertyAlias(const UnicodeString& prop, const UnicodeString& value, UErrorCode& ec)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "size(void)"
  },
  {
    "label": "isEmpty()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "isEmpty(void)"
  },
  {
    "label": "contains()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "contains(UChar32 c)"
  },
  {
    "label": "contains()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "contains(UChar32 start, UChar32 end)"
  },
  {
    "label": "contains()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "contains(const UnicodeString& s)"
  },
  {
    "label": "containsAll()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "containsAll(const UnicodeSet& c)"
  },
  {
    "label": "containsAll()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "containsAll(const UnicodeString& s)"
  },
  {
    "label": "containsNone()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "containsNone(UChar32 start, UChar32 end)"
  },
  {
    "label": "containsNone()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "containsNone(const UnicodeSet& c)"
  },
  {
    "label": "containsNone()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "containsNone(const UnicodeString& s)"
  },
  {
    "label": "containsSome()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "containsSome(UChar32 start, UChar32 end)"
  },
  {
    "label": "containsSome()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "containsSome(const UnicodeSet& s)"
  },
  {
    "label": "containsSome()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "containsSome(const UnicodeString& s)"
  },
  {
    "label": "span()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "span(const char16_t *s, int32_t length, USetSpanCondition spanCondition)"
  },
  {
    "label": "span()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "span(const UnicodeString &s, int32_t start, USetSpanCondition spanCondition)"
  },
  {
    "label": "spanBack()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "spanBack(const char16_t *s, int32_t length, USetSpanCondition spanCondition)"
  },
  {
    "label": "spanBack()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "spanBack(const UnicodeString &s, int32_t limit, USetSpanCondition spanCondition)"
  },
  {
    "label": "spanUTF8()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "spanUTF8(const char *s, int32_t length, USetSpanCondition spanCondition)"
  },
  {
    "label": "spanBackUTF8()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "spanBackUTF8(const char *s, int32_t length, USetSpanCondition spanCondition)"
  },
  {
    "label": "matches()",
    "kind": "Method",
    "detail": "Function (UMatchDegree)",
    "insertText": "matches(const Replaceable& text, int32_t& offset, int32_t limit, UBool incremental)"
  },
  {
    "label": "matchRest()",
    "kind": "Method",
    "detail": "Function (private : int32_t)",
    "insertText": "matchRest(const Replaceable& text, int32_t start, int32_t limit, const UnicodeString& s)"
  },
  {
    "label": "findCodePoint()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "findCodePoint(UChar32 c)"
  },
  {
    "label": "addMatchSetTo()",
    "kind": "Method",
    "detail": "Function (public : void)",
    "insertText": "addMatchSetTo(UnicodeSet& toUnionTo)"
  },
  {
    "label": "indexOf()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "indexOf(UChar32 c)"
  },
  {
    "label": "charAt()",
    "kind": "Method",
    "detail": "Function (UChar32)",
    "insertText": "charAt(int32_t index)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "add(UChar32 start, UChar32 end)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "add(UChar32 c)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "add(const UnicodeString& s)"
  },
  {
    "label": "getSingleCP()",
    "kind": "Method",
    "detail": "Function (private : int32_t)",
    "insertText": "getSingleCP(const UnicodeString& s)"
  },
  {
    "label": "_add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_add(const UnicodeString& s)"
  },
  {
    "label": "addAll()",
    "kind": "Method",
    "detail": "Function (public : UnicodeSet&)",
    "insertText": "addAll(const UnicodeString& s)"
  },
  {
    "label": "retainAll()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "retainAll(const UnicodeString& s)"
  },
  {
    "label": "complementAll()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "complementAll(const UnicodeString& s)"
  },
  {
    "label": "removeAll()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "removeAll(const UnicodeString& s)"
  },
  {
    "label": "createFrom()",
    "kind": "Method",
    "detail": "Function (UnicodeSet* U_EXPORT2)",
    "insertText": "createFrom(const UnicodeString& s)"
  },
  {
    "label": "createFromAll()",
    "kind": "Method",
    "detail": "Function (UnicodeSet* U_EXPORT2)",
    "insertText": "createFromAll(const UnicodeString& s)"
  },
  {
    "label": "retain()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "retain(UChar32 start, UChar32 end)"
  },
  {
    "label": "retain()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "retain(UChar32 c)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "remove(UChar32 start, UChar32 end)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "remove(UChar32 c)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "remove(const UnicodeString& s)"
  },
  {
    "label": "complement()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "complement(void)"
  },
  {
    "label": "complement()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "complement(UChar32 start, UChar32 end)"
  },
  {
    "label": "complement()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "complement(UChar32 c)"
  },
  {
    "label": "complement()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "complement(const UnicodeString& s)"
  },
  {
    "label": "addAll()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "addAll(const UnicodeSet& c)"
  },
  {
    "label": "retainAll()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "retainAll(const UnicodeSet& c)"
  },
  {
    "label": "removeAll()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "removeAll(const UnicodeSet& c)"
  },
  {
    "label": "complementAll()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "complementAll(const UnicodeSet& c)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "clear(void)"
  },
  {
    "label": "closeOver()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "closeOver(int32_t attribute)"
  },
  {
    "label": "removeAllStrings()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "removeAllStrings()"
  },
  {
    "label": "getRangeCount()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "getRangeCount(void)"
  },
  {
    "label": "getRangeStart()",
    "kind": "Method",
    "detail": "Function (UChar32)",
    "insertText": "getRangeStart(int32_t index)"
  },
  {
    "label": "getRangeEnd()",
    "kind": "Method",
    "detail": "Function (UChar32)",
    "insertText": "getRangeEnd(int32_t index)"
  },
  {
    "label": "serialize()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "serialize(uint16_t *dest, int32_t destCapacity, UErrorCode& ec)"
  },
  {
    "label": "compact()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "compact()"
  },
  {
    "label": "getStaticClassID()",
    "kind": "Method",
    "detail": "Function (UClassID U_EXPORT2)",
    "insertText": "getStaticClassID(void)"
  },
  {
    "label": "getDynamicClassID()",
    "kind": "Method",
    "detail": "Function (UClassID)",
    "insertText": "getDynamicClassID(void)"
  },
  {
    "label": "getString()",
    "kind": "Method",
    "detail": "Function (private : class USetAccess ; const UnicodeString*)",
    "insertText": "getString(int32_t index)"
  },
  {
    "label": "matchesIndexValue()",
    "kind": "Method",
    "detail": "Function (private : UBool)",
    "insertText": "matchesIndexValue(uint8_t v)"
  },
  {
    "label": "UnicodeSet()",
    "kind": "Method",
    "detail": "Function (private : class RBBIRuleScanner ;)",
    "insertText": "UnicodeSet(const UnicodeSet& o, UBool)"
  },
  {
    "label": "copyFrom()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "copyFrom(const UnicodeSet& o, UBool asThawed)"
  },
  {
    "label": "applyPatternIgnoreSpace()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "applyPatternIgnoreSpace(const UnicodeString& pattern, ParsePosition& pos, const SymbolTable* symbols, UErrorCode& status)"
  },
  {
    "label": "applyPattern()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "applyPattern(RuleCharacterIterator& chars, const SymbolTable* symbols, UnicodeString& rebuiltPat, uint32_t options, UnicodeSet& (UnicodeSet::*caseClosure)(int32_t attribute), int32_t depth, UErrorCode& ec)"
  },
  {
    "label": "nextCapacity()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "nextCapacity(int32_t minCapacity)"
  },
  {
    "label": "ensureCapacity()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ensureCapacity(int32_t newLen)"
  },
  {
    "label": "ensureBufferCapacity()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ensureBufferCapacity(int32_t newLen)"
  },
  {
    "label": "swapBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swapBuffers(void)"
  },
  {
    "label": "allocateStrings()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "allocateStrings(UErrorCode &status)"
  },
  {
    "label": "hasStrings()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "hasStrings()"
  },
  {
    "label": "stringsSize()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "stringsSize()"
  },
  {
    "label": "stringsContains()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "stringsContains(const UnicodeString &s)"
  },
  {
    "label": "_toPattern()",
    "kind": "Method",
    "detail": "Function (UnicodeString&)",
    "insertText": "_toPattern(UnicodeString& result, UBool escapeUnprintable)"
  },
  {
    "label": "_generatePattern()",
    "kind": "Method",
    "detail": "Function (UnicodeString&)",
    "insertText": "_generatePattern(UnicodeString& result, UBool escapeUnprintable)"
  },
  {
    "label": "_appendToPat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_appendToPat(UnicodeString& buf, const UnicodeString& s, UBool escapeUnprintable)"
  },
  {
    "label": "_appendToPat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_appendToPat(UnicodeString& buf, UChar32 c, UBool escapeUnprintable)"
  },
  {
    "label": "exclusiveOr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "exclusiveOr(const UChar32* other, int32_t otherLen, int8_t polarity)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(const UChar32* other, int32_t otherLen, int8_t polarity)"
  },
  {
    "label": "retain()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "retain(const UChar32* other, int32_t otherLen, int8_t polarity)"
  },
  {
    "label": "resemblesPropertyPattern()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "resemblesPropertyPattern(const UnicodeString& pattern, int32_t pos)"
  },
  {
    "label": "resemblesPropertyPattern()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "resemblesPropertyPattern(RuleCharacterIterator& chars, int32_t iterOpts)"
  },
  {
    "label": "applyPropertyPattern()",
    "kind": "Method",
    "detail": "Function (UnicodeSet&)",
    "insertText": "applyPropertyPattern(const UnicodeString& pattern, ParsePosition& ppos, UErrorCode &ec)"
  },
  {
    "label": "applyPropertyPattern()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "applyPropertyPattern(RuleCharacterIterator& chars, UnicodeString& rebuiltPat, UErrorCode& ec)"
  },
  {
    "label": "getInclusions()",
    "kind": "Method",
    "detail": "Function (const UnicodeSet*)",
    "insertText": "getInclusions(int32_t src, UErrorCode &status)"
  },
  {
    "label": "UBool()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "UBool(*Filter)(UChar32 codePoint, void* context)"
  },
  {
    "label": "applyFilter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "applyFilter(Filter filter, void* context, const UnicodeSet* inclusions, UErrorCode &status)"
  },
  {
    "label": "applyIntPropertyValue()",
    "kind": "Method",
    "detail": "Function (# ifndef void)",
    "insertText": "applyIntPropertyValue(const UCPMap *map, UCPMapValueFilter *filter, const void *context, UErrorCode &errorCode)"
  },
  {
    "label": "setPattern()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "setPattern(const UnicodeString& newPat)"
  },
  {
    "label": "setPattern()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setPattern(newPat.getBuffer(), newPat.length())"
  },
  {
    "label": "setPattern()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setPattern(const char16_t *newPat, int32_t newPatLen)"
  },
  {
    "label": "releasePattern()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "releasePattern()"
  },
  {
    "label": "isBogus()",
    "kind": "Method",
    "detail": "Function (} UBool)",
    "insertText": "isBogus()"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (int32_t sLength = s .)",
    "insertText": "length()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (start = 0 ; } else)",
    "insertText": "if(start>sLength)"
  },
  {
    "label": "span()",
    "kind": "Method",
    "detail": "Function (start = sLength ; } return start +)",
    "insertText": "span(s.getBuffer()+start, sLength-start, spanCondition)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (limit = 0 ; } else)",
    "insertText": "if(limit>sLength)"
  },
  {
    "label": "spanBack()",
    "kind": "Method",
    "detail": "Function (limit = sLength ; } return)",
    "insertText": "spanBack(s.getBuffer(), limit, spanCondition)"
  }
]