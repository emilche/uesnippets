[
  {
    "label": "FRenderTarget",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRenderTarget"
  },
  {
    "label": "FOpenGLSamplerStateData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOpenGLSamplerStateData"
  },
  {
    "label": "EGLSamplerData",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EGLSamplerData"
  },
  {
    "label": "FOpenGLSamplerState",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FOpenGLSamplerState"
  },
  {
    "label": "FOpenGLRasterizerStateData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOpenGLRasterizerStateData"
  },
  {
    "label": "FOpenGLRasterizerState",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FOpenGLRasterizerState"
  },
  {
    "label": "FOpenGLDepthStencilStateData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOpenGLDepthStencilStateData"
  },
  {
    "label": "FOpenGLDepthStencilState",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FOpenGLDepthStencilState"
  },
  {
    "label": "FOpenGLBlendStateData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOpenGLBlendStateData"
  },
  {
    "label": "FOpenGLBlendState",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FOpenGLBlendState"
  },
  {
    "label": "FTextureStage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTextureStage"
  },
  {
    "label": "FOpenGLTexture",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FOpenGLTexture"
  },
  {
    "label": "FOpenGLShaderResourceView",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FOpenGLShaderResourceView"
  },
  {
    "label": "FUAVStage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FUAVStage"
  },
  {
    "label": "FOpenGLCachedAttr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOpenGLCachedAttr"
  },
  {
    "label": "FOpenGLStream",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOpenGLStream"
  },
  {
    "label": "FOpenGLCommonState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOpenGLCommonState"
  },
  {
    "label": "FOpenGLContextState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOpenGLContextState"
  },
  {
    "label": "FOpenGLRHIState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOpenGLRHIState"
  },
  {
    "label": "TOpenGLResourceTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TOpenGLResourceTraits"
  },
  {
    "label": "FOpenGLSamplerStateData()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Misc / AssertionMacros . h \" # include \" HAL / UnrealMemory . h \" # include \" Containers / Array . h \" # include \" Math / Color . h \" # include \" Math / IntRect . h \" # include \" RHIDefinitions . h \" # include \" Containers / StaticArray . h \" # include \" RHI . h \" # include \" OpenGLResources . h \" # define ZERO_FILLED_DUMMY_UNIFORM_BUFFER_SIZE 6 5 5 3 6 class FRenderTarget ; struct FOpenGLSamplerStateData { enum EGLSamplerData { EGLSamplerData_WrapS,EGLSamplerData_WrapT,EGLSamplerData_WrapR,EGLSamplerData_LODBias,EGLSamplerData_MagFilter,EGLSamplerData_MinFilter,EGLSamplerData_MaxAniso,EGLSamplerData_CompareMode,EGLSamplerData_CompareFunc,EGLSamplerData_Num,} ; GLint WrapS ; GLint WrapT ; GLint WrapR ; GLint LODBias ; GLint MagFilter ; GLint MinFilter ; GLint MaxAnisotropy ; GLint CompareMode ; GLint CompareFunc ;)",
    "insertText": "FOpenGLSamplerStateData() : WrapS(GL_REPEAT) , WrapT(GL_REPEAT) , WrapR(GL_REPEAT) , LODBias(0) , MagFilter(GL_NEAREST) , MinFilter(GL_NEAREST) , MaxAnisotropy(1) , CompareMode(GL_NONE) , CompareFunc(GL_ALWAYS)"
  },
  {
    "label": "FOpenGLSamplerState()",
    "kind": "Method",
    "detail": "Function (} } ; class FOpenGLSamplerState : public FRHISamplerState { public : GLuint Resource ; FOpenGLSamplerStateData Data ; ~)",
    "insertText": "FOpenGLSamplerState()"
  },
  {
    "label": "GetInitializer()",
    "kind": "Method",
    "detail": "Function (} ; struct FOpenGLRasterizerStateData { GLenum FillMode = GL_FILL ; GLenum CullMode = GL_NONE ; float DepthBias = 0 . 0 f ; float SlopeScaleDepthBias = 0 . 0 f ; ERasterizerDepthClipMode DepthClipMode = ERasterizerDepthClipMode::DepthClip ; } ; class FOpenGLRasterizerState : public FRHIRasterizerState { public : bool)",
    "insertText": "GetInitializer(FRasterizerStateInitializerRHI& Init)"
  },
  {
    "label": "FOpenGLDepthStencilStateData()",
    "kind": "Method",
    "detail": "Function (FOpenGLRasterizerStateData Data ; } ; struct FOpenGLDepthStencilStateData { bool bZEnable ; bool bZWriteEnable ; GLenum ZFunc ; bool bStencilEnable ; bool bTwoSidedStencilMode ; GLenum StencilFunc ; GLenum StencilFail ; GLenum StencilZFail ; GLenum StencilPass ; GLenum CCWStencilFunc ; GLenum CCWStencilFail ; GLenum CCWStencilZFail ; GLenum CCWStencilPass ; uint32 StencilReadMask ; uint32 StencilWriteMask ;)",
    "insertText": "FOpenGLDepthStencilStateData() : bZEnable(false) , bZWriteEnable(true) , ZFunc(GL_LESS) , bStencilEnable(false) , bTwoSidedStencilMode(false) , StencilFunc(GL_ALWAYS) , StencilFail(GL_KEEP) , StencilZFail(GL_KEEP) , StencilPass(GL_KEEP) , CCWStencilFunc(GL_ALWAYS) , CCWStencilFail(GL_KEEP) , CCWStencilZFail(GL_KEEP) , CCWStencilPass(GL_KEEP) , StencilReadMask(0xFFFFFFFF) , StencilWriteMask(0xFFFFFFFF)"
  },
  {
    "label": "GetInitializer()",
    "kind": "Method",
    "detail": "Function (} } ; class FOpenGLDepthStencilState : public FRHIDepthStencilState { public : bool)",
    "insertText": "GetInitializer(FDepthStencilStateInitializerRHI& Init)"
  },
  {
    "label": "FOpenGLBlendStateData()",
    "kind": "Method",
    "detail": "Function (FOpenGLDepthStencilStateData Data ; } ; struct FOpenGLBlendStateData { struct FRenderTarget { bool bAlphaBlendEnable ; GLenum ColorBlendOperation ; GLenum ColorSourceBlendFactor ; GLenum ColorDestBlendFactor ; bool bSeparateAlphaBlendEnable ; GLenum AlphaBlendOperation ; GLenum AlphaSourceBlendFactor ; GLenum AlphaDestBlendFactor ; uint32 ColorWriteMaskR : 1 ; uint32 ColorWriteMaskG : 1 ; uint32 ColorWriteMaskB : 1 ; uint32 ColorWriteMaskA : 1 ; } ; TStaticArray<FRenderTarget,MaxSimultaneousRenderTargets> RenderTargets ; bool bUseAlphaToCoverage ;)",
    "insertText": "FOpenGLBlendStateData()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bUseAlphaToCoverage = false ;)",
    "insertText": "for(int32 i = 0; i < MaxSimultaneousRenderTargets; ++i)"
  },
  {
    "label": "FOpenGLBlendState()",
    "kind": "Method",
    "detail": "Function (FRenderTarget& Target = RenderTargets [ i ] ; Target . bAlphaBlendEnable = false ; Target . ColorBlendOperation = GL_NONE ; Target . ColorSourceBlendFactor = GL_NONE ; Target . ColorDestBlendFactor = GL_NONE ; Target . bSeparateAlphaBlendEnable = false ; Target . AlphaBlendOperation = GL_NONE ; Target . AlphaSourceBlendFactor = GL_NONE ; Target . AlphaDestBlendFactor = GL_NONE ; Target . ColorWriteMaskR = false ; Target . ColorWriteMaskG = false ; Target . ColorWriteMaskB = false ; Target . ColorWriteMaskA = false ; } } } ; class FOpenGLBlendState : public FRHIBlendState { FBlendStateInitializerRHI RHIInitializer ; public :)",
    "insertText": "FOpenGLBlendState(const FBlendStateInitializerRHI& Initializer) : RHIInitializer(Initializer)"
  },
  {
    "label": "GetInitializer()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "GetInitializer(FBlendStateInitializerRHI& Init)"
  },
  {
    "label": "FTextureStage()",
    "kind": "Method",
    "detail": "Function (Init = RHIInitializer ; return true ; } FOpenGLBlendStateData Data ; } ; struct FTextureStage { class FOpenGLTexture* Texture ; class FOpenGLShaderResourceView* SRV ; GLenum Target ; GLuint Resource ; int32 LimitMip ; bool bHasMips ; int32 NumMips ;)",
    "insertText": "FTextureStage() : Texture(NULL) , SRV(NULL) , Target(GL_NONE) , Resource(0) , LimitMip(-1) , bHasMips(false) , NumMips(0)"
  },
  {
    "label": "FUAVStage()",
    "kind": "Method",
    "detail": "Function (} } ; struct FUAVStage { GLenum Format ; GLuint Resource ; GLenum Access ; GLint Layer ; bool bLayered ;)",
    "insertText": "FUAVStage() : Format(GL_NONE) , Resource(0) , Access(GL_READ_WRITE) , Layer(0) , bLayered(false)"
  },
  {
    "label": "FOpenGLCachedAttr_Invalid()",
    "kind": "Method",
    "detail": "Function (} } ; # define)",
    "insertText": "FOpenGLCachedAttr_Invalid(void*)(UPTRINT)0xFFFFFFFF #define FOpenGLCachedAttr_SingleVertex (void*)(UPTRINT)"
  },
  {
    "label": "FOpenGLCachedAttr()",
    "kind": "Method",
    "detail": "Function (GLuint Size ; GLenum Type ; GLuint StreamOffset ; GLuint StreamIndex ; GLboolean bNormalized ; GLboolean bShouldConvertToFloat ;)",
    "insertText": "FOpenGLCachedAttr() : Size(), Type(0), StreamOffset(), StreamIndex(0xFFFFFFFF), bNormalized(), bShouldConvertToFloat()"
  },
  {
    "label": "FOpenGLStream()",
    "kind": "Method",
    "detail": "Function (} } ; struct FOpenGLStream { GLuint VertexBufferResource ; uint32 Stride ; uint32 Offset ; uint32 Divisor ;)",
    "insertText": "FOpenGLStream() : VertexBufferResource(0) , Stride(0) , Offset(0) , Divisor(0)"
  },
  {
    "label": "FOpenGLCommonState()",
    "kind": "Method",
    "detail": "Function (} } ; # define NUM_OPENGL_VERTEX_STREAMS 1 6 struct FOpenGLCommonState { TArray<FTextureStage> Textures ; TArray<FOpenGLSamplerState*> SamplerStates ; TArray<FUAVStage> UAVs ;)",
    "insertText": "FOpenGLCommonState()"
  },
  {
    "label": "CleanupResources()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CleanupResources()"
  },
  {
    "label": "InitializeResources()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InitializeResources(int32 NumCombinedTextures, int32 NumCombinedUAVUnits)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (Textures .)",
    "insertText": "SetNum(NumCombinedTextures)"
  },
  {
    "label": "SetNumZeroed()",
    "kind": "Method",
    "detail": "Function (SamplerStates .)",
    "insertText": "SetNumZeroed(NumCombinedTextures)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (UAVs .)",
    "insertText": "Reserve(NumCombinedUAVUnits)"
  },
  {
    "label": "AddDefaulted()",
    "kind": "Method",
    "detail": "Function (UAVs .)",
    "insertText": "AddDefaulted(NumCombinedUAVUnits)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (SamplerStates .)",
    "insertText": "Empty()"
  },
  {
    "label": "GetVertexAttrEnabled()",
    "kind": "Method",
    "detail": "Function (} } ; struct FOpenGLContextState final : public FOpenGLCommonState { FOpenGLRasterizerStateData RasterizerState ; FOpenGLDepthStencilStateData DepthStencilState ; uint32 StencilRef ; FOpenGLBlendStateData BlendState ; GLuint Framebuffer ; uint32 RenderTargetWidth ; uint32 RenderTargetHeight ; GLuint OcclusionQuery ; GLuint Program ; GLuint UniformBuffers [ CrossCompiler::NUM_SHADER_STAGES* OGL_MAX_UNIFORM_BUFFER_BINDINGS ] ; GLuint UniformBufferOffsets [ CrossCompiler::NUM_SHADER_STAGES* OGL_MAX_UNIFORM_BUFFER_BINDINGS ] ; TArray<FOpenGLSamplerState*> CachedSamplerStates ; GLenum ActiveTexture ; bool bScissorEnabled ; FIntRect Scissor ; FIntRect Viewport ; float DepthMinZ ; float DepthMaxZ ; GLuint ArrayBufferBound ; GLuint ElementArrayBufferBound ; GLuint StorageBufferBound ; GLuint PixelUnpackBufferBound ; GLuint UniformBufferBound ; FLinearColor ClearColor ; uint16 ClearStencil ; float ClearDepth ; int32 FirstNonzeroRenderTarget ; bool bAlphaToCoverageEnabled ; bool bNonCoherentFramebufferFetchEnabled ; FOpenGLVertexDeclaration* VertexDecl ; FOpenGLCachedAttr VertexAttrs [ NUM_OPENGL_VERTEX_STREAMS ] ; FOpenGLStream VertexStreams [ NUM_OPENGL_VERTEX_STREAMS ] ; uint32 ActiveStreamMask ; uint32 VertexAttrs_EnabledBits ; bool)",
    "insertText": "GetVertexAttrEnabled(int32 Index)"
  },
  {
    "label": "SetVertexAttrEnabled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetVertexAttrEnabled(int32 Index, bool bEnable)"
  },
  {
    "label": "VertexAttrs_EnabledBits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VertexAttrs_EnabledBits(1 << Index)"
  },
  {
    "label": "FOpenGLContextState()",
    "kind": "Method",
    "detail": "Function (} } uint32 ActiveUAVMask ;)",
    "insertText": "FOpenGLContextState() : StencilRef(0) , Framebuffer(0) , Program(0) , ActiveTexture(GL_TEXTURE0) , bScissorEnabled(false) , DepthMinZ(0.0f) , DepthMaxZ(1.0f) , ArrayBufferBound(0) , ElementArrayBufferBound(0) , StorageBufferBound(0) , PixelUnpackBufferBound(0) , UniformBufferBound(0) , ClearColor(-1, -1, -1, -1) , ClearStencil(0xFFFF) , ClearDepth(-1.0f) , FirstNonzeroRenderTarget(0) , bAlphaToCoverageEnabled(false) , bNonCoherentFramebufferFetchEnabled(false) , VertexDecl(0) , VertexAttrs() , VertexStreams() , ActiveStreamMask(0) , VertexAttrs_EnabledBits(0) , ActiveUAVMask(0)"
  },
  {
    "label": "Memzero()",
    "kind": "Method",
    "detail": "Function (Scissor . Min . X = Scissor . Min . Y = Scissor . Max . X = Scissor . Max . Y = 0 ; Viewport . Min . X = Viewport . Min . Y = Viewport . Max . X = Viewport . Max . Y = 0 ;)",
    "insertText": "Memzero(UniformBuffers, sizeof(UniformBuffers))"
  },
  {
    "label": "Memzero()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memzero(UniformBufferOffsets, sizeof(UniformBufferOffsets))"
  },
  {
    "label": "InitializeResources()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeResources(NumCombinedTextures, NumCombinedUAVUnits)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (CachedSamplerStates .)",
    "insertText": "Empty(NumCombinedTextures)"
  },
  {
    "label": "AddZeroed()",
    "kind": "Method",
    "detail": "Function (CachedSamplerStates .)",
    "insertText": "AddZeroed(NumCombinedTextures)"
  },
  {
    "label": "FOpenGLRHIState()",
    "kind": "Method",
    "detail": "Function (} } ; struct FOpenGLRHIState final : public FOpenGLCommonState { FOpenGLRasterizerStateData RasterizerState ; FOpenGLDepthStencilStateData DepthStencilState ; uint32 StencilRef ; FOpenGLBlendStateData BlendState ; GLuint Framebuffer ; bool bScissorEnabled ; FIntRect Scissor ; FIntRect Viewport ; float DepthMinZ ; float DepthMaxZ ; GLuint ZeroFilledDummyUniformBuffer ; uint32 RenderTargetWidth ; uint32 RenderTargetHeight ; bool bAlphaToCoverageEnabled ; int32 NumRenderingSamples ; int32 FirstNonzeroRenderTarget ; FOpenGLTexture* RenderTargets [ MaxSimultaneousRenderTargets ] ; uint32 RenderTargetMipmapLevels [ MaxSimultaneousRenderTargets ] ; uint32 RenderTargetArrayIndex [ MaxSimultaneousRenderTargets ] ; FOpenGLTexture* DepthStencil ; ERenderTargetStoreAction StencilStoreAction ; uint32 DepthTargetWidth ; uint32 DepthTargetHeight ; bool bFramebufferSetupInvalid ; FOpenGLStream DynamicVertexStream ; uint32 NumVertices ; uint32 PrimitiveType ; uint32 NumPrimitives ; uint32 MinVertexIndex ; uint32 IndexDataStride ; FOpenGLStream Streams [ NUM_OPENGL_VERTEX_STREAMS ] ; FOpenGLLinkedProgram* LinkedProgramAndDirtyFlag ; FOpenGLShaderParameterCache* ShaderParameters ; TRefCountPtr<FOpenGLBoundShaderState> BoundShaderState ; TRefCountPtr<FOpenGLComputeShader> CurrentComputeShader ; enum { MAX_UNIFORM_BUFFERS_PER_SHADER_STAGE = 1 4 } ; FRHIUniformBuffer* BoundUniformBuffers [ SF_NumStandardFrequencies ] [ MAX_UNIFORM_BUFFERS_PER_SHADER_STAGE ] ; uint32 BoundUniformBuffersDynamicOffset [ SF_NumStandardFrequencies ] [ MAX_UNIFORM_BUFFERS_PER_SHADER_STAGE ] ; bool bAnyDirtyRealUniformBuffers [ SF_NumStandardFrequencies ] ; bool bAnyDirtyGraphicsUniformBuffers ; uint16 DirtyUniformBuffers [ SF_NumStandardFrequencies ] ; uint32 UpVertexBufferBytes ; uint32 UpIndexBufferBytes ; uint32 UpStride ; void* UpVertexBuffer ; void* UpIndexBuffer ;)",
    "insertText": "FOpenGLRHIState() : StencilRef(0) , Framebuffer(0) , bScissorEnabled(false) , DepthMinZ(0.0f) , DepthMaxZ(1.0f) , ZeroFilledDummyUniformBuffer(0) , RenderTargetWidth(0) , RenderTargetHeight(0) , bAlphaToCoverageEnabled(false) , NumRenderingSamples(1) , FirstNonzeroRenderTarget(-1) , DepthStencil(0) , StencilStoreAction(ERenderTargetStoreAction::ENoAction) , DepthTargetWidth(0) , DepthTargetHeight(0) , bFramebufferSetupInvalid(true) , NumVertices(0) , PrimitiveType(0) , NumPrimitives(0) , MinVertexIndex(0) , IndexDataStride(0) , LinkedProgramAndDirtyFlag(nullptr) , ShaderParameters(NULL) , BoundShaderState(NULL) , CurrentComputeShader(NULL) , UpVertexBufferBytes(0) , UpIndexBufferBytes(0) , UpVertexBuffer(0) , UpIndexBuffer(0)"
  },
  {
    "label": "Memset()",
    "kind": "Method",
    "detail": "Function (Scissor . Min . X = Scissor . Min . Y = Scissor . Max . X = Scissor . Max . Y = 0 ; Viewport . Min . X = Viewport . Min . Y = Viewport . Max . X = Viewport . Max . Y = 0 ;)",
    "insertText": "Memset(RenderTargets, 0, sizeof(RenderTargets))"
  },
  {
    "label": "Memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memset(RenderTargetMipmapLevels, 0, sizeof(RenderTargetMipmapLevels))"
  },
  {
    "label": "Memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memset(RenderTargetArrayIndex, 0, sizeof(RenderTargetArrayIndex))"
  },
  {
    "label": "Memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memset(BoundUniformBuffers, 0, sizeof(BoundUniformBuffers))"
  },
  {
    "label": "Memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memset(BoundUniformBuffersDynamicOffset, 0u, sizeof(BoundUniformBuffersDynamicOffset))"
  },
  {
    "label": "FOpenGLRHIState()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FOpenGLRHIState()"
  },
  {
    "label": "InitializeResources()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InitializeResources(int32 NumCombinedTextures, int32 NumComputeUAVUnits)"
  }
]