[
  {
    "label": "TRAITS",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRAITS"
  },
  {
    "label": "ITypedScalarProperty",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ITypedScalarProperty"
  },
  {
    "label": "getInterpretation()",
    "kind": "Method",
    "detail": "Function (# ifndef Alembic_Abc_ITypedScalarProperty_h # define Alembic_Abc_ITypedScalarProperty_h # include<Alembic / Abc / Foundation . h> # include<Alembic / Abc / IScalarProperty . h> # include<Alembic / Abc / TypedPropertyTraits . h> namespace Alembic { namespace Abc { namespace ALEMBIC_VERSION_NS { template<class TRAITS> class ITypedScalarProperty : public IScalarProperty { public : typedef TRAITS traits_type ; typedef ITypedScalarProperty<TRAITS> this_type ; typedef TRAITS::value_type value_type ; const char*)",
    "insertText": "getInterpretation()"
  },
  {
    "label": "matches()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "matches(const AbcA::MetaData &iMetaData, SchemaInterpMatching iMatching = kStrictMatching)"
  },
  {
    "label": "matches()",
    "kind": "Method",
    "detail": "Function (} return true ; } bool)",
    "insertText": "matches(const AbcA::PropertyHeader &iHeader, SchemaInterpMatching iMatching = kStrictMatching)"
  },
  {
    "label": "ITypedScalarProperty()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ITypedScalarProperty()"
  },
  {
    "label": "ITypedScalarProperty()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ITypedScalarProperty(const ICompoundProperty & iParent, const std::string &iName, const Argument &iArg0 = Argument(), const Argument &iArg1 = Argument())"
  },
  {
    "label": "args()",
    "kind": "Method",
    "detail": "Function (Arguments)",
    "insertText": "args(GetErrorHandlerPolicy( iParent ))"
  },
  {
    "label": "setInto()",
    "kind": "Method",
    "detail": "Function (iArg0 .)",
    "insertText": "setInto(args)"
  },
  {
    "label": "getErrorHandler()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getErrorHandler().setPolicy( args.getErrorHandlerPolicy())"
  },
  {
    "label": "ALEMBIC_ABC_SAFE_CALL_BEGIN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ALEMBIC_ABC_SAFE_CALL_BEGIN(\"ITypedScalarProperty::ITypedScalarProperty()\")"
  },
  {
    "label": "getPtr()",
    "kind": "Method",
    "detail": "Function (AbcA::CompoundPropertyReaderPtr parent = iParent .)",
    "insertText": "getPtr()"
  },
  {
    "label": "ABCA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABCA_ASSERT(parent != NULL, \"NULL CompoundPropertyReader passed into \" << \"ITypedScalarProperty ctor\")"
  },
  {
    "label": "getPropertyHeader()",
    "kind": "Method",
    "detail": "Function (const AbcA::PropertyHeader* pheader = parent ->)",
    "insertText": "getPropertyHeader(iName)"
  },
  {
    "label": "ABCA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABCA_ASSERT(pheader != NULL, \"Nonexistent scalar property: \" << iName)"
  },
  {
    "label": "ABCA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABCA_ASSERT(matches( *pheader, args.getSchemaInterpMatching() ), \"Incorrect match of header datatype: \" << pheader->getDataType() << \" to expected: \" << TRAITS::dataType() << \",\\n...or incorrect match of interpretation: \" << pheader->getMetaData().get( \"interpretation\" ) << \" to expected: \" << TRAITS::interpretation())"
  },
  {
    "label": "getScalarProperty()",
    "kind": "Method",
    "detail": "Function (m_property = parent ->)",
    "insertText": "getScalarProperty(iName)"
  },
  {
    "label": "ALEMBIC_ABC_SAFE_CALL_END_RESET()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ALEMBIC_ABC_SAFE_CALL_END_RESET()"
  },
  {
    "label": "ITypedScalarProperty()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ITypedScalarProperty(AbcA::ScalarPropertyReaderPtr iProperty, const Argument &iArg0 = Argument(), const Argument &iArg1 = Argument())"
  },
  {
    "label": "getHeader()",
    "kind": "Method",
    "detail": "Function (const AbcA::PropertyHeader& pheader = iProperty ->)",
    "insertText": "getHeader()"
  },
  {
    "label": "ABCA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABCA_ASSERT(matches( pheader, GetSchemaInterpMatching( iArg0, iArg1 ) ), \"Incorrect match of header datatype: \" << pheader.getDataType() << \" to expected: \" << TRAITS::dataType() << \",\\n...or incorrect match of interpretation: \" << pheader.getMetaData().get( \"interpretation\" ) << \" to expected: \" << TRAITS::interpretation())"
  },
  {
    "label": "ITypedScalarProperty()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ITypedScalarProperty(AbcA::ScalarPropertyReaderPtr iProp, WrapExistingFlag iWrapFlag, const Argument &iArg0 = Argument(), const Argument &iArg1 = Argument())"
  },
  {
    "label": "ITypedScalarProperty()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "ITypedScalarProperty(iProp, iArg0, iArg1)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "get(value_type &iVal, const ISampleSelector &iSS = ISampleSelector())"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "get(reinterpret_cast<void*>( &iVal ), iSS)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (} value_type)",
    "insertText": "getValue(const ISampleSelector &iSS = ISampleSelector())"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (value_type ret ;)",
    "insertText": "get(ret, iSS)"
  }
]