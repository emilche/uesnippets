[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TAABB",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TAABB"
  },
  {
    "label": "FCylinder",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCylinder"
  },
  {
    "label": "TSphere",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSphere"
  },
  {
    "label": "TPlane",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPlane"
  },
  {
    "label": "TParticles",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TParticles"
  },
  {
    "label": "FBVHParticles",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FBVHParticles"
  },
  {
    "label": "FImplicitObject",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FImplicitObject"
  },
  {
    "label": "TImplicitObjectPtrStorage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TImplicitObjectPtrStorage"
  },
  {
    "label": "TImplicitTypeInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TImplicitTypeInfo"
  },
  {
    "label": "T_DERIVED",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T_DERIVED"
  },
  {
    "label": "TRACK_CHAOS_GEOMETRY()",
    "kind": "Method",
    "detail": "Function (# pragma once # include<atomic> # include \" Chaos / Pair . h \" # include \" Chaos / Serializable . h \" # include \" Chaos / Core . h \" # include \" Chaos / ImplicitFwd . h \" # include \" Chaos / ImplicitObjectType . h \" # include \" Chaos / AABB . h \" # include \" Chaos / RefCountedObject . h \" # include \" Templates / RefCounting . h \" # include \" AutoRTFM / AutoRTFM . h \" # ifndef TRACK_CHAOS_GEOMETRY # define)",
    "insertText": "TRACK_CHAOS_GEOMETRY(UE_BUILD_SHIPPING || UE_BUILD_TEST)"
  },
  {
    "label": "Convert()",
    "kind": "Method",
    "detail": "Function (template<class T,int d> class TAABB ; class FCylinder ; template<class T,int d> class TSphere ; template<class T,int d> class TPlane ; template<class T,int d> class TParticles ; class FBVHParticles ; class FImplicitObject ; using FAABB3 = TAABB<FReal,3> ; using FParticles = TParticles<FReal,3> ; using FSphere = TSphere<FReal,3> ; template<class T,int d,bool bSerializable> struct TImplicitObjectPtrStorage { } ; template<class T,int d> struct TImplicitObjectPtrStorage<T,d,false> { using PtrType = FImplicitObjectRef ; PtrType)",
    "insertText": "Convert(const Chaos::FImplicitObjectPtr& Object)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (using FImplicitHierarchyVisitorBool = TFunctionRef<)",
    "insertText": "bool(const FImplicitObject* Implicit, const FRigidTransform3& Transform, const int32 RootObjectIndex, const int32 ObjectIndex, const int32 LeafObjectIndex)"
  },
  {
    "label": "IsBaseOf()",
    "kind": "Method",
    "detail": "Function (template<T> struct TImplicitTypeInfo { bool)",
    "insertText": "IsBaseOf(const EImplicitObjectType InType)"
  },
  {
    "label": "SerializationFactory()",
    "kind": "Method",
    "detail": "Function (} } ; # define DISALLOW_FIMPLICIT_OBJECT_TAIL_PADDING INTEL_ISPC class FImplicitObject : public FChaosRefCountedObject { public : using TType = FReal ; int D = 3 ; FImplicitObject*)",
    "insertText": "SerializationFactory(FChaosArchive& Ar, FImplicitObject* Obj)"
  },
  {
    "label": "FImplicitObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FImplicitObject(int32 Flags, EImplicitObjectType InType = ImplicitObjectType::Unknown)"
  },
  {
    "label": "FImplicitObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FImplicitObject(const FImplicitObject&)"
  },
  {
    "label": "FImplicitObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FImplicitObject(FImplicitObject&&)"
  },
  {
    "label": "FImplicitObject()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FImplicitObject()"
  },
  {
    "label": "IsA()",
    "kind": "Method",
    "detail": "Function (template<TargetType> bool)",
    "insertText": "IsA()"
  },
  {
    "label": "AsA()",
    "kind": "Method",
    "detail": "Function (} template<TargetType> const TargetType*)",
    "insertText": "AsA()"
  },
  {
    "label": "AsAChecked()",
    "kind": "Method",
    "detail": "Function (} return nullptr ; } template<TargetType> const TargetType*)",
    "insertText": "AsAChecked()"
  },
  {
    "label": "GetObject()",
    "kind": "Method",
    "detail": "Function (} template<class T_DERIVED> T_DERIVED*)",
    "insertText": "GetObject()"
  },
  {
    "label": "GetObjectChecked()",
    "kind": "Method",
    "detail": "Function (} return nullptr ; } template<class T_DERIVED> const T_DERIVED&)",
    "insertText": "GetObjectChecked()"
  },
  {
    "label": "GetNestedType()",
    "kind": "Method",
    "detail": "Function (} EImplicitObjectType)",
    "insertText": "GetNestedType()"
  },
  {
    "label": "GetType()",
    "kind": "Method",
    "detail": "Function (} EImplicitObjectType)",
    "insertText": "GetType()"
  },
  {
    "label": "GetOffsetOfType()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetOffsetOfType()"
  },
  {
    "label": "GetCollisionType()",
    "kind": "Method",
    "detail": "Function (} EImplicitObjectType)",
    "insertText": "GetCollisionType()"
  },
  {
    "label": "SetCollisionType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCollisionType(EImplicitObjectType InCollisionType)"
  },
  {
    "label": "GetRadius()",
    "kind": "Method",
    "detail": "Function (CollisionType = InCollisionType ; } FReal)",
    "insertText": "GetRadius()"
  },
  {
    "label": "IsValidGeometry()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValidGeometry()"
  },
  {
    "label": "CopyGeometry()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectPtr)",
    "insertText": "CopyGeometry()"
  },
  {
    "label": "CopyGeometryWithScale()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectPtr)",
    "insertText": "CopyGeometryWithScale(const FVec3& Scale)"
  },
  {
    "label": "DeepCopyGeometry()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectPtr)",
    "insertText": "DeepCopyGeometry()"
  },
  {
    "label": "DeepCopyGeometryWithScale()",
    "kind": "Method",
    "detail": "Function (} Chaos::FImplicitObjectPtr)",
    "insertText": "DeepCopyGeometryWithScale(const FVec3& Scale)"
  },
  {
    "label": "IsUnderlyingMesh()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsUnderlyingMesh()"
  },
  {
    "label": "SignedDistance()",
    "kind": "Method",
    "detail": "Function (FReal)",
    "insertText": "SignedDistance(const FVec3& x)"
  },
  {
    "label": "Normal()",
    "kind": "Method",
    "detail": "Function (FVec3)",
    "insertText": "Normal(const FVec3& x)"
  },
  {
    "label": "PhiWithNormal()",
    "kind": "Method",
    "detail": "Function (FReal)",
    "insertText": "PhiWithNormal(const FVec3& x, FVec3& Normal)"
  },
  {
    "label": "PhiWithNormalScaled()",
    "kind": "Method",
    "detail": "Function (FReal)",
    "insertText": "PhiWithNormalScaled(const FVec3& Pos, const FVec3& Scale, FVec3& Normal)"
  },
  {
    "label": "PhiWithNormal()",
    "kind": "Method",
    "detail": "Function (const FVec3 UnscaledX = Pos / Scale ; FVec3 UnscaledNormal ; const FReal UnscaledPhi =)",
    "insertText": "PhiWithNormal(UnscaledX, UnscaledNormal)"
  },
  {
    "label": "SafeNormalize()",
    "kind": "Method",
    "detail": "Function (Normal = Scale* UnscaledNormal ; const FReal ScaleFactor = Normal .)",
    "insertText": "SafeNormalize()"
  },
  {
    "label": "BoundingBox()",
    "kind": "Method",
    "detail": "Function (const FReal ScaledPhi = UnscaledPhi* ScaleFactor ; return ScaledPhi ; } const FAABB3)",
    "insertText": "BoundingBox()"
  },
  {
    "label": "CalculateTransformedBounds()",
    "kind": "Method",
    "detail": "Function (FAABB3)",
    "insertText": "CalculateTransformedBounds(const FRigidTransform3& Transform)"
  },
  {
    "label": "HasBoundingBox()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasBoundingBox()"
  },
  {
    "label": "SetDoCollide()",
    "kind": "Method",
    "detail": "Function (bIsConvex = Convex ; } void)",
    "insertText": "SetDoCollide(const bool Collide)"
  },
  {
    "label": "GetDoCollide()",
    "kind": "Method",
    "detail": "Function (bDoCollide = Collide ; } bool)",
    "insertText": "GetDoCollide()"
  },
  {
    "label": "IsPerformanceWarning()",
    "kind": "Method",
    "detail": "Function (# endif bool)",
    "insertText": "IsPerformanceWarning()"
  },
  {
    "label": "FindDeepestIntersection()",
    "kind": "Method",
    "detail": "Function (} ; Pair<FVec3,bool>)",
    "insertText": "FindDeepestIntersection(const FImplicitObject* Other, const FBVHParticles* Particles, const FMatrix33& OtherToLocalTransform, const FReal Thickness)"
  },
  {
    "label": "FindDeepestIntersection()",
    "kind": "Method",
    "detail": "Function (Pair<FVec3,bool>)",
    "insertText": "FindDeepestIntersection(const FImplicitObject* Other, const FParticles* Particles, const FMatrix33& OtherToLocalTransform, const FReal Thickness)"
  },
  {
    "label": "FindClosestIntersection()",
    "kind": "Method",
    "detail": "Function (Pair<FVec3,bool>)",
    "insertText": "FindClosestIntersection(const FVec3& StartPoint, const FVec3& EndPoint, const FReal Thickness)"
  },
  {
    "label": "Raycast()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Raycast(const FVec3& StartPoint, const FVec3& Dir, const FReal Length, const FReal Thickness, FReal& OutTime, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex)"
  },
  {
    "label": "FindClosestIntersection()",
    "kind": "Method",
    "detail": "Function (OutFaceIndex = INDEX_NONE ; const FVec3 EndPoint = StartPoint + Dir* Length ; Pair<FVec3,bool> Result =)",
    "insertText": "FindClosestIntersection(StartPoint, EndPoint, Thickness)"
  },
  {
    "label": "Normal()",
    "kind": "Method",
    "detail": "Function (OutPosition = Result . First ; OutNormal =)",
    "insertText": "Normal(Result.First)"
  },
  {
    "label": "Length()",
    "kind": "Method",
    "detail": "Function (OutTime =)",
    "insertText": "Length(OutPosition - StartPoint).Size()"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (const FReal UnscaledSearchDist = SearchDist / Scale .)",
    "insertText": "Min()"
  },
  {
    "label": "GetInnerUnscaledNormal()",
    "kind": "Method",
    "detail": "Function (const FVec3 UnscaledPosition = Position / Scale ; const FVec3 UnscaledDir =)",
    "insertText": "GetInnerUnscaledNormal(UnitDir, Scale)"
  },
  {
    "label": "FindClosestFaceAndVertices()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "FindClosestFaceAndVertices(const FVec3& Position, TArray<FVec3>& FaceVertices, FReal SearchDist = 0.01f)"
  },
  {
    "label": "AccumulateAllImplicitObjects()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AccumulateAllImplicitObjects(TArray<Pair<const FImplicitObject*, FRigidTransform3>>& Out, const FRigidTransform3& ParentTM)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Out .)",
    "insertText": "Add(MakePair(this, ParentTM))"
  },
  {
    "label": "FindAllIntersectingObjects()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "FindAllIntersectingObjects(TArray < Pair<const FImplicitObject*, FRigidTransform3>>& Out, const FAABB3& LocalBounds)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "ToString()"
  },
  {
    "label": "SerializeImp()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SerializeImp(FArchive& Ar)"
  },
  {
    "label": "StaticType()",
    "kind": "Method",
    "detail": "Function (EImplicitObjectType)",
    "insertText": "StaticType()"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Serialize(FChaosArchive& Ar)"
  },
  {
    "label": "SerializeLegacyHelper()",
    "kind": "Method",
    "detail": "Function (FArchive&)",
    "insertText": "SerializeLegacyHelper(FArchive& Ar, TUniquePtr<FImplicitObject>& Value)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetTypeHash()"
  },
  {
    "label": "GetTypeName()",
    "kind": "Method",
    "detail": "Function (FName)",
    "insertText": "GetTypeName()"
  },
  {
    "label": "GetTypeName()",
    "kind": "Method",
    "detail": "Function (} const FName)",
    "insertText": "GetTypeName(const EImplicitObjectType InType)"
  },
  {
    "label": "GetMaterialIndex()",
    "kind": "Method",
    "detail": "Function (uint16)",
    "insertText": "GetMaterialIndex(uint32 HintIndex)"
  },
  {
    "label": "CountLeafObjectsInHierarchy()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "CountLeafObjectsInHierarchy()"
  },
  {
    "label": "VisitOverlappingLeafObjects()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VisitOverlappingLeafObjects(const FAABB3& LocalBounds, const FImplicitHierarchyVisitor& Visitor)"
  },
  {
    "label": "VisitOverlappingLeafObjectsImpl()",
    "kind": "Method",
    "detail": "Function (int32 LeafObjectIndex = 0 ; int32 ObjectIndex = 0 ; const int32 RootObjectIndex = INDEX_NONE ;)",
    "insertText": "VisitOverlappingLeafObjectsImpl(LocalBounds, FRigidTransform3::Identity, RootObjectIndex, ObjectIndex, LeafObjectIndex, Visitor)"
  },
  {
    "label": "VisitLeafObjects()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VisitLeafObjects(const FImplicitHierarchyVisitor& Visitor)"
  },
  {
    "label": "VisitLeafObjectsImpl()",
    "kind": "Method",
    "detail": "Function (int32 LeafObjectIndex = 0 ; int32 ObjectIndex = 0 ; const int32 RootObjectIndex = INDEX_NONE ;)",
    "insertText": "VisitLeafObjectsImpl(FRigidTransform3::Identity, RootObjectIndex, ObjectIndex, LeafObjectIndex, Visitor)"
  },
  {
    "label": "VisitObjects()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VisitObjects(const FImplicitHierarchyVisitorBool& Visitor)"
  },
  {
    "label": "VisitObjectsImpl()",
    "kind": "Method",
    "detail": "Function (int32 LeafObjectIndex = 0 ; int32 ObjectIndex = 0 ; const int32 RootObjectIndex = INDEX_NONE ;)",
    "insertText": "VisitObjectsImpl(FRigidTransform3::Identity, RootObjectIndex, ObjectIndex, LeafObjectIndex, Visitor)"
  },
  {
    "label": "IsOverlappingBounds()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsOverlappingBounds(const FAABB3& LocalBounds)"
  },
  {
    "label": "CountObjectsInHierarchyImpl()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "CountObjectsInHierarchyImpl()"
  },
  {
    "label": "VisitorFunc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VisitorFunc(this, ObjectTransform, RootObjectIndex, ObjectIndex, LeafObjectIndex)"
  },
  {
    "label": "VisitLeafObjectsImpl()",
    "kind": "Method",
    "detail": "Function (} + + ObjectIndex ; + + LeafObjectIndex ; } void)",
    "insertText": "VisitLeafObjectsImpl(const FRigidTransform3& ObjectTransform, const int32 RootObjectIndex, int32& ObjectIndex, int32& LeafObjectIndex, const FImplicitHierarchyVisitor& VisitorFunc)"
  },
  {
    "label": "VisitObjectsImpl()",
    "kind": "Method",
    "detail": "Function (+ + ObjectIndex ; + + LeafObjectIndex ; } bool)",
    "insertText": "VisitObjectsImpl(const FRigidTransform3& ObjectTransform, const int32 RootObjectIndex, int32& ObjectIndex, int32& LeafObjectIndex, const FImplicitHierarchyVisitorBool& VisitorFunc)"
  },
  {
    "label": "IsOverlappingBoundsImpl()",
    "kind": "Method",
    "detail": "Function (+ + ObjectIndex ; + + LeafObjectIndex ; return bResult ; } bool)",
    "insertText": "IsOverlappingBoundsImpl(const FAABB3& LocalBounds)"
  },
  {
    "label": "ScaleNormalizedHelper()",
    "kind": "Method",
    "detail": "Function (} protected : FVec3)",
    "insertText": "ScaleNormalizedHelper(const FVec3& Normal, const FVec3& Scale)"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (const FVec3 ScaledNormal = Scale* Normal ; const FReal ScaledNormalLen = ScaledNormal .)",
    "insertText": "Size()"
  },
  {
    "label": "GetOuterScaledNormal()",
    "kind": "Method",
    "detail": "Function (} FVec3)",
    "insertText": "GetOuterScaledNormal(const FVec3& InnerNormal, const FVec3& Scale)"
  },
  {
    "label": "GetInnerUnscaledNormal()",
    "kind": "Method",
    "detail": "Function (} FVec3)",
    "insertText": "GetInnerUnscaledNormal(const FVec3& OuterNormal, const FVec3& Scale)"
  },
  {
    "label": "SetMargin()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetMargin(FReal InMargin)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (Margin = InMargin ; } FReal Margin ; bool bIsConvex ; bool bDoCollide ; bool bHasBoundingBox ; # if TRACK_CHAOS_GEOMETRY bool bIsTracked ; # else # if DISALLOW_FIMPLICIT_OBJECT_TAIL_PADDING bool bPad ; # endif # endif EImplicitObjectType Type ; EImplicitObjectType CollisionType ; # if DISALLOW_FIMPLICIT_OBJECT_TAIL_PADDING)",
    "insertText": "static_assert(alignof(bool) <= sizeof(FReal))"
  },
  {
    "label": "AlignOfFImplicitObject()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "AlignOfFImplicitObject(int)FMath::Max(alignof(FReal), FMath::Max(alignof(bool), alignof(EImplicitObjectType)))"
  },
  {
    "label": "AlignOfFImplicitObject()",
    "kind": "Method",
    "detail": "Function (int PadBytes =)",
    "insertText": "AlignOfFImplicitObject(sizeof(FReal) + 4 * sizeof(bool) + 2 * sizeof(EImplicitObjectType))"
  },
  {
    "label": "FindClosestIntersectionImp()",
    "kind": "Method",
    "detail": "Function (char Pad [ PadBytes ] ; # endif private : Pair<FVec3,bool>)",
    "insertText": "FindClosestIntersectionImp(const FVec3& StartPoint, const FVec3& EndPoint, const FReal Thickness)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar, FImplicitObject& Value)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Value .)",
    "insertText": "Serialize(Ar)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T,. . . TArgs)",
    "insertText": "UE_REQUIRES(!std::is_array_v<T>) > FORCEINLINE Chaos::FConstImplicitObjectPtr MakeImplicitObjectConstPtr(TArgs&&... Args)"
  }
]