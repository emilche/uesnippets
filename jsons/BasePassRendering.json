[
  {
    "label": "FScene",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FScene"
  },
  {
    "label": "TUniformBufferRef",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TUniformBufferRef"
  },
  {
    "label": "FSceneWithoutWaterTextures",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSceneWithoutWaterTextures"
  },
  {
    "label": "FViewInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FViewInfo"
  },
  {
    "label": "UMaterialExpressionSingleLayerWaterMaterialOutput",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UMaterialExpressionSingleLayerWaterMaterialOutput"
  },
  {
    "label": "FForwardLocalLightData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FForwardLocalLightData"
  },
  {
    "label": "FForwardBasePassTextures",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FForwardBasePassTextures"
  },
  {
    "label": "FForwardLightingParameters",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FForwardLightingParameters"
  },
  {
    "label": "TBasePassShaderElementData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TBasePassShaderElementData"
  },
  {
    "label": "TBasePassVertexShaderPolicyParamType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TBasePassVertexShaderPolicyParamType"
  },
  {
    "label": "TBasePassVertexShaderBaseType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TBasePassVertexShaderBaseType"
  },
  {
    "label": "TBasePassVS",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TBasePassVS"
  },
  {
    "label": "TBasePassComputeShaderPolicyParamType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TBasePassComputeShaderPolicyParamType"
  },
  {
    "label": "TBasePassComputeShaderBaseType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TBasePassComputeShaderBaseType"
  },
  {
    "label": "TBasePassCS",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TBasePassCS"
  },
  {
    "label": "TBasePassPixelShaderPolicyParamType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TBasePassPixelShaderPolicyParamType"
  },
  {
    "label": "TBasePassPixelShaderBaseType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TBasePassPixelShaderBaseType"
  },
  {
    "label": "TBasePassPS",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TBasePassPS"
  },
  {
    "label": "FSupportOITDim",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSupportOITDim"
  },
  {
    "label": "F128BitRTBasePassPS",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "F128BitRTBasePassPS"
  },
  {
    "label": "FBasePassMeshProcessor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FBasePassMeshProcessor"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FNaniteBasePassData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FNaniteBasePassData"
  },
  {
    "label": "IsSortedPixelsEnabledForProject()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" HAL / IConsoleManager . h \" # include \" RHI . h \" # include \" ShaderParameters . h \" # include \" Shader . h \" # include \" HitProxies . h \" # include \" RHIStaticStates . h \" # include \" SceneManagement . h \" # include \" Materials / Material . h \" # include \" PostProcess / SceneRenderTargets . h \" # include \" DBufferTextures . h \" # include \" LightMapRendering . h \" # include \" VelocityRendering . h \" # include \" MeshMaterialShaderType . h \" # include \" MeshMaterialShader . h \" # include \" ShaderBaseClasses . h \" # include \" FogRendering . h \" # include \" TranslucentLighting . h \" # include \" PlanarReflectionRendering . h \" # include \" UnrealEngine . h \" # include \" ReflectionEnvironment . h \" # include \" Substrate / Substrate . h \" # include \" OIT / OITParameters . h \" # include \" VirtualShadowMaps / VirtualShadowMapArray . h \" # include \" VolumetricCloudRendering . h \" # include \" Nanite / NaniteMaterials . h \" # include \" BlueNoise . h \" # include \" LocalFogVolumeRendering . h \" # include \" LightFunctionAtlas . h \" # include \" RenderUtils . h \" # include \" SceneTexturesConfig . h \" # include \" HeterogeneousVolumes / HeterogeneousVolumes . h \" class FScene ; template<TBufferStruct> class TUniformBufferRef ; struct FSceneWithoutWaterTextures ; class FViewInfo ; class UMaterialExpressionSingleLayerWaterMaterialOutput ; namespace OIT { bool)",
    "insertText": "IsSortedPixelsEnabledForProject(EShaderPlatform InPlatform)"
  },
  {
    "label": "BEGIN_GLOBAL_SHADER_PARAMETER_STRUCT()",
    "kind": "Method",
    "detail": "Function (} int32 GIndirectLightingCache ; class FForwardLocalLightData { public : FVector4f LightPositionAndInvRadius ; FVector4f LightColorAndIdAndFalloffExponent ; FVector4f LightDirectionAndShadowMapChannelMask ; FVector4f SpotAnglesAndSourceRadiusPacked ; FVector4f LightTangentAndIESDataAndSpecularScale ; FVector4f RectDataAndVirtualShadowMapIdOrPrevLocalLightIndex ; } ; struct FForwardBasePassTextures { FRDGTextureRef ScreenSpaceAO = nullptr ; FRDGTextureRef ScreenSpaceShadowMask = nullptr ; FRDGTextureRef SceneDepthIfResolved = nullptr ; bool bIs24BitUnormDepthStencil = false ; } ;)",
    "insertText": "BEGIN_GLOBAL_SHADER_PARAMETER_STRUCT(FSharedBasePassUniformParameters,) SHADER_PARAMETER_STRUCT(FForwardLightData, Forward) SHADER_PARAMETER_STRUCT(FForwardLightData, ForwardISR) SHADER_PARAMETER_STRUCT(FReflectionUniformParameters, Reflection) SHADER_PARAMETER_STRUCT(FPlanarReflectionUniformParameters, PlanarReflection) SHADER_PARAMETER_STRUCT(FFogUniformParameters, Fog) SHADER_PARAMETER_STRUCT(FFogUniformParameters, FogISR) SHADER_PARAMETER_STRUCT(FLocalFogVolumeUniformParameters, LFV) SHADER_PARAMETER_STRUCT(LightFunctionAtlas::FLightFunctionAtlasGlobalParameters, LightFunctionAtlas) SHADER_PARAMETER(uint32, UseBasePassSkylight) END_GLOBAL_SHADER_PARAMETER_STRUCT() BEGIN_GLOBAL_SHADER_PARAMETER_STRUCT(FOpaqueBasePassUniformParameters,) SHADER_PARAMETER_STRUCT(FSharedBasePassUniformParameters, Shared) SHADER_PARAMETER_STRUCT(FSubstrateBasePassUniformParameters, Substrate) SHADER_PARAMETER(int32, UseForwardScreenSpaceShadowMask) SHADER_PARAMETER_RDG_TEXTURE(Texture2D, ForwardScreenSpaceShadowMaskTexture) SHADER_PARAMETER_RDG_TEXTURE(Texture2D, IndirectOcclusionTexture) SHADER_PARAMETER_RDG_TEXTURE(Texture2D, ResolvedSceneDepthTexture) SHADER_PARAMETER_STRUCT_INCLUDE(FDBufferParameters, DBuffer) SHADER_PARAMETER_TEXTURE(Texture2D, PreIntegratedGFTexture) SHADER_PARAMETER_SAMPLER(SamplerState, PreIntegratedGFSampler) SHADER_PARAMETER(int32, Is24BitUnormDepthStencil) SHADER_PARAMETER_RDG_BUFFER_SRV(StructuredBuffer<float4>, EyeAdaptationBuffer) END_GLOBAL_SHADER_PARAMETER_STRUCT() BEGIN_GLOBAL_SHADER_PARAMETER_STRUCT(FTranslucentBasePassUniformParameters,) SHADER_PARAMETER_STRUCT(FSharedBasePassUniformParameters, Shared) SHADER_PARAMETER_STRUCT(FSceneTextureUniformParameters, SceneTextures) SHADER_PARAMETER_STRUCT(FSubstrateForwardPassUniformParameters, Substrate) SHADER_PARAMETER_STRUCT(FLightCloudTransmittanceParameters, ForwardDirLightCloudShadow) SHADER_PARAMETER_STRUCT(FOITBasePassUniformParameters, OIT) SHADER_PARAMETER(FVector4f, HZBUvFactorAndInvFactor) SHADER_PARAMETER(FVector4f, PrevScreenPositionScaleBias) SHADER_PARAMETER(FVector2f, PrevSceneColorBilinearUVMin) SHADER_PARAMETER(FVector2f, PrevSceneColorBilinearUVMax) SHADER_PARAMETER(float, PrevSceneColorPreExposureInv) SHADER_PARAMETER(int32, SSRQuality) SHADER_PARAMETER_RDG_TEXTURE(Texture2D, HZBTexture) SHADER_PARAMETER_SAMPLER(SamplerState, HZBSampler) SHADER_PARAMETER_RDG_TEXTURE_SRV(Texture2D, PrevSceneColor) SHADER_PARAMETER_SAMPLER(SamplerState, PrevSceneColorSampler) SHADER_PARAMETER_RDG_TEXTURE(Texture2D, VolumetricCloudColor) SHADER_PARAMETER_SAMPLER(SamplerState, VolumetricCloudColorSampler) SHADER_PARAMETER_RDG_TEXTURE(Texture2D, VolumetricCloudDepth) SHADER_PARAMETER_SAMPLER(SamplerState, VolumetricCloudDepthSampler) SHADER_PARAMETER(float, ApplyVolumetricCloudOnTransparent) SHADER_PARAMETER(float, SoftBlendingDistanceKm) SHADER_PARAMETER_STRUCT_INCLUDE(FTranslucencyLightingVolumeParameters, TranslucencyLightingVolume) SHADER_PARAMETER_STRUCT_INCLUDE(FLumenTranslucencyLightingParameters, LumenParameters) SHADER_PARAMETER_TEXTURE(Texture2D, PreIntegratedGFTexture) SHADER_PARAMETER_SAMPLER(SamplerState, PreIntegratedGFSampler) SHADER_PARAMETER_RDG_BUFFER_SRV(StructuredBuffer<float4>, EyeAdaptationBuffer) SHADER_PARAMETER_RDG_TEXTURE(Texture2D, SceneColorCopyTexture) SHADER_PARAMETER_SAMPLER(SamplerState, SceneColorCopySampler) SHADER_PARAMETER_STRUCT(FBlueNoiseParameters, BlueNoise) SHADER_PARAMETER_STRUCT(FAdaptiveVolumetricShadowMapUniformBufferParameters, AVSM) SHADER_PARAMETER(int, TranslucencyPass) END_GLOBAL_SHADER_PARAMETER_STRUCT() DECLARE_GPU_DRAWCALL_STAT_EXTERN(Basepass)"
  },
  {
    "label": "DECLARE_GPU_STAT_NAMED_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_GPU_STAT_NAMED_EXTERN(NaniteBasePass, TEXT(\"Nanite BasePass\"))"
  },
  {
    "label": "SetupSharedBasePassParameters()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetupSharedBasePassParameters(FRDGBuilder& GraphBuilder, const FViewInfo& View, const int32 ViewIndex, bool bLumenGIEnabled, FSharedBasePassUniformParameters& BasePassParameters)"
  },
  {
    "label": "CreateOpaqueBasePassUniformBuffer()",
    "kind": "Method",
    "detail": "Function (TRDGUniformBufferRef<FOpaqueBasePassUniformParameters>)",
    "insertText": "CreateOpaqueBasePassUniformBuffer(FRDGBuilder& GraphBuilder, const FViewInfo& View, const int32 ViewIndex = 0, const FForwardBasePassTextures& ForwardBasePassTextures = {}, const FDBufferTextures& DBufferTextures = {}, bool bLumenGIEnabled = false)"
  },
  {
    "label": "CreateTranslucentBasePassUniformBuffer()",
    "kind": "Method",
    "detail": "Function (TRDGUniformBufferRef<FTranslucentBasePassUniformParameters>)",
    "insertText": "CreateTranslucentBasePassUniformBuffer(FRDGBuilder& GraphBuilder, const FScene* Scene, const FViewInfo& View, const int32 ViewIndex = 0, const FTranslucencyLightingVolumeTextures& TranslucencyLightingVolumeTextures = {}, FRDGTextureRef SceneColorCopyTexture = nullptr, const ESceneTextureSetupMode SceneTextureSetupMode = ESceneTextureSetupMode::None, bool bLumenGIEnabled = false, ETranslucencyPass::Type TranslucencyPass = ETranslucencyPass::TPT_MAX)"
  },
  {
    "label": "IsGBufferLayoutSupportedForMaterial()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsGBufferLayoutSupportedForMaterial(EGBufferLayout Layout, const FMeshMaterialShaderPermutationParameters& Params)"
  },
  {
    "label": "ModifyBasePassCSPSCompilationEnvironment()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ModifyBasePassCSPSCompilationEnvironment(const FMeshMaterialShaderPermutationParameters& Params, EGBufferLayout GBufferLayout, bool bEnableSkyLight, FShaderCompilerEnvironment& OutEnvironment)"
  },
  {
    "label": "ModifyCompilationEnvironment()",
    "kind": "Method",
    "detail": "Function (class FForwardLightingParameters { public : void)",
    "insertText": "ModifyCompilationEnvironment(EShaderPlatform Platform, FShaderCompilerEnvironment& OutEnvironment)"
  },
  {
    "label": "SetDefine()",
    "kind": "Method",
    "detail": "Function (OutEnvironment .)",
    "insertText": "SetDefine(TEXT(\"LOCAL_LIGHT_DATA_STRIDE\"), FMath::DivideAndRoundUp<int32>(sizeof(FForwardLocalLightData), sizeof(FVector4f)))"
  },
  {
    "label": "SetDefine()",
    "kind": "Method",
    "detail": "Function (int32 NumCulledLightsGridStride ; OutEnvironment .)",
    "insertText": "SetDefine(TEXT(\"NUM_CULLED_LIGHTS_GRID_STRIDE\"), NumCulledLightsGridStride)"
  },
  {
    "label": "SetDefine()",
    "kind": "Method",
    "detail": "Function (int32 NumCulledGridPrimitiveTypes ; OutEnvironment .)",
    "insertText": "SetDefine(TEXT(\"NUM_CULLED_GRID_PRIMITIVE_TYPES\"), NumCulledGridPrimitiveTypes)"
  },
  {
    "label": "TBasePassShaderElementData()",
    "kind": "Method",
    "detail": "Function (} } ; template<LightMapPolicyType> class TBasePassShaderElementData : public FMeshMaterialShaderElementData { public :)",
    "insertText": "TBasePassShaderElementData(const typename LightMapPolicyType::ElementDataType& InLightMapPolicyElementData) : LightMapPolicyElementData(InLightMapPolicyElementData)"
  },
  {
    "label": "DECLARE_INLINE_TYPE_LAYOUT_EXPLICIT_BASES()",
    "kind": "Method",
    "detail": "Function (} LightMapPolicyType::ElementDataType LightMapPolicyElementData ; } ; template<LightMapPolicyType> class TBasePassVertexShaderPolicyParamType : public FMeshMaterialShader,public LightMapPolicyType::VertexParametersType {)",
    "insertText": "DECLARE_INLINE_TYPE_LAYOUT_EXPLICIT_BASES(TBasePassVertexShaderPolicyParamType, NonVirtual, FMeshMaterialShader, typename LightMapPolicyType::VertexParametersType)"
  },
  {
    "label": "TBasePassVertexShaderPolicyParamType()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "TBasePassVertexShaderPolicyParamType()"
  },
  {
    "label": "TBasePassVertexShaderPolicyParamType()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBasePassVertexShaderPolicyParamType(const FMeshMaterialShaderType::CompiledShaderInitializerType& Initializer): FMeshMaterialShader(Initializer)"
  },
  {
    "label": "Bind()",
    "kind": "Method",
    "detail": "Function (LightMapPolicyType::)",
    "insertText": "Bind(Initializer.ParameterMap)"
  },
  {
    "label": "Bind()",
    "kind": "Method",
    "detail": "Function (ReflectionCaptureBuffer .)",
    "insertText": "Bind(Initializer.ParameterMap, TEXT(\"ReflectionCapture\"))"
  },
  {
    "label": "ModifyCompilationEnvironment()",
    "kind": "Method",
    "detail": "Function (} public : void)",
    "insertText": "ModifyCompilationEnvironment(const FMaterialShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)"
  },
  {
    "label": "ModifyCompilationEnvironment()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ModifyCompilationEnvironment(Parameters, OutEnvironment)"
  },
  {
    "label": "ModifyCompilationEnvironment()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ModifyCompilationEnvironment(Parameters.Platform, OutEnvironment)"
  },
  {
    "label": "GetShaderBindings()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetShaderBindings(const FScene* Scene, ERHIFeatureLevel::Type FeatureLevel, const FPrimitiveSceneProxy* PrimitiveSceneProxy, const FMaterialRenderProxy& MaterialRenderProxy, const FMaterial& Material, const TBasePassShaderElementData<LightMapPolicyType>& ShaderElementData, FMeshDrawSingleShaderBindings& ShaderBindings)"
  },
  {
    "label": "GetElementShaderBindings()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetElementShaderBindings(const FShaderMapPointerTable& PointerTable, const FScene* Scene, const FSceneView* ViewIfDynamicMeshCommand, const FVertexFactory* VertexFactory, const EVertexInputStreamType InputStreamType, ERHIFeatureLevel::Type FeatureLevel, const FPrimitiveSceneProxy* PrimitiveSceneProxy, const FMeshBatch& MeshBatch, const FMeshBatchElement& BatchElement, const TBasePassShaderElementData<LightMapPolicyType>& ShaderElementData, FMeshDrawSingleShaderBindings& ShaderBindings, FVertexInputStreamArray& VertexStreams)"
  },
  {
    "label": "LAYOUT_FIELD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LAYOUT_FIELD(FShaderUniformBufferParameter, ReflectionCaptureBuffer)"
  },
  {
    "label": "DECLARE_INLINE_TYPE_LAYOUT()",
    "kind": "Method",
    "detail": "Function (} ; template<LightMapPolicyType> class TBasePassVertexShaderBaseType : public TBasePassVertexShaderPolicyParamType<LightMapPolicyType> { typedef TBasePassVertexShaderPolicyParamType<LightMapPolicyType> Super ;)",
    "insertText": "DECLARE_INLINE_TYPE_LAYOUT(TBasePassVertexShaderBaseType, NonVirtual)"
  },
  {
    "label": "TBasePassVertexShaderBaseType()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "TBasePassVertexShaderBaseType(const FMeshMaterialShaderType::CompiledShaderInitializerType& Initializer) : Super(Initializer)"
  },
  {
    "label": "TBasePassVertexShaderBaseType()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBasePassVertexShaderBaseType()"
  },
  {
    "label": "ShouldCompilePermutation()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "ShouldCompilePermutation(const FMeshMaterialShaderPermutationParameters& Parameters)"
  },
  {
    "label": "ModifyCompilationEnvironment()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ModifyCompilationEnvironment(const FMeshMaterialShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)"
  },
  {
    "label": "SetCompileArgument()",
    "kind": "Method",
    "detail": "Function (OutEnvironment .)",
    "insertText": "SetCompileArgument(TEXT(\"USING_VARIABLE_RATE_SHADING\"), true)"
  },
  {
    "label": "DECLARE_SHADER_TYPE()",
    "kind": "Method",
    "detail": "Function (} } } ; template<LightMapPolicyType> class TBasePassVS : public TBasePassVertexShaderBaseType<LightMapPolicyType> {)",
    "insertText": "DECLARE_SHADER_TYPE(TBasePassVS,MeshMaterial)"
  },
  {
    "label": "TBasePassVS()",
    "kind": "Method",
    "detail": "Function (typedef TBasePassVertexShaderBaseType<LightMapPolicyType> Super ; protected :)",
    "insertText": "TBasePassVS()"
  },
  {
    "label": "TBasePassVS()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBasePassVS(const FMeshMaterialShaderType::CompiledShaderInitializerType& Initializer): Super(Initializer)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (const auto SupportAllShaderPermutations =)",
    "insertText": "Get().FindTConsoleVariableDataInt(TEXT(\"r.SupportAllShaderPermutations\"))"
  },
  {
    "label": "GetValueOnAnyThread()",
    "kind": "Method",
    "detail": "Function (const bool bForceAllPermutations = SupportAllShaderPermutations&& SupportAllShaderPermutations ->)",
    "insertText": "GetValueOnAnyThread()"
  },
  {
    "label": "ShouldCompilePermutation()",
    "kind": "Method",
    "detail": "Function (bool bShouldCache =)",
    "insertText": "ShouldCompilePermutation(Parameters)"
  },
  {
    "label": "SetDefine()",
    "kind": "Method",
    "detail": "Function (OutEnvironment .)",
    "insertText": "SetDefine(TEXT(\"BASEPASS_SKYATMOSPHERE_AERIALPERSPECTIVE\"), !IsMetalMRTPlatform(Parameters.Platform) ? 1 : 0)"
  },
  {
    "label": "BEGIN_UNIFORM_BUFFER_STRUCT()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "BEGIN_UNIFORM_BUFFER_STRUCT(FComputeShadingOutputs, ) SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, OutTarget0) SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, OutTarget1) SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, OutTarget2) SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, OutTarget3) SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, OutTarget4) SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, OutTarget5) SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, OutTarget6) SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, OutTarget7) SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2DArray<uint>, OutTargets) SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<SUBSTRATE_TOP_LAYER_TYPE>, OutTopLayerTarget) END_UNIFORM_BUFFER_STRUCT()"
  },
  {
    "label": "DECLARE_INLINE_TYPE_LAYOUT_EXPLICIT_BASES()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_INLINE_TYPE_LAYOUT_EXPLICIT_BASES(TBasePassComputeShaderPolicyParamType, NonVirtual, FMeshMaterialShader, typename LightMapPolicyType::ComputeParametersType)"
  },
  {
    "label": "ValidateCompiledResult()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ValidateCompiledResult(EShaderPlatform Platform, const FShaderParameterMap& ParameterMap, TArray<FString>& OutError)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutError .)",
    "insertText": "Add(TEXT(\"Base pass shaders cannot read from the SceneTexturesStruct.\"))"
  },
  {
    "label": "Bind()",
    "kind": "Method",
    "detail": "Function (ShadingOutputsParam .)",
    "insertText": "Bind(Initializer.ParameterMap, TEXT(\"ComputeShadingOutputs\"))"
  },
  {
    "label": "Bind()",
    "kind": "Method",
    "detail": "Function (ViewRectParam .)",
    "insertText": "Bind(Initializer.ParameterMap, TEXT(\"ViewRect\"))"
  },
  {
    "label": "Bind()",
    "kind": "Method",
    "detail": "Function (PassDataParam .)",
    "insertText": "Bind(Initializer.ParameterMap, TEXT(\"PassData\"))"
  },
  {
    "label": "Bind()",
    "kind": "Method",
    "detail": "Function (Target0 .)",
    "insertText": "Bind(Initializer.ParameterMap, TEXT(\"ComputeShadingOutputs.OutTarget0\"))"
  },
  {
    "label": "Bind()",
    "kind": "Method",
    "detail": "Function (Target1 .)",
    "insertText": "Bind(Initializer.ParameterMap, TEXT(\"ComputeShadingOutputs.OutTarget1\"))"
  },
  {
    "label": "Bind()",
    "kind": "Method",
    "detail": "Function (Target2 .)",
    "insertText": "Bind(Initializer.ParameterMap, TEXT(\"ComputeShadingOutputs.OutTarget2\"))"
  },
  {
    "label": "Bind()",
    "kind": "Method",
    "detail": "Function (Target3 .)",
    "insertText": "Bind(Initializer.ParameterMap, TEXT(\"ComputeShadingOutputs.OutTarget3\"))"
  },
  {
    "label": "Bind()",
    "kind": "Method",
    "detail": "Function (Target4 .)",
    "insertText": "Bind(Initializer.ParameterMap, TEXT(\"ComputeShadingOutputs.OutTarget4\"))"
  },
  {
    "label": "Bind()",
    "kind": "Method",
    "detail": "Function (Target5 .)",
    "insertText": "Bind(Initializer.ParameterMap, TEXT(\"ComputeShadingOutputs.OutTarget5\"))"
  },
  {
    "label": "Bind()",
    "kind": "Method",
    "detail": "Function (Target6 .)",
    "insertText": "Bind(Initializer.ParameterMap, TEXT(\"ComputeShadingOutputs.OutTarget6\"))"
  },
  {
    "label": "Bind()",
    "kind": "Method",
    "detail": "Function (Target7 .)",
    "insertText": "Bind(Initializer.ParameterMap, TEXT(\"ComputeShadingOutputs.OutTarget7\"))"
  },
  {
    "label": "Bind()",
    "kind": "Method",
    "detail": "Function (Targets .)",
    "insertText": "Bind(Initializer.ParameterMap, TEXT(\"ComputeShadingOutputs.OutTargets\"))"
  },
  {
    "label": "TBasePassComputeShaderPolicyParamType()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBasePassComputeShaderPolicyParamType()"
  },
  {
    "label": "SetPassParameters()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetPassParameters(FRHIBatchedShaderParameters& BatchedParameters, const FUintVector4& ViewRect, const FUintVector4& PassData, FRHIUniformBuffer* ShadingOutputs)"
  },
  {
    "label": "GetBoundTargetMask()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetBoundTargetMask()"
  },
  {
    "label": "LAYOUT_FIELD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LAYOUT_FIELD(FShaderUniformBufferParameter, ShadingOutputsParam)"
  },
  {
    "label": "LAYOUT_FIELD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LAYOUT_FIELD(FShaderParameter, ViewRectParam)"
  },
  {
    "label": "LAYOUT_FIELD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LAYOUT_FIELD(FShaderParameter, PassDataParam)"
  },
  {
    "label": "LAYOUT_FIELD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LAYOUT_FIELD(FShaderUniformBufferMemberParameter, Target0)"
  },
  {
    "label": "LAYOUT_FIELD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LAYOUT_FIELD(FShaderUniformBufferMemberParameter, Target1)"
  },
  {
    "label": "LAYOUT_FIELD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LAYOUT_FIELD(FShaderUniformBufferMemberParameter, Target2)"
  },
  {
    "label": "LAYOUT_FIELD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LAYOUT_FIELD(FShaderUniformBufferMemberParameter, Target3)"
  },
  {
    "label": "LAYOUT_FIELD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LAYOUT_FIELD(FShaderUniformBufferMemberParameter, Target4)"
  },
  {
    "label": "LAYOUT_FIELD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LAYOUT_FIELD(FShaderUniformBufferMemberParameter, Target5)"
  },
  {
    "label": "LAYOUT_FIELD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LAYOUT_FIELD(FShaderUniformBufferMemberParameter, Target6)"
  },
  {
    "label": "LAYOUT_FIELD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LAYOUT_FIELD(FShaderUniformBufferMemberParameter, Target7)"
  },
  {
    "label": "LAYOUT_FIELD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LAYOUT_FIELD(FShaderUniformBufferMemberParameter, Targets)"
  },
  {
    "label": "DECLARE_INLINE_TYPE_LAYOUT()",
    "kind": "Method",
    "detail": "Function (} ; template<LightMapPolicyType> class TBasePassComputeShaderBaseType : public TBasePassComputeShaderPolicyParamType<LightMapPolicyType> { typedef TBasePassComputeShaderPolicyParamType<LightMapPolicyType> Super ;)",
    "insertText": "DECLARE_INLINE_TYPE_LAYOUT(TBasePassComputeShaderBaseType, NonVirtual)"
  },
  {
    "label": "TBasePassComputeShaderBaseType()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBasePassComputeShaderBaseType(const FMeshMaterialShaderType::CompiledShaderInitializerType& Initializer) : Super(Initializer)"
  },
  {
    "label": "TBasePassComputeShaderBaseType()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBasePassComputeShaderBaseType()"
  },
  {
    "label": "DECLARE_SHADER_TYPE()",
    "kind": "Method",
    "detail": "Function (} } ; template<LightMapPolicyType,bool bEnableSkyLight,EShaderFrequency ShaderFrequency> class TBasePassCS : public TBasePassComputeShaderBaseType<LightMapPolicyType> {)",
    "insertText": "DECLARE_SHADER_TYPE(TBasePassCS,MeshMaterial)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (const auto SupportStationarySkylight =)",
    "insertText": "Get().FindTConsoleVariableDataInt(TEXT(\"r.SupportStationarySkylight\"))"
  },
  {
    "label": "HasShadingModel()",
    "kind": "Method",
    "detail": "Function (const bool IsSingleLayerWater = Parameters . MaterialParameters . ShadingModels .)",
    "insertText": "HasShadingModel(MSM_SingleLayerWater)"
  },
  {
    "label": "IsTranslucentBlendMode()",
    "kind": "Method",
    "detail": "Function (const bool bTranslucent =)",
    "insertText": "IsTranslucentBlendMode(Parameters.MaterialParameters)"
  },
  {
    "label": "IsSingleLayerWater()",
    "kind": "Method",
    "detail": "Function (const bool bCacheShaders = ! bEnableSkyLight | | bTranslucent | |)",
    "insertText": "IsSingleLayerWater((bProjectSupportsStationarySkylight || IsForwardShadingEnabled(Parameters.Platform)) && Parameters.MaterialParameters.ShadingModels.IsLit())"
  },
  {
    "label": "ModifyBasePassCSPSCompilationEnvironment()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ModifyBasePassCSPSCompilationEnvironment(Parameters, GBL_ForceVelocity, bEnableSkyLight, OutEnvironment)"
  },
  {
    "label": "SetDefine()",
    "kind": "Method",
    "detail": "Function (OutEnvironment .)",
    "insertText": "SetDefine(TEXT(\"COMPUTE_SHADED\"), 1)"
  },
  {
    "label": "SetDefine()",
    "kind": "Method",
    "detail": "Function (OutEnvironment .)",
    "insertText": "SetDefine(TEXT(\"WORKGRAPH_NODE\"), 1)"
  },
  {
    "label": "GetSingleLayerWaterUsesLightFunctionAtlas()",
    "kind": "Method",
    "detail": "Function (const bool bSingleLayerWaterUsesLightFunctionAtlas = bIsSingleLayerWater&&)",
    "insertText": "GetSingleLayerWaterUsesLightFunctionAtlas()"
  },
  {
    "label": "GetTranslucentUsesLightFunctionAtlas()",
    "kind": "Method",
    "detail": "Function (const bool bTranslucentUsesLightFunctionAtlas = bTranslucent&&)",
    "insertText": "GetTranslucentUsesLightFunctionAtlas()"
  },
  {
    "label": "SetDefine()",
    "kind": "Method",
    "detail": "Function (OutEnvironment .)",
    "insertText": "SetDefine(TEXT(\"USE_LIGHT_FUNCTION_ATLAS\"), (bSingleLayerWaterUsesLightFunctionAtlas || bTranslucentUsesLightFunctionAtlas) ? TEXT(\"1\") : TEXT(\"0\"))"
  },
  {
    "label": "TBasePassCS()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBasePassCS(const ShaderMetaType::CompiledShaderInitializerType& Initializer): TBasePassComputeShaderBaseType<LightMapPolicyType>(Initializer)"
  },
  {
    "label": "TBasePassCS()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBasePassCS()"
  },
  {
    "label": "DECLARE_INLINE_TYPE_LAYOUT_EXPLICIT_BASES()",
    "kind": "Method",
    "detail": "Function (} } ; template<LightMapPolicyType> class TBasePassPixelShaderPolicyParamType : public FMeshMaterialShader,public LightMapPolicyType::PixelParametersType {)",
    "insertText": "DECLARE_INLINE_TYPE_LAYOUT_EXPLICIT_BASES(TBasePassPixelShaderPolicyParamType, NonVirtual, FMeshMaterialShader, typename LightMapPolicyType::PixelParametersType)"
  },
  {
    "label": "TBasePassPixelShaderPolicyParamType()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBasePassPixelShaderPolicyParamType()"
  },
  {
    "label": "DECLARE_INLINE_TYPE_LAYOUT()",
    "kind": "Method",
    "detail": "Function (} ; template<LightMapPolicyType> class TBasePassPixelShaderBaseType : public TBasePassPixelShaderPolicyParamType<LightMapPolicyType> { typedef TBasePassPixelShaderPolicyParamType<LightMapPolicyType> Super ;)",
    "insertText": "DECLARE_INLINE_TYPE_LAYOUT(TBasePassPixelShaderBaseType, NonVirtual)"
  },
  {
    "label": "TBasePassPixelShaderBaseType()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBasePassPixelShaderBaseType(const FMeshMaterialShaderType::CompiledShaderInitializerType& Initializer) : Super(Initializer)"
  },
  {
    "label": "TBasePassPixelShaderBaseType()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBasePassPixelShaderBaseType()"
  },
  {
    "label": "DECLARE_SHADER_TYPE()",
    "kind": "Method",
    "detail": "Function (} } ; template<LightMapPolicyType,bool bEnableSkyLight,EGBufferLayout GBufferLayout> class TBasePassPS : public TBasePassPixelShaderBaseType<LightMapPolicyType> {)",
    "insertText": "DECLARE_SHADER_TYPE(TBasePassPS,MeshMaterial)"
  },
  {
    "label": "SHADER_PERMUTATION_BOOL()",
    "kind": "Method",
    "detail": "Function (class FSupportOITDim :)",
    "insertText": "SHADER_PERMUTATION_BOOL(\"PERMUTATION_SUPPORTS_OIT\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FPermutationDomain PermutationVector { Parameters . PermutationId } ;)",
    "insertText": "if(PermutationVector.template Get<FSupportOITDim>())"
  },
  {
    "label": "ModifyBasePassCSPSCompilationEnvironment()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ModifyBasePassCSPSCompilationEnvironment(Parameters, GBufferLayout, bEnableSkyLight, OutEnvironment)"
  },
  {
    "label": "IsSingleLayerWaterDepthPrepassEnabled()",
    "kind": "Method",
    "detail": "Function (const bool bHasDepthPrepass =)",
    "insertText": "IsSingleLayerWaterDepthPrepassEnabled(Parameters.Platform, GetMaxSupportedFeatureLevel(Parameters.Platform))"
  },
  {
    "label": "SetDefine()",
    "kind": "Method",
    "detail": "Function (OutEnvironment .)",
    "insertText": "SetDefine(TEXT(\"SINGLE_LAYER_WATER_NO_DISCARD\"), TEXT(\"1\"))"
  },
  {
    "label": "SetDefine()",
    "kind": "Method",
    "detail": "Function (OutEnvironment .)",
    "insertText": "SetDefine(TEXT(\"ADAPTIVE_VOLUMETRIC_SHADOW_MAP\"), TEXT(\"1\"))"
  },
  {
    "label": "TBasePassPS()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBasePassPS(const ShaderMetaType::CompiledShaderInitializerType& Initializer): TBasePassPixelShaderBaseType<LightMapPolicyType>(Initializer)"
  },
  {
    "label": "TBasePassPS()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBasePassPS()"
  },
  {
    "label": "DECLARE_SHADER_TYPE()",
    "kind": "Method",
    "detail": "Function (} } ; class F128BitRTBasePassPS : public TBasePassPS<TUniformLightMapPolicy<LMP_NO_LIGHTMAP>,false,GBL_Default> {)",
    "insertText": "DECLARE_SHADER_TYPE(F128BitRTBasePassPS, MeshMaterial)"
  },
  {
    "label": "F128BitRTBasePassPS()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "F128BitRTBasePassPS()"
  },
  {
    "label": "F128BitRTBasePassPS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "F128BitRTBasePassPS(const ShaderMetaType::CompiledShaderInitializerType& Initializer)"
  },
  {
    "label": "AddBasePassComputeShader()",
    "kind": "Method",
    "detail": "Function (} ; template<LightMapPolicyType> void)",
    "insertText": "AddBasePassComputeShader(bool bEnableSkyLight, EShaderFrequency ShaderFrequency, FMaterialShaderTypes& OutShaderTypes)"
  },
  {
    "label": "SF_Compute()",
    "kind": "Method",
    "detail": "Function (OutShaderTypes . AddShaderType<TBasePassCS<LightMapPolicyType,true,)",
    "insertText": "SF_Compute()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(ShaderFrequency == SF_WorkGraphComputeNode)"
  },
  {
    "label": "SF_WorkGraphComputeNode()",
    "kind": "Method",
    "detail": "Function (OutShaderTypes . AddShaderType<TBasePassCS<LightMapPolicyType,true,)",
    "insertText": "SF_WorkGraphComputeNode()"
  },
  {
    "label": "GetBasePassShader()",
    "kind": "Method",
    "detail": "Function (} } } template<LightMapPolicyType> bool)",
    "insertText": "GetBasePassShader(const FMaterial& Material, const FVertexFactoryType* VertexFactoryType, LightMapPolicyType LightMapPolicy, ERHIFeatureLevel::Type FeatureLevel, bool bEnableSkyLight, EShaderFrequency ShaderFrequency, TShaderRef<TBasePassComputeShaderPolicyParamType<LightMapPolicyType>>* ComputeShader)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FMaterialShaderTypes ShaderTypes ;)",
    "insertText": "if(ComputeShader)"
  },
  {
    "label": "LightMapPolicyType()",
    "kind": "Method",
    "detail": "Function (AddBasePassComputeShader<)",
    "insertText": "LightMapPolicyType(bEnableSkyLight, ShaderFrequency, ShaderTypes)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} FMaterialShaders Shaders ;)",
    "insertText": "if(!Material.TryGetShaders(ShaderTypes, VertexFactoryType, Shaders))"
  },
  {
    "label": "AddBasePassPixelShader()",
    "kind": "Method",
    "detail": "Function (template<LightMapPolicyType,EGBufferLayout GBufferLayout> void)",
    "insertText": "AddBasePassPixelShader(bool bEnableSkyLight, FMaterialShaderTypes& OutShaderTypes, bool bIsForOITPass = false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 PermutationId = 0 ;)",
    "insertText": "if(bIsForOITPass)"
  },
  {
    "label": "FSupportOITDim()",
    "kind": "Method",
    "detail": "Function (using FMyShader = TBasePassPS<LightMapPolicyType,true,GBufferLayout> ; FMyShader::FPermutationDomain PermutationVector ; PermutationVector . template Set<)",
    "insertText": "FSupportOITDim(true)"
  },
  {
    "label": "ToDimensionValueId()",
    "kind": "Method",
    "detail": "Function (PermutationId = PermutationVector .)",
    "insertText": "ToDimensionValueId()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bEnableSkyLight)"
  },
  {
    "label": "GBufferLayout()",
    "kind": "Method",
    "detail": "Function (OutShaderTypes . AddShaderType<TBasePassPS<LightMapPolicyType,true,)",
    "insertText": "GBufferLayout(PermutationId)"
  },
  {
    "label": "GetBasePassShaders()",
    "kind": "Method",
    "detail": "Function (} } template<LightMapPolicyType> bool)",
    "insertText": "GetBasePassShaders(const FMaterial& Material, const FVertexFactoryType* VertexFactoryType, LightMapPolicyType LightMapPolicy, ERHIFeatureLevel::Type FeatureLevel, bool bEnableSkyLight, bool bUse128bitRT, EGBufferLayout GBufferLayout, TShaderRef<TBasePassVertexShaderPolicyParamType<LightMapPolicyType>>* VertexShader, TShaderRef<TBasePassPixelShaderPolicyParamType<LightMapPolicyType>>* PixelShader, bool bIsForOITPass = false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FMaterialShaderTypes ShaderTypes ;)",
    "insertText": "if(VertexShader)"
  },
  {
    "label": "LightMapPolicyType()",
    "kind": "Method",
    "detail": "Function (ShaderTypes . AddShaderType<TBasePassVS<)",
    "insertText": "LightMapPolicyType()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(PixelShader)"
  },
  {
    "label": "GBL_ForceVelocity()",
    "kind": "Method",
    "detail": "Function (break ; case GBL_ForceVelocity : AddBasePassPixelShader<LightMapPolicyType,)",
    "insertText": "GBL_ForceVelocity(bEnableSkyLight, ShaderTypes, bIsForOITPass)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (break ; default :)",
    "insertText": "check(false)"
  },
  {
    "label": "TryGetPixelShader()",
    "kind": "Method",
    "detail": "Function (Shaders .)",
    "insertText": "TryGetPixelShader(PixelShader)"
  },
  {
    "label": "CanUseDepthStencil()",
    "kind": "Method",
    "detail": "Function (class FBasePassMeshProcessor : public FSceneRenderingAllocatorObject<FBasePassMeshProcessor>,public FMeshPassProcessor { public : enum class EFlags { None = 0,)",
    "insertText": "CanUseDepthStencil(1 << 0), bRequires128bitRT = (1 << 1)"
  },
  {
    "label": "FBasePassMeshProcessor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBasePassMeshProcessor(EMeshPass::Type InMeshPassType, const FScene* InScene, ERHIFeatureLevel::Type InFeatureLevel, const FSceneView* InViewIfDynamicMeshCommand, const FMeshPassProcessorRenderState& InDrawRenderState, FMeshPassDrawListContext* InDrawListContext, EFlags Flags, ETranslucencyPass::Type InTranslucencyPassType = ETranslucencyPass::TPT_MAX)"
  },
  {
    "label": "AddMeshBatch()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddMeshBatch(const FMeshBatch& RESTRICT MeshBatch, uint64 BatchElementMask, const FPrimitiveSceneProxy* RESTRICT PrimitiveSceneProxy, int32 StaticMeshId = -1)"
  },
  {
    "label": "CollectPSOInitializers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CollectPSOInitializers(const FSceneTexturesConfig& SceneTexturesConfig, const FMaterial& Material, const FPSOPrecacheVertexFactoryData& VertexFactoryData, const FPSOPrecacheParams& PreCacheParams, TArray<FPSOPrecacheData>& PSOInitializers)"
  },
  {
    "label": "Set128BitRequirement()",
    "kind": "Method",
    "detail": "Function (FMeshPassProcessorRenderState PassDrawRenderState ; void)",
    "insertText": "Set128BitRequirement(const bool Required)"
  },
  {
    "label": "Get128BitRequirement()",
    "kind": "Method",
    "detail": "Function (bRequiresExplicit128bitRT = Required ; } bool)",
    "insertText": "Get128BitRequirement()"
  },
  {
    "label": "GetUniformLightMapPolicyTypeForPSOCollection()",
    "kind": "Method",
    "detail": "Function (TArray<ELightMapPolicyType,TInlineAllocator<2>>)",
    "insertText": "GetUniformLightMapPolicyTypeForPSOCollection(ERHIFeatureLevel::Type FeatureLevel, const FMaterial& Material)"
  },
  {
    "label": "AddBasePassGraphicsPipelineStateInitializer()",
    "kind": "Method",
    "detail": "Function (template<PassShadersType> void)",
    "insertText": "AddBasePassGraphicsPipelineStateInitializer(ERHIFeatureLevel::Type InFeatureLevel, const FPSOPrecacheVertexFactoryData& VertexFactoryData, const FMaterial& RESTRICT MaterialResource, const FMeshPassProcessorRenderState& RESTRICT DrawRenderState, const FGraphicsPipelineRenderTargetsInfo& RESTRICT RenderTargetsInfo, const PassShadersType& PassShaders, ERasterizerFillMode MeshFillMode, ERasterizerCullMode MeshCullMode, EPrimitiveType PrimitiveType, bool bPrecacheAlphaColorChannel, int InPSOCollectorIndex, TArray<FPSOPrecacheData>& PSOInitializers)"
  },
  {
    "label": "AddGraphicsPipelineStateInitializer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddGraphicsPipelineStateInitializer(VertexFactoryData, MaterialResource, DrawRenderState, RenderTargetsInfo, PassShaders, MeshFillMode, MeshCullMode, PrimitiveType, EMeshPassFeatures::Default, ESubpassHint::None, 0, true , InPSOCollectorIndex, PSOInitializers)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (TConsoleVariableData<int32>* CVar =)",
    "insertText": "Get().FindTConsoleVariableDataInt(TEXT(\"r.PSOPrecache.PrecacheAlphaColorChannel\"))"
  },
  {
    "label": "GetSceneColorFormatAndCreateFlags()",
    "kind": "Method",
    "detail": "Function (FGraphicsPipelineRenderTargetsInfo AlphaColorRenderTargetsInfo = RenderTargetsInfo ; bool bRequiresAlphaChannel = true ; ETextureCreateFlags ExtraSceneColorCreateFlags = ETextureCreateFlags::None ; EPixelFormat SceneColorFormatWithAlpha ; ETextureCreateFlags SceneColorCreateFlagsWithAlpha ;)",
    "insertText": "GetSceneColorFormatAndCreateFlags(InFeatureLevel, bRequiresAlphaChannel, ExtraSceneColorCreateFlags, RenderTargetsInfo.NumSamples, false, SceneColorFormatWithAlpha, SceneColorCreateFlagsWithAlpha)"
  },
  {
    "label": "AddGraphicsPipelineStateInitializer()",
    "kind": "Method",
    "detail": "Function (AlphaColorRenderTargetsInfo . RenderTargetFormats [ 0 ] = SceneColorFormatWithAlpha ; AlphaColorRenderTargetsInfo . RenderTargetFlags [ 0 ] = SceneColorCreateFlagsWithAlpha ;)",
    "insertText": "AddGraphicsPipelineStateInitializer(VertexFactoryData, MaterialResource, DrawRenderState, AlphaColorRenderTargetsInfo, PassShaders, MeshFillMode, MeshCullMode, PrimitiveType, EMeshPassFeatures::Default, ESubpassHint::None, 0, true, InPSOCollectorIndex, PSOInitializers)"
  },
  {
    "label": "TryAddMeshBatch()",
    "kind": "Method",
    "detail": "Function (} } private : bool)",
    "insertText": "TryAddMeshBatch(const FMeshBatch& RESTRICT MeshBatch, uint64 BatchElementMask, const FPrimitiveSceneProxy* RESTRICT PrimitiveSceneProxy, int32 StaticMeshId, const FMaterialRenderProxy& MaterialRenderProxy, const FMaterial& Material)"
  },
  {
    "label": "ShouldDraw()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldDraw(const FMaterial& Material)"
  },
  {
    "label": "Process()",
    "kind": "Method",
    "detail": "Function (template<LightMapPolicyType> bool)",
    "insertText": "Process(const FMeshBatch& RESTRICT MeshBatch, uint64 BatchElementMask, int32 StaticMeshId, const FPrimitiveSceneProxy* RESTRICT PrimitiveSceneProxy, const FMaterialRenderProxy& RESTRICT MaterialRenderProxy, const FMaterial& RESTRICT MaterialResource, const bool bIsMasked, const bool bIsTranslucent, FMaterialShadingModelField ShadingModels, const LightMapPolicyType& RESTRICT LightMapPolicy, const typename LightMapPolicyType::ElementDataType& RESTRICT LightMapElementData, ERasterizerFillMode MeshFillMode, ERasterizerCullMode MeshCullMode)"
  },
  {
    "label": "CollectPSOInitializersForSkyLight()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CollectPSOInitializersForSkyLight(const FSceneTexturesConfig& SceneTexturesConfig, const FPSOPrecacheVertexFactoryData& VertexFactoryData, const FPSOPrecacheParams& PreCacheParams, const FMaterial& RESTRICT MaterialResource, const bool bRenderSkylight, const bool bDitheredLODTransition, ERasterizerFillMode MeshFillMode, ERasterizerCullMode MeshCullMode, EPrimitiveType PrimitiveType, TArray<FPSOPrecacheData>& PSOInitializers)"
  },
  {
    "label": "CollectPSOInitializersForLMPolicy()",
    "kind": "Method",
    "detail": "Function (template<LightMapPolicyType> void)",
    "insertText": "CollectPSOInitializersForLMPolicy(const FSceneTexturesConfig& SceneTexturesConfig, const FPSOPrecacheVertexFactoryData& VertexFactoryData, const FPSOPrecacheParams& PreCacheParams, const FMaterial& RESTRICT MaterialResource, FMaterialShadingModelField ShadingModels, const bool bRenderSkylight, const bool bDitheredLODTransition, const LightMapPolicyType& RESTRICT LightMapPolicy, ERasterizerFillMode MeshFillMode, ERasterizerCullMode MeshCullMode, EPrimitiveType PrimitiveType, TArray<FPSOPrecacheData>& PSOInitializers)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (const ETranslucencyPass::Type TranslucencyPassType ; const bool bTranslucentBasePass ; const bool bOITBasePass ; const bool bEnableReceiveDecalOutput ; EDepthDrawingMode EarlyZPassMode ; bool bRequiresExplicit128bitRT ; float AutoBeforeDOFTranslucencyBoundary = 0 . 0 f ; } ;)",
    "insertText": "ENUM_CLASS_FLAGS(FBasePassMeshProcessor::EFlags)"
  },
  {
    "label": "SetupBasePassState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetupBasePassState(FExclusiveDepthStencil::Type BasePassDepthStencilAccess, const bool bShaderComplexity, FMeshPassProcessorRenderState& DrawRenderState)"
  },
  {
    "label": "CalculateTranslucentMeshStaticSortKey()",
    "kind": "Method",
    "detail": "Function (FMeshDrawCommandSortKey)",
    "insertText": "CalculateTranslucentMeshStaticSortKey(const FPrimitiveSceneProxy* RESTRICT PrimitiveSceneProxy, uint16 MeshIdInPrimitive)"
  }
]