[
  {
    "label": "TTypeCompatibleBytes",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TTypeCompatibleBytes"
  },
  {
    "label": "TUseBitwiseSwap",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TUseBitwiseSwap"
  },
  {
    "label": "CNoncopyable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CNoncopyable"
  },
  {
    "label": "TGuardValue",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TGuardValue"
  },
  {
    "label": "TGuard",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TGuard"
  },
  {
    "label": "ULangGetData()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" uLang / Common / Common . h \" # include \" uLang / Common / Containers / RangeView . h \" # include \" uLang / Common / Templates / Conditionals . h \" # include \" uLang / Common / Templates / Invoke . h \" # include \" uLang / Common / Templates / TypeTraits . h \" # include \" uLang / Common / Memory / MemoryOps . h \" # include<initializer_list> # include<type_traits> # include<new> # include<string . h> namespace uLang { template<T,= TEnableIf<TIsContiguousContainer<T>::Value>::Type> auto)",
    "insertText": "ULangGetData(T&& Container) -> decltype(Container.GetData())"
  },
  {
    "label": "ULangGetData()",
    "kind": "Method",
    "detail": "Function (} template<T,size_t N> T*)",
    "insertText": "ULangGetData(T (&Container)[N])"
  },
  {
    "label": "ULangGetData()",
    "kind": "Method",
    "detail": "Function (} template<FirstIterator,LastIterator> FirstIterator)",
    "insertText": "ULangGetData(const TRangeView<FirstIterator, LastIterator>& View)"
  },
  {
    "label": "ULangGetNum()",
    "kind": "Method",
    "detail": "Function (} template<T,= TEnableIf<TIsContiguousContainer<T>::Value>::Type> size_t)",
    "insertText": "ULangGetNum(T&& Container)"
  },
  {
    "label": "ULangGetNum()",
    "kind": "Method",
    "detail": "Function (} template<T,size_t N> size_t)",
    "insertText": "ULangGetNum(T (&Container)[N])"
  },
  {
    "label": "ULangGetNum()",
    "kind": "Method",
    "detail": "Function (} template<FirstIterator,LastIterator> int32_t)",
    "insertText": "ULangGetNum(const TRangeView<FirstIterator, LastIterator>& View)"
  },
  {
    "label": "AlignUp()",
    "kind": "Method",
    "detail": "Function (} template<T> ULANG_FORCEINLINE T)",
    "insertText": "AlignUp(T Val, uint64_t Alignment)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} template<ElementType> struct TTypeCompatibleBytes { ElementType&)",
    "insertText": "Get()"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "alignas(ElementType) uint8_t _Bytes[sizeof(ElementType)"
  },
  {
    "label": "__is_enum()",
    "kind": "Method",
    "detail": "Function (} ; template<T> struct TUseBitwiseSwap { enum { Value = ! TOrValue<)",
    "insertText": "__is_enum(T)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (} ; template<T> TEnableIf<TUseBitwiseSwap<T>::Value>::Type)",
    "insertText": "Swap(T& A, T& B)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (TTypeCompatibleBytes<T> Temp ; ULANG_IGNORE_CLASS_MEMACCESS_WARNING_START)",
    "insertText": "memcpy(&Temp, &A, sizeof(T))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&A, &B, sizeof(T))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&B, &Temp, sizeof(T))"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (T Temp =)",
    "insertText": "Move(A)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (A =)",
    "insertText": "Move(B)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (B =)",
    "insertText": "Move(Temp)"
  },
  {
    "label": "CNoncopyable()",
    "kind": "Method",
    "detail": "Function (} class CNoncopyable { protected :)",
    "insertText": "CNoncopyable()"
  },
  {
    "label": "CNoncopyable()",
    "kind": "Method",
    "detail": "Function (private :)",
    "insertText": "CNoncopyable(const CNoncopyable&)"
  },
  {
    "label": "CNoncopyable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CNoncopyable(CNoncopyable&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (CNoncopyable&)",
    "insertText": "operator(const CNoncopyable&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (CNoncopyable&)",
    "insertText": "operator(CNoncopyable&&)"
  },
  {
    "label": "TGuardValue()",
    "kind": "Method",
    "detail": "Function (} ; template<RefType,AssignedType = RefType> struct TGuardValue : private CNoncopyable {)",
    "insertText": "TGuardValue(RefType& ReferenceValue, const AssignedType& NewValue) : RefValue(ReferenceValue), OldValue(ReferenceValue)"
  },
  {
    "label": "TGuardValue()",
    "kind": "Method",
    "detail": "Function (RefValue = NewValue ; })",
    "insertText": "TGuardValue(RefType& ReferenceValue) : RefValue(ReferenceValue), OldValue(ReferenceValue)"
  },
  {
    "label": "TGuardValue()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TGuardValue()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (RefValue = OldValue ; } ULANG_FORCEINLINE const AssignedType&)",
    "insertText": "operator()"
  },
  {
    "label": "TGuard()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TGuard()"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Invoke(_Function)"
  },
  {
    "label": "TGuard()",
    "kind": "Method",
    "detail": "Function (TGuard<std::decay_t<Function>>)",
    "insertText": "TGuard(Function&&)"
  }
]