[
  {
    "label": "_EXCEPTION_POINTERS",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_EXCEPTION_POINTERS"
  },
  {
    "label": "_CONTEXT",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_CONTEXT"
  },
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_DEBUG_STACK_TRACE_H_ # define BASE_DEBUG_STACK_TRACE_H_ # include<stddef . h> # include<iosfwd> # include<string> # include \" base / base_export . h \" # include \" base / debug / debugging_buildflags . h \" # include \" base / memory / raw_ptr . h \" # include \" build / build_config . h \" # if)",
    "insertText": "BUILDFLAG(IS_POSIX) #if !BUILDFLAG(IS_NACL) #include <signal.h> #endif #include <unistd.h> #endif #if BUILDFLAG(IS_WIN)"
  },
  {
    "label": "EnableInProcessStackDumping()",
    "kind": "Method",
    "detail": "Function (struct _CONTEXT ; # endif namespace base { namespace debug { BASE_EXPORT bool)",
    "insertText": "EnableInProcessStackDumping()"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(IS_POSIX) && !BUILDFLAG(IS_NACL) BASE_EXPORT bool SetStackDumpFirstChanceCallback(bool (*handler)(int, siginfo_t*, void*))"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# endif # if)",
    "insertText": "BUILDFLAG(CAN_UNWIND_WITH_FRAME_POINTERS) BASE_EXPORT uintptr_t GetStackEnd()"
  },
  {
    "label": "StackTrace()",
    "kind": "Method",
    "detail": "Function (# endif class BASE_EXPORT StackTrace { public :)",
    "insertText": "StackTrace()"
  },
  {
    "label": "StackTrace()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StackTrace(size_t count)"
  },
  {
    "label": "StackTrace()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StackTrace(const void* const* trace, size_t count)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(IS_WIN) StackTrace(_EXCEPTION_POINTERS* exception_pointers)"
  },
  {
    "label": "StackTrace()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StackTrace(const _CONTEXT* context)"
  },
  {
    "label": "WillSymbolizeToStreamForTesting()",
    "kind": "Method",
    "detail": "Function (# endif bool)",
    "insertText": "WillSymbolizeToStreamForTesting()"
  },
  {
    "label": "Addresses()",
    "kind": "Method",
    "detail": "Function (const void* const*)",
    "insertText": "Addresses(size_t* count)"
  },
  {
    "label": "Print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Print()"
  },
  {
    "label": "PrintWithPrefix()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintWithPrefix(const char* prefix_string)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if !)",
    "insertText": "defined(__UCLIBC__) && !defined(_AIX) void OutputToStream(std::ostream* os)"
  },
  {
    "label": "OutputToStreamWithPrefix()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OutputToStreamWithPrefix(std::ostream* os, const char* prefix_string)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (# endif std::string)",
    "insertText": "ToString()"
  },
  {
    "label": "ToStringWithPrefix()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "ToStringWithPrefix(const char* prefix_string)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (private : # if)",
    "insertText": "BUILDFLAG(IS_WIN) void InitTrace(const _CONTEXT* context_record)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# endif # if)",
    "insertText": "BUILDFLAG(IS_ANDROID)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# else int kMaxTraces = 2 5 0 ; # endif void* trace_ [ kMaxTraces ] ; size_t count_ ; } ; BASE_EXPORT std::ostream&)",
    "insertText": "operator(std::ostream& os, const StackTrace& s)"
  },
  {
    "label": "CollectStackTrace()",
    "kind": "Method",
    "detail": "Function (BASE_EXPORT size_t)",
    "insertText": "CollectStackTrace(void** trace, size_t count)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(CAN_UNWIND_WITH_FRAME_POINTERS) #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)"
  },
  {
    "label": "TraceStackFramePointers()",
    "kind": "Method",
    "detail": "Function (# else bool kEnableScanningByDefault = false ; # endif BASE_EXPORT size_t)",
    "insertText": "TraceStackFramePointers(const void** out_trace, size_t max_depth, size_t skip_initial, bool enable_scanning = kEnableScanningByDefault)"
  },
  {
    "label": "TraceStackFramePointersFromBuffer()",
    "kind": "Method",
    "detail": "Function (BASE_EXPORT size_t)",
    "insertText": "TraceStackFramePointersFromBuffer(uintptr_t fp, uintptr_t stack_end, const void** out_trace, size_t max_depth, size_t skip_initial, bool enable_scanning = kEnableScanningByDefault)"
  },
  {
    "label": "ScopedStackFrameLinker()",
    "kind": "Method",
    "detail": "Function (class BASE_EXPORT ScopedStackFrameLinker { public :)",
    "insertText": "ScopedStackFrameLinker(void* fp, void* parent_fp)"
  },
  {
    "label": "ScopedStackFrameLinker()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ScopedStackFrameLinker(const ScopedStackFrameLinker&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ScopedStackFrameLinker&)",
    "insertText": "operator(const ScopedStackFrameLinker&)"
  },
  {
    "label": "ScopedStackFrameLinker()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "ScopedStackFrameLinker()"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (private : raw_ptr<void> fp_ ; raw_ptr<void> parent_fp_ ; raw_ptr<void> original_parent_fp_ ; } ; # endif namespace internal { # if)",
    "insertText": "BUILDFLAG(IS_POSIX) && !BUILDFLAG(IS_ANDROID) BASE_EXPORT char *itoa_r(intptr_t i, char *buf, size_t sz, int base, size_t padding)"
  }
]