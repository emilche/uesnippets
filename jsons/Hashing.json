[
  {
    "label": "hash_code",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "hash_code"
  },
  {
    "label": "hash_state",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "hash_state"
  },
  {
    "label": "is_hashable_data",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_hashable_data"
  },
  {
    "label": "hash_combine_recursive_helper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "hash_combine_recursive_helper"
  },
  {
    "label": "hash_code()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_ADT_HASHING_H # define LLVM_ADT_HASHING_H # include \" llvm / Support / DataTypes . h \" # include \" llvm / Support / Host . h \" # include \" llvm / Support / SwapByteOrder . h \" # include \" llvm / Support / type_traits . h \" # include<algorithm> # include<cassert> # include<cstring> # include<iterator> # include<string> # include<utility> namespace llvm { class hash_code { size_t value ; public :)",
    "insertText": "hash_code()"
  },
  {
    "label": "hash_code()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "hash_code(size_t value) : value(value)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "size_t()"
  },
  {
    "label": "hash_value()",
    "kind": "Method",
    "detail": "Function (template<T> hash_code)",
    "insertText": "hash_value(const T *ptr)"
  },
  {
    "label": "hash_value()",
    "kind": "Method",
    "detail": "Function (template<T,U> hash_code)",
    "insertText": "hash_value(const std::pair<T, U> &arg)"
  },
  {
    "label": "hash_value()",
    "kind": "Method",
    "detail": "Function (template<T> hash_code)",
    "insertText": "hash_value(const std::basic_string<T> &arg)"
  },
  {
    "label": "set_fixed_execution_hash_seed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_fixed_execution_hash_seed(size_t fixed_value)"
  },
  {
    "label": "fetch64()",
    "kind": "Method",
    "detail": "Function (namespace hashing { namespace detail { uint64_t)",
    "insertText": "fetch64(const char *p)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (uint64_t result ;)",
    "insertText": "memcpy(&result, p, sizeof(result))"
  },
  {
    "label": "shift_mix()",
    "kind": "Method",
    "detail": "Function (} uint64_t)",
    "insertText": "shift_mix(uint64_t val)"
  },
  {
    "label": "hash_16_bytes()",
    "kind": "Method",
    "detail": "Function (} uint64_t)",
    "insertText": "hash_16_bytes(uint64_t low, uint64_t high)"
  },
  {
    "label": "a()",
    "kind": "Method",
    "detail": "Function (const uint64_t kMul = 0 x9ddfea08eb382d69ULL ; uint64_t)",
    "insertText": "a(low ^ high)"
  },
  {
    "label": "a()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "a(a >> 47)"
  },
  {
    "label": "b()",
    "kind": "Method",
    "detail": "Function (uint64_t)",
    "insertText": "b(high ^ a)"
  },
  {
    "label": "b()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "b(b >> 47)"
  },
  {
    "label": "hash_1to3_bytes()",
    "kind": "Method",
    "detail": "Function (b* = kMul ; return b ; } uint64_t)",
    "insertText": "hash_1to3_bytes(const char *s, size_t len, uint64_t seed)"
  },
  {
    "label": "uint32_t()",
    "kind": "Method",
    "detail": "Function (uint8_t a = s [ 0 ] ; uint8_t b = s [ len>> 1 ] ; uint8_t c = s [ len - 1 ] ; uint32_t y = static_cast<)",
    "insertText": "uint32_t(a) + (static_cast<uint32_t>(b) << 8)"
  },
  {
    "label": "len()",
    "kind": "Method",
    "detail": "Function (uint32_t z =)",
    "insertText": "len(static_cast<uint32_t>(c) << 2)"
  },
  {
    "label": "hash_4to8_bytes()",
    "kind": "Method",
    "detail": "Function (} uint64_t)",
    "insertText": "hash_4to8_bytes(const char *s, size_t len, uint64_t seed)"
  },
  {
    "label": "fetch32()",
    "kind": "Method",
    "detail": "Function (uint64_t a =)",
    "insertText": "fetch32(s)"
  },
  {
    "label": "hash_9to16_bytes()",
    "kind": "Method",
    "detail": "Function (} uint64_t)",
    "insertText": "hash_9to16_bytes(const char *s, size_t len, uint64_t seed)"
  },
  {
    "label": "fetch64()",
    "kind": "Method",
    "detail": "Function (uint64_t a =)",
    "insertText": "fetch64(s)"
  },
  {
    "label": "fetch64()",
    "kind": "Method",
    "detail": "Function (uint64_t b =)",
    "insertText": "fetch64(s + len - 8)"
  },
  {
    "label": "hash_17to32_bytes()",
    "kind": "Method",
    "detail": "Function (} uint64_t)",
    "insertText": "hash_17to32_bytes(const char *s, size_t len, uint64_t seed)"
  },
  {
    "label": "fetch64()",
    "kind": "Method",
    "detail": "Function (uint64_t b =)",
    "insertText": "fetch64(s + 8)"
  },
  {
    "label": "fetch64()",
    "kind": "Method",
    "detail": "Function (uint64_t d =)",
    "insertText": "fetch64(s + len - 16)"
  },
  {
    "label": "hash_33to64_bytes()",
    "kind": "Method",
    "detail": "Function (} uint64_t)",
    "insertText": "hash_33to64_bytes(const char *s, size_t len, uint64_t seed)"
  },
  {
    "label": "fetch64()",
    "kind": "Method",
    "detail": "Function (uint64_t z =)",
    "insertText": "fetch64(s + 24)"
  },
  {
    "label": "fetch64()",
    "kind": "Method",
    "detail": "Function (uint64_t a =)",
    "insertText": "fetch64(s) + (len + fetch64(s + len - 16))"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (uint64_t b =)",
    "insertText": "rotate(a + z, 52)"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (uint64_t c =)",
    "insertText": "rotate(a, 37)"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (c + =)",
    "insertText": "rotate(a, 7)"
  },
  {
    "label": "fetch64()",
    "kind": "Method",
    "detail": "Function (a + =)",
    "insertText": "fetch64(s + 16)"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (uint64_t vf = a + z ; uint64_t vs = b +)",
    "insertText": "rotate(a, 31)"
  },
  {
    "label": "fetch64()",
    "kind": "Method",
    "detail": "Function (a =)",
    "insertText": "fetch64(s + 16) + fetch64(s + len - 32)"
  },
  {
    "label": "fetch64()",
    "kind": "Method",
    "detail": "Function (a + =)",
    "insertText": "fetch64(s + len - 24)"
  },
  {
    "label": "shift_mix()",
    "kind": "Method",
    "detail": "Function (uint64_t r =)",
    "insertText": "shift_mix((vf + ws) * k2 + (wf + vs) * k0)"
  },
  {
    "label": "hash_short()",
    "kind": "Method",
    "detail": "Function (} uint64_t)",
    "insertText": "hash_short(const char *s, size_t length, uint64_t seed)"
  },
  {
    "label": "hash_16_bytes()",
    "kind": "Method",
    "detail": "Function (hash_state state = { 0,seed,)",
    "insertText": "hash_16_bytes(seed, k1), rotate(seed ^ k1, 49), seed * k1, shift_mix(seed)"
  },
  {
    "label": "hash_16_bytes()",
    "kind": "Method",
    "detail": "Function (state . h6 =)",
    "insertText": "hash_16_bytes(state.h4, state.h5)"
  },
  {
    "label": "mix()",
    "kind": "Method",
    "detail": "Function (state .)",
    "insertText": "mix(s)"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (b =)",
    "insertText": "rotate(b + a + c, 21)"
  },
  {
    "label": "fetch64()",
    "kind": "Method",
    "detail": "Function (uint64_t d = a ; a + =)",
    "insertText": "fetch64(s + 8) + fetch64(s + 16)"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (b + =)",
    "insertText": "rotate(a, 44)"
  },
  {
    "label": "mix()",
    "kind": "Method",
    "detail": "Function (a + = c ; } void)",
    "insertText": "mix(const char *s)"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (h0 =)",
    "insertText": "rotate(h0 + h1 + h3 + fetch64(s + 8), 37)"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (h1 =)",
    "insertText": "rotate(h1 + h4 + fetch64(s + 48), 42)"
  },
  {
    "label": "fetch64()",
    "kind": "Method",
    "detail": "Function (h0 ^ = h6 ; h1 + = h3 +)",
    "insertText": "fetch64(s + 40)"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (h2 =)",
    "insertText": "rotate(h2 + h5, 33)"
  },
  {
    "label": "mix_32_bytes()",
    "kind": "Method",
    "detail": "Function (h3 = h4* k1 ; h4 = h0 + h5 ;)",
    "insertText": "mix_32_bytes(s, h3, h4)"
  },
  {
    "label": "mix_32_bytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mix_32_bytes(s + 32, h5, h6)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(h2, h0)"
  },
  {
    "label": "finalize()",
    "kind": "Method",
    "detail": "Function (} uint64_t)",
    "insertText": "finalize(size_t length)"
  },
  {
    "label": "get_execution_seed()",
    "kind": "Method",
    "detail": "Function (} } ; size_t fixed_seed_override ; size_t)",
    "insertText": "get_execution_seed()"
  },
  {
    "label": "fixed_seed_override()",
    "kind": "Method",
    "detail": "Function (const uint64_t seed_prime = 0 xff51afd7ed558ccdULL ; size_t seed = fixed_seed_override ?)",
    "insertText": "fixed_seed_override(size_t)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} ; template<T,U> struct is_hashable_data<std::pair<T,U>> : std::integral_constant<)",
    "insertText": "bool(is_hashable_data<T>::value && is_hashable_data<U>::value && (sizeof(T) + sizeof(U)) == sizeof(std::pair<T, U>))"
  },
  {
    "label": "get_hashable_data()",
    "kind": "Method",
    "detail": "Function (} ; template<T> std::enable_if<is_hashable_data<T>::value,T>::type)",
    "insertText": "get_hashable_data(const T &value)"
  },
  {
    "label": "hash_value()",
    "kind": "Method",
    "detail": "Function (using::llvm::hash_value ; return)",
    "insertText": "hash_value(value)"
  },
  {
    "label": "store_and_advance()",
    "kind": "Method",
    "detail": "Function (} template<T> bool)",
    "insertText": "store_and_advance(char *&buffer_ptr, char *buffer_end, const T& value, size_t offset = 0)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (size_t store_size =)",
    "insertText": "sizeof(value)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (const char* value_data = reinterpret_cast<const)",
    "insertText": "char(&value)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(buffer_ptr, value_data + offset, store_size)"
  },
  {
    "label": "hash_combine_range_impl()",
    "kind": "Method",
    "detail": "Function (buffer_ptr + = store_size ; return true ; } template<InputIteratorT> hash_code)",
    "insertText": "hash_combine_range_impl(InputIteratorT first, InputIteratorT last)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (char buffer [ 6 4 ],* buffer_ptr = buffer ; char* const buffer_end =)",
    "insertText": "end(buffer)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(buffer_ptr == buffer_end)"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (hash_state state = state .)",
    "insertText": "create(buffer, seed)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (size_t length = 6 4 ;)",
    "insertText": "while(first != last)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (buffer_ptr = buffer ;)",
    "insertText": "while(first != last && store_and_advance(buffer_ptr, buffer_end, get_hashable_data(*first)))"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rotate(buffer, buffer_ptr, buffer_end)"
  },
  {
    "label": "mix()",
    "kind": "Method",
    "detail": "Function (state .)",
    "insertText": "mix(buffer)"
  },
  {
    "label": "finalize()",
    "kind": "Method",
    "detail": "Function (length + = buffer_ptr - buffer ; } ; return state .)",
    "insertText": "finalize(length)"
  },
  {
    "label": "hash_combine_range_impl()",
    "kind": "Method",
    "detail": "Function (} template<ValueT> std::enable_if<is_hashable_data<ValueT>::value,hash_code>::type)",
    "insertText": "hash_combine_range_impl(ValueT *first, ValueT *last)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (const char* s_begin = reinterpret_cast<const)",
    "insertText": "char(first)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (const char* s_end = reinterpret_cast<const)",
    "insertText": "char(last)"
  },
  {
    "label": "distance()",
    "kind": "Method",
    "detail": "Function (const size_t length =)",
    "insertText": "distance(s_begin, s_end)"
  },
  {
    "label": "s_begin()",
    "kind": "Method",
    "detail": "Function (const char* s_aligned_end =)",
    "insertText": "s_begin(length & ~63)"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (hash_state state = state .)",
    "insertText": "create(s_begin, seed)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (s_begin + = 6 4 ;)",
    "insertText": "while(s_begin != s_aligned_end)"
  },
  {
    "label": "mix()",
    "kind": "Method",
    "detail": "Function (state .)",
    "insertText": "mix(s_begin)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (s_begin + = 6 4 ; })",
    "insertText": "if(length & 63) state.mix(s_end - 64)"
  },
  {
    "label": "hash_combine_range()",
    "kind": "Method",
    "detail": "Function (} } } template<InputIteratorT> hash_code)",
    "insertText": "hash_combine_range(InputIteratorT first, InputIteratorT last)"
  },
  {
    "label": "hash_combine_recursive_helper()",
    "kind": "Method",
    "detail": "Function (} namespace hashing { namespace detail { struct hash_combine_recursive_helper { char buffer [ 6 4 ] ; hash_state state ; const size_t seed ; public :)",
    "insertText": "hash_combine_recursive_helper() : seed(get_execution_seed())"
  },
  {
    "label": "combine_data()",
    "kind": "Method",
    "detail": "Function (} template<T> char*)",
    "insertText": "combine_data(size_t &length, char *buffer_ptr, char *buffer_end, T data)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (size_t partial_store_size = buffer_end - buffer_ptr ;)",
    "insertText": "memcpy(buffer_ptr, &data, partial_store_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (length + = 6 4 ; } buffer_ptr = buffer ;)",
    "insertText": "if(!store_and_advance(buffer_ptr, buffer_end, data, partial_store_size)) abort()"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (} return buffer_ptr ; } template<T,. . . Ts> hash_code)",
    "insertText": "combine(size_t length, char *buffer_ptr, char *buffer_end, const T &arg, const Ts &...args)"
  },
  {
    "label": "combine_data()",
    "kind": "Method",
    "detail": "Function (buffer_ptr =)",
    "insertText": "combine_data(length, buffer_ptr, buffer_end, get_hashable_data(arg))"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (} hash_code)",
    "insertText": "combine(size_t length, char *buffer_ptr, char *buffer_end)"
  },
  {
    "label": "hash_combine()",
    "kind": "Method",
    "detail": "Function (} } ; } } template<. . . Ts> hash_code)",
    "insertText": "hash_combine(const Ts &...args)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (::llvm::hashing::detail::hash_combine_recursive_helper helper ; return helper .)",
    "insertText": "combine(0, helper.buffer, helper.buffer + 64, args...)"
  },
  {
    "label": "hash_integer_value()",
    "kind": "Method",
    "detail": "Function (} namespace hashing { namespace detail { hash_code)",
    "insertText": "hash_integer_value(uint64_t value)"
  },
  {
    "label": "hash_value()",
    "kind": "Method",
    "detail": "Function (} } } template<T> std::enable_if<is_integral_or_enum<T>::value,hash_code>::type)",
    "insertText": "hash_value(T value)"
  }
]