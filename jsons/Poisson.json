[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TV",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TV"
  },
  {
    "label": "TV_INT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TV_INT"
  },
  {
    "label": "RowMaj3x3Set()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Framework / Parallel . h \" # include \" Chaos / Math / Krylov . h \" # include \" Chaos / UniformGrid . h \" # include \" Chaos / Vector . h \" # include \" Math / Matrix . h \" # include \" Math / Vector . h \" # include \" Chaos / Utilities . h \" # include<iostream> namespace Chaos { template<class T> void)",
    "insertText": "RowMaj3x3Set(T* A, const int32 i, const int32 j, const T Value)"
  },
  {
    "label": "RowMaj3x3Get()",
    "kind": "Method",
    "detail": "Function (A [ 3* i + j ] = Value ; } template<class T> const T&)",
    "insertText": "RowMaj3x3Get(const T* A, const int32 i, const int32 j)"
  },
  {
    "label": "RowMaj3x3Set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RowMaj3x3Set(A, i, j, Values[i])"
  },
  {
    "label": "RowMaj3x3SetRow()",
    "kind": "Method",
    "detail": "Function (} } template<class T,class TV> void)",
    "insertText": "RowMaj3x3SetRow(T* A, const int32 i, const TV Value)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T Tmp [ 3 ] { static_cast<)",
    "insertText": "T(Value[0]), static_cast<T>(Value[1]), static_cast<T>(Value[2])"
  },
  {
    "label": "RowMaj3x3SetRow()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RowMaj3x3SetRow(A, i, &Tmp[0])"
  },
  {
    "label": "RowMaj3x3GetRow()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TV> void)",
    "insertText": "RowMaj3x3GetRow(T* A, const int32 i, TV& Row)"
  },
  {
    "label": "RowMaj3x3Get()",
    "kind": "Method",
    "detail": "Function (Row [ j ] =)",
    "insertText": "RowMaj3x3Get(A, i, j)"
  },
  {
    "label": "RowMaj3x3SetCol()",
    "kind": "Method",
    "detail": "Function (} } template<class T> void)",
    "insertText": "RowMaj3x3SetCol(T* A, const int32 j, const T* Values)"
  },
  {
    "label": "RowMaj3x3SetCol()",
    "kind": "Method",
    "detail": "Function (} } template<class T,class TV> void)",
    "insertText": "RowMaj3x3SetCol(T* A, const int32 j, const TV Value)"
  },
  {
    "label": "RowMaj3x3Set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RowMaj3x3Set(A, i, j, static_cast<T>(Value[i]))"
  },
  {
    "label": "RowMaj3x3GetCol()",
    "kind": "Method",
    "detail": "Function (} } template<class T,class TV> void)",
    "insertText": "RowMaj3x3GetCol(T* A, const int32 j, TV& Col)"
  },
  {
    "label": "RowMaj3x3Determinant()",
    "kind": "Method",
    "detail": "Function (} } template<class T> T)",
    "insertText": "RowMaj3x3Determinant(const T A0, const T A1, const T A2, const T A3, const T A4, const T A5, const T A6, const T A7, const T A8)"
  },
  {
    "label": "RowMaj3x3Determinant()",
    "kind": "Method",
    "detail": "Function (} template<class T> T)",
    "insertText": "RowMaj3x3Determinant(const T* A)"
  },
  {
    "label": "RowMaj3x3Inverse()",
    "kind": "Method",
    "detail": "Function (} template<class T> void)",
    "insertText": "RowMaj3x3Inverse(const T Det, const T A0, const T A1, const T A2, const T A3, const T A4, const T A5, const T A6, const T A7, const T A8, T* Inv)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Inv [ 0 ] =)",
    "insertText": "T(1)"
  },
  {
    "label": "Inv()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Inv(A2 * A7 - A1 * A8)"
  },
  {
    "label": "Inv()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Inv(A1 * A5 - A2 * A4)"
  },
  {
    "label": "Inv()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Inv(A5 * A6 - A3 * A8)"
  },
  {
    "label": "Inv()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Inv(A0 * A8 - A2 * A6)"
  },
  {
    "label": "Inv()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Inv(A2 * A3 - A0 * A5)"
  },
  {
    "label": "Inv()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Inv(A3 * A7 - A4 * A6)"
  },
  {
    "label": "Inv()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Inv(A1 * A6 - A0 * A7)"
  },
  {
    "label": "Inv()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Inv(A0 * A4 - A1 * A3)"
  },
  {
    "label": "RowMaj3x3Inverse()",
    "kind": "Method",
    "detail": "Function (} template<class T> void)",
    "insertText": "RowMaj3x3Inverse(const T Det, const T* A, T* Inv)"
  },
  {
    "label": "RowMaj3x3Inverse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RowMaj3x3Inverse(Det, A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[8], Inv)"
  },
  {
    "label": "RowMaj3x3Inverse()",
    "kind": "Method",
    "detail": "Function (} template<class T> void)",
    "insertText": "RowMaj3x3Inverse(const T* A, T* Inv)"
  },
  {
    "label": "RowMaj3x3Inverse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RowMaj3x3Inverse(RowMaj3x3Determinant(A), A, Inv)"
  },
  {
    "label": "RowMaj3x3Transpose()",
    "kind": "Method",
    "detail": "Function (} template<class T> void)",
    "insertText": "RowMaj3x3Transpose(const T* A, T* Transpose)"
  },
  {
    "label": "RowMaj3x3Multiply()",
    "kind": "Method",
    "detail": "Function (Transpose [ 3* j + i ] = A [ 3* i + j ] ; } } } template<class T,class TV> TV)",
    "insertText": "RowMaj3x3Multiply(const T* A, const TV& x)"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (TV)",
    "insertText": "Result(0,0,0)"
  },
  {
    "label": "RowMaj3x3RobustSolveLinearSystem()",
    "kind": "Method",
    "detail": "Function (Result [ i ] + = A [ 3* i + j ]* x [ j ] ; } } return Result ; } template<class T,class TV> TV)",
    "insertText": "RowMaj3x3RobustSolveLinearSystem(const T* A, const TV& b)"
  },
  {
    "label": "RowMaj3x3Multiply()",
    "kind": "Method",
    "detail": "Function (T Cofactor11 = A [ 4 ]* A [ 8 ] - A [ 7 ]* A [ 5 ] ; T Cofactor12 = A [ 7 ]* A [ 2 ] - A [ 1 ]* A [ 8 ] ; T Cofactor13 = A [ 1 ]* A [ 5 ] - A [ 4 ]* A [ 2 ] ; T Determinant = A [ 0 ]* Cofactor11 + A [ 3 ]* Cofactor12 + A [ 6 ]* Cofactor13 ; T Matrix [ 9 ] = { Cofactor11,Cofactor12,Cofactor13,A [ 6 ]* A [ 5 ] - A [ 3 ]* A [ 8 ],A [ 0 ]* A [ 8 ] - A [ 6 ]* A [ 2 ],A [ 3 ]* A [ 2 ] - A [ 0 ]* A [ 5 ],A [ 3 ]* A [ 7 ] - A [ 6 ]* A [ 4 ],A [ 6 ]* A [ 1 ] - A [ 0 ]* A [ 7 ],A [ 0 ]* A [ 4 ] - A [ 3 ]* A [ 1 ] } ; TV UnscaledResult =)",
    "insertText": "RowMaj3x3Multiply(&Matrix[0], b)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T RelativeTolerance = static_cast<)",
    "insertText": "T(TNumericLimits<float>::Min()) * FMath::Max3(FMath::Abs(UnscaledResult[0]), FMath::Abs(UnscaledResult[1]), FMath::Abs(UnscaledResult[2]))"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (RelativeTolerance =)",
    "insertText": "Max(RelativeTolerance, static_cast<T>(TNumericLimits<float>::Min()))"
  },
  {
    "label": "ComputeDeInverseAndElementMeasures()",
    "kind": "Method",
    "detail": "Function (Determinant = Determinant> = 0 ? RelativeTolerance : - RelativeTolerance ; } return UnscaledResult / Determinant ; } template<class T,class TV = FVector3f,class TV_INT = FIntVector4,int32 d = 3> void)",
    "insertText": "ComputeDeInverseAndElementMeasures(const TArray<TV_INT>& Mesh, const TArray<TV>& X, TArray<T>& De_inverse, TArray<T>& measure)"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (De_inverse .)",
    "insertText": "SetNumUninitialized(d * d * Mesh.Num())"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (measure .)",
    "insertText": "SetNumUninitialized(Mesh.Num())"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const int32* MeshPtr =& Mesh [ 0 ] [ 0 ] ; const int32 eBegin = 0 ; const int32 eEnd = Mesh .)",
    "insertText": "Num()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function ({ T Inv [ d* d ] ;)",
    "insertText": "for(int32 e=eBegin; e < eEnd; e++)"
  },
  {
    "label": "RowMaj3x3Determinant()",
    "kind": "Method",
    "detail": "Function (const TV_INT& Elem = Mesh [ e ] ; T De [ 9 ] = { X [ Elem [ 1 ] ] [ 0 ] - X [ Elem [ 0 ] ] [ 0 ],X [ Elem [ 2 ] ] [ 0 ] - X [ Elem [ 0 ] ] [ 0 ],X [ Elem [ 3 ] ] [ 0 ] - X [ Elem [ 0 ] ] [ 0 ],X [ Elem [ 1 ] ] [ 1 ] - X [ Elem [ 0 ] ] [ 1 ],X [ Elem [ 2 ] ] [ 1 ] - X [ Elem [ 0 ] ] [ 1 ],X [ Elem [ 3 ] ] [ 1 ] - X [ Elem [ 0 ] ] [ 1 ],X [ Elem [ 1 ] ] [ 2 ] - X [ Elem [ 0 ] ] [ 2 ],X [ Elem [ 2 ] ] [ 2 ] - X [ Elem [ 0 ] ] [ 2 ],X [ Elem [ 3 ] ] [ 2 ] - X [ Elem [ 0 ] ] [ 2 ] } ; T Det =)",
    "insertText": "RowMaj3x3Determinant(De)"
  },
  {
    "label": "Det()",
    "kind": "Method",
    "detail": "Function (measure [ e ] =)",
    "insertText": "Det(T)"
  },
  {
    "label": "RowMaj3x3Inverse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RowMaj3x3Inverse(Det, De, Inv)"
  },
  {
    "label": "Fill()",
    "kind": "Method",
    "detail": "Function (De_inverse [ d* d* e + i ] = Inv [ i ] ; } } } } template<class T> void)",
    "insertText": "Fill(TArray<T>& Array, const T Value)"
  },
  {
    "label": "MinFlatIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "MinFlatIndex(const TArray<int32>& ElemIdx, const TArray<int32>& LocalIdx)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 MinIdx = 0 ;)",
    "insertText": "for(int32 i = 1; i < ElemIdx.Num(); i++)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "return(ElemIdx[MinIdx] * 4)"
  },
  {
    "label": "PoissonSolve()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TV,class TV_INT = FIntVector4,int d = 3> void)",
    "insertText": "PoissonSolve(const TArray<int32>& InConstrainedNodes, const TArray<T>& ConstrainedWeights, const TArray<TV_INT>& Mesh, const TArray<TV>& X, const int32 MaxItCG, const T CGTol, TArray<T>& Weights)"
  },
  {
    "label": "ComputeDeInverseAndElementMeasures()",
    "kind": "Method",
    "detail": "Function (TArray<T> De_inverse ; TArray<T> measure ;)",
    "insertText": "ComputeDeInverseAndElementMeasures(Mesh, X, De_inverse, measure)"
  },
  {
    "label": "ComputeIncidentElements()",
    "kind": "Method",
    "detail": "Function (TArray<TArray<int32>> IncidentElementsLocalIndex ; TArray<TArray<int32>> IncidentElements = Chaos::)",
    "insertText": "ComputeIncidentElements(Mesh, &IncidentElementsLocalIndex)"
  },
  {
    "label": "InConstrainedNodes()",
    "kind": "Method",
    "detail": "Function (auto ProjectBCs = [&)",
    "insertText": "InConstrainedNodes(TArray<T>& U)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (U [ InConstrainedNodes [)",
    "insertText": "i(T)"
  },
  {
    "label": "MultiplyLaplacian()",
    "kind": "Method",
    "detail": "Function (} } ; auto)",
    "insertText": "MultiplyLaplacian(TArray<T>& LU, const TArray<T>& U)"
  },
  {
    "label": "Laplacian()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Laplacian(Mesh, IncidentElements, IncidentElementsLocalIndex, De_inverse, measure, U, LU)"
  },
  {
    "label": "ProjectBCs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ProjectBCs(LU)"
  },
  {
    "label": "Fill()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "Fill(Weights, T(0))"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (TArray<T> InitialGuess ; InitialGuess .)",
    "insertText": "Init((T)0., Weights.Num())"
  },
  {
    "label": "MultiplyLaplacian()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MultiplyLaplacian(MinusResidual, InitialGuess)"
  },
  {
    "label": "LanczosCG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LanczosCG(MultiplyLaplacian, MinusDw, MinusResidual, MaxItCG, CGTol, false)"
  },
  {
    "label": "Laplacian()",
    "kind": "Method",
    "detail": "Function (Weights [ i ] = InitialGuess [ i ] - MinusDw [ i ] ; } } template<class T,class TV_INT = FIntVector4,int d = 3> void)",
    "insertText": "Laplacian(const TArray<TV_INT>& Mesh, const TArray<TArray<int32>>& IncidentElements, const TArray<TArray<int32>>& IncidentElementsLocalIndex, const TArray<T>& De_inverse, const TArray<T>& measure, const TArray<T>& u, TArray<T>& Lu)"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (TArray<Chaos::TVector<T,d>> grad_Nie_hat ; grad_Nie_hat .)",
    "insertText": "SetNumUninitialized(d + 1)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (grad_Nie_hat [ 0 ] = {)",
    "insertText": "T(-1),T(-1),T(-1)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (grad_Nie_hat [ 1 ] = {)",
    "insertText": "T(1),T(0),T(0)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (grad_Nie_hat [ 2 ] = {)",
    "insertText": "T(0),T(1),T(0)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (grad_Nie_hat [ 3 ] = {)",
    "insertText": "T(0),T(0),T(1)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (Lu .)",
    "insertText": "SetNum(u.Num())"
  },
  {
    "label": "Fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Fill(Lu, T(0))"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (TArray<T> element_contributions ; element_contributions .)",
    "insertText": "SetNum(Mesh.Num() * 4)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const int32* MeshPtr =& Mesh [ 0 ] [ 0 ] ;)",
    "insertText": "for(int32 e=0; e < Mesh.Num(); e++)"
  },
  {
    "label": "RowMaj3x3Transpose()",
    "kind": "Method",
    "detail": "Function (T Deinv [ d* d ] { De_inverse [ d* d* e + 0 ],De_inverse [ d* d* e + 1 ],De_inverse [ d* d* e + 2 ],De_inverse [ d* d* e + 3 ],De_inverse [ d* d* e + 4 ],De_inverse [ d* d* e + 5 ],De_inverse [ d* d* e + 6 ],De_inverse [ d* d* e + 7 ],De_inverse [ d* d* e + 8 ],} ; T De_inverse_transpose [ d* d ] ;)",
    "insertText": "RowMaj3x3Transpose(Deinv, De_inverse_transpose)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const TV_INT& Elem = Mesh [ e ] ; TVector<T,d> grad_Nie ;)",
    "insertText": "for(int32 ie = 0; ie < d+1; ie++)"
  },
  {
    "label": "RowMaj3x3Multiply()",
    "kind": "Method",
    "detail": "Function (grad_Nie =)",
    "insertText": "RowMaj3x3Multiply(De_inverse_transpose, grad_Nie_hat[ie])"
  },
  {
    "label": "RowMaj3x3Multiply()",
    "kind": "Method",
    "detail": "Function (Chaos::TVector<T,d> grad_Nje =)",
    "insertText": "RowMaj3x3Multiply(De_inverse_transpose, grad_Nie_hat[je])"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (T Ae_ieje = Chaos::TVector<T,d)",
    "insertText": "DotProduct(grad_Nie, grad_Nje)"
  },
  {
    "label": "element_contributions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "element_contributions(d + 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "for(int32 i = 0; i < IncidentElements.Num(); i++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const TArray<int32>& IncidentElements_i = IncidentElements [ i ] ; const TArray<int32>& IncidentElementsLocalIndex_i = IncidentElementsLocalIndex [ i ] ;)",
    "insertText": "if(!IncidentElements_i.Num())"
  },
  {
    "label": "MinFlatIndex()",
    "kind": "Method",
    "detail": "Function (const int32 p = MeshPtr [)",
    "insertText": "MinFlatIndex(IncidentElements_i, IncidentElementsLocalIndex_i)"
  },
  {
    "label": "element_contributions()",
    "kind": "Method",
    "detail": "Function (const int32 Elem = IncidentElements_i [ e ] ; const int32 Local = IncidentElementsLocalIndex_i [ e ] ; Lu [ p ] + =)",
    "insertText": "element_contributions(Elem * 4)"
  },
  {
    "label": "LaplacianEnergy()",
    "kind": "Method",
    "detail": "Function (} } } template<class T,class TV_INT,int d = 3> T)",
    "insertText": "LaplacianEnergy(const TArray<TV_INT>& Mesh, const TArray<T>& De_inverse, const TArray<T>& measure, const TArray<T>& u)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const TV_INT& Elem = Mesh [ e ] ; TVector<T,d> grad_Nie ;)",
    "insertText": "for(int32 ie = 0; ie < d + 1; ie++)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (element_contributions [ e ] + = u [ Elem [ ie ] ]* Ae_ieje* u [ Elem [ je ] ] ; } } } } T result =)",
    "insertText": "T(0)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (result + = element_contributions [ i ] ; } return)",
    "insertText": "T(.5)"
  },
  {
    "label": "ComputeFiberField()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TV,class TV_INT,int d = 3> void)",
    "insertText": "ComputeFiberField(const TArray<TV_INT>& Mesh, const TArray<TV>& Vertices, const TArray<TArray<int32>>& IncidentElements, const TArray<TArray<int32>>& IncidentElementsLocalIndex, const TArray<int32>& Origins, const TArray<int32>& Insertions, TArray<TV>& Directions, TArray<T>& ScalarField, const int32 MaxIt=100, const T Tol=T(1e-7))"
  },
  {
    "label": "Insertions()",
    "kind": "Method",
    "detail": "Function (auto set_bcs = [& Origins,&)",
    "insertText": "Insertions(TArray<T>& minus_u_bc, const T scale, bool zero_non_boundary = true)"
  },
  {
    "label": "Insertions()",
    "kind": "Method",
    "detail": "Function (} ; auto proj_bcs = [& Origins,&)",
    "insertText": "Insertions(TArray<T>& u)"
  },
  {
    "label": "SetNumZeroed()",
    "kind": "Method",
    "detail": "Function (} ; TArray<T> u ; u .)",
    "insertText": "SetNumZeroed(Vertices.Num())"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (TArray<T> De_inverse ; TArray<T> measure ; Chaos::ComputeDeInverseAndElementMeasures<)",
    "insertText": "T(Mesh, Vertices, De_inverse, measure)"
  },
  {
    "label": "SetNumZeroed()",
    "kind": "Method",
    "detail": "Function (TArray<T> negative_u_bc ; negative_u_bc .)",
    "insertText": "SetNumZeroed(u.Num())"
  },
  {
    "label": "set_bcs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_bcs(negative_u_bc, T(-1), true)"
  },
  {
    "label": "Laplacian()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Laplacian(Mesh, IncidentElements, IncidentElementsLocalIndex, De_inverse, measure, negative_u_bc, rhs)"
  },
  {
    "label": "proj_bcs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "proj_bcs(rhs)"
  },
  {
    "label": "mult()",
    "kind": "Method",
    "detail": "Function (auto)",
    "insertText": "mult(TArray<T>& out, const TArray<T>& in)"
  },
  {
    "label": "proj_bcs()",
    "kind": "Method",
    "detail": "Function (TArray<T> proj_in = in ;)",
    "insertText": "proj_bcs(proj_in)"
  },
  {
    "label": "Laplacian()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Laplacian(Mesh, IncidentElements, IncidentElementsLocalIndex, De_inverse, measure, proj_in, out)"
  },
  {
    "label": "proj_bcs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "proj_bcs(out)"
  },
  {
    "label": "LanczosCG()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "LanczosCG(mult, u, rhs, MaxIt, Tol, true)"
  },
  {
    "label": "set_bcs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_bcs(u, T(1), false)"
  },
  {
    "label": "Fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Fill(Directions, TV(0))"
  },
  {
    "label": "Normalize()",
    "kind": "Method",
    "detail": "Function (TV pseudo_direction = Vertices [ Insertions [ 0 ] ] - Vertices [ Origins [ 0 ] ] ; pseudo_direction .)",
    "insertText": "Normalize()"
  },
  {
    "label": "PhysicsParallelFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PhysicsParallelFor(Mesh.Num(), [&](const int32 e) { T Deinv[d * d]{ De_inverse[d * d * e + 0], De_inverse[d * d * e + 1], De_inverse[d * d * e + 2], De_inverse[d * d * e + 3], De_inverse[d * d * e + 4], De_inverse[d * d * e + 5], De_inverse[d * d * e + 6], De_inverse[d * d * e + 7], De_inverse[d * d * e + 8], }; T De_inverse_transpose[d * d]; RowMaj3x3Transpose(Deinv, De_inverse_transpose); const TV_INT& Elem = Mesh[e]; TV gradient(0); TVector<T, d> grad_Nie; for (size_t ie = 0; ie < d + 1; ie++) { grad_Nie = RowMaj3x3Multiply(De_inverse_transpose, grad_Nie_hat[ie]); gradient += grad_Nie * u[Elem[ie]]; } const T Len = gradient.Length(); if (Len > T(1e-10)) { Directions[e] = gradient * T(1) / Len; } else if (u[Mesh[e][0]] > 0) { Directions[e] = pseudo_direction; } else { Directions[e] = gradient; } })"
  },
  {
    "label": "Laplacian()",
    "kind": "Method",
    "detail": "Function (} template<class TV,class T,bool NodalValues = false> void)",
    "insertText": "Laplacian(const TUniformGrid<T, 3>& UniformGrid, const TArray<TV>& U, TArray<TV>& Lu)"
  },
  {
    "label": "NodeCounts()",
    "kind": "Method",
    "detail": "Function (const TVec3<int32> Counts = NodalValues ? UniformGrid .)",
    "insertText": "NodeCounts() : UniformGrid.Counts()"
  },
  {
    "label": "TV()",
    "kind": "Method",
    "detail": "Function (const int32 XStride = Counts [ 1 ]* Counts [ 2 ] ; const int32 YStride = Counts [ 2 ] ; int32 ZStride = 1 ; const Chaos::TVector<TV,3> OneOverDxSq = Chaos::TVector<)",
    "insertText": "TV(1) / (UniformGrid.Dx() * UniformGrid.Dx())"
  },
  {
    "label": "Fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Fill(Lu, TV(0))"
  },
  {
    "label": "FlatIndex()",
    "kind": "Method",
    "detail": "Function (const int32 FlatIndex = I* XStride + J* YStride + K* ZStride ; Lu [)",
    "insertText": "FlatIndex(U[FlatIndex + XStride] - (T)2. * U[FlatIndex] + U[FlatIndex - XStride]) * OneOverDxSq[0] + (U[FlatIndex + YStride] - (T)2. * U[FlatIndex] + U[FlatIndex - YStride]) * OneOverDxSq[1] + (U[FlatIndex + ZStride] - (T)2. * U[FlatIndex] + U[FlatIndex - ZStride])"
  },
  {
    "label": "PoissonSolve()",
    "kind": "Method",
    "detail": "Function (} } } } template<class TV,class T,bool NodalValues = false> void)",
    "insertText": "PoissonSolve(const TArray<int32>& InConstrainedNodes, const TArray<TV>& ConstrainedWeights, const TUniformGrid<T, 3>& UniformGrid, const int32 MaxItCG, const TV CGTol, TArray<TV>& Weights, bool bCheckResidual = false, int32 MinParallelBatchSize = 1000)"
  },
  {
    "label": "InConstrainedNodes()",
    "kind": "Method",
    "detail": "Function (auto ProjectBCs = [&)",
    "insertText": "InConstrainedNodes(TArray<TV>& U)"
  },
  {
    "label": "UniformGrid()",
    "kind": "Method",
    "detail": "Function (} } ; auto MultiplyLaplacian = [& ProjectBCs,&)",
    "insertText": "UniformGrid(TArray<TV>& LU, const TArray<TV>& U)"
  },
  {
    "label": "NodalValues()",
    "kind": "Method",
    "detail": "Function (Laplacian<TV,T,)",
    "insertText": "NodalValues(UniformGrid, U, LU)"
  },
  {
    "label": "Fill()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "Fill(Weights, TV(0))"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (TArray<TV> InitialGuess ; InitialGuess .)",
    "insertText": "Init((TV)0., Weights.Num())"
  },
  {
    "label": "LanczosCG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LanczosCG(MultiplyLaplacian, MinusDw, MinusResidual, MaxItCG, CGTol, bCheckResidual, MinParallelBatchSize)"
  }
]