[
  {
    "label": "FQueuedThreadPoolWrapper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FQueuedThreadPoolWrapper"
  },
  {
    "label": "FScheduledWork",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FScheduledWork"
  },
  {
    "label": "FQueuedThreadPoolDynamicWrapper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FQueuedThreadPoolDynamicWrapper"
  },
  {
    "label": "FQueuedThreadPoolTaskGraphWrapper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FQueuedThreadPoolTaskGraphWrapper"
  },
  {
    "label": "FQueuedLowLevelThreadPool",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FQueuedLowLevelThreadPool"
  },
  {
    "label": "FQueuedWorkInternalData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FQueuedWorkInternalData"
  },
  {
    "label": "FQueuedThreadPoolWrapper()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Async / Fundamental / Scheduler . h \" # include \" Async / Fundamental / Task . h \" # include \" Async / ManualResetEvent . h \" # include \" Async / TaskGraphInterfaces . h \" # include \" Containers / Array . h \" # include \" Containers / Map . h \" # include \" CoreMinimal . h \" # include \" Experimental / ConcurrentLinearAllocator . h \" # include \" Experimental / Containers / FAAArrayQueue . h \" # include \" Experimental / Misc / ExecutionResource . h \" # include \" GenericPlatform / GenericPlatformAffinity . h \" # include \" HAL / CriticalSection . h \" # include \" HAL / Platform . h \" # include \" HAL / PlatformAffinity . h \" # include \" HAL / PlatformCrt . h \" # include \" HAL / PlatformProcess . h \" # include \" HAL / ThreadSafeCounter . h \" # include \" HAL / UnrealMemory . h \" # include \" Misc / AssertionMacros . h \" # include \" Misc / IQueuedWork . h \" # include \" Misc / MemStack . h \" # include \" Misc / ScopeLock . h \" # include \" QueuedThreadPool . h \" # include \" ScopeRWLock . h \" # include \" Stats / Stats2 . h \" # include \" Templates / Atomic . h \" # include \" Templates / Function . h \" # include \" Templates / RefCounting . h \" # include<atomic> class FQueuedThreadPoolWrapper : public FQueuedThreadPool { public :)",
    "insertText": "FQueuedThreadPoolWrapper(FQueuedThreadPool* InWrappedQueuedThreadPool, int32 InMaxConcurrency = -1, TFunction<EQueuedWorkPriority(EQueuedWorkPriority)> InPriorityMapper = [](EQueuedWorkPriority InPriority) { return InPriority; })"
  },
  {
    "label": "FQueuedThreadPoolWrapper()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FQueuedThreadPoolWrapper()"
  },
  {
    "label": "Pause()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Pause()"
  },
  {
    "label": "Resume()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Resume(int32 InNumQueuedWork = -1)"
  },
  {
    "label": "SetMaxConcurrency()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMaxConcurrency(int32 MaxConcurrency = -1)"
  },
  {
    "label": "AddQueuedWork()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddQueuedWork(IQueuedWork* InQueuedWork, EQueuedWorkPriority InPriority = EQueuedWorkPriority::Normal)"
  },
  {
    "label": "RetractQueuedWork()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RetractQueuedWork(IQueuedWork* InQueuedWork)"
  },
  {
    "label": "GetNumThreads()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumThreads()"
  },
  {
    "label": "GetCurrentConcurrency()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetCurrentConcurrency()"
  },
  {
    "label": "FScheduledWork()",
    "kind": "Method",
    "detail": "Function (} protected : class FScheduledWork : public IQueuedWork,public IExecutionResource { public :)",
    "insertText": "FScheduledWork()"
  },
  {
    "label": "FScheduledWork()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FScheduledWork(const FScheduledWork&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FScheduledWork&)",
    "insertText": "operator(const FScheduledWork&)"
  },
  {
    "label": "FScheduledWork()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FScheduledWork(const FScheduledWork&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FScheduledWork&)",
    "insertText": "operator(const FScheduledWork&&)"
  },
  {
    "label": "GetDebugName()",
    "kind": "Method",
    "detail": "Function (const TCHAR*)",
    "insertText": "GetDebugName()"
  },
  {
    "label": "TEXT()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "TEXT(\"FScheduledWork\")"
  },
  {
    "label": "AddRef()",
    "kind": "Method",
    "detail": "Function (} } private : uint32)",
    "insertText": "AddRef()"
  },
  {
    "label": "Release()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "Release()"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (uint32 Refs =)",
    "insertText": "uint32(NumRefs.Decrement())"
  },
  {
    "label": "Schedule()",
    "kind": "Method",
    "detail": "Function (ParentPool ->)",
    "insertText": "Schedule(const_cast<FScheduledWork*>(this))"
  },
  {
    "label": "GetRefCount()",
    "kind": "Method",
    "detail": "Function (} return Refs ; } uint32)",
    "insertText": "GetRefCount()"
  },
  {
    "label": "Assign()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Assign(FQueuedThreadPoolWrapper* InParentPool, IQueuedWork* InWork, EQueuedWorkPriority InPriority)"
  },
  {
    "label": "DoThreadedWork()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DoThreadedWork()"
  },
  {
    "label": "ExecutionContextScope()",
    "kind": "Method",
    "detail": "Function ({ FExecutionResourceContextScope)",
    "insertText": "ExecutionContextScope(this)"
  },
  {
    "label": "Abandon()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Abandon()"
  },
  {
    "label": "GetQueuedWorkFlags()",
    "kind": "Method",
    "detail": "Function (} EQueuedWorkFlags)",
    "insertText": "GetQueuedWorkFlags()"
  },
  {
    "label": "GetRequiredMemory()",
    "kind": "Method",
    "detail": "Function (} int64)",
    "insertText": "GetRequiredMemory()"
  },
  {
    "label": "GetInnerWork()",
    "kind": "Method",
    "detail": "Function (} IQueuedWork*)",
    "insertText": "GetInnerWork()"
  },
  {
    "label": "GetMaxConcurrency()",
    "kind": "Method",
    "detail": "Function (Work = nullptr ; } FThreadSafeCounter NumRefs ; class FQueuedThreadPoolWrapper ; FQueuedThreadPoolWrapper* ParentPool ; IQueuedWork* Work ; EQueuedWorkPriority Priority ; } ; FCriticalSection Lock ; FThreadPoolPriorityQueue QueuedWork ; int32)",
    "insertText": "GetMaxConcurrency()"
  },
  {
    "label": "OnScheduled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnScheduled(const IQueuedWork*)"
  },
  {
    "label": "OnUnscheduled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnUnscheduled(const IQueuedWork*)"
  },
  {
    "label": "AllocateScheduledWork()",
    "kind": "Method",
    "detail": "Function (} FScheduledWork*)",
    "insertText": "AllocateScheduledWork()"
  },
  {
    "label": "AllocateWork()",
    "kind": "Method",
    "detail": "Function (} private : FScheduledWork*)",
    "insertText": "AllocateWork(IQueuedWork* InnerWork, EQueuedWorkPriority Priority)"
  },
  {
    "label": "CanSchedule()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CanSchedule(EQueuedWorkPriority Priority)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Create(uint32 InNumQueuedThreads, uint32 StackSize, EThreadPriority ThreadPriority, const TCHAR* Name)"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destroy()"
  },
  {
    "label": "Schedule()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Schedule(FScheduledWork* Work = nullptr)"
  },
  {
    "label": "ReleaseWorkNoLock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseWorkNoLock(FScheduledWork* Work)"
  },
  {
    "label": "TryRetractWorkNoLock()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TryRetractWorkNoLock(EQueuedWorkPriority InPriority)"
  },
  {
    "label": "EQueuedWorkPriority()",
    "kind": "Method",
    "detail": "Function (TFunction<)",
    "insertText": "EQueuedWorkPriority(EQueuedWorkPriority)"
  },
  {
    "label": "FQueuedThreadPoolDynamicWrapper()",
    "kind": "Method",
    "detail": "Function (FQueuedThreadPool* WrappedQueuedThreadPool ; TArray<FScheduledWork*> WorkPool ; TMap<IQueuedWork*,FScheduledWork*> ScheduledWork ; std::atomic<int32> MaxConcurrency ; int32 MaxTaskToSchedule ; std::atomic<int32> CurrentConcurrency ; EQueuedWorkPriority WrappedQueuePriority ; bool bIsScheduling = false ; } ; class FQueuedThreadPoolDynamicWrapper : public FQueuedThreadPoolWrapper { public :)",
    "insertText": "FQueuedThreadPoolDynamicWrapper(FQueuedThreadPool* InWrappedQueuedThreadPool, int32 InMaxConcurrency = -1, TFunction<EQueuedWorkPriority(EQueuedWorkPriority)> InPriorityMapper = [](EQueuedWorkPriority InPriority) { return InPriority; }) : FQueuedThreadPoolWrapper(InWrappedQueuedThreadPool, InMaxConcurrency, InPriorityMapper)"
  },
  {
    "label": "AddQueuedWork()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddQueuedWork(InQueuedWork, EQueuedWorkPriority::Normal)"
  },
  {
    "label": "Sort()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Sort(TFunctionRef<bool(const IQueuedWork* Lhs, const IQueuedWork* Rhs)> Predicate)"
  },
  {
    "label": "ScopeLock()",
    "kind": "Method",
    "detail": "Function (FScopeLock)",
    "insertText": "ScopeLock(&Lock)"
  },
  {
    "label": "Sort()",
    "kind": "Method",
    "detail": "Function (QueuedWork .)",
    "insertText": "Sort(EQueuedWorkPriority::Normal, Predicate)"
  },
  {
    "label": "FQueuedThreadPoolTaskGraphWrapper()",
    "kind": "Method",
    "detail": "Function (} } ; class FQueuedThreadPoolTaskGraphWrapper final : public FQueuedThreadPool { public :)",
    "insertText": "FQueuedThreadPoolTaskGraphWrapper(TFunction<ENamedThreads::Type (EQueuedWorkPriority)> InPriorityMapper = nullptr) : TaskCount(0) , bIsExiting(0)"
  },
  {
    "label": "this()",
    "kind": "Method",
    "detail": "Function (PriorityMapper = InPriorityMapper ; } else { PriorityMapper = [)",
    "insertText": "this(EQueuedWorkPriority InPriority)"
  },
  {
    "label": "FQueuedThreadPoolTaskGraphWrapper()",
    "kind": "Method",
    "detail": "Function (} ; } })",
    "insertText": "FQueuedThreadPoolTaskGraphWrapper(ENamedThreads::Type InDesiredThread) : TaskCount(0) , bIsExiting(0)"
  },
  {
    "label": "InDesiredThread()",
    "kind": "Method",
    "detail": "Function (PriorityMapper = [)",
    "insertText": "InDesiredThread(EQueuedWorkPriority InPriority)"
  },
  {
    "label": "CreateAndDispatchWhenReady()",
    "kind": "Method",
    "detail": "Function (TaskCount + + ;)",
    "insertText": "CreateAndDispatchWhenReady([this, InQueuedWork](ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent) { FMemMark Mark(FMemStack::Get()); InQueuedWork->DoThreadedWork(); OnTaskCompleted(InQueuedWork); }, QUICK_USE_CYCLE_STAT(FQueuedThreadPoolTaskGraphWrapper, STATGROUP_ThreadPoolAsyncTasks), nullptr, PriorityMapper(InPriority))"
  },
  {
    "label": "Notify()",
    "kind": "Method",
    "detail": "Function (Finished .)",
    "insertText": "Notify()"
  },
  {
    "label": "GetDefaultPriorityMapping()",
    "kind": "Method",
    "detail": "Function (} ENamedThreads::Type)",
    "insertText": "GetDefaultPriorityMapping(EQueuedWorkPriority InQueuedWorkPriority)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ENamedThreads::Type DesiredThread = ENamedThreads::AnyNormalThreadNormalTask ;)",
    "insertText": "if(InQueuedWorkPriority > EQueuedWorkPriority::Normal)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (DesiredThread = ENamedThreads::AnyBackgroundThreadNormalTask ; } else)",
    "insertText": "if(InQueuedWorkPriority < EQueuedWorkPriority::Normal)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bIsExiting = true ;)",
    "insertText": "if(TaskCount != 0)"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (Finished .)",
    "insertText": "Wait()"
  },
  {
    "label": "Type()",
    "kind": "Method",
    "detail": "Function (} } private : TFunction<)",
    "insertText": "Type(EQueuedWorkPriority)"
  },
  {
    "label": "Retract()",
    "kind": "Method",
    "detail": "Function (TAtomic<uint32> TaskCount ; TAtomic<bool> bIsExiting ; UE::FManualResetEvent Finished ; } ; class FQueuedLowLevelThreadPool final : public FQueuedThreadPool { struct FQueuedWorkInternalData : TConcurrentLinearObject<FQueuedWorkInternalData,FTaskGraphBlockAllocationTag>,IQueuedWorkInternalData { LowLevelTasks::FTask Task ; bool)",
    "insertText": "Retract()"
  },
  {
    "label": "FQueuedLowLevelThreadPool()",
    "kind": "Method",
    "detail": "Function (} } ; public :)",
    "insertText": "FQueuedLowLevelThreadPool(TFunction<EQueuedWorkPriority(EQueuedWorkPriority)> InPriorityMapper = [](EQueuedWorkPriority InPriority) { return InPriority; }, LowLevelTasks::FScheduler* InScheduler = &LowLevelTasks::FScheduler::Get()) : Scheduler(InScheduler), PriorityMapper(InPriorityMapper)"
  },
  {
    "label": "FQueuedLowLevelThreadPool()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FQueuedLowLevelThreadPool()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (} void* operator)",
    "insertText": "new(size_t size)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (} void operator)",
    "insertText": "delete(void* ptr)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(ptr)"
  },
  {
    "label": "Dequeue()",
    "kind": "Method",
    "detail": "Function (FQueuedWorkInternalData* QueuedWork =)",
    "insertText": "Dequeue()"
  },
  {
    "label": "fetch_add()",
    "kind": "Method",
    "detail": "Function (break ; } TaskCount .)",
    "insertText": "fetch_add(1, std::memory_order_acquire)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(InNumQueuedWork == -1)"
  },
  {
    "label": "ScheduleTasks()",
    "kind": "Method",
    "detail": "Function (bIsPaused = false ; } bool bWakeUpWorker = true ;)",
    "insertText": "ScheduleTasks(bWakeUpWorker)"
  },
  {
    "label": "ScheduleTasks()",
    "kind": "Method",
    "detail": "Function (} private : void)",
    "insertText": "ScheduleTasks(bool &bWakeUpWorker)"
  },
  {
    "label": "IsBusyWaiting()",
    "kind": "Method",
    "detail": "Function (bWakeUpWorker | = LowLevelTasks::)",
    "insertText": "IsBusyWaiting()"
  },
  {
    "label": "FinalizeExecution()",
    "kind": "Method",
    "detail": "Function (bWakeUpWorker = true ; } else { break ; } } } void)",
    "insertText": "FinalizeExecution()"
  },
  {
    "label": "FQueuedWorkInternalData()",
    "kind": "Method",
    "detail": "Function (FQueuedWorkInternalData* QueuedWorkInternalData = new)",
    "insertText": "FQueuedWorkInternalData()"
  },
  {
    "label": "PriorityMapper()",
    "kind": "Method",
    "detail": "Function (InQueuedWork -> InternalData = QueuedWorkInternalData ; EQueuedWorkPriority Priority =)",
    "insertText": "PriorityMapper(InPriority)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (LowLevelTasks::ETaskPriority TaskPriorityMapper [)",
    "insertText": "int(EQueuedWorkPriority::Count)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (LowLevelTasks::ETaskPriority::High,LowLevelTasks::ETaskPriority::High,LowLevelTasks::ETaskPriority::BackgroundHigh,LowLevelTasks::ETaskPriority::BackgroundNormal,LowLevelTasks::ETaskPriority::BackgroundLow,LowLevelTasks::ETaskPriority::BackgroundLow } ; LowLevelTasks::ETaskPriority TaskPriority = TaskPriorityMapper [)",
    "insertText": "int(Priority)"
  },
  {
    "label": "Flags()",
    "kind": "Method",
    "detail": "Function (LowLevelTasks::ETaskFlags)",
    "insertText": "Flags(InQueuedWork->GetQueuedWorkFlags() & EQueuedWorkFlags::DoNotRunInsideBusyWait) == EQueuedWorkFlags::None ? LowLevelTasks::ETaskFlags::DefaultFlags : (LowLevelTasks::ETaskFlags::DefaultFlags & ~LowLevelTasks::ETaskFlags::AllowBusyWaiting)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (QueuedWorkInternalData -> Task .)",
    "insertText": "Init(TEXT(\"FQueuedLowLevelThreadPoolTask\"), TaskPriority, [InQueuedWork, InternalData = InQueuedWork->InternalData, Deleter = LowLevelTasks::TDeleter<FQueuedLowLevelThreadPool, &FQueuedLowLevelThreadPool::FinalizeExecution>{ this }] { FMemMark Mark(FMemStack::Get()); InQueuedWork->DoThreadedWork(); }, Flags)"
  },
  {
    "label": "Enqueue()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "Enqueue(Priority, QueuedWorkInternalData)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bCancelled = false ;)",
    "insertText": "if(InQueuedWork->InternalData.IsValid())"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (} protected : bool)",
    "insertText": "Create(uint32 InNumQueuedThreads, uint32 InStackSize, EThreadPriority InThreadPriority, const TCHAR* InName)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (bIsExiting = true ;)",
    "insertText": "while(true)"
  },
  {
    "label": "verify()",
    "kind": "Method",
    "detail": "Function (break ; })",
    "insertText": "verify(QueuedWork->Retract())"
  },
  {
    "label": "verifySlow()",
    "kind": "Method",
    "detail": "Function (TaskCount + + ;)",
    "insertText": "verifySlow(Scheduler->TryLaunch(QueuedWork->Task, LowLevelTasks::EQueuePreference::GlobalQueuePreference))"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (} } private : FAAArrayQueue<FQueuedWorkInternalData> PendingWork [)",
    "insertText": "int32(EQueuedWorkPriority::Count)"
  },
  {
    "label": "dequeue()",
    "kind": "Method",
    "detail": "Function (FQueuedWorkInternalData* QueuedWork = PendingWork [ i ] .)",
    "insertText": "dequeue()"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (PendingWork [)",
    "insertText": "int32(Priority)].enqueue(Item)"
  }
]