[
  {
    "label": "GetFirst",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GetFirst"
  },
  {
    "label": "Key",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Key"
  },
  {
    "label": "Mapped",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Mapped"
  },
  {
    "label": "Compare",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Compare"
  },
  {
    "label": "Container",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Container"
  },
  {
    "label": "flat_map",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "flat_map"
  },
  {
    "label": "K",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "K"
  },
  {
    "label": "M",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "M"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# ifndef RTC_BASE_CONTAINERS_FLAT_MAP_H_ # define RTC_BASE_CONTAINERS_FLAT_MAP_H_ # include<functional> # include<tuple> # include<utility> # include<vector> # include \" rtc_base / checks . h \" # include \" rtc_base / containers / flat_tree . h \" namespace webrtc { namespace flat_containers_internal { struct GetFirst { template<class Key,class Mapped> const Key&)",
    "insertText": "operator()(const std::pair<Key, Mapped>& p)"
  },
  {
    "label": "at()",
    "kind": "Method",
    "detail": "Function (template<class K> const mapped_type&)",
    "insertText": "at(const K& key)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (mapped_type&)",
    "insertText": "operator(const key_type& key)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (mapped_type&)",
    "insertText": "operator(key_type&& key)"
  },
  {
    "label": "insert_or_assign()",
    "kind": "Method",
    "detail": "Function (template<class K,class M> std::pair<iterator,bool>)",
    "insertText": "insert_or_assign(K&& key, M&& obj)"
  },
  {
    "label": "insert_or_assign()",
    "kind": "Method",
    "detail": "Function (template<class K,class M> iterator)",
    "insertText": "insert_or_assign(const_iterator hint, K&& key, M&& obj)"
  },
  {
    "label": "try_emplace()",
    "kind": "Method",
    "detail": "Function (template<class K,class . . . Args> std::enable_if_t<std::is_constructible<key_type,K&&>::value,std::pair<iterator,bool>>)",
    "insertText": "try_emplace(K&& key, Args&&... args)"
  },
  {
    "label": "try_emplace()",
    "kind": "Method",
    "detail": "Function (template<class K,class . . . Args> std::enable_if_t<std::is_constructible<key_type,K&&>::value,iterator>)",
    "insertText": "try_emplace(const_iterator hint, K&& key, Args&&... args)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(flat_map& other)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(flat_map& lhs, flat_map& rhs)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (lhs .)",
    "insertText": "swap(rhs)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (iterator found =)",
    "insertText": "find(key)"
  },
  {
    "label": "RTC_CHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_CHECK(found != tree::end())"
  },
  {
    "label": "RTC_CHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_CHECK(found != tree::cend())"
  },
  {
    "label": "lower_bound()",
    "kind": "Method",
    "detail": "Function (iterator found =)",
    "insertText": "lower_bound(key)"
  },
  {
    "label": "emplace_key_args()",
    "kind": "Method",
    "detail": "Function (auto result =)",
    "insertText": "emplace_key_args(key, std::forward<K>(key), std::forward<M>(obj))"
  },
  {
    "label": "emplace_hint_key_args()",
    "kind": "Method",
    "detail": "Function (auto result =)",
    "insertText": "emplace_hint_key_args(hint, key, std::forward<K>(key), std::forward<M>(obj))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(other)"
  }
]