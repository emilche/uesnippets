[
  {
    "label": "FTypedElementHandle",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTypedElementHandle"
  },
  {
    "label": "TTypedElementBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TTypedElementBase"
  },
  {
    "label": "TTypedElement",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TTypedElement"
  },
  {
    "label": "TTypedElementOwner",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TTypedElementOwner"
  },
  {
    "label": "FScriptTypedElementHandle",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FScriptTypedElementHandle"
  },
  {
    "label": "UTypedElementHandleLibrary",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UTypedElementHandleLibrary"
  },
  {
    "label": "FTypedElementHandle()",
    "kind": "Method",
    "detail": "Function (# pragma once # include<type_traits> # include \" CoreMinimal . h \" # include \" Elements / Framework / TypedElementData . h \" # include \" TypedElementHandle . generated . h \" struct FTypedElementHandle { public :)",
    "insertText": "FTypedElementHandle()"
  },
  {
    "label": "FTypedElementHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FTypedElementHandle(const FTypedElementHandle& InOther)"
  },
  {
    "label": "Private_InitializeAddRef()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Private_InitializeAddRef(*InOther.DataPtr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } FTypedElementHandle&)",
    "insertText": "operator(const FTypedElementHandle& InOther)"
  },
  {
    "label": "Private_DestroyReleaseRef()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Private_DestroyReleaseRef()"
  },
  {
    "label": "FTypedElementHandle()",
    "kind": "Method",
    "detail": "Function (} } return* this ; })",
    "insertText": "FTypedElementHandle(FTypedElementHandle&& InOther) : DataPtr(InOther.DataPtr) #if UE_TYPED_ELEMENT_HAS_REFTRACKING , ReferenceId(InOther.ReferenceId)"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (InOther . DataPtr = nullptr ; # if UE_TYPED_ELEMENT_HAS_REFTRACKING InOther . ReferenceId = INDEX_NONE ; # endif)",
    "insertText": "checkSlow(!InOther.IsSet())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FTypedElementHandle&)",
    "insertText": "operator(FTypedElementHandle&& InOther)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "IsSet()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsSet()"
  },
  {
    "label": "GetId()",
    "kind": "Method",
    "detail": "Function (} const FTypedElementId&)",
    "insertText": "GetId()"
  },
  {
    "label": "IsDataOfType()",
    "kind": "Method",
    "detail": "Function (} template<ElementDataType> bool)",
    "insertText": "IsDataOfType()"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (} template<ElementDataType> const ElementDataType*)",
    "insertText": "GetData(const bool bSilent = false)"
  },
  {
    "label": "KismetExecutionMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "KismetExecutionMessage(TEXT(\"Element handle data is null!\"), ELogVerbosity::Error)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} return nullptr ; })",
    "insertText": "if(!IsDataOfType<ElementDataType>())"
  },
  {
    "label": "KismetExecutionMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "KismetExecutionMessage(*FString::Printf(TEXT(\"Element handle data type is '%d', but '%d' (%s) was requested!\"), GetId().GetTypeId(), ElementDataType::StaticTypeId(), *ElementDataType::StaticTypeName().ToString()), ELogVerbosity::Error)"
  },
  {
    "label": "ElementDataType()",
    "kind": "Method",
    "detail": "Function (} return nullptr ; } return static_cast<const)",
    "insertText": "ElementDataType(DataPtr->GetUntypedData())"
  },
  {
    "label": "GetDataChecked()",
    "kind": "Method",
    "detail": "Function (} template<ElementDataType> const ElementDataType&)",
    "insertText": "GetDataChecked()"
  },
  {
    "label": "AcquireId()",
    "kind": "Method",
    "detail": "Function (} FTypedElementId)",
    "insertText": "AcquireId()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FTypedElementId ElementId ;)",
    "insertText": "if(IsSet())"
  },
  {
    "label": "AddRef()",
    "kind": "Method",
    "detail": "Function (DataPtr ->)",
    "insertText": "AddRef(false)"
  },
  {
    "label": "Private_InitializeNoRef()",
    "kind": "Method",
    "detail": "Function (ElementId .)",
    "insertText": "Private_InitializeNoRef(DataPtr->GetId().GetTypeId(), DataPtr->GetId().GetElementId())"
  },
  {
    "label": "ReleaseId()",
    "kind": "Method",
    "detail": "Function (} return ElementId ; } void)",
    "insertText": "ReleaseId(FTypedElementId& InOutElementId)"
  },
  {
    "label": "ReleaseRef()",
    "kind": "Method",
    "detail": "Function (DataPtr ->)",
    "insertText": "ReleaseRef(INDEX_NONE)"
  },
  {
    "label": "Private_DestroyNoRef()",
    "kind": "Method",
    "detail": "Function (InOutElementId .)",
    "insertText": "Private_DestroyNoRef()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "operator(const FTypedElementHandle& InLHS, const FTypedElementHandle& InRHS)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetTypeHash(const FTypedElementHandle& InElementHandle)"
  },
  {
    "label": "Private_InitializeNoRef()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Private_InitializeNoRef(const FTypedElementInternalData& InData)"
  },
  {
    "label": "Private_InitializeAddRef()",
    "kind": "Method",
    "detail": "Function (DataPtr =& InData ; } void)",
    "insertText": "Private_InitializeAddRef(const FTypedElementInternalData& InData)"
  },
  {
    "label": "Private_InitializeNoRef()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Private_InitializeNoRef(InData)"
  },
  {
    "label": "RegisterRef()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterRef()"
  },
  {
    "label": "UnregisterRef()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnregisterRef()"
  },
  {
    "label": "Private_GetInternalData()",
    "kind": "Method",
    "detail": "Function (} const FTypedElementInternalData*)",
    "insertText": "Private_GetInternalData()"
  },
  {
    "label": "AddRef()",
    "kind": "Method",
    "detail": "Function (# if ! UE_TYPED_ELEMENT_HAS_REFTRACKING FTypedElementReferenceId ReferenceId = INDEX_NONE ; # endif ReferenceId = DataPtr ->)",
    "insertText": "AddRef(true)"
  },
  {
    "label": "ReleaseRef()",
    "kind": "Method",
    "detail": "Function (# if ! UE_TYPED_ELEMENT_HAS_REFTRACKING FTypedElementReferenceId ReferenceId = INDEX_NONE ; # endif DataPtr ->)",
    "insertText": "ReleaseRef(ReferenceId)"
  },
  {
    "label": "TTypedElementBase()",
    "kind": "Method",
    "detail": "Function (} } const FTypedElementInternalData* DataPtr = nullptr ; # if UE_TYPED_ELEMENT_HAS_REFTRACKING FTypedElementReferenceId ReferenceId = INDEX_NONE ; # endif } ; template<BaseInterfaceType> struct TTypedElementBase : public FTypedElementHandle { public :)",
    "insertText": "TTypedElementBase()"
  },
  {
    "label": "TTypedElementBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TTypedElementBase(const TTypedElementBase&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TTypedElementBase&)",
    "insertText": "operator(const TTypedElementBase&)"
  },
  {
    "label": "TTypedElementBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TTypedElementBase(TTypedElementBase&& InOther) : FTypedElementHandle(MoveTemp(InOther)) , InterfacePtr(InOther.InterfacePtr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TTypedElementBase&)",
    "insertText": "operator(TTypedElementBase&& InOther)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(MoveTemp(InOther))"
  },
  {
    "label": "Release()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Release()"
  },
  {
    "label": "GetInterface()",
    "kind": "Method",
    "detail": "Function (} BaseInterfaceType*)",
    "insertText": "GetInterface()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TTypedElementBase& InLHS, const TTypedElementBase& InRHS)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetTypeHash(const TTypedElementBase& InElement)"
  },
  {
    "label": "Private_InitializeNoRef()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Private_InitializeNoRef(const FTypedElementInternalData& InData, BaseInterfaceType* InInterfacePtr)"
  },
  {
    "label": "Private_InitializeAddRef()",
    "kind": "Method",
    "detail": "Function (InterfacePtr = InInterfacePtr ; } void)",
    "insertText": "Private_InitializeAddRef(const FTypedElementInternalData& InData, BaseInterfaceType* InInterfacePtr)"
  },
  {
    "label": "Private_InitializeAddRef()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Private_InitializeAddRef(InData)"
  },
  {
    "label": "TTypedElementOwner()",
    "kind": "Method",
    "detail": "Function (InterfacePtr = nullptr ; } protected : BaseInterfaceType* InterfacePtr = nullptr ; } ; template<BaseInterfaceType> struct TTypedElement : public TTypedElementBase<BaseInterfaceType> { } ; using FTypedElement = TTypedElement<void> ; template<ElementDataType> struct TTypedElementOwner { public :)",
    "insertText": "TTypedElementOwner()"
  },
  {
    "label": "TTypedElementOwner()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TTypedElementOwner(const TTypedElementOwner&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TTypedElementOwner&)",
    "insertText": "operator(const TTypedElementOwner&)"
  },
  {
    "label": "TTypedElementOwner()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TTypedElementOwner(TTypedElementOwner&& InOther) : DataPtr(InOther.DataPtr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TTypedElementOwner&)",
    "insertText": "operator(TTypedElementOwner&& InOther)"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (} template<U = ElementDataType,std::enable_if_t<! std::is_void<U>::value>* = nullptr> U*)",
    "insertText": "GetData()"
  },
  {
    "label": "AcquireHandle()",
    "kind": "Method",
    "detail": "Function (} } FTypedElementHandle)",
    "insertText": "AcquireHandle()"
  },
  {
    "label": "Private_InitializeAddRef()",
    "kind": "Method",
    "detail": "Function (ElementHandle .)",
    "insertText": "Private_InitializeAddRef(*DataPtr)"
  },
  {
    "label": "ReleaseHandle()",
    "kind": "Method",
    "detail": "Function (} return ElementHandle ; } void)",
    "insertText": "ReleaseHandle(FTypedElementHandle& InOutElementHandle)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TTypedElementOwner& InLHS, const TTypedElementOwner& InRHS)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetTypeHash(const TTypedElementOwner& InElementOwner)"
  },
  {
    "label": "Private_InitializeNoRef()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Private_InitializeNoRef(TTypedElementInternalData<ElementDataType>& InData)"
  },
  {
    "label": "Private_InitializeAddRef()",
    "kind": "Method",
    "detail": "Function (DataPtr =& InData ; } void)",
    "insertText": "Private_InitializeAddRef(TTypedElementInternalData<ElementDataType>& InData)"
  },
  {
    "label": "USTRUCT()",
    "kind": "Method",
    "detail": "Function (} } TTypedElementInternalData<ElementDataType>* DataPtr = nullptr ; # if UE_TYPED_ELEMENT_HAS_REFTRACKING FTypedElementReferenceId ReferenceId = INDEX_NONE ; # endif } ; using FTypedElementOwner = TTypedElementOwner<void> ;)",
    "insertText": "USTRUCT(BlueprintType)"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() public: FScriptTypedElementHandle()"
  },
  {
    "label": "FScriptTypedElementHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FScriptTypedElementHandle(const FScriptTypedElementHandle& InOther) : InternalData(InOther.InternalData)"
  },
  {
    "label": "FScriptTypedElementHandle()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FScriptTypedElementHandle(FScriptTypedElementHandle&& InOther) : InternalData(MoveTemp(InOther.InternalData))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FScriptTypedElementHandle&)",
    "insertText": "operator(const FScriptTypedElementHandle& InOther)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (InternalData = InOther . InternalData ; return* this ; } FScriptTypedElementHandle&)",
    "insertText": "operator(FScriptTypedElementHandle&& InOther)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (InternalData =)",
    "insertText": "MoveTemp(InOther.InternalData)"
  },
  {
    "label": "Private_Initialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Private_Initialize(FScriptTypedElementInternalDataPtr&& InInternalData)"
  },
  {
    "label": "GetTypedElementHandle()",
    "kind": "Method",
    "detail": "Function (} FTypedElementHandle)",
    "insertText": "GetTypedElementHandle()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FTypedElementHandle Handle ;)",
    "insertText": "if(FTypedElementInternalData* TypedElementInternalData = InternalData.GetInternalData())"
  },
  {
    "label": "Private_InitializeAddRef()",
    "kind": "Method",
    "detail": "Function (Handle .)",
    "insertText": "Private_InitializeAddRef(*TypedElementInternalData)"
  },
  {
    "label": "UCLASS()",
    "kind": "Method",
    "detail": "Function (} return Handle ; } private : FScriptTypedElementInternalDataPtr InternalData ; } ;)",
    "insertText": "UCLASS()"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() public: UFUNCTION(BlueprintPure, Category=\"TypedElementFramework|Handle\", meta=(ScriptMethod, ScriptOperator=\"bool\")) static bool IsSet(const FScriptTypedElementHandle& ElementHandle)"
  }
]