[
  {
    "label": "_EXRVersion",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_EXRVersion"
  },
  {
    "label": "_EXRAttribute",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_EXRAttribute"
  },
  {
    "label": "_EXRChannelInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_EXRChannelInfo"
  },
  {
    "label": "_EXRTile",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_EXRTile"
  },
  {
    "label": "_EXRHeader",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_EXRHeader"
  },
  {
    "label": "_EXRMultiPartHeader",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_EXRMultiPartHeader"
  },
  {
    "label": "_EXRImage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_EXRImage"
  },
  {
    "label": "_EXRMultiPartImage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_EXRMultiPartImage"
  },
  {
    "label": "_DeepImage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_DeepImage"
  },
  {
    "label": "mz_internal_state",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "mz_internal_state"
  },
  {
    "label": "mz_stream_s",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "mz_stream_s"
  },
  {
    "label": "mz_zip_internal_state_tag",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "mz_zip_internal_state_tag"
  },
  {
    "label": "mz_zip_archive_tag",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "mz_zip_archive_tag"
  },
  {
    "label": "tinfl_decompressor_tag",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "tinfl_decompressor_tag"
  },
  {
    "label": "tm",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "tm"
  },
  {
    "label": "MZ_FILE_STAT_STRUCT",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MZ_FILE_STAT_STRUCT"
  },
  {
    "label": "utimbuf",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "utimbuf"
  },
  {
    "label": "ChannelInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ChannelInfo"
  },
  {
    "label": "HeaderInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HeaderInfo"
  },
  {
    "label": "PIZChannelData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PIZChannelData"
  },
  {
    "label": "HufDec",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HufDec"
  },
  {
    "label": "FHeapCompare",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FHeapCompare"
  },
  {
    "label": "ZFPCompressionParam",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ZFPCompressionParam"
  },
  {
    "label": "LayerChannel",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LayerChannel"
  },
  {
    "label": "TINYEXR_USE_MINIZ()",
    "kind": "Method",
    "detail": "Function (# ifndef TINYEXR_H_ # define TINYEXR_H_ # include<stddef . h> # include<stdint . h> # ifdef __cplusplus \" C \" { # endif # ifndef TINYEXR_USE_MINIZ # define)",
    "insertText": "TINYEXR_USE_MINIZ(1) #endif #ifndef TINYEXR_USE_PIZ #define TINYEXR_USE_PIZ (1) #endif #ifndef TINYEXR_USE_ZFP #define TINYEXR_USE_ZFP (0) #endif #ifndef TINYEXR_USE_THREAD #define TINYEXR_USE_THREAD (0) #endif #ifndef TINYEXR_USE_OPENMP #ifdef _OPENMP #define TINYEXR_USE_OPENMP (1) #else #define TINYEXR_USE_OPENMP (0) #endif #endif #define TINYEXR_SUCCESS (0) #define TINYEXR_ERROR_INVALID_MAGIC_NUMBER (-1) #define TINYEXR_ERROR_INVALID_EXR_VERSION (-2) #define TINYEXR_ERROR_INVALID_ARGUMENT (-3) #define TINYEXR_ERROR_INVALID_DATA (-4) #define TINYEXR_ERROR_INVALID_FILE (-5) #define TINYEXR_ERROR_INVALID_PARAMETER (-6) #define TINYEXR_ERROR_CANT_OPEN_FILE (-7) #define TINYEXR_ERROR_UNSUPPORTED_FORMAT (-8) #define TINYEXR_ERROR_INVALID_HEADER (-9) #define TINYEXR_ERROR_UNSUPPORTED_FEATURE (-10) #define TINYEXR_ERROR_CANT_WRITE_FILE (-11) #define TINYEXR_ERROR_SERIALZATION_FAILED (-12) #define TINYEXR_ERROR_LAYER_NOT_FOUND (-13) #define TINYEXR_PIXELTYPE_UINT (0) #define TINYEXR_PIXELTYPE_HALF (1) #define TINYEXR_PIXELTYPE_FLOAT (2) #define TINYEXR_MAX_HEADER_ATTRIBUTES (1024) #define TINYEXR_MAX_CUSTOM_ATTRIBUTES (128) #define TINYEXR_COMPRESSIONTYPE_NONE (0) #define TINYEXR_COMPRESSIONTYPE_RLE (1) #define TINYEXR_COMPRESSIONTYPE_ZIPS (2) #define TINYEXR_COMPRESSIONTYPE_ZIP (3) #define TINYEXR_COMPRESSIONTYPE_PIZ (4) #define TINYEXR_COMPRESSIONTYPE_ZFP (128) #define TINYEXR_ZFP_COMPRESSIONTYPE_RATE (0) #define TINYEXR_ZFP_COMPRESSIONTYPE_PRECISION (1) #define TINYEXR_ZFP_COMPRESSIONTYPE_ACCURACY (2) #define TINYEXR_TILE_ONE_LEVEL (0) #define TINYEXR_TILE_MIPMAP_LEVELS (1) #define TINYEXR_TILE_RIPMAP_LEVELS (2) #define TINYEXR_TILE_ROUND_DOWN (0) #define TINYEXR_TILE_ROUND_UP (1)"
  },
  {
    "label": "LoadEXR()",
    "kind": "Method",
    "detail": "Function (int version ; int tiled ; int long_name ; int non_image ; int multipart ; } EXRVersion ; typedef struct _EXRAttribute { char name [ 2 5 6 ] ; char type [ 2 5 6 ] ; unsigned char* value ; int size ; int pad0 ; } EXRAttribute ; typedef struct _EXRChannelInfo { char name [ 2 5 6 ] ; int pixel_type ; int x_sampling ; int y_sampling ; unsigned char p_linear ; unsigned char pad [ 3 ] ; } EXRChannelInfo ; typedef struct _EXRTile { int offset_x ; int offset_y ; int level_x ; int level_y ; int width ; int height ; unsigned char** images ; } EXRTile ; typedef struct _EXRHeader { float pixel_aspect_ratio ; int line_order ; int data_window [ 4 ] ; int display_window [ 4 ] ; float screen_window_center [ 2 ] ; float screen_window_width ; int chunk_count ; int tiled ; int tile_size_x ; int tile_size_y ; int tile_level_mode ; int tile_rounding_mode ; int long_name ; int non_image ; int multipart ; unsigned int header_len ; int num_custom_attributes ; EXRAttribute* custom_attributes ; EXRChannelInfo* channels ; int* pixel_types ; int num_channels ; int compression_type ; int* requested_pixel_types ; } EXRHeader ; typedef struct _EXRMultiPartHeader { int num_headers ; EXRHeader* headers ; } EXRMultiPartHeader ; typedef struct _EXRImage { EXRTile* tiles ; unsigned char** images ; int width ; int height ; int num_channels ; int num_tiles ; } EXRImage ; typedef struct _EXRMultiPartImage { int num_images ; EXRImage* images ; } EXRMultiPartImage ; typedef struct _DeepImage { const char** channel_names ; float*** image ; int** offset_table ; int num_channels ; int width ; int height ; int pad0 ; } DeepImage ; int)",
    "insertText": "LoadEXR(float **out_rgba, int *width, int *height, const char *filename, const char **err)"
  },
  {
    "label": "LoadEXRWithLayer()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "LoadEXRWithLayer(float **out_rgba, int *width, int *height, const char *filename, const char *layer_name, const char **err)"
  },
  {
    "label": "EXRLayers()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "EXRLayers(const char *filename, const char **layer_names[], int *num_layers, const char **err)"
  },
  {
    "label": "IsEXR()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "IsEXR(const char *filename)"
  },
  {
    "label": "SaveEXR()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "SaveEXR(const float *data, const int width, const int height, const int components, const int save_as_fp16, const char *filename, const char **err)"
  },
  {
    "label": "InitEXRHeader()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitEXRHeader(EXRHeader *exr_header)"
  },
  {
    "label": "InitEXRImage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitEXRImage(EXRImage *exr_image)"
  },
  {
    "label": "FreeEXRHeader()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "FreeEXRHeader(EXRHeader *exr_header)"
  },
  {
    "label": "FreeEXRImage()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "FreeEXRImage(EXRImage *exr_image)"
  },
  {
    "label": "FreeEXRErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeEXRErrorMessage(const char *msg)"
  },
  {
    "label": "ParseEXRVersionFromFile()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "ParseEXRVersionFromFile(EXRVersion *version, const char *filename)"
  },
  {
    "label": "ParseEXRVersionFromMemory()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "ParseEXRVersionFromMemory(EXRVersion *version, const unsigned char *memory, size_t size)"
  },
  {
    "label": "ParseEXRHeaderFromFile()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "ParseEXRHeaderFromFile(EXRHeader *header, const EXRVersion *version, const char *filename, const char **err)"
  },
  {
    "label": "ParseEXRHeaderFromMemory()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "ParseEXRHeaderFromMemory(EXRHeader *header, const EXRVersion *version, const unsigned char *memory, size_t size, const char **err)"
  },
  {
    "label": "ParseEXRMultipartHeaderFromFile()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "ParseEXRMultipartHeaderFromFile(EXRHeader ***headers, int *num_headers, const EXRVersion *version, const char *filename, const char **err)"
  },
  {
    "label": "ParseEXRMultipartHeaderFromMemory()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "ParseEXRMultipartHeaderFromMemory(EXRHeader ***headers, int *num_headers, const EXRVersion *version, const unsigned char *memory, size_t size, const char **err)"
  },
  {
    "label": "LoadEXRImageFromFile()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "LoadEXRImageFromFile(EXRImage *image, const EXRHeader *header, const char *filename, const char **err)"
  },
  {
    "label": "LoadEXRImageFromMemory()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "LoadEXRImageFromMemory(EXRImage *image, const EXRHeader *header, const unsigned char *memory, const size_t size, const char **err)"
  },
  {
    "label": "LoadEXRMultipartImageFromFile()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "LoadEXRMultipartImageFromFile(EXRImage *images, const EXRHeader **headers, unsigned int num_parts, const char *filename, const char **err)"
  },
  {
    "label": "LoadEXRMultipartImageFromMemory()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "LoadEXRMultipartImageFromMemory(EXRImage *images, const EXRHeader **headers, unsigned int num_parts, const unsigned char *memory, const size_t size, const char **err)"
  },
  {
    "label": "SaveEXRImageToFile()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "SaveEXRImageToFile(const EXRImage *image, const EXRHeader *exr_header, const char *filename, const char **err)"
  },
  {
    "label": "SaveEXRImageToMemory()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "SaveEXRImageToMemory(const EXRImage *image, const EXRHeader *exr_header, unsigned char **memory, const char **err)"
  },
  {
    "label": "LoadDeepEXR()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "LoadDeepEXR(DeepImage *out_image, const char *filename, const char **err)"
  },
  {
    "label": "LoadEXRFromMemory()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "LoadEXRFromMemory(float **out_rgba, int *width, int *height, const unsigned char *memory, size_t size, const char **err)"
  },
  {
    "label": "__has_warning()",
    "kind": "Method",
    "detail": "Function (# ifdef __cplusplus } # endif # endif # ifdef TINYEXR_IMPLEMENTATION # ifndef TINYEXR_IMPLEMENTATION_DEIFNED # define TINYEXR_IMPLEMENTATION_DEIFNED # include<algorithm> # include<cstdio> # include<cstdlib> # include<cstring> # include<sstream> # include<limits> # include<string> # include<vector> # if __cplusplus> 1 9 9 7 1 1 L # include<cstdint> # if TINYEXR_USE_THREAD # include<atomic> # include<thread> # endif # endif # if TINYEXR_USE_OPENMP # include<omp . h> # endif # if TINYEXR_USE_MINIZ # else # endif # if TINYEXR_USE_ZFP # include \" zfp . h \" # endif namespace tinyexr { # if __cplusplus> 1 9 9 7 1 1 L typedef uint64_t tinyexr_uint64 ; typedef int64_t tinyexr_int64 ; # else # ifdef __clang__ # pragma clang diagnostic push # pragma clang diagnostic ignored \" - Wc + + 1 1 - long - long \" # endif typedef unsigned long long tinyexr_uint64 ; typedef long long tinyexr_int64 ; # ifdef __clang__ # pragma clang diagnostic pop # endif # endif # if TINYEXR_USE_MINIZ namespace miniz { # ifdef __clang__ # pragma clang diagnostic push # pragma clang diagnostic ignored \" - Wc + + 1 1 - long - long \" # pragma clang diagnostic ignored \" - Wold - style - cast \" # pragma clang diagnostic ignored \" - Wpadded \" # pragma clang diagnostic ignored \" - Wsign - conversion \" # pragma clang diagnostic ignored \" - Wc + + 1 1 - extensions \" # pragma clang diagnostic ignored \" - Wconversion \" # pragma clang diagnostic ignored \" - Wunused - function \" # pragma clang diagnostic ignored \" - Wc + + 9 8 - compat - pedantic \" # pragma clang diagnostic ignored \" - Wundef \" # if)",
    "insertText": "__has_warning(\"-Wcomma\") #pragma clang diagnostic ignored \"-Wcomma\" #endif #if __has_warning(\"-Wmacro-redefined\") #pragma clang diagnostic ignored \"-Wmacro-redefined\" #endif #if __has_warning(\"-Wcast-qual\") #pragma clang diagnostic ignored \"-Wcast-qual\" #endif #if __has_warning(\"-Wzero-as-null-pointer-constant\") #pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\" #endif #if __has_warning(\"-Wtautological-constant-compare\") #pragma clang diagnostic ignored \"-Wtautological-constant-compare\" #endif #if __has_warning(\"-Wextra-semi-stmt\") #pragma clang diagnostic ignored \"-Wextra-semi-stmt\" #endif #endif #ifndef MINIZ_HEADER_INCLUDED #define MINIZ_HEADER_INCLUDED #define MINIZ_NO_TIME #define MINIZ_NO_ARCHIVE_APIS #if defined(__TINYC__) && (defined(__linux) || defined(__linux__)) #define MINIZ_NO_TIME #endif #if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_ARCHIVE_APIS) #endif #if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || \\ defined(__i386) || defined(__i486__) || defined(__i486) || \\ defined(i386) || defined(__ia64__) || defined(__x86_64__) #define MINIZ_X86_OR_X64_CPU 1 #endif #if defined(__sparcv9) #else #if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || MINIZ_X86_OR_X64_CPU #define MINIZ_LITTLE_ENDIAN 1 #endif #endif #if MINIZ_X86_OR_X64_CPU #define MINIZ_USE_UNALIGNED_LOADS_AND_STORES \\ 0 #endif #if defined(_M_X64) || defined(_WIN64) || defined(__MINGW64__) || \\ defined(_LP64) || defined(__LP64__) || defined(__ia64__) || \\ defined(__x86_64__)"
  },
  {
    "label": "mz_free()",
    "kind": "Method",
    "detail": "Function (# endif typedef unsigned long mz_ulong ; void)",
    "insertText": "mz_free(void *p)"
  },
  {
    "label": "MZ_ADLER32_INIT()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "MZ_ADLER32_INIT(1) mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len)"
  },
  {
    "label": "MZ_CRC32_INIT()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "MZ_CRC32_INIT(0) mz_ulong mz_crc32(mz_ulong crc, const unsigned char *ptr, size_t buf_len)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (enum { MZ_DEFAULT_STRATEGY = 0,MZ_FILTERED = 1,MZ_HUFFMAN_ONLY = 2,MZ_RLE = 3,MZ_FIXED = 4 } ; # define MZ_DEFLATED 8 # ifndef MINIZ_NO_ZLIB_APIS typedef)",
    "insertText": "void(*mz_alloc_func)(void *opaque, size_t items, size_t size)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "void(*mz_free_func)(void *opaque, void *address)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "void(*mz_realloc_func)(void *opaque, void *address, size_t items, size_t size)"
  },
  {
    "label": "mz_version()",
    "kind": "Method",
    "detail": "Function (# define MZ_VERSION \" 9 . 1 . 1 5 \" # define MZ_VERNUM 0 x91F0 # define MZ_VER_MAJOR 9 # define MZ_VER_MINOR 1 # define MZ_VER_REVISION 1 5 # define MZ_VER_SUBREVISION 0 enum { MZ_NO_FLUSH = 0,MZ_PARTIAL_FLUSH = 1,MZ_SYNC_FLUSH = 2,MZ_FULL_FLUSH = 3,MZ_FINISH = 4,MZ_BLOCK = 5 } ; enum { MZ_OK = 0,MZ_STREAM_END = 1,MZ_NEED_DICT = 2,MZ_ERRNO = - 1,MZ_STREAM_ERROR = - 2,MZ_DATA_ERROR = - 3,MZ_MEM_ERROR = - 4,MZ_BUF_ERROR = - 5,MZ_VERSION_ERROR = - 6,MZ_PARAM_ERROR = - 1 0 0 0 0 } ; enum { MZ_NO_COMPRESSION = 0,MZ_BEST_SPEED = 1,MZ_BEST_COMPRESSION = 9,MZ_UBER_COMPRESSION = 1 0,MZ_DEFAULT_LEVEL = 6,MZ_DEFAULT_COMPRESSION = - 1 } ; # define MZ_DEFAULT_WINDOW_BITS 1 5 struct mz_internal_state ; typedef struct mz_stream_s { const unsigned char* next_in ; unsigned int avail_in ; mz_ulong total_in ; unsigned char* next_out ; unsigned int avail_out ; mz_ulong total_out ; char* msg ; struct mz_internal_state* state ; mz_alloc_func zalloc ; mz_free_func zfree ; void* opaque ; int data_type ; mz_ulong adler ; mz_ulong reserved ; } mz_stream ; typedef mz_stream* mz_streamp ; const char*)",
    "insertText": "mz_version(void)"
  },
  {
    "label": "mz_deflateInit()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "mz_deflateInit(mz_streamp pStream, int level)"
  },
  {
    "label": "mz_deflateInit2()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy)"
  },
  {
    "label": "mz_deflateReset()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "mz_deflateReset(mz_streamp pStream)"
  },
  {
    "label": "mz_deflate()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "mz_deflate(mz_streamp pStream, int flush)"
  },
  {
    "label": "mz_deflateEnd()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "mz_deflateEnd(mz_streamp pStream)"
  },
  {
    "label": "mz_deflateBound()",
    "kind": "Method",
    "detail": "Function (mz_ulong)",
    "insertText": "mz_deflateBound(mz_streamp pStream, mz_ulong source_len)"
  },
  {
    "label": "mz_compress()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)"
  },
  {
    "label": "mz_compress2()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level)"
  },
  {
    "label": "mz_compressBound()",
    "kind": "Method",
    "detail": "Function (mz_ulong)",
    "insertText": "mz_compressBound(mz_ulong source_len)"
  },
  {
    "label": "mz_inflateInit()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "mz_inflateInit(mz_streamp pStream)"
  },
  {
    "label": "mz_inflateInit2()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "mz_inflateInit2(mz_streamp pStream, int window_bits)"
  },
  {
    "label": "mz_inflate()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "mz_inflate(mz_streamp pStream, int flush)"
  },
  {
    "label": "mz_inflateEnd()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "mz_inflateEnd(mz_streamp pStream)"
  },
  {
    "label": "mz_uncompress()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)"
  },
  {
    "label": "mz_error()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "mz_error(int err)"
  },
  {
    "label": "mz_version()",
    "kind": "Method",
    "detail": "Function (# ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES typedef unsigned char Byte ; typedef unsigned int uInt ; typedef mz_ulong uLong ; typedef Byte Bytef ; typedef uInt uIntf ; typedef char charf ; typedef int intf ; typedef void* voidpf ; typedef uLong uLongf ; typedef void* voidp ; typedef void* const voidpc ; # define Z_NULL 0 # define Z_NO_FLUSH MZ_NO_FLUSH # define Z_PARTIAL_FLUSH MZ_PARTIAL_FLUSH # define Z_SYNC_FLUSH MZ_SYNC_FLUSH # define Z_FULL_FLUSH MZ_FULL_FLUSH # define Z_FINISH MZ_FINISH # define Z_BLOCK MZ_BLOCK # define Z_OK MZ_OK # define Z_STREAM_END MZ_STREAM_END # define Z_NEED_DICT MZ_NEED_DICT # define Z_ERRNO MZ_ERRNO # define Z_STREAM_ERROR MZ_STREAM_ERROR # define Z_DATA_ERROR MZ_DATA_ERROR # define Z_MEM_ERROR MZ_MEM_ERROR # define Z_BUF_ERROR MZ_BUF_ERROR # define Z_VERSION_ERROR MZ_VERSION_ERROR # define Z_PARAM_ERROR MZ_PARAM_ERROR # define Z_NO_COMPRESSION MZ_NO_COMPRESSION # define Z_BEST_SPEED MZ_BEST_SPEED # define Z_BEST_COMPRESSION MZ_BEST_COMPRESSION # define Z_DEFAULT_COMPRESSION MZ_DEFAULT_COMPRESSION # define Z_DEFAULT_STRATEGY MZ_DEFAULT_STRATEGY # define Z_FILTERED MZ_FILTERED # define Z_HUFFMAN_ONLY MZ_HUFFMAN_ONLY # define Z_RLE MZ_RLE # define Z_FIXED MZ_FIXED # define Z_DEFLATED MZ_DEFLATED # define Z_DEFAULT_WINDOW_BITS MZ_DEFAULT_WINDOW_BITS # define alloc_func mz_alloc_func # define free_func mz_free_func # define internal_state mz_internal_state # define z_stream mz_stream # define deflateInit mz_deflateInit # define deflateInit2 mz_deflateInit2 # define deflateReset mz_deflateReset # define deflate mz_deflate # define deflateEnd mz_deflateEnd # define deflateBound mz_deflateBound # define compress mz_compress # define compress2 mz_compress2 # define compressBound mz_compressBound # define inflateInit mz_inflateInit # define inflateInit2 mz_inflateInit2 # define inflate mz_inflate # define inflateEnd mz_inflateEnd # define uncompress mz_uncompress # define crc32 mz_crc32 # define adler32 mz_adler32 # define MAX_WBITS 1 5 # define MAX_MEM_LEVEL 9 # define zError mz_error # define ZLIB_VERSION MZ_VERSION # define ZLIB_VERNUM MZ_VERNUM # define ZLIB_VER_MAJOR MZ_VER_MAJOR # define ZLIB_VER_MINOR MZ_VER_MINOR # define ZLIB_VER_REVISION MZ_VER_REVISION # define ZLIB_VER_SUBREVISION MZ_VER_SUBREVISION # define zlibVersion mz_version # define zlib_version)",
    "insertText": "mz_version()"
  },
  {
    "label": "MZ_FALSE()",
    "kind": "Method",
    "detail": "Function (typedef signed short mz_int16 ; typedef unsigned short mz_uint16 ; typedef unsigned int mz_uint32 ; typedef unsigned int mz_uint ; typedef long long mz_int64 ; typedef unsigned long long mz_uint64 ; typedef int mz_bool ; # define)",
    "insertText": "MZ_FALSE(0) #define MZ_TRUE (1) #ifdef _MSC_VER #define MZ_MACRO_END while (0, 0) #else #define MZ_MACRO_END while (0)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (MZ_ZIP_MAX_IO_BUF_SIZE = 6 4* 1 0 2 4,MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 2 6 0,MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 2 5 6 } ; typedef struct { mz_uint32 m_file_index ; mz_uint32 m_central_dir_ofs ; mz_uint16 m_version_made_by ; mz_uint16 m_version_needed ; mz_uint16 m_bit_flag ; mz_uint16 m_method ; # ifndef MINIZ_NO_TIME time_t m_time ; # endif mz_uint32 m_crc32 ; mz_uint64 m_comp_size ; mz_uint64 m_uncomp_size ; mz_uint16 m_internal_attr ; mz_uint32 m_external_attr ; mz_uint64 m_local_header_ofs ; mz_uint32 m_comment_size ; char m_filename [ MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE ] ; char m_comment [ MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE ] ; } mz_zip_archive_file_stat ; typedef)",
    "insertText": "size_t(*mz_file_read_func)(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "size_t(*mz_file_write_func)(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)"
  },
  {
    "label": "mz_zip_reader_init()",
    "kind": "Method",
    "detail": "Function (struct mz_zip_internal_state_tag ; typedef struct mz_zip_internal_state_tag mz_zip_internal_state ; typedef enum { MZ_ZIP_MODE_INVALID = 0,MZ_ZIP_MODE_READING = 1,MZ_ZIP_MODE_WRITING = 2,MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3 } mz_zip_mode ; typedef struct mz_zip_archive_tag { mz_uint64 m_archive_size ; mz_uint64 m_central_directory_file_ofs ; mz_uint m_total_files ; mz_zip_mode m_zip_mode ; mz_uint m_file_offset_alignment ; mz_alloc_func m_pAlloc ; mz_free_func m_pFree ; mz_realloc_func m_pRealloc ; void* m_pAlloc_opaque ; mz_file_read_func m_pRead ; mz_file_write_func m_pWrite ; void* m_pIO_opaque ; mz_zip_internal_state* m_pState ; } mz_zip_archive ; typedef enum { MZ_ZIP_FLAG_CASE_SENSITIVE = 0 x0100,MZ_ZIP_FLAG_IGNORE_PATH = 0 x0200,MZ_ZIP_FLAG_COMPRESSED_DATA = 0 x0400,MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0 x0800 } mz_zip_flags ; mz_bool)",
    "insertText": "mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint32 flags)"
  },
  {
    "label": "mz_zip_reader_init_mem()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint32 flags)"
  },
  {
    "label": "mz_zip_reader_init_file()",
    "kind": "Method",
    "detail": "Function (# ifndef MINIZ_NO_STDIO mz_bool)",
    "insertText": "mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags)"
  },
  {
    "label": "mz_zip_reader_get_num_files()",
    "kind": "Method",
    "detail": "Function (# endif mz_uint)",
    "insertText": "mz_zip_reader_get_num_files(mz_zip_archive *pZip)"
  },
  {
    "label": "mz_zip_reader_file_stat()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat)"
  },
  {
    "label": "mz_zip_reader_is_file_a_directory()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index)"
  },
  {
    "label": "mz_zip_reader_is_file_encrypted()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index)"
  },
  {
    "label": "mz_zip_reader_get_filename()",
    "kind": "Method",
    "detail": "Function (mz_uint)",
    "insertText": "mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size)"
  },
  {
    "label": "mz_zip_reader_locate_file()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags)"
  },
  {
    "label": "mz_zip_reader_extract_to_mem_no_alloc()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)"
  },
  {
    "label": "mz_zip_reader_extract_file_to_mem_no_alloc()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)"
  },
  {
    "label": "mz_zip_reader_extract_to_mem()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags)"
  },
  {
    "label": "mz_zip_reader_extract_file_to_mem()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags)"
  },
  {
    "label": "mz_zip_reader_extract_to_heap()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags)"
  },
  {
    "label": "mz_zip_reader_extract_file_to_heap()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags)"
  },
  {
    "label": "mz_zip_reader_extract_to_callback()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)"
  },
  {
    "label": "mz_zip_reader_extract_file_to_callback()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)"
  },
  {
    "label": "mz_zip_reader_extract_to_file()",
    "kind": "Method",
    "detail": "Function (# ifndef MINIZ_NO_STDIO mz_bool)",
    "insertText": "mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags)"
  },
  {
    "label": "mz_zip_reader_extract_file_to_file()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags)"
  },
  {
    "label": "mz_zip_reader_end()",
    "kind": "Method",
    "detail": "Function (# endif mz_bool)",
    "insertText": "mz_zip_reader_end(mz_zip_archive *pZip)"
  },
  {
    "label": "mz_zip_writer_init()",
    "kind": "Method",
    "detail": "Function (# ifndef MINIZ_NO_ARCHIVE_WRITING_APIS mz_bool)",
    "insertText": "mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size)"
  },
  {
    "label": "mz_zip_writer_init_heap()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size)"
  },
  {
    "label": "mz_zip_writer_init_file()",
    "kind": "Method",
    "detail": "Function (# ifndef MINIZ_NO_STDIO mz_bool)",
    "insertText": "mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning)"
  },
  {
    "label": "mz_zip_writer_init_from_reader()",
    "kind": "Method",
    "detail": "Function (# endif mz_bool)",
    "insertText": "mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename)"
  },
  {
    "label": "mz_zip_writer_add_mem()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags)"
  },
  {
    "label": "mz_zip_writer_add_mem_ex()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32)"
  },
  {
    "label": "mz_zip_writer_add_file()",
    "kind": "Method",
    "detail": "Function (# ifndef MINIZ_NO_STDIO mz_bool)",
    "insertText": "mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)"
  },
  {
    "label": "mz_zip_writer_add_from_zip_reader()",
    "kind": "Method",
    "detail": "Function (# endif mz_bool)",
    "insertText": "mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint file_index)"
  },
  {
    "label": "mz_zip_writer_finalize_archive()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "mz_zip_writer_finalize_archive(mz_zip_archive *pZip)"
  },
  {
    "label": "mz_zip_writer_finalize_heap_archive()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **pBuf, size_t *pSize)"
  },
  {
    "label": "mz_zip_writer_end()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "mz_zip_writer_end(mz_zip_archive *pZip)"
  },
  {
    "label": "mz_zip_add_mem_to_archive_file_in_place()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)"
  },
  {
    "label": "mz_zip_extract_archive_file_to_heap()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint zip_flags)"
  },
  {
    "label": "tinfl_decompress_mem_to_heap()",
    "kind": "Method",
    "detail": "Function (# endif # endif enum { TINFL_FLAG_PARSE_ZLIB_HEADER = 1,TINFL_FLAG_HAS_MORE_INPUT = 2,TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,TINFL_FLAG_COMPUTE_ADLER32 = 8 } ; void*)",
    "insertText": "tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)"
  },
  {
    "label": "TINFL_DECOMPRESS_MEM_TO_MEM_FAILED()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "TINFL_DECOMPRESS_MEM_TO_MEM_FAILED((size_t)(-1)) size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "int(*tinfl_put_buf_func_ptr)(const void *pBuf, int len, void *pUser)"
  },
  {
    "label": "tinfl_decompress_mem_to_callback()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)"
  },
  {
    "label": "tinfl_init()",
    "kind": "Method",
    "detail": "Function (struct tinfl_decompressor_tag ; typedef struct tinfl_decompressor_tag tinfl_decompressor ; # define TINFL_LZ_DICT_SIZE 3 2 7 6 8 typedef enum { TINFL_STATUS_BAD_PARAM = - 3,TINFL_STATUS_ADLER32_MISMATCH = - 2,TINFL_STATUS_FAILED = - 1,TINFL_STATUS_DONE = 0,TINFL_STATUS_NEEDS_MORE_INPUT = 1,TINFL_STATUS_HAS_MORE_OUTPUT = 2 } tinfl_status ; # define)",
    "insertText": "tinfl_init(r)"
  },
  {
    "label": "tinfl_get_adler32()",
    "kind": "Method",
    "detail": "Function (\\ } \\ MZ_MACRO_END # define)",
    "insertText": "tinfl_get_adler32(r) (r)->m_check_adler32 tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags)"
  },
  {
    "label": "TINFL_BITBUF_SIZE()",
    "kind": "Method",
    "detail": "Function (enum { TINFL_MAX_HUFF_TABLES = 3,TINFL_MAX_HUFF_SYMBOLS_0 = 2 8 8,TINFL_MAX_HUFF_SYMBOLS_1 = 3 2,TINFL_MAX_HUFF_SYMBOLS_2 = 1 9,TINFL_FAST_LOOKUP_BITS = 1 0,TINFL_FAST_LOOKUP_SIZE = 1<<TINFL_FAST_LOOKUP_BITS } ; typedef struct { mz_uint8 m_code_size [ TINFL_MAX_HUFF_SYMBOLS_0 ] ; mz_int16 m_look_up [ TINFL_FAST_LOOKUP_SIZE ],m_tree [ TINFL_MAX_HUFF_SYMBOLS_0* 2 ] ; } tinfl_huff_table ; # if MINIZ_HAS_64BIT_REGISTERS # define TINFL_USE_64BIT_BITBUF 1 # endif # if TINFL_USE_64BIT_BITBUF typedef mz_uint64 tinfl_bit_buf_t ; # define)",
    "insertText": "TINFL_BITBUF_SIZE(64)"
  },
  {
    "label": "TINFL_BITBUF_SIZE()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "TINFL_BITBUF_SIZE(32)"
  },
  {
    "label": "tdefl_compress_mem_to_heap()",
    "kind": "Method",
    "detail": "Function (mz_uint32 m_state,m_num_bits,m_zhdr0,m_zhdr1,m_z_adler32,m_final,m_type,m_check_adler32,m_dist,m_counter,m_num_extra,m_table_sizes [ TINFL_MAX_HUFF_TABLES ] ; tinfl_bit_buf_t m_bit_buf ; size_t m_dist_from_out_buf_start ; tinfl_huff_table m_tables [ TINFL_MAX_HUFF_TABLES ] ; mz_uint8 m_raw_header [ 4 ],m_len_codes [ TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 1 3 7 ] ; } ; # define TDEFL_LESS_MEMORY 0 enum { TDEFL_HUFFMAN_ONLY = 0,TDEFL_DEFAULT_MAX_PROBES = 1 2 8,TDEFL_MAX_PROBES_MASK = 0 xFFF } ; enum { TDEFL_WRITE_ZLIB_HEADER = 0 x01000,TDEFL_COMPUTE_ADLER32 = 0 x02000,TDEFL_GREEDY_PARSING_FLAG = 0 x04000,TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0 x08000,TDEFL_RLE_MATCHES = 0 x10000,TDEFL_FILTER_MATCHES = 0 x20000,TDEFL_FORCE_ALL_STATIC_BLOCKS = 0 x40000,TDEFL_FORCE_ALL_RAW_BLOCKS = 0 x80000 } ; void*)",
    "insertText": "tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)"
  },
  {
    "label": "tdefl_compress_mem_to_mem()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)"
  },
  {
    "label": "tdefl_write_image_to_png_file_in_memory_ex()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip)"
  },
  {
    "label": "tdefl_write_image_to_png_file_in_memory()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out)"
  },
  {
    "label": "mz_bool()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "mz_bool(*tdefl_put_buf_func_ptr)(const void *pBuf, int len, void *pUser)"
  },
  {
    "label": "tdefl_compress_mem_to_output()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)"
  },
  {
    "label": "TDEFL_OUT_BUF_SIZE()",
    "kind": "Method",
    "detail": "Function (enum { TDEFL_MAX_HUFF_TABLES = 3,TDEFL_MAX_HUFF_SYMBOLS_0 = 2 8 8,TDEFL_MAX_HUFF_SYMBOLS_1 = 3 2,TDEFL_MAX_HUFF_SYMBOLS_2 = 1 9,TDEFL_LZ_DICT_SIZE = 3 2 7 6 8,TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1,TDEFL_MIN_MATCH_LEN = 3,TDEFL_MAX_MATCH_LEN = 2 5 8 } ; # if TDEFL_LESS_MEMORY enum { TDEFL_LZ_CODE_BUF_SIZE = 2 4* 1 0 2 4,)",
    "insertText": "TDEFL_OUT_BUF_SIZE(TDEFL_LZ_CODE_BUF_SIZE * 13) / 10, TDEFL_MAX_HUFF_SYMBOLS = 288, TDEFL_LZ_HASH_BITS = 12, TDEFL_LEVEL1_HASH_SIZE_MASK = 4095, TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2)"
  },
  {
    "label": "TDEFL_OUT_BUF_SIZE()",
    "kind": "Method",
    "detail": "Function (# else enum { TDEFL_LZ_CODE_BUF_SIZE = 6 4* 1 0 2 4,)",
    "insertText": "TDEFL_OUT_BUF_SIZE(TDEFL_LZ_CODE_BUF_SIZE * 13) / 10, TDEFL_MAX_HUFF_SYMBOLS = 288, TDEFL_LZ_HASH_BITS = 15, TDEFL_LEVEL1_HASH_SIZE_MASK = 4095, TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2)"
  },
  {
    "label": "tdefl_init()",
    "kind": "Method",
    "detail": "Function (# endif typedef enum { TDEFL_STATUS_BAD_PARAM = - 2,TDEFL_STATUS_PUT_BUF_FAILED = - 1,TDEFL_STATUS_OKAY = 0,TDEFL_STATUS_DONE = 1 } tdefl_status ; typedef enum { TDEFL_NO_FLUSH = 0,TDEFL_SYNC_FLUSH = 2,TDEFL_FULL_FLUSH = 3,TDEFL_FINISH = 4 } tdefl_flush ; typedef struct { tdefl_put_buf_func_ptr m_pPut_buf_func ; void* m_pPut_buf_user ; mz_uint m_flags,m_max_probes [ 2 ] ; int m_greedy_parsing ; mz_uint m_adler32,m_lookahead_pos,m_lookahead_size,m_dict_size ; mz_uint8* m_pLZ_code_buf,* m_pLZ_flags,* m_pOutput_buf,* m_pOutput_buf_end ; mz_uint m_num_flags_left,m_total_lz_bytes,m_lz_code_buf_dict_pos,m_bits_in,m_bit_buffer ; mz_uint m_saved_match_dist,m_saved_match_len,m_saved_lit,m_output_flush_ofs,m_output_flush_remaining,m_finished,m_block_index,m_wants_to_finish ; tdefl_status m_prev_return_status ; const void* m_pIn_buf ; void* m_pOut_buf ; size_t* m_pIn_buf_size,* m_pOut_buf_size ; tdefl_flush m_flush ; const mz_uint8* m_pSrc ; size_t m_src_buf_left,m_out_buf_ofs ; mz_uint8 m_dict [ TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1 ] ; mz_uint16 m_huff_count [ TDEFL_MAX_HUFF_TABLES ] [ TDEFL_MAX_HUFF_SYMBOLS ] ; mz_uint16 m_huff_codes [ TDEFL_MAX_HUFF_TABLES ] [ TDEFL_MAX_HUFF_SYMBOLS ] ; mz_uint8 m_huff_code_sizes [ TDEFL_MAX_HUFF_TABLES ] [ TDEFL_MAX_HUFF_SYMBOLS ] ; mz_uint8 m_lz_code_buf [ TDEFL_LZ_CODE_BUF_SIZE ] ; mz_uint16 m_next [ TDEFL_LZ_DICT_SIZE ] ; mz_uint16 m_hash [ TDEFL_LZ_HASH_SIZE ] ; mz_uint8 m_output_buf [ TDEFL_OUT_BUF_SIZE ] ; } tdefl_compressor ; tdefl_status)",
    "insertText": "tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)"
  },
  {
    "label": "tdefl_compress()",
    "kind": "Method",
    "detail": "Function (tdefl_status)",
    "insertText": "tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush)"
  },
  {
    "label": "tdefl_compress_buffer()",
    "kind": "Method",
    "detail": "Function (tdefl_status)",
    "insertText": "tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush)"
  },
  {
    "label": "tdefl_get_prev_return_status()",
    "kind": "Method",
    "detail": "Function (tdefl_status)",
    "insertText": "tdefl_get_prev_return_status(tdefl_compressor *d)"
  },
  {
    "label": "tdefl_get_adler32()",
    "kind": "Method",
    "detail": "Function (mz_uint32)",
    "insertText": "tdefl_get_adler32(tdefl_compressor *d)"
  },
  {
    "label": "tdefl_create_comp_flags_from_zip_params()",
    "kind": "Method",
    "detail": "Function (# ifndef MINIZ_NO_ZLIB_APIS mz_uint)",
    "insertText": "tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (# endif # ifdef __cplusplus } # endif # endif # ifndef MINIZ_HEADER_FILE_ONLY typedef unsigned char mz_validate_uint16 [)",
    "insertText": "sizeof(mz_uint16)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (typedef unsigned char mz_validate_uint32 [)",
    "insertText": "sizeof(mz_uint32)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (typedef unsigned char mz_validate_uint64 [)",
    "insertText": "sizeof(mz_uint64)"
  },
  {
    "label": "MZ_ASSERT()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "MZ_ASSERT(x) TEXR_ASSERT(x) #ifdef MINIZ_NO_MALLOC #define MZ_MALLOC(x) NULL #define MZ_FREE(x) (void)x, ((void)0) #define MZ_REALLOC(p, x) NULL #else #define MZ_MALLOC(x) malloc(x) #define MZ_FREE(x) free(x) #define MZ_REALLOC(p, x) realloc(p, x) #endif #define MZ_MAX(a, b) (((a) > (b)) ? (a) : (b)) #define MZ_MIN(a, b) (((a) < (b)) ? (a) : (b)) #define MZ_CLEAR_OBJ(obj) memset(&(obj), 0, sizeof(obj)) #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN #define MZ_READ_LE16(p) *((const mz_uint16 *)(p)) #define MZ_READ_LE32(p) *((const mz_uint32 *)(p)) #else #define MZ_READ_LE16(p) \\ ((mz_uint32)(((const mz_uint8 *)(p))[0]) | \\ ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U)) #define MZ_READ_LE32(p) \\ ((mz_uint32)(((const mz_uint8 *)(p))[0]) | \\ ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U) | \\ ((mz_uint32)(((const mz_uint8 *)(p))[2]) << 16U) | \\ ((mz_uint32)(((const mz_uint8 *)(p))[3]) << 24U)) #endif #ifdef _MSC_VER #define MZ_FORCEINLINE __forceinline #elif defined(__GNUC__) #define MZ_FORCEINLINE inline __attribute__((__always_inline__))"
  },
  {
    "label": "mz_adler32()",
    "kind": "Method",
    "detail": "Function (# endif mz_ulong)",
    "insertText": "mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len)"
  },
  {
    "label": "s1()",
    "kind": "Method",
    "detail": "Function (mz_uint32 i,)",
    "insertText": "s1(mz_uint32)(adler & 0xffff), s2 = (mz_uint32)(adler >> 16)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t block_len = buf_len % 5 5 5 2 ;)",
    "insertText": "if(!ptr)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (s1 + = ptr [ 0 ],s2 + = s1 ; s1 + = ptr [ 1 ],s2 + = s1 ; s1 + = ptr [ 2 ],s2 + = s1 ; s1 + = ptr [ 3 ],s2 + = s1 ; s1 + = ptr [ 4 ],s2 + = s1 ; s1 + = ptr [ 5 ],s2 + = s1 ; s1 + = ptr [ 6 ],s2 + = s1 ; s1 + = ptr [ 7 ],s2 + = s1 ; })",
    "insertText": "for(; i < block_len; ++i)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (s1 % = 6 5 5 2 1 U,s2 % = 6 5 5 2 1 U ; buf_len - = block_len ; block_len = 5 5 5 2 ; })",
    "insertText": "return(s2 << 16)"
  },
  {
    "label": "mz_crc32()",
    "kind": "Method",
    "detail": "Function (} mz_ulong)",
    "insertText": "mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len)"
  },
  {
    "label": "crcu32()",
    "kind": "Method",
    "detail": "Function (const mz_uint32 s_crc32 [ 1 6 ] = { 0,0 x1db71064,0 x3b6e20c8,0 x26d930ac,0 x76dc4190,0 x6b6b51f4,0 x4db26158,0 x5005713c,0 xedb88320,0 xf00f9344,0 xd6d6a3e8,0 xcb61b38c,0 x9b64c2b0,0 x86d3d2d4,0 xa00ae278,0 xbdbdf21c } ; mz_uint32)",
    "insertText": "crcu32(mz_uint32)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (crcu32 = ~ crcu32 ;)",
    "insertText": "while(buf_len--)"
  },
  {
    "label": "crcu32()",
    "kind": "Method",
    "detail": "Function (mz_uint8 b =* ptr + + ;)",
    "insertText": "crcu32(crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)"
  },
  {
    "label": "crcu32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "crcu32(crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)"
  },
  {
    "label": "MZ_FREE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_FREE(p)"
  },
  {
    "label": "def_alloc_func()",
    "kind": "Method",
    "detail": "Function (} # ifndef MINIZ_NO_ZLIB_APIS void*)",
    "insertText": "def_alloc_func(void *opaque, size_t items, size_t size)"
  },
  {
    "label": "def_free_func()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "def_free_func(void *opaque, void *address)"
  },
  {
    "label": "MZ_FREE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_FREE(address)"
  },
  {
    "label": "tdefl_create_comp_flags_from_zip_params()",
    "kind": "Method",
    "detail": "Function (tdefl_compressor* pComp ; mz_uint comp_flags = TDEFL_COMPUTE_ADLER32 |)",
    "insertText": "tdefl_create_comp_flags_from_zip_params(level, window_bits, strategy)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (zalloc = def_alloc_func)",
    "insertText": "if(!pStream->zalloc)"
  },
  {
    "label": "pComp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pComp(tdefl_compressor *)pStream->zalloc(pStream->opaque, 1, sizeof(tdefl_compressor))"
  },
  {
    "label": "state()",
    "kind": "Method",
    "detail": "Function (pStream ->)",
    "insertText": "state(struct mz_internal_state *)"
  },
  {
    "label": "mz_deflateEnd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mz_deflateEnd(pStream)"
  },
  {
    "label": "tdefl_init()",
    "kind": "Method",
    "detail": "Function (pStream -> total_in = pStream -> total_out = 0 ;)",
    "insertText": "tdefl_init((tdefl_compressor *)pStream->state, NULL, NULL, ((tdefl_compressor *)pStream->state)->m_flags)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t in_bytes,out_bytes ; mz_ulong orig_total_in,orig_total_out ; int mz_status = MZ_OK ;)",
    "insertText": "if((!pStream) || (!pStream->state) || (flush < 0) || (flush > MZ_FINISH) || (!pStream->next_out))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (orig_total_in = pStream -> total_in ; orig_total_out = pStream -> total_out ;)",
    "insertText": "for(;;)"
  },
  {
    "label": "tdefl_compress()",
    "kind": "Method",
    "detail": "Function (tdefl_status defl_status ; in_bytes = pStream -> avail_in ; out_bytes = pStream -> avail_out ; defl_status =)",
    "insertText": "tdefl_compress((tdefl_compressor *)pStream->state, pStream->next_in, &in_bytes, pStream->next_out, &out_bytes, (tdefl_flush)flush)"
  },
  {
    "label": "next_in()",
    "kind": "Method",
    "detail": "Function (pStream ->)",
    "insertText": "next_in(mz_uint)"
  },
  {
    "label": "avail_in()",
    "kind": "Method",
    "detail": "Function (pStream ->)",
    "insertText": "avail_in(mz_uint)"
  },
  {
    "label": "total_in()",
    "kind": "Method",
    "detail": "Function (pStream ->)",
    "insertText": "total_in(mz_uint)"
  },
  {
    "label": "tdefl_get_adler32()",
    "kind": "Method",
    "detail": "Function (pStream -> adler =)",
    "insertText": "tdefl_get_adler32((tdefl_compressor *)pStream->state)"
  },
  {
    "label": "next_out()",
    "kind": "Method",
    "detail": "Function (pStream ->)",
    "insertText": "next_out(mz_uint)"
  },
  {
    "label": "avail_out()",
    "kind": "Method",
    "detail": "Function (pStream ->)",
    "insertText": "avail_out(mz_uint)"
  },
  {
    "label": "total_out()",
    "kind": "Method",
    "detail": "Function (pStream ->)",
    "insertText": "total_out(mz_uint)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mz_status = MZ_STREAM_ERROR ; break ; } else)",
    "insertText": "if(defl_status == TDEFL_STATUS_DONE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mz_status = MZ_STREAM_END ; break ; } else)",
    "insertText": "if(!pStream->avail_out)"
  },
  {
    "label": "zfree()",
    "kind": "Method",
    "detail": "Function (pStream ->)",
    "insertText": "zfree(pStream->opaque, pStream->state)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (int status ; mz_stream stream ;)",
    "insertText": "memset(&stream, 0, sizeof(stream))"
  },
  {
    "label": "avail_in()",
    "kind": "Method",
    "detail": "Function (stream . next_in = pSource ; stream .)",
    "insertText": "avail_in(mz_uint32)"
  },
  {
    "label": "avail_out()",
    "kind": "Method",
    "detail": "Function (stream . next_out = pDest ; stream .)",
    "insertText": "avail_out(mz_uint32)"
  },
  {
    "label": "mz_deflateInit()",
    "kind": "Method",
    "detail": "Function (status =)",
    "insertText": "mz_deflateInit(&stream, level)"
  },
  {
    "label": "mz_deflate()",
    "kind": "Method",
    "detail": "Function (status =)",
    "insertText": "mz_deflate(&stream, MZ_FINISH)"
  },
  {
    "label": "mz_deflateEnd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mz_deflateEnd(&stream)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (inflate_state* pDecomp ;)",
    "insertText": "if(!pStream)"
  },
  {
    "label": "pDecomp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pDecomp(inflate_state *)pStream->zalloc(pStream->opaque, 1, sizeof(inflate_state))"
  },
  {
    "label": "tinfl_init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tinfl_init(&pDecomp->m_decomp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (inflate_state* pState ; mz_uint n,first_call,decomp_flags = TINFL_FLAG_COMPUTE_ADLER32 ; size_t in_bytes,out_bytes,orig_avail_in ; tinfl_status status ;)",
    "insertText": "if((!pStream) || (!pStream->state))"
  },
  {
    "label": "pState()",
    "kind": "Method",
    "detail": "Function (state)",
    "insertText": "pState(inflate_state *)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (orig_avail_in = pStream -> avail_in ; first_call = pState -> m_first_call ; pState -> m_first_call = 0 ;)",
    "insertText": "if(pState->m_last_status < 0)"
  },
  {
    "label": "m_has_flushed()",
    "kind": "Method",
    "detail": "Function (pState ->)",
    "insertText": "m_has_flushed(flush == MZ_FINISH)"
  },
  {
    "label": "tinfl_decompress()",
    "kind": "Method",
    "detail": "Function (decomp_flags | = TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF ; in_bytes = pStream -> avail_in ; out_bytes = pStream -> avail_out ; status =)",
    "insertText": "tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pStream->next_out, pStream->next_out, &out_bytes, decomp_flags)"
  },
  {
    "label": "tinfl_get_adler32()",
    "kind": "Method",
    "detail": "Function (pStream -> adler =)",
    "insertText": "tinfl_get_adler32(&pState->m_decomp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pState -> m_last_status = TINFL_STATUS_FAILED ; return MZ_BUF_ERROR ; } return MZ_STREAM_END ; })",
    "insertText": "if(flush != MZ_FINISH)"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (n =)",
    "insertText": "MZ_MIN(pState->m_dict_avail, pStream->avail_out)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n)"
  },
  {
    "label": "m_dict_ofs()",
    "kind": "Method",
    "detail": "Function (pStream -> next_out + = n ; pStream -> avail_out - = n ; pStream -> total_out + = n ; pState -> m_dict_avail - = n ; pState ->)",
    "insertText": "m_dict_ofs(pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1)"
  },
  {
    "label": "tinfl_decompress()",
    "kind": "Method",
    "detail": "Function (in_bytes = pStream -> avail_in ; out_bytes = TINFL_LZ_DICT_SIZE - pState -> m_dict_ofs ; status =)",
    "insertText": "tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pState->m_dict, pState->m_dict + pState->m_dict_ofs, &out_bytes, decomp_flags)"
  },
  {
    "label": "m_dict_avail()",
    "kind": "Method",
    "detail": "Function (pState ->)",
    "insertText": "m_dict_avail(mz_uint)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((status == TINFL_STATUS_DONE) || (!pStream->avail_in) || (!pStream->avail_out) || (pState->m_dict_avail))"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "return((status == TINFL_STATUS_DONE) && (!pState->m_dict_avail))"
  },
  {
    "label": "mz_inflateInit()",
    "kind": "Method",
    "detail": "Function (status =)",
    "insertText": "mz_inflateInit(&stream)"
  },
  {
    "label": "mz_inflate()",
    "kind": "Method",
    "detail": "Function (status =)",
    "insertText": "mz_inflate(&stream, MZ_FINISH)"
  },
  {
    "label": "mz_inflateEnd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mz_inflateEnd(&stream)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (struct { int m_err ; const char* m_pDesc ; } s_error_descs [ ] = { { MZ_OK,\" \" },{ MZ_STREAM_END,\" stream end \" },{ MZ_NEED_DICT,\" need dictionary \" },{ MZ_ERRNO,\" file error \" },{ MZ_STREAM_ERROR,\" stream error \" },{ MZ_DATA_ERROR,\" data error \" },{ MZ_MEM_ERROR,\" out of memory \" },{ MZ_BUF_ERROR,\" buf error \" },{ MZ_VERSION_ERROR,\" version error \" },{ MZ_PARAM_ERROR,\" parameter error \" } } ; mz_uint i ;)",
    "insertText": "for(i = 0; i < sizeof(s_error_descs) / sizeof(s_error_descs[0]); ++i) if (s_error_descs[i].m_err == err)"
  },
  {
    "label": "TINFL_CR_RETURN()",
    "kind": "Method",
    "detail": "Function (\\ case 0 : # define)",
    "insertText": "TINFL_CR_RETURN(state_index, result)"
  },
  {
    "label": "TINFL_CR_RETURN_FOREVER()",
    "kind": "Method",
    "detail": "Function (\\ status = result ; \\ r -> m_state = state_index ; \\ goto common_exit ; \\ case state_index : ; \\ } \\ MZ_MACRO_END # define)",
    "insertText": "TINFL_CR_RETURN_FOREVER(state_index, result)"
  },
  {
    "label": "TINFL_GET_BYTE()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } \\ MZ_MACRO_END # define TINFL_CR_FINISH } # define)",
    "insertText": "TINFL_GET_BYTE(state_index, c)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(pIn_buf_cur >= pIn_buf_end)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(decomp_flags & TINFL_FLAG_HAS_MORE_INPUT)"
  },
  {
    "label": "TINFL_CR_RETURN()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "TINFL_CR_RETURN(state_index, TINFL_STATUS_NEEDS_MORE_INPUT)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(pIn_buf_cur < pIn_buf_end)"
  },
  {
    "label": "TINFL_NEED_BITS()",
    "kind": "Method",
    "detail": "Function (\\ c =* pIn_buf_cur + + ; \\ break ; \\ } \\ } else { \\ c = 0 ; \\ break ; \\ } \\ } \\ } else \\ c =* pIn_buf_cur + + ; \\ } \\ MZ_MACRO_END # define)",
    "insertText": "TINFL_NEED_BITS(state_index, n)"
  },
  {
    "label": "bit_buf()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "bit_buf(((tinfl_bit_buf_t)c) << num_bits)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ num_bits + = 8 ; \\ })",
    "insertText": "while(num_bits < (mz_uint)(n)) #define TINFL_SKIP_BITS(state_index, n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(num_bits < (mz_uint)(n))"
  },
  {
    "label": "bit_buf()",
    "kind": "Method",
    "detail": "Function (\\ } \\)",
    "insertText": "bit_buf(n)"
  },
  {
    "label": "num_bits()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "num_bits(n)"
  },
  {
    "label": "TINFL_GET_BITS()",
    "kind": "Method",
    "detail": "Function (\\ } \\ MZ_MACRO_END # define)",
    "insertText": "TINFL_GET_BITS(state_index, b, n)"
  },
  {
    "label": "bit_buf()",
    "kind": "Method",
    "detail": "Function (\\ } \\ b =)",
    "insertText": "bit_buf((1 << (n)) - 1)"
  },
  {
    "label": "TINFL_HUFF_BITBUF_FILL()",
    "kind": "Method",
    "detail": "Function (\\ } \\ MZ_MACRO_END # define)",
    "insertText": "TINFL_HUFF_BITBUF_FILL(state_index, pHuff)"
  },
  {
    "label": "temp()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "temp(pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(temp >= 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\ code_len = temp>> 9 ; \\)",
    "insertText": "if((code_len) && (num_bits >= code_len))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\ } else)",
    "insertText": "if(num_bits > TINFL_FAST_LOOKUP_BITS)"
  },
  {
    "label": "temp()",
    "kind": "Method",
    "detail": "Function (\\ code_len = TINFL_FAST_LOOKUP_BITS ; \\ do { \\)",
    "insertText": "temp(pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "while((temp < 0) && (num_bits >= (code_len + 1)))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ num_bits + = 8 ; \\ })",
    "insertText": "while(num_bits < 15)"
  },
  {
    "label": "TINFL_HUFF_DECODE()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "TINFL_HUFF_DECODE(state_index, sym, pHuff)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\ int temp ; \\ mz_uint code_len,c ; \\)",
    "insertText": "if(num_bits < 15)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if((pIn_buf_end - pIn_buf_cur) < 2)"
  },
  {
    "label": "bit_buf()",
    "kind": "Method",
    "detail": "Function (\\ } else { \\)",
    "insertText": "bit_buf(((tinfl_bit_buf_t)pIn_buf_cur[0]) << num_bits) | \\ (((tinfl_bit_buf_t)pIn_buf_cur[1]) << (num_bits + 8))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\ pIn_buf_cur + = 2 ; \\ num_bits + = 1 6 ; \\ } \\ } \\)",
    "insertText": "if((temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= \\ 0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "while(temp < 0)"
  },
  {
    "label": "tinfl_decompress()",
    "kind": "Method",
    "detail": "Function (\\ } \\ sym = temp ; \\ bit_buf>> = code_len ; \\ num_bits - = code_len ; \\ } \\ MZ_MACRO_END tinfl_status)",
    "insertText": "tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags)"
  },
  {
    "label": "out_buf_size_mask()",
    "kind": "Method",
    "detail": "Function (const int s_length_base [ 3 1 ] = { 3,4,5,6,7,8,9,1 0,1 1,1 3,1 5,1 7,1 9,2 3,2 7,3 1,3 5,4 3,5 1,5 9,6 7,8 3,9 9,1 1 5,1 3 1,1 6 3,1 9 5,2 2 7,2 5 8,0,0 } ; const int s_length_extra [ 3 1 ] = { 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 } ; const int s_dist_base [ 3 2 ] = { 1,2,3,4,5,7,9,1 3,1 7,2 5,3 3,4 9,6 5,9 7,1 2 9,1 9 3,2 5 7,3 8 5,5 1 3,7 6 9,1 0 2 5,1 5 3 7,2 0 4 9,3 0 7 3,4 0 9 7,6 1 4 5,8 1 9 3,1 2 2 8 9,1 6 3 8 5,2 4 5 7 7,0,0 } ; const int s_dist_extra [ 3 2 ] = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,1 0,1 0,1 1,1 1,1 2,1 2,1 3,1 3 } ; const mz_uint8 s_length_dezigzag [ 1 9 ] = { 1 6,1 7,1 8,0,8,7,9,6,1 0,5,1 1,4,1 2,3,1 3,2,1 4,1,1 5 } ; const int s_min_table_sizes [ 3 ] = { 2 5 7,1,4 } ; tinfl_status status = TINFL_STATUS_FAILED ; mz_uint32 num_bits,dist,counter,num_extra ; tinfl_bit_buf_t bit_buf ; const mz_uint8* pIn_buf_cur = pIn_buf_next,* const pIn_buf_end = pIn_buf_next +* pIn_buf_size ; mz_uint8* pOut_buf_cur = pOut_buf_next,* const pOut_buf_end = pOut_buf_next +* pOut_buf_size ; size_t)",
    "insertText": "out_buf_size_mask(decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) ? (size_t)-1 : ((pOut_buf_next - pOut_buf_start) + *pOut_buf_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* pIn_buf_size =* pOut_buf_size = 0 ; return TINFL_STATUS_BAD_PARAM ; } num_bits = r -> m_num_bits ; bit_buf = r -> m_bit_buf ; dist = r -> m_dist ; counter = r -> m_counter ; num_extra = r -> m_num_extra ; dist_from_out_buf_start = r -> m_dist_from_out_buf_start ; TINFL_CR_BEGIN bit_buf = num_bits = dist = counter = num_extra = r -> m_zhdr0 = r -> m_zhdr1 = 0 ; r -> m_z_adler32 = r -> m_check_adler32 = 1 ;)",
    "insertText": "if(decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)"
  },
  {
    "label": "TINFL_GET_BYTE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_GET_BYTE(1, r->m_zhdr0)"
  },
  {
    "label": "TINFL_GET_BYTE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_GET_BYTE(2, r->m_zhdr1)"
  },
  {
    "label": "counter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "counter(((r->m_zhdr0 * 256 + r->m_zhdr1) % 31 != 0) || (r->m_zhdr1 & 32) || ((r->m_zhdr0 & 15) != 8))"
  },
  {
    "label": "TINFL_CR_RETURN_FOREVER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_CR_RETURN_FOREVER(36, TINFL_STATUS_FAILED)"
  },
  {
    "label": "TINFL_GET_BITS()",
    "kind": "Method",
    "detail": "Function (} } do {)",
    "insertText": "TINFL_GET_BITS(3, r->m_final, 3)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (r -> m_type = r -> m_final>> 1 ;)",
    "insertText": "if(r->m_type == 0)"
  },
  {
    "label": "TINFL_SKIP_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_SKIP_BITS(5, num_bits & 7)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if((counter = (r->m_raw_header[0] | (r->m_raw_header[1] << 8))) != (mz_uint)(0xFFFF ^ (r->m_raw_header[2] | (r->m_raw_header[3] << 8))))"
  },
  {
    "label": "TINFL_CR_RETURN_FOREVER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_CR_RETURN_FOREVER(39, TINFL_STATUS_FAILED)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while((counter) && (num_bits))"
  },
  {
    "label": "TINFL_GET_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_GET_BITS(51, dist, 8)"
  },
  {
    "label": "TINFL_CR_RETURN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_CR_RETURN(52, TINFL_STATUS_HAS_MORE_OUTPUT)"
  },
  {
    "label": "pOut_buf_cur()",
    "kind": "Method",
    "detail": "Function (}*)",
    "insertText": "pOut_buf_cur(mz_uint8)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (counter - - ; })",
    "insertText": "while(counter)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (size_t n ;)",
    "insertText": "while(pOut_buf_cur >= pOut_buf_end)"
  },
  {
    "label": "TINFL_CR_RETURN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_CR_RETURN(9, TINFL_STATUS_HAS_MORE_OUTPUT)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(pIn_buf_cur >= pIn_buf_end)"
  },
  {
    "label": "TINFL_CR_RETURN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_CR_RETURN(38, TINFL_STATUS_NEEDS_MORE_INPUT)"
  },
  {
    "label": "TINFL_CR_RETURN_FOREVER()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "TINFL_CR_RETURN_FOREVER(40, TINFL_STATUS_FAILED)"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (} } n =)",
    "insertText": "MZ_MIN(MZ_MIN((size_t)(pOut_buf_end - pOut_buf_cur), (size_t)(pIn_buf_end - pIn_buf_cur)), counter)"
  },
  {
    "label": "TINFL_MEMCPY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_MEMCPY(pOut_buf_cur, pIn_buf_cur, n)"
  },
  {
    "label": "counter()",
    "kind": "Method",
    "detail": "Function (pIn_buf_cur + = n ; pOut_buf_cur + = n ;)",
    "insertText": "counter(mz_uint)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(r->m_type == 3)"
  },
  {
    "label": "TINFL_CR_RETURN_FOREVER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_CR_RETURN_FOREVER(10, TINFL_STATUS_FAILED)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(r->m_type == 1)"
  },
  {
    "label": "TINFL_MEMSET()",
    "kind": "Method",
    "detail": "Function (mz_uint8* p = r -> m_tables [ 0 ] . m_code_size ; mz_uint i ; r -> m_table_sizes [ 0 ] = 2 8 8 ; r -> m_table_sizes [ 1 ] = 3 2 ;)",
    "insertText": "TINFL_MEMSET(r->m_tables[1].m_code_size, 5, 32)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "for(counter = 0; counter < 3; counter++)"
  },
  {
    "label": "TINFL_GET_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_GET_BITS(11, r->m_table_sizes[counter], \"\\05\\05\\04\"[counter])"
  },
  {
    "label": "MZ_CLEAR_OBJ()",
    "kind": "Method",
    "detail": "Function (r -> m_table_sizes [ counter ] + = s_min_table_sizes [ counter ] ; })",
    "insertText": "MZ_CLEAR_OBJ(r->m_tables[2].m_code_size)"
  },
  {
    "label": "TINFL_GET_BITS()",
    "kind": "Method",
    "detail": "Function (mz_uint s ;)",
    "insertText": "TINFL_GET_BITS(14, s, 3)"
  },
  {
    "label": "counter()",
    "kind": "Method",
    "detail": "Function (r -> m_tables [ 2 ] . m_code_size [ s_length_dezigzag [)",
    "insertText": "counter(mz_uint8)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} r -> m_table_sizes [ 2 ] = 1 9 ; })",
    "insertText": "for(; (int)r->m_type >= 0; r->m_type--)"
  },
  {
    "label": "MZ_CLEAR_OBJ()",
    "kind": "Method",
    "detail": "Function (int tree_next,tree_cur ; tinfl_huff_table* pTable ; mz_uint i,j,used_syms,total,sym_index,next_code [ 1 7 ],total_syms [ 1 6 ] ; pTable =& r -> m_tables [ r -> m_type ] ;)",
    "insertText": "MZ_CLEAR_OBJ(total_syms)"
  },
  {
    "label": "MZ_CLEAR_OBJ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_CLEAR_OBJ(pTable->m_look_up)"
  },
  {
    "label": "MZ_CLEAR_OBJ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_CLEAR_OBJ(pTable->m_tree)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (used_syms = 0,total = 0 ; next_code [ 0 ] = next_code [ 1 ] = 0 ;)",
    "insertText": "for(i = 1; i <= 15; ++i)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (used_syms + = total_syms [ i ] ; next_code [)",
    "insertText": "i(total = ((total + total_syms[i]) << 1))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if((65536 != total) && (used_syms > 1))"
  },
  {
    "label": "TINFL_CR_RETURN_FOREVER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_CR_RETURN_FOREVER(35, TINFL_STATUS_FAILED)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(tree_next = -1, sym_index = 0; sym_index < r->m_table_sizes[r->m_type]; ++sym_index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mz_uint rev_code = 0,l,cur_code,code_size = pTable -> m_code_size [ sym_index ] ;)",
    "insertText": "if(!code_size)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (cur_code = next_code [ code_size ] + + ;)",
    "insertText": "for(l = code_size; l > 0; l--, cur_code >>= 1) rev_code = (rev_code << 1) | (cur_code & 1)"
  },
  {
    "label": "k()",
    "kind": "Method",
    "detail": "Function (mz_int16)",
    "insertText": "k(mz_int16)((code_size << 9) | sym_index)"
  },
  {
    "label": "rev_code()",
    "kind": "Method",
    "detail": "Function (pTable -> m_look_up [ rev_code ] = k ;)",
    "insertText": "rev_code(1 << code_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} continue ; })",
    "insertText": "if(0 == (tree_cur = pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)]))"
  },
  {
    "label": "rev_code()",
    "kind": "Method",
    "detail": "Function (pTable -> m_look_up [)",
    "insertText": "rev_code(TINFL_FAST_LOOKUP_SIZE - 1)] = (mz_int16)"
  },
  {
    "label": "rev_code()",
    "kind": "Method",
    "detail": "Function (tree_cur = tree_next ; tree_next - = 2 ; })",
    "insertText": "rev_code(TINFL_FAST_LOOKUP_BITS - 1)"
  },
  {
    "label": "tree_cur()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tree_cur((rev_code >>= 1) & 1)"
  },
  {
    "label": "tree_cur()",
    "kind": "Method",
    "detail": "Function (pTable -> m_tree [ -)",
    "insertText": "tree_cur(mz_int16)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(r->m_type == 2)"
  },
  {
    "label": "TINFL_HUFF_DECODE()",
    "kind": "Method",
    "detail": "Function (mz_uint s ;)",
    "insertText": "TINFL_HUFF_DECODE(16, dist, &r->m_tables[2])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((dist == 16) && (!counter))"
  },
  {
    "label": "TINFL_CR_RETURN_FOREVER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_CR_RETURN_FOREVER(17, TINFL_STATUS_FAILED)"
  },
  {
    "label": "TINFL_GET_BITS()",
    "kind": "Method",
    "detail": "Function (} num_extra = \" \\ 0 2 \\ 0 3 \\ 0 7 \" [ dist - 1 6 ] ;)",
    "insertText": "TINFL_GET_BITS(18, s, num_extra)"
  },
  {
    "label": "TINFL_MEMSET()",
    "kind": "Method",
    "detail": "Function (s + = \" \\ 0 3 \\ 0 3 \\ 0 1 3 \" [ dist - 1 6 ] ;)",
    "insertText": "TINFL_MEMSET(r->m_len_codes + counter, (dist == 16) ? r->m_len_codes[counter - 1] : 0, s)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (counter + = s ; })",
    "insertText": "if((r->m_table_sizes[0] + r->m_table_sizes[1]) != counter)"
  },
  {
    "label": "TINFL_CR_RETURN_FOREVER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_CR_RETURN_FOREVER(21, TINFL_STATUS_FAILED)"
  },
  {
    "label": "TINFL_MEMCPY()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TINFL_MEMCPY(r->m_tables[0].m_code_size, r->m_len_codes, r->m_table_sizes[0])"
  },
  {
    "label": "TINFL_MEMCPY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_MEMCPY(r->m_tables[1].m_code_size, r->m_len_codes + r->m_table_sizes[0], r->m_table_sizes[1])"
  },
  {
    "label": "TINFL_HUFF_DECODE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_HUFF_DECODE(23, counter, &r->m_tables[0])"
  },
  {
    "label": "TINFL_CR_RETURN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_CR_RETURN(24, TINFL_STATUS_HAS_MORE_OUTPUT)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { int sym2 ; mz_uint code_len ; # if TINFL_USE_64BIT_BITBUF)",
    "insertText": "if(num_bits < 30)"
  },
  {
    "label": "bit_buf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bit_buf(((tinfl_bit_buf_t)MZ_READ_LE32(pIn_buf_cur)) << num_bits)"
  },
  {
    "label": "bit_buf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bit_buf(((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pIn_buf_cur + = 2 ; num_bits + = 1 6 ; } # endif)",
    "insertText": "if((sym2 = r->m_tables[0] .m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(sym2 < 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} counter = sym2 ; bit_buf>> = code_len ; num_bits - = code_len ;)",
    "insertText": "if(counter & 256)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pOut_buf_cur + = 2 ; } })",
    "insertText": "if((counter &= 511) == 256)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (num_extra = s_length_extra [ counter - 2 5 7 ] ; counter = s_length_base [ counter - 2 5 7 ] ;)",
    "insertText": "if(num_extra)"
  },
  {
    "label": "TINFL_GET_BITS()",
    "kind": "Method",
    "detail": "Function (mz_uint extra_bits ;)",
    "insertText": "TINFL_GET_BITS(25, extra_bits, num_extra)"
  },
  {
    "label": "TINFL_HUFF_DECODE()",
    "kind": "Method",
    "detail": "Function (counter + = extra_bits ; })",
    "insertText": "TINFL_HUFF_DECODE(26, dist, &r->m_tables[1])"
  },
  {
    "label": "TINFL_GET_BITS()",
    "kind": "Method",
    "detail": "Function (mz_uint extra_bits ;)",
    "insertText": "TINFL_GET_BITS(27, extra_bits, num_extra)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (dist + = extra_bits ; } dist_from_out_buf_start = pOut_buf_cur - pOut_buf_start ;)",
    "insertText": "if((dist > dist_from_out_buf_start) && (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))"
  },
  {
    "label": "TINFL_CR_RETURN_FOREVER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_CR_RETURN_FOREVER(37, TINFL_STATUS_FAILED)"
  },
  {
    "label": "pOut_buf_start()",
    "kind": "Method",
    "detail": "Function (} pSrc =)",
    "insertText": "pOut_buf_start((dist_from_out_buf_start - dist) & out_buf_size_mask)"
  },
  {
    "label": "TINFL_CR_RETURN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_CR_RETURN(53, TINFL_STATUS_HAS_MORE_OUTPUT)"
  },
  {
    "label": "pOut_buf_start()",
    "kind": "Method",
    "detail": "Function (}* pOut_buf_cur + + =)",
    "insertText": "pOut_buf_start(dist_from_out_buf_start++ - dist)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} continue ; } # if MINIZ_USE_UNALIGNED_LOADS_AND_STORES else)",
    "insertText": "if((counter >= 9) && (counter <= dist))"
  },
  {
    "label": "pSrc()",
    "kind": "Method",
    "detail": "Function (const mz_uint8* pSrc_end =)",
    "insertText": "pSrc(counter & ~7)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (pOut_buf_cur + = 8 ; })",
    "insertText": "while((pSrc += 8) < pSrc_end)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pOut_buf_cur [ 0 ] = pSrc [ 0 ] ;)",
    "insertText": "if(counter > 1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (pOut_buf_cur + = counter ; } continue ; } } # endif do { pOut_buf_cur [ 0 ] = pSrc [ 0 ] ; pOut_buf_cur [ 1 ] = pSrc [ 1 ] ; pOut_buf_cur [ 2 ] = pSrc [ 2 ] ; pOut_buf_cur + = 3 ; pSrc + = 3 ; })",
    "insertText": "while((int)(counter -= 3) > 2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pOut_buf_cur [ 0 ] = pSrc [ 0 ] ;)",
    "insertText": "if((int)counter > 1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (pOut_buf_cur + = counter ; } } } })",
    "insertText": "while(!(r->m_final & 1))"
  },
  {
    "label": "TINFL_SKIP_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TINFL_SKIP_BITS(32, num_bits & 7)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mz_uint s ;)",
    "insertText": "if(num_bits) TINFL_GET_BITS(41, s, 8)"
  },
  {
    "label": "m_z_adler32()",
    "kind": "Method",
    "detail": "Function (r ->)",
    "insertText": "m_z_adler32(r->m_z_adler32 << 8)"
  },
  {
    "label": "TINFL_CR_RETURN_FOREVER()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "TINFL_CR_RETURN_FOREVER(34, TINFL_STATUS_DONE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TINFL_CR_FINISH common_exit : r -> m_num_bits = num_bits ; r -> m_bit_buf = bit_buf ; r -> m_dist = dist ; r -> m_counter = counter ; r -> m_num_extra = num_extra ; r -> m_dist_from_out_buf_start = dist_from_out_buf_start ;* pIn_buf_size = pIn_buf_cur - pIn_buf_next ;* pOut_buf_size = pOut_buf_cur - pOut_buf_next ;)",
    "insertText": "if((decomp_flags & (TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) && (status >= 0))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const mz_uint8* ptr = pOut_buf_next ; size_t buf_len =* pOut_buf_size ; mz_uint32 i,s1 = r -> m_check_adler32& 0 xffff,s2 = r -> m_check_adler32>> 1 6 ; size_t block_len = buf_len % 5 5 5 2 ;)",
    "insertText": "while(buf_len)"
  },
  {
    "label": "m_check_adler32()",
    "kind": "Method",
    "detail": "Function (s1 % = 6 5 5 2 1 U,s2 % = 6 5 5 2 1 U ; buf_len - = block_len ; block_len = 5 5 5 2 ; } r ->)",
    "insertText": "m_check_adler32(s2 << 16)"
  },
  {
    "label": "tinfl_init()",
    "kind": "Method",
    "detail": "Function (tinfl_decompressor decomp ; void* pBuf = NULL,* pNew_buf ; size_t src_buf_ofs = 0,out_buf_capacity = 0 ;* pOut_len = 0 ;)",
    "insertText": "tinfl_init(&decomp)"
  },
  {
    "label": "tinfl_decompress()",
    "kind": "Method",
    "detail": "Function (size_t src_buf_size = src_buf_len - src_buf_ofs,dst_buf_size = out_buf_capacity -* pOut_len,new_out_buf_capacity ; tinfl_status status =)",
    "insertText": "tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf + src_buf_ofs, &src_buf_size, (mz_uint8 *)pBuf, pBuf ? (mz_uint8 *)pBuf + *pOut_len : NULL, &dst_buf_size, (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)"
  },
  {
    "label": "MZ_FREE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_FREE(pBuf)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* pOut_len = 0 ; return NULL ; } src_buf_ofs + = src_buf_size ;* pOut_len + = dst_buf_size ;)",
    "insertText": "if(status == TINFL_STATUS_DONE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (new_out_buf_capacity = out_buf_capacity* 2 ;)",
    "insertText": "if(new_out_buf_capacity < 128)"
  },
  {
    "label": "MZ_REALLOC()",
    "kind": "Method",
    "detail": "Function (pNew_buf =)",
    "insertText": "MZ_REALLOC(pBuf, new_out_buf_capacity)"
  },
  {
    "label": "tinfl_decompress_mem_to_mem()",
    "kind": "Method",
    "detail": "Function (* pOut_len = 0 ; return NULL ; } pBuf = pNew_buf ; out_buf_capacity = new_out_buf_capacity ; } return pBuf ; } size_t)",
    "insertText": "tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)"
  },
  {
    "label": "tinfl_decompress()",
    "kind": "Method",
    "detail": "Function (status =)",
    "insertText": "tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf, &src_buf_len, (mz_uint8 *)pOut_buf, (mz_uint8 *)pOut_buf, &out_buf_len, (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)"
  },
  {
    "label": "pDict()",
    "kind": "Method",
    "detail": "Function (int result = 0 ; tinfl_decompressor decomp ; mz_uint8*)",
    "insertText": "pDict(mz_uint8 *)MZ_MALLOC(TINFL_LZ_DICT_SIZE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t in_buf_ofs = 0,dict_ofs = 0 ;)",
    "insertText": "if(!pDict)"
  },
  {
    "label": "tinfl_decompress()",
    "kind": "Method",
    "detail": "Function (size_t in_buf_size =* pIn_buf_size - in_buf_ofs,dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs ; tinfl_status status =)",
    "insertText": "tinfl_decompress(&decomp, (const mz_uint8 *)pIn_buf + in_buf_ofs, &in_buf_size, pDict, pDict + dict_ofs, &dst_buf_size, (flags & ~(TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (in_buf_ofs + = in_buf_size ;)",
    "insertText": "if((dst_buf_size) && (!(*pPut_buf_func)(pDict + dict_ofs, (int)dst_buf_size, pPut_buf_user)))"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "result(status == TINFL_STATUS_DONE)"
  },
  {
    "label": "dict_ofs()",
    "kind": "Method",
    "detail": "Function (break ; })",
    "insertText": "dict_ofs(dict_ofs + dst_buf_size) & (TINFL_LZ_DICT_SIZE - 1)"
  },
  {
    "label": "MZ_FREE()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MZ_FREE(pDict)"
  },
  {
    "label": "tdefl_radix_sort_syms()",
    "kind": "Method",
    "detail": "Function (* pIn_buf_size = in_buf_ofs ; return result ; } const mz_uint16 s_tdefl_len_sym [ 2 5 6 ] = { 2 5 7,2 5 8,2 5 9,2 6 0,2 6 1,2 6 2,2 6 3,2 6 4,2 6 5,2 6 5,2 6 6,2 6 6,2 6 7,2 6 7,2 6 8,2 6 8,2 6 9,2 6 9,2 6 9,2 6 9,2 7 0,2 7 0,2 7 0,2 7 0,2 7 1,2 7 1,2 7 1,2 7 1,2 7 2,2 7 2,2 7 2,2 7 2,2 7 3,2 7 3,2 7 3,2 7 3,2 7 3,2 7 3,2 7 3,2 7 3,2 7 4,2 7 4,2 7 4,2 7 4,2 7 4,2 7 4,2 7 4,2 7 4,2 7 5,2 7 5,2 7 5,2 7 5,2 7 5,2 7 5,2 7 5,2 7 5,2 7 6,2 7 6,2 7 6,2 7 6,2 7 6,2 7 6,2 7 6,2 7 6,2 7 7,2 7 7,2 7 7,2 7 7,2 7 7,2 7 7,2 7 7,2 7 7,2 7 7,2 7 7,2 7 7,2 7 7,2 7 7,2 7 7,2 7 7,2 7 7,2 7 8,2 7 8,2 7 8,2 7 8,2 7 8,2 7 8,2 7 8,2 7 8,2 7 8,2 7 8,2 7 8,2 7 8,2 7 8,2 7 8,2 7 8,2 7 8,2 7 9,2 7 9,2 7 9,2 7 9,2 7 9,2 7 9,2 7 9,2 7 9,2 7 9,2 7 9,2 7 9,2 7 9,2 7 9,2 7 9,2 7 9,2 7 9,2 8 0,2 8 0,2 8 0,2 8 0,2 8 0,2 8 0,2 8 0,2 8 0,2 8 0,2 8 0,2 8 0,2 8 0,2 8 0,2 8 0,2 8 0,2 8 0,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 1,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 2,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 3,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 4,2 8 5 } ; const mz_uint8 s_tdefl_len_extra [ 2 5 6 ] = { 0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0 } ; const mz_uint8 s_tdefl_small_dist_sym [ 5 1 2 ] = { 0,1,2,3,4,4,5,5,6,6,6,6,7,7,7,7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,1 0,1 0,1 0,1 0,1 0,1 0,1 0,1 0,1 0,1 0,1 0,1 0,1 0,1 0,1 0,1 0,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 4,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 5,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 6,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7,1 7 } ; const mz_uint8 s_tdefl_small_dist_extra [ 5 1 2 ] = { 0,0,0,0,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7 } ; const mz_uint8 s_tdefl_large_dist_sym [ 1 2 8 ] = { 0,0,1 8,1 9,2 0,2 0,2 1,2 1,2 2,2 2,2 2,2 2,2 3,2 3,2 3,2 3,2 4,2 4,2 4,2 4,2 4,2 4,2 4,2 4,2 5,2 5,2 5,2 5,2 5,2 5,2 5,2 5,2 6,2 6,2 6,2 6,2 6,2 6,2 6,2 6,2 6,2 6,2 6,2 6,2 6,2 6,2 6,2 6,2 7,2 7,2 7,2 7,2 7,2 7,2 7,2 7,2 7,2 7,2 7,2 7,2 7,2 7,2 7,2 7,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 8,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9,2 9 } ; const mz_uint8 s_tdefl_large_dist_extra [ 1 2 8 ] = { 0,0,8,8,9,9,9,9,1 0,1 0,1 0,1 0,1 0,1 0,1 0,1 0,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 1,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 2,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3,1 3 } ; typedef struct { mz_uint16 m_key,m_sym_index ; } tdefl_sym_freq ; tdefl_sym_freq*)",
    "insertText": "tdefl_radix_sort_syms(mz_uint num_syms, tdefl_sym_freq *pSyms0, tdefl_sym_freq *pSyms1)"
  },
  {
    "label": "MZ_CLEAR_OBJ()",
    "kind": "Method",
    "detail": "Function (mz_uint32 total_passes = 2,pass_shift,pass,i,hist [ 2 5 6* 2 ] ; tdefl_sym_freq* pCur_syms = pSyms0,* pNew_syms = pSyms1 ;)",
    "insertText": "MZ_CLEAR_OBJ(hist)"
  },
  {
    "label": "hist()",
    "kind": "Method",
    "detail": "Function (mz_uint freq = pSyms0 [ i ] . m_key ; hist [ freq& 0 xFF ] + + ;)",
    "insertText": "hist((freq >> 8) & 0xFF)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256]))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const mz_uint32* pHist =& hist [ pass<<8 ] ; mz_uint offsets [ 2 5 6 ],cur_ofs = 0 ;)",
    "insertText": "for(i = 0; i < 256; i++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (offsets [ i ] = cur_ofs ; cur_ofs + = pHist [ i ] ; })",
    "insertText": "for(i = 0; i < num_syms; i++) pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift)"
  },
  {
    "label": "tdefl_calculate_minimum_redundancy()",
    "kind": "Method",
    "detail": "Function ({ tdefl_sym_freq* t = pCur_syms ; pCur_syms = pNew_syms ; pNew_syms = t ; } } return pCur_syms ; } void)",
    "insertText": "tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, int n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int root,leaf,next,avbl,used,dpth ;)",
    "insertText": "if(n == 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (A [ 0 ] . m_key = 1 ; return ; } A [ 0 ] . m_key + = A [ 1 ] . m_key ; root = 0 ; leaf = 2 ;)",
    "insertText": "for(next = 1; next < n - 1; next++)"
  },
  {
    "label": "m_key()",
    "kind": "Method",
    "detail": "Function (A [ next ] . m_key = A [ root ] . m_key ; A [ root + + ] .)",
    "insertText": "m_key(mz_uint16)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else A [ next ] . m_key = A [ leaf + + ] . m_key ;)",
    "insertText": "if(leaf >= n || (root < next && A[root].m_key < A[leaf].m_key))"
  },
  {
    "label": "m_key()",
    "kind": "Method",
    "detail": "Function (A [ next ] .)",
    "insertText": "m_key(mz_uint16)(A[next].m_key + A[root].m_key)"
  },
  {
    "label": "m_key()",
    "kind": "Method",
    "detail": "Function (} else A [ next ] .)",
    "insertText": "m_key(mz_uint16)(A[next].m_key + A[leaf++].m_key)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} A [ n - 2 ] . m_key = 0 ;)",
    "insertText": "for(next = n - 3; next >= 0; next--)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (avbl = 1 ; used = dpth = 0 ; root = n - 2 ; next = n - 1 ;)",
    "insertText": "while(avbl > 0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (used + + ; root - - ; })",
    "insertText": "while(avbl > used)"
  },
  {
    "label": "m_key()",
    "kind": "Method",
    "detail": "Function (A [ next - - ] .)",
    "insertText": "m_key(mz_uint16)(dpth)"
  },
  {
    "label": "tdefl_huffman_enforce_max_code_size()",
    "kind": "Method",
    "detail": "Function (avbl - - ; } avbl = 2* used ; dpth + + ; used = 0 ; } } enum { TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 3 2 } ; void)",
    "insertText": "tdefl_huffman_enforce_max_code_size(int *pNum_codes, int code_list_len, int max_code_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int i ; mz_uint32 total = 0 ;)",
    "insertText": "if(code_list_len <= 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (pNum_codes [ max_code_size ] - - ;)",
    "insertText": "for(i = max_code_size - 1; i > 0; i--) if (pNum_codes[i])"
  },
  {
    "label": "tdefl_optimize_huffman_table()",
    "kind": "Method",
    "detail": "Function (pNum_codes [ i ] - - ; pNum_codes [ i + 1 ] + = 2 ; break ; } total - - ; } } void)",
    "insertText": "tdefl_optimize_huffman_table(tdefl_compressor *d, int table_num, int table_len, int code_size_limit, int static_table)"
  },
  {
    "label": "MZ_CLEAR_OBJ()",
    "kind": "Method",
    "detail": "Function (int i,j,l,num_codes [ 1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE ] ; mz_uint next_code [ TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1 ] ;)",
    "insertText": "MZ_CLEAR_OBJ(num_codes)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else { tdefl_sym_freq syms0 [ TDEFL_MAX_HUFF_SYMBOLS ],syms1 [ TDEFL_MAX_HUFF_SYMBOLS ],* pSyms ; int num_used_syms = 0 ; const mz_uint16* pSym_count =& d -> m_huff_count [ table_num ] [ 0 ] ;)",
    "insertText": "for(i = 0; i < table_len; i++) if (pSym_count[i])"
  },
  {
    "label": "m_sym_index()",
    "kind": "Method",
    "detail": "Function (syms0 [ num_used_syms + + ] .)",
    "insertText": "m_sym_index(mz_uint16)"
  },
  {
    "label": "tdefl_radix_sort_syms()",
    "kind": "Method",
    "detail": "Function (} pSyms =)",
    "insertText": "tdefl_radix_sort_syms(num_used_syms, syms0, syms1)"
  },
  {
    "label": "tdefl_calculate_minimum_redundancy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tdefl_calculate_minimum_redundancy(pSyms, num_used_syms)"
  },
  {
    "label": "tdefl_huffman_enforce_max_code_size()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tdefl_huffman_enforce_max_code_size(num_codes, num_used_syms, code_size_limit)"
  },
  {
    "label": "MZ_CLEAR_OBJ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_CLEAR_OBJ(d->m_huff_code_sizes[table_num])"
  },
  {
    "label": "MZ_CLEAR_OBJ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_CLEAR_OBJ(d->m_huff_codes[table_num])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} next_code [ 1 ] = 0 ;)",
    "insertText": "for(j = 0, i = 2; i <= code_size_limit; i++) next_code[i] = j = ((j + num_codes[i - 1]) << 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mz_uint rev_code = 0,code,code_size ;)",
    "insertText": "if((code_size = d->m_huff_code_sizes[table_num][i]) == 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (code = next_code [ code_size ] + + ;)",
    "insertText": "for(l = code_size; l > 0; l--, code >>= 1) rev_code = (rev_code << 1) | (code & 1)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (d -> m_huff_codes [ table_num ] [)",
    "insertText": "i(mz_uint16)"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (} } # define)",
    "insertText": "TDEFL_PUT_BITS(b, l)"
  },
  {
    "label": "MZ_ASSERT()",
    "kind": "Method",
    "detail": "Function (\\ mz_uint bits = b ; \\ mz_uint len = l ; \\)",
    "insertText": "MZ_ASSERT(bits <= ((1U << len) - 1U))"
  },
  {
    "label": "m_bit_buffer()",
    "kind": "Method",
    "detail": "Function (\\ d ->)",
    "insertText": "m_bit_buffer(bits << d->m_bits_in)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ d -> m_bits_in + = len ; \\)",
    "insertText": "while(d->m_bits_in >= 8)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(d->m_pOutput_buf < d->m_pOutput_buf_end) \\ *d->m_pOutput_buf++ = (mz_uint8)(d->m_bit_buffer)"
  },
  {
    "label": "TDEFL_RLE_PREV_CODE_SIZE()",
    "kind": "Method",
    "detail": "Function (\\ d -> m_bit_buffer>> = 8 ; \\ d -> m_bits_in - = 8 ; \\ } \\ } \\ MZ_MACRO_END # define)",
    "insertText": "TDEFL_RLE_PREV_CODE_SIZE()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(rle_repeat_count)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(rle_repeat_count < 3)"
  },
  {
    "label": "prev_code_size()",
    "kind": "Method",
    "detail": "Function (\\ d -> m_huff_count [ 2 ] [)",
    "insertText": "prev_code_size(mz_uint16)( \\ d->m_huff_count[2][prev_code_size] + rle_repeat_count)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "while(rle_repeat_count--)"
  },
  {
    "label": "m_huff_count()",
    "kind": "Method",
    "detail": "Function (\\ } else { \\ d ->)",
    "insertText": "m_huff_count(mz_uint16)(d->m_huff_count[2][16] + 1)"
  },
  {
    "label": "num_packed_code_sizes()",
    "kind": "Method",
    "detail": "Function (\\ packed_code_sizes [ num_packed_code_sizes + + ] = 1 6 ; \\ packed_code_sizes [)",
    "insertText": "num_packed_code_sizes(mz_uint8)(rle_repeat_count - 3)"
  },
  {
    "label": "TDEFL_RLE_ZERO_CODE_SIZE()",
    "kind": "Method",
    "detail": "Function (\\ } \\ rle_repeat_count = 0 ; \\ } \\ } # define)",
    "insertText": "TDEFL_RLE_ZERO_CODE_SIZE()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(rle_z_count)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(rle_z_count < 3)"
  },
  {
    "label": "m_huff_count()",
    "kind": "Method",
    "detail": "Function (\\ d ->)",
    "insertText": "m_huff_count(mz_uint16)(d->m_huff_count[2][0] + rle_z_count)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "while(rle_z_count--)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\ } else)",
    "insertText": "if(rle_z_count <= 10)"
  },
  {
    "label": "m_huff_count()",
    "kind": "Method",
    "detail": "Function (\\ d ->)",
    "insertText": "m_huff_count(mz_uint16)(d->m_huff_count[2][17] + 1)"
  },
  {
    "label": "num_packed_code_sizes()",
    "kind": "Method",
    "detail": "Function (\\ packed_code_sizes [ num_packed_code_sizes + + ] = 1 7 ; \\ packed_code_sizes [)",
    "insertText": "num_packed_code_sizes(mz_uint8)(rle_z_count - 3)"
  },
  {
    "label": "m_huff_count()",
    "kind": "Method",
    "detail": "Function (\\ } else { \\ d ->)",
    "insertText": "m_huff_count(mz_uint16)(d->m_huff_count[2][18] + 1)"
  },
  {
    "label": "num_packed_code_sizes()",
    "kind": "Method",
    "detail": "Function (\\ packed_code_sizes [ num_packed_code_sizes + + ] = 1 8 ; \\ packed_code_sizes [)",
    "insertText": "num_packed_code_sizes(mz_uint8)(rle_z_count - 11)"
  },
  {
    "label": "tdefl_start_dynamic_block()",
    "kind": "Method",
    "detail": "Function (\\ } \\ rle_z_count = 0 ; \\ } \\ } mz_uint8 s_tdefl_packed_code_size_syms_swizzle [ ] = { 1 6,1 7,1 8,0,8,7,9,6,1 0,5,1 1,4,1 2,3,1 3,2,1 4,1,1 5 } ; void)",
    "insertText": "tdefl_start_dynamic_block(tdefl_compressor *d)"
  },
  {
    "label": "tdefl_optimize_huffman_table()",
    "kind": "Method",
    "detail": "Function (int num_lit_codes,num_dist_codes,num_bit_lengths ; mz_uint i,total_code_sizes_to_pack,num_packed_code_sizes,rle_z_count,rle_repeat_count,packed_code_sizes_index ; mz_uint8 code_sizes_to_pack [ TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1 ],packed_code_sizes [ TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1 ],prev_code_size = 0 xFF ; d -> m_huff_count [ 0 ] [ 2 5 6 ] = 1 ;)",
    "insertText": "tdefl_optimize_huffman_table(d, 0, TDEFL_MAX_HUFF_SYMBOLS_0, 15, MZ_FALSE)"
  },
  {
    "label": "tdefl_optimize_huffman_table()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tdefl_optimize_huffman_table(d, 1, TDEFL_MAX_HUFF_SYMBOLS_1, 15, MZ_FALSE)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(code_sizes_to_pack, &d->m_huff_code_sizes[0][0], num_lit_codes)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(code_sizes_to_pack + num_lit_codes, &d->m_huff_code_sizes[1][0], num_dist_codes)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (total_code_sizes_to_pack = num_lit_codes + num_dist_codes ; num_packed_code_sizes = 0 ; rle_z_count = 0 ; rle_repeat_count = 0 ;)",
    "insertText": "memset(&d->m_huff_count[2][0], 0, sizeof(d->m_huff_count[2][0]) * TDEFL_MAX_HUFF_SYMBOLS_2)"
  },
  {
    "label": "code_size()",
    "kind": "Method",
    "detail": "Function (d -> m_huff_count [ 2 ] [)",
    "insertText": "code_size(mz_uint16)(d->m_huff_count[2][code_size] + 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (packed_code_sizes [ num_packed_code_sizes + + ] = code_size ; } else)",
    "insertText": "if(++rle_repeat_count == 6)"
  },
  {
    "label": "tdefl_optimize_huffman_table()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "tdefl_optimize_huffman_table(d, 2, TDEFL_MAX_HUFF_SYMBOLS_2, 7, MZ_FALSE)"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS(2, 2)"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS(num_lit_codes - 257, 5)"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS(num_dist_codes - 1, 5)"
  },
  {
    "label": "MZ_MAX()",
    "kind": "Method",
    "detail": "Function (num_bit_lengths =)",
    "insertText": "MZ_MAX(4, (num_bit_lengths + 1))"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS(num_bit_lengths - 4, 4)"
  },
  {
    "label": "MZ_ASSERT()",
    "kind": "Method",
    "detail": "Function (mz_uint code = packed_code_sizes [ packed_code_sizes_index + + ] ;)",
    "insertText": "MZ_ASSERT(code < TDEFL_MAX_HUFF_SYMBOLS_2)"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS(d->m_huff_codes[2][code], d->m_huff_code_sizes[2][code])"
  },
  {
    "label": "tdefl_start_static_block()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "tdefl_start_static_block(tdefl_compressor *d)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (mz_uint i ; mz_uint8* p =& d -> m_huff_code_sizes [ 0 ] [ 0 ] ;)",
    "insertText": "for(i = 0; i <= 143; ++i)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(d->m_huff_code_sizes[1], 5, 32)"
  },
  {
    "label": "tdefl_optimize_huffman_table()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tdefl_optimize_huffman_table(d, 0, 288, 15, MZ_TRUE)"
  },
  {
    "label": "tdefl_optimize_huffman_table()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tdefl_optimize_huffman_table(d, 1, 32, 15, MZ_TRUE)"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS(1, 2)"
  },
  {
    "label": "tdefl_compress_lz_codes()",
    "kind": "Method",
    "detail": "Function (} const mz_uint mz_bitmasks [ 1 7 ] = { 0 x0000,0 x0001,0 x0003,0 x0007,0 x000F,0 x001F,0 x003F,0 x007F,0 x00FF,0 x01FF,0 x03FF,0 x07FF,0 x0FFF,0 x1FFF,0 x3FFF,0 x7FFF,0 xFFFF } ; # if MINIZ_USE_UNALIGNED_LOADS_AND_STORES&& MINIZ_LITTLE_ENDIAN&& \\ MINIZ_HAS_64BIT_REGISTERS mz_bool)",
    "insertText": "tdefl_compress_lz_codes(tdefl_compressor *d)"
  },
  {
    "label": "TDEFL_PUT_BITS_FAST()",
    "kind": "Method",
    "detail": "Function (mz_uint flags ; mz_uint8* pLZ_codes ; mz_uint8* pOutput_buf = d -> m_pOutput_buf ; mz_uint8* pLZ_code_buf_end = d -> m_pLZ_code_buf ; mz_uint64 bit_buffer = d -> m_bit_buffer ; mz_uint bits_in = d -> m_bits_in ; # define)",
    "insertText": "TDEFL_PUT_BITS_FAST(b, l)"
  },
  {
    "label": "bit_buffer()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "bit_buffer(((mz_uint64)(b)) << bits_in)"
  },
  {
    "label": "bits_in()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "bits_in(l)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (\\ } flags = 1 ;)",
    "insertText": "for(pLZ_codes = d->m_lz_code_buf; pLZ_codes < pLZ_code_buf_end; flags >>= 1)"
  },
  {
    "label": "match_dist()",
    "kind": "Method",
    "detail": "Function (mz_uint s0,s1,n0,n1,sym,num_extra_bits ; mz_uint match_len = pLZ_codes [ 0 ],)",
    "insertText": "match_dist(const mz_uint16 *)(pLZ_codes + 1)"
  },
  {
    "label": "MZ_ASSERT()",
    "kind": "Method",
    "detail": "Function (pLZ_codes + = 3 ;)",
    "insertText": "MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]])"
  },
  {
    "label": "TDEFL_PUT_BITS_FAST()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]])"
  },
  {
    "label": "TDEFL_PUT_BITS_FAST()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS_FAST(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len])"
  },
  {
    "label": "sym()",
    "kind": "Method",
    "detail": "Function (s0 = s_tdefl_small_dist_sym [ match_dist& 5 1 1 ] ; n0 = s_tdefl_small_dist_extra [ match_dist& 5 1 1 ] ; s1 = s_tdefl_large_dist_sym [ match_dist>> 8 ] ; n1 = s_tdefl_large_dist_extra [ match_dist>> 8 ] ;)",
    "insertText": "sym(match_dist < 512)"
  },
  {
    "label": "num_extra_bits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "num_extra_bits(match_dist < 512)"
  },
  {
    "label": "MZ_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_ASSERT(d->m_huff_code_sizes[1][sym])"
  },
  {
    "label": "TDEFL_PUT_BITS_FAST()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS_FAST(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym])"
  },
  {
    "label": "TDEFL_PUT_BITS_FAST()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS_FAST(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits)"
  },
  {
    "label": "MZ_ASSERT()",
    "kind": "Method",
    "detail": "Function (} else { mz_uint lit =* pLZ_codes + + ;)",
    "insertText": "MZ_ASSERT(d->m_huff_code_sizes[0][lit])"
  },
  {
    "label": "TDEFL_PUT_BITS_FAST()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "if(pOutput_buf >= d->m_pOutput_buf_end)"
  },
  {
    "label": "pOutput_buf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pOutput_buf(bits_in >> 3)"
  },
  {
    "label": "bit_buffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bit_buffer(bits_in & ~7)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (bits_in& = 7 ; } # undef TDEFL_PUT_BITS_FAST d -> m_pOutput_buf = pOutput_buf ; d -> m_bits_in = 0 ; d -> m_bit_buffer = 0 ;)",
    "insertText": "while(bits_in)"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (mz_uint32 n =)",
    "insertText": "MZ_MIN(bits_in, 16)"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS((mz_uint)bit_buffer & mz_bitmasks[n], n)"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (bit_buffer>> = n ; bits_in - = n ; })",
    "insertText": "TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (mz_uint flags ; mz_uint8* pLZ_codes ; flags = 1 ;)",
    "insertText": "for(pLZ_codes = d->m_lz_code_buf; pLZ_codes < d->m_pLZ_code_buf; flags >>= 1)"
  },
  {
    "label": "match_dist()",
    "kind": "Method",
    "detail": "Function (mz_uint sym,num_extra_bits ; mz_uint match_len = pLZ_codes [ 0 ],)",
    "insertText": "match_dist(pLZ_codes[1] | (pLZ_codes[2] << 8))"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]])"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len])"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym])"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits)"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit])"
  },
  {
    "label": "tdefl_compress_block()",
    "kind": "Method",
    "detail": "Function (} # endif mz_bool)",
    "insertText": "tdefl_compress_block(tdefl_compressor *d, mz_bool static_block)"
  },
  {
    "label": "tdefl_flush_block()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "tdefl_flush_block(tdefl_compressor *d, int flush)"
  },
  {
    "label": "use_raw_block()",
    "kind": "Method",
    "detail": "Function (m_dict_size)",
    "insertText": "use_raw_block((d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS) != 0) && (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos)"
  },
  {
    "label": "pOutput_buf_start()",
    "kind": "Method",
    "detail": "Function (m_output_buf)",
    "insertText": "pOutput_buf_start((d->m_pPut_buf_func == NULL) && ((*d->m_pOut_buf_size - d->m_out_buf_ofs) >= TDEFL_OUT_BUF_SIZE)) ? ((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs)"
  },
  {
    "label": "MZ_ASSERT()",
    "kind": "Method",
    "detail": "Function (d -> m_pOutput_buf = pOutput_buf_start ; d -> m_pOutput_buf_end = d -> m_pOutput_buf + TDEFL_OUT_BUF_SIZE - 1 6 ;)",
    "insertText": "MZ_ASSERT(!d->m_output_flush_remaining)"
  },
  {
    "label": "m_pLZ_flags()",
    "kind": "Method",
    "detail": "Function (d -> m_output_flush_ofs = 0 ; d -> m_output_flush_remaining = 0 ;* d ->)",
    "insertText": "m_pLZ_flags(mz_uint8)(*d->m_pLZ_flags >> d->m_num_flags_left)"
  },
  {
    "label": "m_pLZ_code_buf()",
    "kind": "Method",
    "detail": "Function (d ->)",
    "insertText": "m_pLZ_code_buf(d->m_num_flags_left == 8)"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS(0x78, 8)"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS(0x01, 8)"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TDEFL_PUT_BITS(flush == TDEFL_FINISH, 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pSaved_output_buf = d -> m_pOutput_buf ; saved_bit_buf = d -> m_bit_buffer ; saved_bits_in = d -> m_bits_in ;)",
    "insertText": "if(!use_raw_block) comp_block_succeeded = tdefl_compress_block(d, (d->m_flags & TDEFL_FORCE_ALL_STATIC_BLOCKS) || (d->m_total_lz_bytes < 48))"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (mz_uint i ; d -> m_pOutput_buf = pSaved_output_buf ; d -> m_bit_buffer = saved_bit_buf,d -> m_bits_in = saved_bits_in ;)",
    "insertText": "TDEFL_PUT_BITS(0, 2)"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS(0, 8 - d->m_bits_in)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(i = 2; i; --i, d->m_total_lz_bytes ^= 0xFFFF)"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS(d->m_total_lz_bytes & 0xFFFF, 16)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(i = 0; i < d->m_total_lz_bytes; ++i)"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS(d->m_dict[(d->m_lz_code_buf_dict_pos + i) & TDEFL_LZ_DICT_SIZE_MASK], 8)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(!comp_block_succeeded)"
  },
  {
    "label": "tdefl_compress_block()",
    "kind": "Method",
    "detail": "Function (d -> m_pOutput_buf = pSaved_output_buf ; d -> m_bit_buffer = saved_bit_buf,d -> m_bits_in = saved_bits_in ;)",
    "insertText": "tdefl_compress_block(d, MZ_TRUE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(flush)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(d->m_flags & TDEFL_WRITE_ZLIB_HEADER)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (mz_uint i,a = d -> m_adler32 ;)",
    "insertText": "for(i = 0; i < 4; i++)"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS((a >> 24) & 0xFF, 8)"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (a<<= 8 ; } } } else { mz_uint i,z = 0 ;)",
    "insertText": "TDEFL_PUT_BITS(0, 3)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(i = 2; i; --i, z ^= 0xFFFF)"
  },
  {
    "label": "TDEFL_PUT_BITS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDEFL_PUT_BITS(z & 0xFFFF, 16)"
  },
  {
    "label": "MZ_ASSERT()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "MZ_ASSERT(d->m_pOutput_buf < d->m_pOutput_buf_end)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (d -> m_pLZ_code_buf = d -> m_lz_code_buf + 1 ; d -> m_pLZ_flags = d -> m_lz_code_buf ; d -> m_num_flags_left = 8 ; d -> m_lz_code_buf_dict_pos + = d -> m_total_lz_bytes ; d -> m_total_lz_bytes = 0 ; d -> m_block_index + + ;)",
    "insertText": "if((n = (int)(d->m_pOutput_buf - pOutput_buf_start)) != 0)"
  },
  {
    "label": "m_pSrc()",
    "kind": "Method",
    "detail": "Function (m_pIn_buf)",
    "insertText": "m_pSrc(const mz_uint8 *)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(pOutput_buf_start == d->m_output_buf)"
  },
  {
    "label": "bytes_to_copy()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "bytes_to_copy(int)MZ_MIN( (size_t)n, (size_t)(*d->m_pOut_buf_size - d->m_out_buf_ofs))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf, bytes_to_copy)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (d -> m_out_buf_ofs + = bytes_to_copy ;)",
    "insertText": "if((n -= bytes_to_copy) != 0)"
  },
  {
    "label": "TDEFL_READ_UNALIGNED_WORD()",
    "kind": "Method",
    "detail": "Function (d -> m_output_flush_ofs = bytes_to_copy ; d -> m_output_flush_remaining = n ; } } else { d -> m_out_buf_ofs + = n ; } } return d -> m_output_flush_remaining ; } # if MINIZ_USE_UNALIGNED_LOADS_AND_STORES # define)",
    "insertText": "TDEFL_READ_UNALIGNED_WORD(p) *(const mz_uint16 *)(p) static MZ_FORCEINLINE void tdefl_find_match( tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)"
  },
  {
    "label": "s()",
    "kind": "Method",
    "detail": "Function (mz_uint dist,pos = lookahead_pos& TDEFL_LZ_DICT_SIZE_MASK,match_len =* pMatch_len,probe_pos = pos,next_probe_pos,probe_len ; mz_uint num_probes_left = d -> m_max_probes [ match_len> = 3 2 ] ; const mz_uint16*)",
    "insertText": "s(const mz_uint16 *)(d->m_dict + pos)"
  },
  {
    "label": "TDEFL_READ_UNALIGNED_WORD()",
    "kind": "Method",
    "detail": "Function (mz_uint16 c01 =)",
    "insertText": "TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]), s01 = TDEFL_READ_UNALIGNED_WORD(s)"
  },
  {
    "label": "MZ_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# define TDEFL_PROBE \\ next_probe_pos = d -> m_next [ probe_pos ] ; \\)",
    "insertText": "if((!next_probe_pos) || \\ ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\ probe_pos = next_probe_pos& TDEFL_LZ_DICT_SIZE_MASK ; \\)",
    "insertText": "if(TDEFL_READ_UNALIGNED_WORD(&d->m_dict[probe_pos + match_len - 1]) == c01)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TDEFL_PROBE ; TDEFL_PROBE ; TDEFL_PROBE ; })",
    "insertText": "if(!dist)"
  },
  {
    "label": "q()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "q(const mz_uint16 *)(d->m_dict + probe_pos)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (p = s ; probe_len = 3 2 ; do { })",
    "insertText": "while((TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (--probe_len > 0))"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (* pMatch_dist = dist ;* pMatch_len =)",
    "insertText": "MZ_MIN(max_match_len, TDEFL_MAX_MATCH_LEN)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } else)",
    "insertText": "if((probe_len = ((mz_uint)(p - s) * 2) + (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q)) > match_len)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* pMatch_dist = dist ;)",
    "insertText": "if((*pMatch_len = match_len = MZ_MIN(max_match_len, probe_len)) == max_match_len)"
  },
  {
    "label": "TDEFL_READ_UNALIGNED_WORD()",
    "kind": "Method",
    "detail": "Function (c01 =)",
    "insertText": "TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1])"
  },
  {
    "label": "tdefl_find_match()",
    "kind": "Method",
    "detail": "Function (} } } # else MZ_FORCEINLINE void)",
    "insertText": "tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\ probe_pos = next_probe_pos& TDEFL_LZ_DICT_SIZE_MASK ; \\)",
    "insertText": "if((d->m_dict[probe_pos + match_len] == c0) && \\ (d->m_dict[probe_pos + match_len - 1] == c1))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (p = s ; q = d -> m_dict + probe_pos ;)",
    "insertText": "for(probe_len = 0; probe_len < max_match_len; probe_len++) if (*p++ != *q++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* pMatch_dist = dist ;)",
    "insertText": "if((*pMatch_len = match_len = probe_len) == max_match_len)"
  },
  {
    "label": "tdefl_compress_fast()",
    "kind": "Method",
    "detail": "Function (c0 = d -> m_dict [ pos + match_len ] ; c1 = d -> m_dict [ pos + match_len - 1 ] ; } } } # endif # if MINIZ_USE_UNALIGNED_LOADS_AND_STORES&& MINIZ_LITTLE_ENDIAN mz_bool)",
    "insertText": "tdefl_compress_fast(tdefl_compressor *d)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (mz_uint lookahead_pos = d -> m_lookahead_pos,lookahead_size = d -> m_lookahead_size,dict_size = d -> m_dict_size,total_lz_bytes = d -> m_total_lz_bytes,num_flags_left = d -> m_num_flags_left ; mz_uint8* pLZ_code_buf = d -> m_pLZ_code_buf,* pLZ_flags = d -> m_pLZ_flags ; mz_uint cur_pos = lookahead_pos& TDEFL_LZ_DICT_SIZE_MASK ;)",
    "insertText": "while((d->m_src_buf_left) || ((d->m_flush) && (lookahead_size)))"
  },
  {
    "label": "dst_pos()",
    "kind": "Method",
    "detail": "Function (const mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4 0 9 6 ; mz_uint)",
    "insertText": "dst_pos(lookahead_pos + lookahead_size)"
  },
  {
    "label": "num_bytes_to_process()",
    "kind": "Method",
    "detail": "Function (mz_uint)",
    "insertText": "num_bytes_to_process(mz_uint)MZ_MIN( d->m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (d -> m_src_buf_left - = num_bytes_to_process ; lookahead_size + = num_bytes_to_process ;)",
    "insertText": "while(num_bytes_to_process)"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (mz_uint32 n =)",
    "insertText": "MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(d->m_dict + dst_pos, d->m_pSrc, n)"
  },
  {
    "label": "dst_pos()",
    "kind": "Method",
    "detail": "Function (d -> m_pSrc + = n ;)",
    "insertText": "dst_pos(dst_pos + n)"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (num_bytes_to_process - = n ; } dict_size =)",
    "insertText": "MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size)"
  },
  {
    "label": "first_trigram()",
    "kind": "Method",
    "detail": "Function (mz_uint cur_match_dist,cur_match_len = 1 ; mz_uint8* pCur_dict = d -> m_dict + cur_pos ; mz_uint)",
    "insertText": "first_trigram(*(const mz_uint32 *)pCur_dict)"
  },
  {
    "label": "hash()",
    "kind": "Method",
    "detail": "Function (mz_uint)",
    "insertText": "hash(first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8))))"
  },
  {
    "label": "hash()",
    "kind": "Method",
    "detail": "Function (mz_uint probe_pos = d -> m_hash [ hash ] ; d -> m_hash [)",
    "insertText": "hash(mz_uint16)"
  },
  {
    "label": "p()",
    "kind": "Method",
    "detail": "Function (const mz_uint16*)",
    "insertText": "p(const mz_uint16 *)"
  },
  {
    "label": "cur_match_len()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cur_match_len((mz_uint)(p - (const mz_uint16 *)pCur_dict) * 2) + (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q)"
  },
  {
    "label": "pLZ_code_buf()",
    "kind": "Method",
    "detail": "Function (cur_match_len = 1 ;*)",
    "insertText": "pLZ_code_buf(mz_uint8)"
  },
  {
    "label": "pLZ_flags()",
    "kind": "Method",
    "detail": "Function (*)",
    "insertText": "pLZ_flags(mz_uint8)(*pLZ_flags >> 1)"
  },
  {
    "label": "m_huff_count()",
    "kind": "Method",
    "detail": "Function (d ->)",
    "insertText": "m_huff_count(mz_uint8)"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (} else { mz_uint32 s0,s1 ; cur_match_len =)",
    "insertText": "MZ_MIN(cur_match_len, lookahead_size)"
  },
  {
    "label": "MZ_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_ASSERT((cur_match_len >= TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 1) && (cur_match_dist <= TDEFL_LZ_DICT_SIZE))"
  },
  {
    "label": "pLZ_code_buf()",
    "kind": "Method",
    "detail": "Function (cur_match_dist - - ;)",
    "insertText": "pLZ_code_buf(mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN)"
  },
  {
    "label": "pLZ_flags()",
    "kind": "Method",
    "detail": "Function (pLZ_code_buf + = 3 ;*)",
    "insertText": "pLZ_flags(mz_uint8)((*pLZ_flags >> 1) | 0x80)"
  },
  {
    "label": "m_huff_count()",
    "kind": "Method",
    "detail": "Function (s0 = s_tdefl_small_dist_sym [ cur_match_dist& 5 1 1 ] ; s1 = s_tdefl_large_dist_sym [ cur_match_dist>> 8 ] ; d ->)",
    "insertText": "m_huff_count(cur_match_dist < 512)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(--num_flags_left == 0)"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (num_flags_left = 8 ; pLZ_flags = pLZ_code_buf + + ; } total_lz_bytes + = cur_match_len ; lookahead_pos + = cur_match_len ; dict_size =)",
    "insertText": "MZ_MIN(dict_size + cur_match_len, TDEFL_LZ_DICT_SIZE)"
  },
  {
    "label": "cur_pos()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cur_pos(cur_pos + cur_match_len)"
  },
  {
    "label": "MZ_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_ASSERT(lookahead_size >= cur_match_len)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lookahead_size - = cur_match_len ;)",
    "insertText": "if(pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int n ; d -> m_lookahead_pos = lookahead_pos ; d -> m_lookahead_size = lookahead_size ; d -> m_dict_size = dict_size ; d -> m_total_lz_bytes = total_lz_bytes ; d -> m_pLZ_code_buf = pLZ_code_buf ; d -> m_pLZ_flags = pLZ_flags ; d -> m_num_flags_left = num_flags_left ;)",
    "insertText": "if((n = tdefl_flush_block(d, 0)) != 0) return (n < 0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (total_lz_bytes = d -> m_total_lz_bytes ; pLZ_code_buf = d -> m_pLZ_code_buf ; pLZ_flags = d -> m_pLZ_flags ; num_flags_left = d -> m_num_flags_left ; } })",
    "insertText": "while(lookahead_size)"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (num_flags_left = 8 ; pLZ_flags = pLZ_code_buf + + ; } d -> m_huff_count [ 0 ] [ lit ] + + ; lookahead_pos + + ; dict_size =)",
    "insertText": "MZ_MIN(dict_size + 1, TDEFL_LZ_DICT_SIZE)"
  },
  {
    "label": "cur_pos()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cur_pos(cur_pos + 1)"
  },
  {
    "label": "tdefl_record_literal()",
    "kind": "Method",
    "detail": "Function (total_lz_bytes = d -> m_total_lz_bytes ; pLZ_code_buf = d -> m_pLZ_code_buf ; pLZ_flags = d -> m_pLZ_flags ; num_flags_left = d -> m_num_flags_left ; } } } d -> m_lookahead_pos = lookahead_pos ; d -> m_lookahead_size = lookahead_size ; d -> m_dict_size = dict_size ; d -> m_total_lz_bytes = total_lz_bytes ; d -> m_pLZ_code_buf = pLZ_code_buf ; d -> m_pLZ_flags = pLZ_flags ; d -> m_num_flags_left = num_flags_left ; return MZ_TRUE ; } # endif MZ_FORCEINLINE void)",
    "insertText": "tdefl_record_literal(tdefl_compressor *d, mz_uint8 lit)"
  },
  {
    "label": "m_pLZ_flags()",
    "kind": "Method",
    "detail": "Function (d -> m_total_lz_bytes + + ;* d -> m_pLZ_code_buf + + = lit ;* d ->)",
    "insertText": "m_pLZ_flags(mz_uint8)(*d->m_pLZ_flags >> 1)"
  },
  {
    "label": "tdefl_record_match()",
    "kind": "Method",
    "detail": "Function (d -> m_num_flags_left = 8 ; d -> m_pLZ_flags = d -> m_pLZ_code_buf + + ; } d -> m_huff_count [ 0 ] [ lit ] + + ; } MZ_FORCEINLINE void)",
    "insertText": "tdefl_record_match(tdefl_compressor *d, mz_uint match_len, mz_uint match_dist)"
  },
  {
    "label": "MZ_ASSERT()",
    "kind": "Method",
    "detail": "Function (mz_uint32 s0,s1 ;)",
    "insertText": "MZ_ASSERT((match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) && (match_dist <= TDEFL_LZ_DICT_SIZE))"
  },
  {
    "label": "m_pLZ_code_buf()",
    "kind": "Method",
    "detail": "Function (d -> m_total_lz_bytes + = match_len ; d ->)",
    "insertText": "m_pLZ_code_buf(mz_uint8)(match_len - TDEFL_MIN_MATCH_LEN)"
  },
  {
    "label": "m_pLZ_code_buf()",
    "kind": "Method",
    "detail": "Function (match_dist - = 1 ; d ->)",
    "insertText": "m_pLZ_code_buf(mz_uint8)(match_dist & 0xFF)"
  },
  {
    "label": "m_pLZ_code_buf()",
    "kind": "Method",
    "detail": "Function (d ->)",
    "insertText": "m_pLZ_code_buf(mz_uint8)(match_dist >> 8)"
  },
  {
    "label": "m_pLZ_flags()",
    "kind": "Method",
    "detail": "Function (d -> m_pLZ_code_buf + = 3 ;* d ->)",
    "insertText": "m_pLZ_flags(mz_uint8)((*d->m_pLZ_flags >> 1) | 0x80)"
  },
  {
    "label": "s_tdefl_large_dist_sym()",
    "kind": "Method",
    "detail": "Function (d -> m_num_flags_left = 8 ; d -> m_pLZ_flags = d -> m_pLZ_code_buf + + ; } s0 = s_tdefl_small_dist_sym [ match_dist& 5 1 1 ] ; s1 =)",
    "insertText": "s_tdefl_large_dist_sym(match_dist >> 8)"
  },
  {
    "label": "m_huff_count()",
    "kind": "Method",
    "detail": "Function (d ->)",
    "insertText": "m_huff_count(match_dist < 512)"
  },
  {
    "label": "tdefl_compress_normal()",
    "kind": "Method",
    "detail": "Function (} mz_bool)",
    "insertText": "tdefl_compress_normal(tdefl_compressor *d)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const mz_uint8* pSrc = d -> m_pSrc ; size_t src_buf_left = d -> m_src_buf_left ; tdefl_flush flush = d -> m_flush ;)",
    "insertText": "while((src_buf_left) || ((flush) && (d->m_lookahead_size)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mz_uint len_to_move,cur_match_dist,cur_match_len,cur_pos ;)",
    "insertText": "if((d->m_lookahead_size + d->m_dict_size) >= (TDEFL_MIN_MATCH_LEN - 1))"
  },
  {
    "label": "dst_pos()",
    "kind": "Method",
    "detail": "Function (m_lookahead_pos + d->m_lookahead_size - 2)",
    "insertText": "dst_pos(d->m_lookahead_pos + d->m_lookahead_size)"
  },
  {
    "label": "hash()",
    "kind": "Method",
    "detail": "Function (mz_uint)",
    "insertText": "hash(d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ d->m_dict[(ins_pos + 1)"
  },
  {
    "label": "num_bytes_to_process()",
    "kind": "Method",
    "detail": "Function (mz_uint)",
    "insertText": "num_bytes_to_process(mz_uint)MZ_MIN( src_buf_left, TDEFL_MAX_MATCH_LEN - d->m_lookahead_size)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const mz_uint8* pSrc_end = pSrc + num_bytes_to_process ; src_buf_left - = num_bytes_to_process ; d -> m_lookahead_size + = num_bytes_to_process ;)",
    "insertText": "while(pSrc != pSrc_end)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c)",
    "insertText": "if(dst_pos < (TDEFL_MAX_MATCH_LEN - 1))"
  },
  {
    "label": "hash()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "hash((hash << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1)"
  },
  {
    "label": "hash()",
    "kind": "Method",
    "detail": "Function (d -> m_next [ ins_pos& TDEFL_LZ_DICT_SIZE_MASK ] = d -> m_hash [ hash ] ; d -> m_hash [)",
    "insertText": "hash(mz_uint16)(ins_pos)"
  },
  {
    "label": "dst_pos()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dst_pos(dst_pos + 1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (ins_pos + + ; } } else {)",
    "insertText": "while((src_buf_left) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))"
  },
  {
    "label": "m_lookahead_pos()",
    "kind": "Method",
    "detail": "Function (mz_uint ins_pos = d ->)",
    "insertText": "m_lookahead_pos(d->m_lookahead_size - 1)"
  },
  {
    "label": "hash()",
    "kind": "Method",
    "detail": "Function (mz_uint)",
    "insertText": "hash((d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << (TDEFL_LZ_HASH_SHIFT * 2)) ^ (d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1)"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (} } } d -> m_dict_size =)",
    "insertText": "MZ_MIN(TDEFL_LZ_DICT_SIZE - d->m_lookahead_size, d->m_dict_size)"
  },
  {
    "label": "m_saved_match_len()",
    "kind": "Method",
    "detail": "Function (len_to_move = 1 ; cur_match_dist = 0 ; cur_match_len = d -> m_saved_match_len ? d ->)",
    "insertText": "m_saved_match_len(TDEFL_MIN_MATCH_LEN - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (cur_pos = d -> m_lookahead_pos& TDEFL_LZ_DICT_SIZE_MASK ;)",
    "insertText": "if(d->m_flags & (TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS))"
  },
  {
    "label": "m_dict()",
    "kind": "Method",
    "detail": "Function (mz_uint8 c = d ->)",
    "insertText": "m_dict(cur_pos - 1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (cur_match_len = 0 ;)",
    "insertText": "while(cur_match_len < d->m_lookahead_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (cur_match_len + + ; })",
    "insertText": "if(cur_match_len < TDEFL_MIN_MATCH_LEN)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U * 1024U)) || (cur_pos == cur_match_dist) || ((d->m_flags & TDEFL_FILTER_MATCHES) && (cur_match_len <= 5)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (cur_match_dist = cur_match_len = 0 ; })",
    "insertText": "if(d->m_saved_match_len)"
  },
  {
    "label": "tdefl_record_literal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tdefl_record_literal(d, (mz_uint8)d->m_saved_lit)"
  },
  {
    "label": "tdefl_record_match()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tdefl_record_match(d, cur_match_len, cur_match_dist)"
  },
  {
    "label": "tdefl_record_match()",
    "kind": "Method",
    "detail": "Function (d -> m_saved_match_len = 0 ; len_to_move = cur_match_len ; } else { d -> m_saved_lit = d -> m_dict [ cur_pos ] ; d -> m_saved_match_dist = cur_match_dist ; d -> m_saved_match_len = cur_match_len ; } } else {)",
    "insertText": "tdefl_record_match(d, d->m_saved_match_len, d->m_saved_match_dist)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (len_to_move = d -> m_saved_match_len - 1 ; d -> m_saved_match_len = 0 ; } } else)",
    "insertText": "if(!cur_match_dist) tdefl_record_literal(d, d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)])"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (len_to_move = cur_match_len ; } else { d -> m_saved_lit = d -> m_dict [)",
    "insertText": "MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)"
  },
  {
    "label": "MZ_ASSERT()",
    "kind": "Method",
    "detail": "Function (d -> m_saved_match_dist = cur_match_dist ; d -> m_saved_match_len = cur_match_len ; } d -> m_lookahead_pos + = len_to_move ;)",
    "insertText": "MZ_ASSERT(d->m_lookahead_size >= len_to_move)"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (d -> m_lookahead_size - = len_to_move ; d -> m_dict_size =)",
    "insertText": "MZ_MIN(d->m_dict_size + len_to_move, (mz_uint)TDEFL_LZ_DICT_SIZE)"
  },
  {
    "label": "tdefl_flush_output_buffer()",
    "kind": "Method",
    "detail": "Function (} } d -> m_pSrc = pSrc ; d -> m_src_buf_left = src_buf_left ; return MZ_TRUE ; } tdefl_status)",
    "insertText": "tdefl_flush_output_buffer(tdefl_compressor *d)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(d->m_pOut_buf_size)"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (size_t n =)",
    "insertText": "MZ_MIN(*d->m_pOut_buf_size - d->m_out_buf_ofs, d->m_output_flush_remaining)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf + d->m_output_flush_ofs, n)"
  },
  {
    "label": "m_output_flush_ofs()",
    "kind": "Method",
    "detail": "Function (d ->)",
    "insertText": "m_output_flush_ofs(mz_uint)"
  },
  {
    "label": "m_output_flush_remaining()",
    "kind": "Method",
    "detail": "Function (d ->)",
    "insertText": "m_output_flush_remaining(mz_uint)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (d -> m_out_buf_ofs + = n ;* d -> m_pOut_buf_size = d -> m_out_buf_ofs ; })",
    "insertText": "return(d->m_finished && !d->m_output_flush_remaining)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (d -> m_src_buf_left = pIn_buf_size ?* pIn_buf_size : 0 ; d -> m_out_buf_ofs = 0 ; d -> m_flush = flush ;)",
    "insertText": "if(((d->m_pPut_buf_func != NULL) == ((pOut_buf != NULL) || (pOut_buf_size != NULL))) || (d->m_prev_return_status != TDEFL_STATUS_OKAY) || (d->m_wants_to_finish && (flush != TDEFL_FINISH)) || (pIn_buf_size && *pIn_buf_size && !pIn_buf) || (pOut_buf_size && *pOut_buf_size && !pOut_buf))"
  },
  {
    "label": "m_wants_to_finish()",
    "kind": "Method",
    "detail": "Function (} d ->)",
    "insertText": "m_wants_to_finish(flush == TDEFL_FINISH)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if MINIZ_USE_UNALIGNED_LOADS_AND_STORES&& MINIZ_LITTLE_ENDIAN)",
    "insertText": "if(((d->m_flags & TDEFL_MAX_PROBES_MASK) == 1) && ((d->m_flags & TDEFL_GREEDY_PARSING_FLAG) != 0) && ((d->m_flags & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS | TDEFL_RLE_MATCHES)) == 0))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_prev_return_status)",
    "insertText": "if(!tdefl_compress_normal(d))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if((d->m_flags & (TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) && (pIn_buf)) d->m_adler32 = (mz_uint32)mz_adler32(d->m_adler32, (const mz_uint8 *)pIn_buf, d->m_pSrc - (const mz_uint8 *)pIn_buf)"
  },
  {
    "label": "m_finished()",
    "kind": "Method",
    "detail": "Function (d ->)",
    "insertText": "m_finished(flush == TDEFL_FINISH)"
  },
  {
    "label": "MZ_CLEAR_OBJ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_CLEAR_OBJ(d->m_hash)"
  },
  {
    "label": "MZ_CLEAR_OBJ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_CLEAR_OBJ(d->m_next)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (d -> m_dict_size = 0 ; } })",
    "insertText": "return(d->m_prev_return_status = tdefl_flush_output_buffer(d))"
  },
  {
    "label": "MZ_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_ASSERT(d->m_pPut_buf_func)"
  },
  {
    "label": "m_flags()",
    "kind": "Method",
    "detail": "Function (d -> m_pPut_buf_func = pPut_buf_func ; d -> m_pPut_buf_user = pPut_buf_user ; d ->)",
    "insertText": "m_flags(mz_uint)(flags)"
  },
  {
    "label": "m_max_probes()",
    "kind": "Method",
    "detail": "Function (d ->)",
    "insertText": "m_max_probes((flags & 0xFFF) + 2)"
  },
  {
    "label": "m_greedy_parsing()",
    "kind": "Method",
    "detail": "Function (d ->)",
    "insertText": "m_greedy_parsing(flags & TDEFL_GREEDY_PARSING_FLAG)"
  },
  {
    "label": "m_max_probes()",
    "kind": "Method",
    "detail": "Function (d ->)",
    "insertText": "m_max_probes(((flags & 0xFFF) >> 2) + 2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (tdefl_compressor* pComp ; mz_bool succeeded ;)",
    "insertText": "if(((buf_len) && (!pBuf)) || (!pPut_buf_func))"
  },
  {
    "label": "pComp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pComp(tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor))"
  },
  {
    "label": "succeeded()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "succeeded(tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) == TDEFL_STATUS_OKAY)"
  },
  {
    "label": "succeeded()",
    "kind": "Method",
    "detail": "Function (succeeded =)",
    "insertText": "succeeded(tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) == TDEFL_STATUS_DONE)"
  },
  {
    "label": "MZ_FREE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_FREE(pComp)"
  },
  {
    "label": "p()",
    "kind": "Method",
    "detail": "Function (tdefl_output_buffer*)",
    "insertText": "p(tdefl_output_buffer *)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t new_size = p -> m_size + len ;)",
    "insertText": "if(new_size > p->m_capacity)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t new_capacity = p -> m_capacity ; mz_uint8* pNew_buf ;)",
    "insertText": "if(!p->m_expandable)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(new_size > new_capacity)"
  },
  {
    "label": "pNew_buf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pNew_buf(mz_uint8 *)MZ_REALLOC(p->m_pBuf, new_capacity)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (p -> m_pBuf = pNew_buf ; p -> m_capacity = new_capacity ; })",
    "insertText": "memcpy((mz_uint8 *)p->m_pBuf + p->m_size, pBuf, len)"
  },
  {
    "label": "MZ_CLEAR_OBJ()",
    "kind": "Method",
    "detail": "Function (tdefl_output_buffer out_buf ;)",
    "insertText": "MZ_CLEAR_OBJ(out_buf)"
  },
  {
    "label": "m_pBuf()",
    "kind": "Method",
    "detail": "Function (out_buf .)",
    "insertText": "m_pBuf(mz_uint8 *)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (out_buf . m_capacity = out_buf_len ;)",
    "insertText": "if(!tdefl_compress_mem_to_output( pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))"
  },
  {
    "label": "s_tdefl_num_probes()",
    "kind": "Method",
    "detail": "Function (mz_uint comp_flags =)",
    "insertText": "s_tdefl_num_probes(level >= 0) ? MZ_MIN(10, level) : MZ_DEFAULT_LEVEL] | ((level <= 3) ? TDEFL_GREEDY_PARSING_FLAG : 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (tdefl_output_buffer out_buf ; int i,bpl = w* num_chans,y,z ; mz_uint32 c ;* pLen_out = 0 ;)",
    "insertText": "if(!pComp)"
  },
  {
    "label": "MZ_MAX()",
    "kind": "Method",
    "detail": "Function (out_buf . m_expandable = MZ_TRUE ; out_buf . m_capacity = 5 7 +)",
    "insertText": "MZ_MAX(64, (1 + bpl) * h)"
  },
  {
    "label": "tdefl_init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tdefl_init(pComp, tdefl_output_buffer_putter, &out_buf, s_tdefl_png_num_probes[MZ_MIN(10, level)] | TDEFL_WRITE_ZLIB_HEADER)"
  },
  {
    "label": "tdefl_compress_buffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH)"
  },
  {
    "label": "tdefl_compress_buffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tdefl_compress_buffer(pComp, (mz_uint8 *)pImage + (flip ? (h - 1 - y) : y) * bpl, bpl, TDEFL_NO_FLUSH)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) != TDEFL_STATUS_DONE)"
  },
  {
    "label": "MZ_FREE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_FREE(out_buf.m_pBuf)"
  },
  {
    "label": "c()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "c(mz_uint32)mz_crc32(MZ_CRC32_INIT, pnghdr + 12, 17)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(out_buf.m_pBuf, pnghdr, 41)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!tdefl_output_buffer_putter( \"\\0\\0\\0\\0\\0\\0\\0\\0\\x49\\x45\\x4e\\x44\\xae\\x42\\x60\\x82\", 16, &out_buf))"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # ifndef MINIZ_NO_ARCHIVE_APIS # error \" No arvhive APIs \" # ifdef MINIZ_NO_STDIO # define MZ_FILE void* # else # include<stdio . h> # include<sys / stat . h> # if)",
    "insertText": "defined(_MSC_VER) || defined(__MINGW64__) static FILE *mz_fopen(const char *pFilename, const char *pMode)"
  },
  {
    "label": "fopen_s()",
    "kind": "Method",
    "detail": "Function (FILE* pFile = NULL ;)",
    "insertText": "fopen_s(&pFile, pFilename, pMode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FILE* pFile = NULL ;)",
    "insertText": "if(freopen_s(&pFile, pPath, pMode, pStream))"
  },
  {
    "label": "MZ_ZIP_ARRAY_SET_ELEMENT_SIZE()",
    "kind": "Method",
    "detail": "Function (MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG = 0 x06054b50,MZ_ZIP_CENTRAL_DIR_HEADER_SIG = 0 x02014b50,MZ_ZIP_LOCAL_DIR_HEADER_SIG = 0 x04034b50,MZ_ZIP_LOCAL_DIR_HEADER_SIZE = 3 0,MZ_ZIP_CENTRAL_DIR_HEADER_SIZE = 4 6,MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE = 2 2,MZ_ZIP_CDH_SIG_OFS = 0,MZ_ZIP_CDH_VERSION_MADE_BY_OFS = 4,MZ_ZIP_CDH_VERSION_NEEDED_OFS = 6,MZ_ZIP_CDH_BIT_FLAG_OFS = 8,MZ_ZIP_CDH_METHOD_OFS = 1 0,MZ_ZIP_CDH_FILE_TIME_OFS = 1 2,MZ_ZIP_CDH_FILE_DATE_OFS = 1 4,MZ_ZIP_CDH_CRC32_OFS = 1 6,MZ_ZIP_CDH_COMPRESSED_SIZE_OFS = 2 0,MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS = 2 4,MZ_ZIP_CDH_FILENAME_LEN_OFS = 2 8,MZ_ZIP_CDH_EXTRA_LEN_OFS = 3 0,MZ_ZIP_CDH_COMMENT_LEN_OFS = 3 2,MZ_ZIP_CDH_DISK_START_OFS = 3 4,MZ_ZIP_CDH_INTERNAL_ATTR_OFS = 3 6,MZ_ZIP_CDH_EXTERNAL_ATTR_OFS = 3 8,MZ_ZIP_CDH_LOCAL_HEADER_OFS = 4 2,MZ_ZIP_LDH_SIG_OFS = 0,MZ_ZIP_LDH_VERSION_NEEDED_OFS = 4,MZ_ZIP_LDH_BIT_FLAG_OFS = 6,MZ_ZIP_LDH_METHOD_OFS = 8,MZ_ZIP_LDH_FILE_TIME_OFS = 1 0,MZ_ZIP_LDH_FILE_DATE_OFS = 1 2,MZ_ZIP_LDH_CRC32_OFS = 1 4,MZ_ZIP_LDH_COMPRESSED_SIZE_OFS = 1 8,MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS = 2 2,MZ_ZIP_LDH_FILENAME_LEN_OFS = 2 6,MZ_ZIP_LDH_EXTRA_LEN_OFS = 2 8,MZ_ZIP_ECDH_SIG_OFS = 0,MZ_ZIP_ECDH_NUM_THIS_DISK_OFS = 4,MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS = 6,MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 8,MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS = 1 0,MZ_ZIP_ECDH_CDIR_SIZE_OFS = 1 2,MZ_ZIP_ECDH_CDIR_OFS_OFS = 1 6,MZ_ZIP_ECDH_COMMENT_SIZE_OFS = 2 0,} ; typedef struct { void* m_p ; size_t m_size,m_capacity ; mz_uint m_element_size ; } mz_zip_array ; struct mz_zip_internal_state_tag { mz_zip_array m_central_dir ; mz_zip_array m_central_dir_offsets ; mz_zip_array m_sorted_central_dir_offsets ; MZ_FILE* m_pFile ; void* m_pMem ; size_t m_mem_size ; size_t m_mem_capacity ; } ; # define)",
    "insertText": "MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(array_ptr, element_size) \\ (array_ptr)->m_element_size = element_size #define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) \\ ((element_type *)((array_ptr)->m_p))[index] static MZ_FORCEINLINE void mz_zip_array_clear(mz_zip_archive *pZip, mz_zip_array *pArray)"
  },
  {
    "label": "m_pFree()",
    "kind": "Method",
    "detail": "Function (pZip ->)",
    "insertText": "m_pFree(pZip->m_pAlloc_opaque, pArray->m_p)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(pArray, 0, sizeof(mz_zip_array))"
  },
  {
    "label": "mz_zip_array_ensure_capacity()",
    "kind": "Method",
    "detail": "Function (} mz_bool)",
    "insertText": "mz_zip_array_ensure_capacity(mz_zip_archive *pZip, mz_zip_array *pArray, size_t min_new_capacity, mz_uint growing)"
  },
  {
    "label": "MZ_ASSERT()",
    "kind": "Method",
    "detail": "Function (void* pNew_p ; size_t new_capacity = min_new_capacity ;)",
    "insertText": "MZ_ASSERT(pArray->m_element_size)"
  },
  {
    "label": "MZ_MAX()",
    "kind": "Method",
    "detail": "Function (new_capacity =)",
    "insertText": "MZ_MAX(1, pArray->m_capacity)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(NULL == (pNew_p = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pArray->m_p, pArray->m_element_size, new_capacity)))"
  },
  {
    "label": "mz_zip_array_reserve()",
    "kind": "Method",
    "detail": "Function (pArray -> m_p = pNew_p ; pArray -> m_capacity = new_capacity ; return MZ_TRUE ; } MZ_FORCEINLINE mz_bool)",
    "insertText": "mz_zip_array_reserve(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_capacity, mz_uint growing)"
  },
  {
    "label": "mz_zip_array_resize()",
    "kind": "Method",
    "detail": "Function (} return MZ_TRUE ; } MZ_FORCEINLINE mz_bool)",
    "insertText": "mz_zip_array_resize(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_size, mz_uint growing)"
  },
  {
    "label": "mz_zip_array_ensure_room()",
    "kind": "Method",
    "detail": "Function (} pArray -> m_size = new_size ; return MZ_TRUE ; } MZ_FORCEINLINE mz_bool)",
    "insertText": "mz_zip_array_ensure_room(mz_zip_archive *pZip, mz_zip_array *pArray, size_t n)"
  },
  {
    "label": "mz_zip_array_push_back()",
    "kind": "Method",
    "detail": "Function (} MZ_FORCEINLINE mz_bool)",
    "insertText": "mz_zip_array_push_back(mz_zip_archive *pZip, mz_zip_array *pArray, const void *pElements, size_t n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t orig_size = pArray -> m_size ;)",
    "insertText": "if(!mz_zip_array_resize(pZip, pArray, orig_size + n, MZ_TRUE))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy((mz_uint8 *)pArray->m_p + orig_size * pArray->m_element_size, pElements, n * pArray->m_element_size)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (struct tm tm ;)",
    "insertText": "memset(&tm, 0, sizeof(tm))"
  },
  {
    "label": "tm_year()",
    "kind": "Method",
    "detail": "Function (tm . tm_isdst = - 1 ; tm .)",
    "insertText": "tm_year((dos_date >> 9) & 127)"
  },
  {
    "label": "tm_mon()",
    "kind": "Method",
    "detail": "Function (tm .)",
    "insertText": "tm_mon((dos_date >> 5) & 15)"
  },
  {
    "label": "tm_hour()",
    "kind": "Method",
    "detail": "Function (tm . tm_mday = dos_date& 3 1 ; tm .)",
    "insertText": "tm_hour(dos_time >> 11)"
  },
  {
    "label": "tm_min()",
    "kind": "Method",
    "detail": "Function (tm .)",
    "insertText": "tm_min(dos_time >> 5)"
  },
  {
    "label": "tm_sec()",
    "kind": "Method",
    "detail": "Function (tm .)",
    "insertText": "tm_sec(dos_time << 1)"
  },
  {
    "label": "mz_zip_time_to_dos_time()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "mz_zip_time_to_dos_time(time_t time, mz_uint16 *pDOS_time, mz_uint16 *pDOS_date)"
  },
  {
    "label": "localtime_s()",
    "kind": "Method",
    "detail": "Function (# ifdef _MSC_VER struct tm tm_struct ; struct tm* tm =& tm_struct ; errno_t err =)",
    "insertText": "localtime_s(tm, &time)"
  },
  {
    "label": "localtime()",
    "kind": "Method",
    "detail": "Function (* pDOS_date = 0 ;* pDOS_time = 0 ; return ; } # else struct tm* tm =)",
    "insertText": "localtime(&time)"
  },
  {
    "label": "pDOS_time()",
    "kind": "Method",
    "detail": "Function (# endif*)",
    "insertText": "pDOS_time(mz_uint16)(((tm->tm_hour) << 11) + ((tm->tm_min) << 5) + ((tm->tm_sec) >> 1))"
  },
  {
    "label": "pDOS_date()",
    "kind": "Method",
    "detail": "Function (*)",
    "insertText": "pDOS_date(mz_uint16)(((tm->tm_year + 1900 - 1980) << 9) + ((tm->tm_mon + 1) << 5) + tm->tm_mday)"
  },
  {
    "label": "mz_zip_get_file_modified_time()",
    "kind": "Method",
    "detail": "Function (} # endif # ifndef MINIZ_NO_STDIO mz_bool)",
    "insertText": "mz_zip_get_file_modified_time(const char *pFilename, mz_uint16 *pDOS_time, mz_uint16 *pDOS_date)"
  },
  {
    "label": "MINIZ_NO_TIME()",
    "kind": "Method",
    "detail": "Function (# ifdef)",
    "insertText": "MINIZ_NO_TIME(void)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* pDOS_date =* pDOS_time = 0 ; # else struct MZ_FILE_STAT_STRUCT file_stat ;)",
    "insertText": "if(MZ_FILE_STAT(pFilename, &file_stat) != 0)"
  },
  {
    "label": "mz_zip_time_to_dos_time()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mz_zip_time_to_dos_time(file_stat.st_mtime, pDOS_time, pDOS_date)"
  },
  {
    "label": "mz_zip_set_file_times()",
    "kind": "Method",
    "detail": "Function (# endif return MZ_TRUE ; } # ifndef MINIZ_NO_TIME mz_bool)",
    "insertText": "mz_zip_set_file_times(const char *pFilename, time_t access_time, time_t modified_time)"
  },
  {
    "label": "utime()",
    "kind": "Method",
    "detail": "Function (struct utimbuf t ; t . actime = access_time ; t . modtime = modified_time ; return !)",
    "insertText": "utime(pFilename, &t)"
  },
  {
    "label": "mz_zip_reader_init_internal()",
    "kind": "Method",
    "detail": "Function (} # endif # endif mz_bool)",
    "insertText": "mz_zip_reader_init_internal(mz_zip_archive *pZip, mz_uint32 flags)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pZip -> m_zip_mode = MZ_ZIP_MODE_READING ; pZip -> m_archive_size = 0 ; pZip -> m_central_directory_file_ofs = 0 ; pZip -> m_total_files = 0 ;)",
    "insertText": "if(NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc( pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state))"
  },
  {
    "label": "MZ_ZIP_ARRAY_SET_ELEMENT_SIZE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8))"
  },
  {
    "label": "MZ_ZIP_ARRAY_SET_ELEMENT_SIZE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32))"
  },
  {
    "label": "MZ_ZIP_ARRAY_SET_ELEMENT_SIZE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32))"
  },
  {
    "label": "MZ_ZIP_ARRAY_ELEMENT()",
    "kind": "Method",
    "detail": "Function (const mz_uint8* pL =&)",
    "insertText": "MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index))"
  },
  {
    "label": "MZ_ZIP_ARRAY_ELEMENT()",
    "kind": "Method",
    "detail": "Function (const mz_uint8* pR =&)",
    "insertText": "MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, r_index))"
  },
  {
    "label": "MZ_READ_LE16()",
    "kind": "Method",
    "detail": "Function (mz_uint l_len =)",
    "insertText": "MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS), r_len = MZ_READ_LE16(pR + MZ_ZIP_CDH_FILENAME_LEN_OFS)"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (mz_uint8 l = 0,r = 0 ; pL + = MZ_ZIP_CENTRAL_DIR_HEADER_SIZE ; pR + = MZ_ZIP_CENTRAL_DIR_HEADER_SIZE ; pE = pL +)",
    "insertText": "MZ_MIN(l_len, r_len)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (pL + + ; pR + + ; })",
    "insertText": "return(pL == pE) ? (l_len < r_len) : (l < r)"
  },
  {
    "label": "MZ_SWAP_UINT32()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "MZ_SWAP_UINT32(a, b)"
  },
  {
    "label": "mz_zip_reader_sort_central_dir_offsets_by_filename()",
    "kind": "Method",
    "detail": "Function (\\ mz_uint32 t = a ; \\ a = b ; \\ b = t ; \\ } \\ MZ_MACRO_END void)",
    "insertText": "mz_zip_reader_sort_central_dir_offsets_by_filename(mz_zip_archive *pZip)"
  },
  {
    "label": "MZ_ZIP_ARRAY_ELEMENT()",
    "kind": "Method",
    "detail": "Function (mz_zip_internal_state* pState = pZip -> m_pState ; const mz_zip_array* pCentral_dir_offsets =& pState -> m_central_dir_offsets ; const mz_zip_array* pCentral_dir =& pState -> m_central_dir ; mz_uint32* pIndices =&)",
    "insertText": "MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0)"
  },
  {
    "label": "start()",
    "kind": "Method",
    "detail": "Function (const int size = pZip -> m_total_files ; int)",
    "insertText": "start(size - 2)"
  },
  {
    "label": "child()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "child(((child + 1) < size) && (mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1])))"
  },
  {
    "label": "MZ_SWAP_UINT32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_SWAP_UINT32(pIndices[root], pIndices[child])"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (root = child ; } start - - ; } end = size - 1 ;)",
    "insertText": "while(end > 0)"
  },
  {
    "label": "MZ_SWAP_UINT32()",
    "kind": "Method",
    "detail": "Function (int child,root = 0 ;)",
    "insertText": "MZ_SWAP_UINT32(pIndices[end], pIndices[0])"
  },
  {
    "label": "child()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "child(((child + 1) < end) && mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1]))"
  },
  {
    "label": "mz_zip_reader_read_central_dir()",
    "kind": "Method",
    "detail": "Function (root = child ; } end - - ; } } mz_bool)",
    "insertText": "mz_zip_reader_read_central_dir(mz_zip_archive *pZip, mz_uint32 flags)"
  },
  {
    "label": "pBuf()",
    "kind": "Method",
    "detail": "Function (mz_uint8*)",
    "insertText": "pBuf(mz_uint8 *)"
  },
  {
    "label": "sort_central_dir()",
    "kind": "Method",
    "detail": "Function (mz_bool)",
    "insertText": "sort_central_dir((flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0)"
  },
  {
    "label": "MZ_MAX()",
    "kind": "Method",
    "detail": "Function (cur_file_ofs =)",
    "insertText": "MZ_MAX((mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32), 0)"
  },
  {
    "label": "n()",
    "kind": "Method",
    "detail": "Function (int i,)",
    "insertText": "n(int)MZ_MIN(sizeof(buf_u32), pZip->m_archive_size - cur_file_ofs)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (cur_file_ofs + = i ; break ; })",
    "insertText": "if((!cur_file_ofs) || ((pZip->m_archive_size - cur_file_ofs) >= (0xFFFF + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)))"
  },
  {
    "label": "MZ_MAX()",
    "kind": "Method",
    "detail": "Function (cur_file_ofs =)",
    "insertText": "MZ_MAX(cur_file_ofs - (sizeof(buf_u32) - 3), 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)"
  },
  {
    "label": "MZ_READ_LE16()",
    "kind": "Method",
    "detail": "Function (num_this_disk =)",
    "insertText": "MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_THIS_DISK_OFS)"
  },
  {
    "label": "MZ_READ_LE16()",
    "kind": "Method",
    "detail": "Function (cdir_disk_index =)",
    "insertText": "MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS)"
  },
  {
    "label": "MZ_READ_LE32()",
    "kind": "Method",
    "detail": "Function (cdir_ofs =)",
    "insertText": "MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pZip -> m_central_directory_file_ofs = cdir_ofs ;)",
    "insertText": "if(pZip->m_total_files)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mz_uint i,n ;)",
    "insertText": "if((!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir, cdir_size, MZ_FALSE)) || (!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir_offsets, pZip->m_total_files, MZ_FALSE)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs, pZip->m_pState->m_central_dir.m_p, cdir_size) != cdir_size)"
  },
  {
    "label": "p()",
    "kind": "Method",
    "detail": "Function (m_pState->m_central_dir.m_p)",
    "insertText": "p(const mz_uint8 *)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mz_uint total_header_size,comp_size,decomp_size,disk_index ;)",
    "insertText": "if((n < MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) || (MZ_READ_LE32(p) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG))"
  },
  {
    "label": "MZ_ZIP_ARRAY_ELEMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, i) = (mz_uint32)(p - (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p)"
  },
  {
    "label": "MZ_READ_LE32()",
    "kind": "Method",
    "detail": "Function (comp_size =)",
    "insertText": "MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS)"
  },
  {
    "label": "MZ_READ_LE32()",
    "kind": "Method",
    "detail": "Function (decomp_size =)",
    "insertText": "MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS)"
  },
  {
    "label": "MZ_READ_LE16()",
    "kind": "Method",
    "detail": "Function (disk_index =)",
    "insertText": "MZ_READ_LE16(p + MZ_ZIP_CDH_DISK_START_OFS)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (n - = total_header_size ; p + = total_header_size ; } })",
    "insertText": "if(sort_central_dir) mz_zip_reader_sort_central_dir_offsets_by_filename(pZip)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pZip -> m_archive_size = size ;)",
    "insertText": "if(!mz_zip_reader_read_central_dir(pZip, flags))"
  },
  {
    "label": "mz_zip_reader_end()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mz_zip_reader_end(pZip)"
  },
  {
    "label": "pZip()",
    "kind": "Method",
    "detail": "Function (mz_zip_archive*)",
    "insertText": "pZip(mz_zip_archive *)"
  },
  {
    "label": "s()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "s(file_ofs >= pZip->m_archive_size) ? 0 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (pZip -> m_archive_size = size ; pZip -> m_pRead = mz_zip_mem_read_func ; pZip -> m_pIO_opaque = pZip ; # ifdef __cplusplus pZip -> m_pState -> m_pMem = const_cast<)",
    "insertText": "void(pMem)"
  },
  {
    "label": "m_pMem()",
    "kind": "Method",
    "detail": "Function (# else pZip -> m_pState ->)",
    "insertText": "m_pMem(void *)"
  },
  {
    "label": "MZ_FTELL64()",
    "kind": "Method",
    "detail": "Function (mz_int64 cur_ofs =)",
    "insertText": "MZ_FTELL64(pZip->m_pState->m_pFile)"
  },
  {
    "label": "MZ_FOPEN()",
    "kind": "Method",
    "detail": "Function (mz_uint64 file_size ; MZ_FILE* pFile =)",
    "insertText": "MZ_FOPEN(pFilename, \"rb\")"
  },
  {
    "label": "MZ_FCLOSE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_FCLOSE(pFile)"
  },
  {
    "label": "mz_zip_reader_get_cdh()",
    "kind": "Method",
    "detail": "Function (mz_uint m_bit_flag ; const mz_uint8* p =)",
    "insertText": "mz_zip_reader_get_cdh(pZip, file_index)"
  },
  {
    "label": "MZ_READ_LE16()",
    "kind": "Method",
    "detail": "Function (m_bit_flag =)",
    "insertText": "MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS)"
  },
  {
    "label": "MZ_READ_LE16()",
    "kind": "Method",
    "detail": "Function (filename_len =)",
    "insertText": "MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS)"
  },
  {
    "label": "MZ_READ_LE32()",
    "kind": "Method",
    "detail": "Function (} external_attr =)",
    "insertText": "MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS)"
  },
  {
    "label": "MZ_ZIP_ARRAY_ELEMENT()",
    "kind": "Method",
    "detail": "Function (pStat -> m_file_index = file_index ; pStat -> m_central_dir_ofs =)",
    "insertText": "MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index)"
  },
  {
    "label": "MZ_READ_LE16()",
    "kind": "Method",
    "detail": "Function (pStat -> m_version_made_by =)",
    "insertText": "MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS)"
  },
  {
    "label": "MZ_READ_LE16()",
    "kind": "Method",
    "detail": "Function (pStat -> m_version_needed =)",
    "insertText": "MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_NEEDED_OFS)"
  },
  {
    "label": "MZ_READ_LE16()",
    "kind": "Method",
    "detail": "Function (pStat -> m_method =)",
    "insertText": "MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS)"
  },
  {
    "label": "mz_zip_dos_to_time_t()",
    "kind": "Method",
    "detail": "Function (# ifndef MINIZ_NO_TIME pStat -> m_time =)",
    "insertText": "mz_zip_dos_to_time_t(MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_TIME_OFS), MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_DATE_OFS))"
  },
  {
    "label": "MZ_READ_LE32()",
    "kind": "Method",
    "detail": "Function (# endif pStat -> m_crc32 =)",
    "insertText": "MZ_READ_LE32(p + MZ_ZIP_CDH_CRC32_OFS)"
  },
  {
    "label": "MZ_READ_LE16()",
    "kind": "Method",
    "detail": "Function (pStat -> m_internal_attr =)",
    "insertText": "MZ_READ_LE16(p + MZ_ZIP_CDH_INTERNAL_ATTR_OFS)"
  },
  {
    "label": "MZ_READ_LE32()",
    "kind": "Method",
    "detail": "Function (pStat -> m_local_header_ofs =)",
    "insertText": "MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS)"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (n =)",
    "insertText": "MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n)"
  },
  {
    "label": "MZ_READ_LE16()",
    "kind": "Method",
    "detail": "Function (pStat -> m_filename [ n ] = ' \\ 0 ' ; n =)",
    "insertText": "MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS)"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (n =)",
    "insertText": "MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (pStat -> m_comment_size = n ;)",
    "insertText": "memcpy(pStat->m_comment, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS), n)"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (n =)",
    "insertText": "MZ_MIN(n, filename_buf_size - 1)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(pFilename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n)"
  },
  {
    "label": "mz_zip_reader_string_equal()",
    "kind": "Method",
    "detail": "Function (pFilename [ n ] = ' \\ 0 ' ; } return n + 1 ; } MZ_FORCEINLINE mz_bool)",
    "insertText": "mz_zip_reader_string_equal(const char *pA, const char *pB, mz_uint len, mz_uint flags)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mz_uint i ;)",
    "insertText": "if(flags & MZ_ZIP_FLAG_CASE_SENSITIVE) return 0 == memcmp(pA, pB, len)"
  },
  {
    "label": "MZ_READ_LE16()",
    "kind": "Method",
    "detail": "Function (mz_uint l_len =)",
    "insertText": "MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (pL + + ; pR + + ; })",
    "insertText": "return(pL == pE) ? (int)(l_len - r_len) : (l - r)"
  },
  {
    "label": "mz_zip_reader_locate_file_binary_search()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "mz_zip_reader_locate_file_binary_search(mz_zip_archive *pZip, const char *pFilename)"
  },
  {
    "label": "filename_len()",
    "kind": "Method",
    "detail": "Function (const int size = pZip -> m_total_files ; const mz_uint)",
    "insertText": "filename_len(mz_uint)strlen(pFilename)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int l = 0,h = size - 1 ;)",
    "insertText": "while(l <= h)"
  },
  {
    "label": "m()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "m(l + h) >> 1, file_index = pIndices[m], comp = mz_zip_reader_filename_compare(pCentral_dir, pCentral_dir_offsets, file_index, pFilename, filename_len)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mz_uint file_index ; size_t name_len,comment_len ;)",
    "insertText": "if((!pZip) || (!pZip->m_pState) || (!pName) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))"
  },
  {
    "label": "strlen()",
    "kind": "Method",
    "detail": "Function (name_len =)",
    "insertText": "strlen(pName)"
  },
  {
    "label": "strlen()",
    "kind": "Method",
    "detail": "Function (comment_len = pComment ?)",
    "insertText": "strlen(pComment)"
  },
  {
    "label": "MZ_ZIP_ARRAY_ELEMENT()",
    "kind": "Method",
    "detail": "Function (const mz_uint8* pHeader =&)",
    "insertText": "MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index))"
  },
  {
    "label": "MZ_READ_LE16()",
    "kind": "Method",
    "detail": "Function (mz_uint filename_len =)",
    "insertText": "MZ_READ_LE16(pHeader + MZ_ZIP_CDH_FILENAME_LEN_OFS)"
  },
  {
    "label": "pFilename()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "pFilename(const char *)"
  },
  {
    "label": "MZ_READ_LE16()",
    "kind": "Method",
    "detail": "Function (mz_uint file_extra_len =)",
    "insertText": "MZ_READ_LE16(pHeader + MZ_ZIP_CDH_EXTRA_LEN_OFS), file_comment_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_COMMENT_LEN_OFS)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const char* pFile_comment = pFilename + filename_len + file_extra_len ;)",
    "insertText": "if((file_comment_len != comment_len) || (!mz_zip_reader_string_equal(pComment, pFile_comment, file_comment_len, flags)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if((flags & MZ_ZIP_FLAG_IGNORE_PATH) && (filename_len))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int ofs = filename_len - 1 ; do {)",
    "insertText": "if((pFilename[ofs] == '/') || (pFilename[ofs] == '\\\\') || (pFilename[ofs] == ':'))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(--ofs >= 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ofs + + ; pFilename + = ofs ; filename_len - = ofs ; })",
    "insertText": "if((filename_len == name_len) && (mz_zip_reader_string_equal(pName, pFilename, filename_len, flags)))"
  },
  {
    "label": "local_header_u32()",
    "kind": "Method",
    "detail": "Function (int status = TINFL_STATUS_DONE ; mz_uint64 needed_size,cur_file_ofs,comp_remaining,out_buf_ofs = 0,read_buf_size,read_buf_ofs = 0,read_buf_avail ; mz_zip_archive_file_stat file_stat ; void* pRead_buf ; mz_uint32)",
    "insertText": "local_header_u32(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)"
  },
  {
    "label": "pLocal_header()",
    "kind": "Method",
    "detail": "Function (mz_uint8*)",
    "insertText": "pLocal_header(mz_uint8 *)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (tinfl_decompressor inflator ;)",
    "insertText": "if((buf_size) && (!pBuf))"
  },
  {
    "label": "needed_size()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "needed_size(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (cur_file_ofs = file_stat . m_local_header_ofs ;)",
    "insertText": "if(pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)"
  },
  {
    "label": "MZ_READ_LE16()",
    "kind": "Method",
    "detail": "Function (cur_file_ofs + = MZ_ZIP_LOCAL_DIR_HEADER_SIZE +)",
    "insertText": "MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS)"
  },
  {
    "label": "tinfl_init()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "tinfl_init(&inflator)"
  },
  {
    "label": "pRead_buf()",
    "kind": "Method",
    "detail": "Function (m_pState->m_pMem + cur_file_ofs)",
    "insertText": "pRead_buf(mz_uint8 *)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (read_buf_size = read_buf_avail = file_stat . m_comp_size ; comp_remaining = 0 ; } else)",
    "insertText": "if(pUser_read_buf)"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (read_buf_size = user_read_buf_size ; read_buf_avail = 0 ; comp_remaining = file_stat . m_comp_size ; } else { read_buf_size =)",
    "insertText": "MZ_MIN(file_stat.m_comp_size, (mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef _MSC_VER)",
    "insertText": "if(((0, sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF)) #else if (((sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))"
  },
  {
    "label": "out_buf_size()",
    "kind": "Method",
    "detail": "Function (read_buf_avail = 0 ; comp_remaining = file_stat . m_comp_size ; } do { size_t in_buf_size,)",
    "insertText": "out_buf_size(size_t)(file_stat.m_uncomp_size - out_buf_ofs)"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (read_buf_avail =)",
    "insertText": "MZ_MIN(read_buf_size, comp_remaining)"
  },
  {
    "label": "in_buf_size()",
    "kind": "Method",
    "detail": "Function (status = TINFL_STATUS_FAILED ; break ; } cur_file_ofs + = read_buf_avail ; comp_remaining - = read_buf_avail ; read_buf_ofs = 0 ; })",
    "insertText": "in_buf_size(size_t)"
  },
  {
    "label": "tinfl_decompress()",
    "kind": "Method",
    "detail": "Function (status =)",
    "insertText": "tinfl_decompress(&inflator, (mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pBuf, (mz_uint8 *)pBuf + out_buf_ofs, &out_buf_size, TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF | (comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (read_buf_avail - = in_buf_size ; read_buf_ofs + = in_buf_size ; out_buf_ofs + = out_buf_size ; })",
    "insertText": "while(status == TINFL_STATUS_NEEDS_MORE_INPUT)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if((!pZip->m_pState->m_pMem) && (!pUser_read_buf)) pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf)"
  },
  {
    "label": "mz_zip_reader_locate_file()",
    "kind": "Method",
    "detail": "Function (int file_index =)",
    "insertText": "mz_zip_reader_locate_file(pZip, pFilename, NULL, flags)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (void* pBuf ;)",
    "insertText": "if(pSize)"
  },
  {
    "label": "alloc_size()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "alloc_size(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef _MSC_VER)",
    "insertText": "if(((0, sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF)) #else if (((sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))"
  },
  {
    "label": "m_pFree()",
    "kind": "Method",
    "detail": "Function (pZip ->)",
    "insertText": "m_pFree(pZip->m_pAlloc_opaque, pBuf)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (read_buf_avail = 0 ; comp_remaining = file_stat . m_comp_size ; })",
    "insertText": "if((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef _MSC_VER)",
    "insertText": "if(((0, sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > 0xFFFFFFFF)) #else if (((sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > 0xFFFFFFFF))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (cur_file_ofs + = file_stat . m_comp_size ; out_buf_ofs + = file_stat . m_comp_size ; comp_remaining = 0 ; } else {)",
    "insertText": "while(comp_remaining)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (status = TINFL_STATUS_FAILED ; break ; })",
    "insertText": "if(!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) file_crc32 = (mz_uint32)mz_crc32( file_crc32, (const mz_uint8 *)pRead_buf, (size_t)read_buf_avail)"
  },
  {
    "label": "TINFL_LZ_DICT_SIZE()",
    "kind": "Method",
    "detail": "Function (size_t in_buf_size,out_buf_size =)",
    "insertText": "TINFL_LZ_DICT_SIZE(out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1))"
  },
  {
    "label": "tinfl_decompress()",
    "kind": "Method",
    "detail": "Function (status =)",
    "insertText": "tinfl_decompress(&inflator, (const mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pWrite_buf, pWrite_buf_cur, &out_buf_size, comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (read_buf_avail - = in_buf_size ; read_buf_ofs + = in_buf_size ;)",
    "insertText": "if(out_buf_size)"
  },
  {
    "label": "file_crc32()",
    "kind": "Method",
    "detail": "Function (status = TINFL_STATUS_FAILED ; break ; })",
    "insertText": "file_crc32(mz_uint32)mz_crc32(file_crc32, pWrite_buf_cur, out_buf_size)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (status = TINFL_STATUS_FAILED ; break ; } } })",
    "insertText": "while((status == TINFL_STATUS_NEEDS_MORE_INPUT) || (status == TINFL_STATUS_HAS_MORE_OUTPUT))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if((status == TINFL_STATUS_DONE) && (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!pZip->m_pState->m_pMem) pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf)"
  },
  {
    "label": "mz_zip_file_write_callback()",
    "kind": "Method",
    "detail": "Function (} # ifndef MINIZ_NO_STDIO size_t)",
    "insertText": "mz_zip_file_write_callback(void *pOpaque, mz_uint64 ofs, const void *pBuf, size_t n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mz_bool status ; mz_zip_archive_file_stat file_stat ; MZ_FILE* pFile ;)",
    "insertText": "if(!mz_zip_reader_file_stat(pZip, file_index, &file_stat))"
  },
  {
    "label": "MZ_FOPEN()",
    "kind": "Method",
    "detail": "Function (pFile =)",
    "insertText": "MZ_FOPEN(pDst_filename, \"wb\")"
  },
  {
    "label": "mz_zip_reader_extract_to_callback()",
    "kind": "Method",
    "detail": "Function (status =)",
    "insertText": "mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifndef MINIZ_NO_TIME)",
    "insertText": "if(status) mz_zip_set_file_times(pDst_filename, file_stat.m_time, file_stat.m_time)"
  },
  {
    "label": "mz_zip_array_clear()",
    "kind": "Method",
    "detail": "Function (mz_zip_internal_state* pState = pZip -> m_pState ; pZip -> m_pState = NULL ;)",
    "insertText": "mz_zip_array_clear(pZip, &pState->m_central_dir)"
  },
  {
    "label": "mz_zip_array_clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mz_zip_array_clear(pZip, &pState->m_central_dir_offsets)"
  },
  {
    "label": "mz_zip_array_clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifndef MINIZ_NO_STDIO)",
    "insertText": "if(pState->m_pFile)"
  },
  {
    "label": "MZ_FCLOSE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_FCLOSE(pState->m_pFile)"
  },
  {
    "label": "m_pFree()",
    "kind": "Method",
    "detail": "Function (pState -> m_pFile = NULL ; } # endif pZip ->)",
    "insertText": "m_pFree(pZip->m_pAlloc_opaque, pState)"
  },
  {
    "label": "mz_zip_reader_locate_file()",
    "kind": "Method",
    "detail": "Function (int file_index =)",
    "insertText": "mz_zip_reader_locate_file(pZip, pArchive_filename, NULL, flags)"
  },
  {
    "label": "mz_write_le16()",
    "kind": "Method",
    "detail": "Function (} # endif # ifndef MINIZ_NO_ARCHIVE_WRITING_APIS void)",
    "insertText": "mz_write_le16(mz_uint8 *p, mz_uint16 v)"
  },
  {
    "label": "p()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "p(mz_uint8)"
  },
  {
    "label": "p()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "p(mz_uint8)(v >> 8)"
  },
  {
    "label": "mz_write_le32()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "mz_write_le32(mz_uint8 *p, mz_uint32 v)"
  },
  {
    "label": "p()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "p(mz_uint8)(v >> 16)"
  },
  {
    "label": "p()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "p(mz_uint8)(v >> 24)"
  },
  {
    "label": "MZ_WRITE_LE16()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "MZ_WRITE_LE16(p, v) mz_write_le16((mz_uint8 *)(p), (mz_uint16)(v)) #define MZ_WRITE_LE32(p, v) mz_write_le32((mz_uint8 *)(p), (mz_uint32)(v)) mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_pAlloc = def_alloc_func)",
    "insertText": "if(!pZip->m_pAlloc)"
  },
  {
    "label": "MZ_MAX()",
    "kind": "Method",
    "detail": "Function (mz_zip_internal_state* pState = pZip -> m_pState ; mz_uint64 new_size =)",
    "insertText": "MZ_MAX(file_ofs + n, pState->m_mem_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef _MSC_VER)",
    "insertText": "if((!n) || ((0, sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF))) #else if ((!n) || ((sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))"
  },
  {
    "label": "MZ_MAX()",
    "kind": "Method",
    "detail": "Function (void* pNew_block ; size_t new_capacity =)",
    "insertText": "MZ_MAX(64, pState->m_mem_capacity)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (pState -> m_pMem = pNew_block ; pState -> m_mem_capacity = new_capacity ; })",
    "insertText": "memcpy((mz_uint8 *)pState->m_pMem + file_ofs, pBuf, n)"
  },
  {
    "label": "m_mem_size()",
    "kind": "Method",
    "detail": "Function (pState ->)",
    "insertText": "m_mem_size(size_t)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pZip -> m_pWrite = mz_zip_heap_write_func ; pZip -> m_pIO_opaque = pZip ;)",
    "insertText": "if(!mz_zip_writer_init(pZip, size_to_reserve_at_beginning))"
  },
  {
    "label": "mz_zip_writer_end()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mz_zip_writer_end(pZip)"
  },
  {
    "label": "MZ_CLEAR_OBJ()",
    "kind": "Method",
    "detail": "Function (mz_uint64 cur_ofs = 0 ; char buf [ 4 0 9 6 ] ;)",
    "insertText": "MZ_CLEAR_OBJ(buf)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mz_zip_internal_state* pState ;)",
    "insertText": "if((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef MINIZ_NO_STDIO pFilename ; return MZ_FALSE ; # else)",
    "insertText": "if(pZip->m_pIO_opaque != pZip)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pZip -> m_pWrite = mz_zip_file_write_func ;)",
    "insertText": "if(NULL == (pState->m_pFile = MZ_FREOPEN(pFilename, \"r+b\", pState->m_pFile)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pState -> m_mem_capacity = pState -> m_mem_size ; pZip -> m_pWrite = mz_zip_heap_write_func ; } else)",
    "insertText": "if(!pZip->m_pWrite)"
  },
  {
    "label": "mz_zip_writer_add_put_buf_callback()",
    "kind": "Method",
    "detail": "Function (} typedef struct { mz_zip_archive* m_pZip ; mz_uint64 m_cur_archive_file_ofs ; mz_uint64 m_comp_size ; } mz_zip_writer_add_state ; mz_bool)",
    "insertText": "mz_zip_writer_add_put_buf_callback(const void *pBuf, int len, void *pUser)"
  },
  {
    "label": "pState()",
    "kind": "Method",
    "detail": "Function (mz_zip_writer_add_state*)",
    "insertText": "pState(mz_zip_writer_add_state *)"
  },
  {
    "label": "mz_zip_writer_create_local_dir_header()",
    "kind": "Method",
    "detail": "Function (pState -> m_cur_archive_file_ofs + = len ; pState -> m_comp_size + = len ; return MZ_TRUE ; } mz_bool)",
    "insertText": "mz_zip_writer_create_local_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size, mz_uint16 extra_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(pDst, 0, MZ_ZIP_LOCAL_DIR_HEADER_SIZE)"
  },
  {
    "label": "MZ_WRITE_LE32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_SIG_OFS, MZ_ZIP_LOCAL_DIR_HEADER_SIG)"
  },
  {
    "label": "MZ_WRITE_LE16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_VERSION_NEEDED_OFS, method ? 20 : 0)"
  },
  {
    "label": "MZ_WRITE_LE16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_BIT_FLAG_OFS, bit_flags)"
  },
  {
    "label": "MZ_WRITE_LE16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_METHOD_OFS, method)"
  },
  {
    "label": "MZ_WRITE_LE16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_TIME_OFS, dos_time)"
  },
  {
    "label": "MZ_WRITE_LE16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_DATE_OFS, dos_date)"
  },
  {
    "label": "MZ_WRITE_LE32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_CRC32_OFS, uncomp_crc32)"
  },
  {
    "label": "MZ_WRITE_LE32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS, comp_size)"
  },
  {
    "label": "MZ_WRITE_LE32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS, uncomp_size)"
  },
  {
    "label": "MZ_WRITE_LE16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILENAME_LEN_OFS, filename_size)"
  },
  {
    "label": "MZ_WRITE_LE16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_EXTRA_LEN_OFS, extra_size)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(pDst, 0, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)"
  },
  {
    "label": "MZ_WRITE_LE32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_SIG_OFS, MZ_ZIP_CENTRAL_DIR_HEADER_SIG)"
  },
  {
    "label": "MZ_WRITE_LE16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_VERSION_NEEDED_OFS, method ? 20 : 0)"
  },
  {
    "label": "MZ_WRITE_LE16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_BIT_FLAG_OFS, bit_flags)"
  },
  {
    "label": "MZ_WRITE_LE16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_METHOD_OFS, method)"
  },
  {
    "label": "MZ_WRITE_LE16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_TIME_OFS, dos_time)"
  },
  {
    "label": "MZ_WRITE_LE16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_DATE_OFS, dos_date)"
  },
  {
    "label": "MZ_WRITE_LE32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_CRC32_OFS, uncomp_crc32)"
  },
  {
    "label": "MZ_WRITE_LE32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, comp_size)"
  },
  {
    "label": "MZ_WRITE_LE32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, uncomp_size)"
  },
  {
    "label": "MZ_WRITE_LE16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILENAME_LEN_OFS, filename_size)"
  },
  {
    "label": "MZ_WRITE_LE16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_EXTRA_LEN_OFS, extra_size)"
  },
  {
    "label": "MZ_WRITE_LE16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_COMMENT_LEN_OFS, comment_size)"
  },
  {
    "label": "MZ_WRITE_LE32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS, ext_attributes)"
  },
  {
    "label": "MZ_WRITE_LE32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_header_ofs)"
  },
  {
    "label": "central_dir_ofs()",
    "kind": "Method",
    "detail": "Function (m_central_dir.m_size)",
    "insertText": "central_dir_ofs(mz_uint32)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t orig_central_dir_size = pState -> m_central_dir . m_size ; mz_uint8 central_dir_header [ MZ_ZIP_CENTRAL_DIR_HEADER_SIZE ] ;)",
    "insertText": "if((local_header_ofs > 0xFFFFFFFF) || (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + extra_size + comment_size) > 0xFFFFFFFF))"
  },
  {
    "label": "mz_zip_array_resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE)"
  },
  {
    "label": "mz_zip_writer_compute_padding_needed_for_file_alignment()",
    "kind": "Method",
    "detail": "Function (pArchive_name + + ; } return MZ_TRUE ; } mz_uint)",
    "insertText": "mz_zip_writer_compute_padding_needed_for_file_alignment(mz_zip_archive *pZip)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mz_uint32 n ;)",
    "insertText": "if(!pZip->m_file_offset_alignment)"
  },
  {
    "label": "n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "n(mz_uint32)(pZip->m_archive_size & (pZip->m_file_offset_alignment - 1))"
  },
  {
    "label": "mz_zip_writer_write_zeros()",
    "kind": "Method",
    "detail": "Function (} mz_bool)",
    "insertText": "mz_zip_writer_write_zeros(mz_zip_archive *pZip, mz_uint64 cur_file_ofs, mz_uint32 n)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (char buf [ 4 0 9 6 ] ;)",
    "insertText": "memset(buf, 0, MZ_MIN(sizeof(buf), n))"
  },
  {
    "label": "MZ_MIN()",
    "kind": "Method",
    "detail": "Function (mz_uint32 s =)",
    "insertText": "MZ_MIN(sizeof(buf), n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mz_uint16 method = 0,dos_time = 0,dos_date = 0 ; mz_uint level,ext_attributes = 0,num_alignment_padding_bytes ; mz_uint64 local_dir_header_ofs = pZip -> m_archive_size,cur_archive_file_ofs = pZip -> m_archive_size,comp_size = 0 ; size_t archive_name_size ; mz_uint8 local_dir_header [ MZ_ZIP_LOCAL_DIR_HEADER_SIZE ] ; tdefl_compressor* pComp = NULL ; mz_bool store_data_uncompressed ; mz_zip_internal_state* pState ;)",
    "insertText": "if((int)level_and_flags < 0)"
  },
  {
    "label": "store_data_uncompressed()",
    "kind": "Method",
    "detail": "Function (level = level_and_flags& 0 xF ;)",
    "insertText": "store_data_uncompressed((!level) || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pState = pZip -> m_pState ;)",
    "insertText": "if((!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (uncomp_size))"
  },
  {
    "label": "time()",
    "kind": "Method",
    "detail": "Function (# ifndef MINIZ_NO_TIME { time_t cur_time ;)",
    "insertText": "time(&cur_time)"
  },
  {
    "label": "mz_zip_time_to_dos_time()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mz_zip_time_to_dos_time(cur_time, &dos_time, &dos_date)"
  },
  {
    "label": "strlen()",
    "kind": "Method",
    "detail": "Function (} # endif archive_name_size =)",
    "insertText": "strlen(pArchive_name)"
  },
  {
    "label": "mz_zip_writer_compute_padding_needed_for_file_alignment()",
    "kind": "Method",
    "detail": "Function (num_alignment_padding_bytes =)",
    "insertText": "mz_zip_writer_compute_padding_needed_for_file_alignment(pZip)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ext_attributes | = 0 x10 ;)",
    "insertText": "if((buf_size) || (uncomp_size))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if((!mz_zip_array_ensure_room( pZip, &pState->m_central_dir, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size)) || (!mz_zip_array_ensure_room(pZip, &pState->m_central_dir_offsets, 1)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!mz_zip_writer_write_zeros( pZip, cur_archive_file_ofs, num_alignment_padding_bytes + sizeof(local_dir_header)))"
  },
  {
    "label": "m_pFree()",
    "kind": "Method",
    "detail": "Function (pZip ->)",
    "insertText": "m_pFree(pZip->m_pAlloc_opaque, pComp)"
  },
  {
    "label": "MZ_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} cur_archive_file_ofs + = num_alignment_padding_bytes +)",
    "insertText": "sizeof(local_dir_header)"
  },
  {
    "label": "MZ_CLEAR_OBJ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_CLEAR_OBJ(local_dir_header)"
  },
  {
    "label": "uncomp_crc32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uncomp_crc32(mz_uint32)mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, buf_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uncomp_size = buf_size ;)",
    "insertText": "if(uncomp_size <= 3)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (level = 0 ; store_data_uncompressed = MZ_TRUE ; } })",
    "insertText": "if(store_data_uncompressed)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(buf_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mz_zip_writer_add_state state ; state . m_pZip = pZip ; state . m_cur_archive_file_ofs = cur_archive_file_ofs ; state . m_comp_size = 0 ;)",
    "insertText": "if((tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params( level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY) || (tdefl_compress_buffer(pComp, pBuf, buf_size, TDEFL_FINISH) != TDEFL_STATUS_DONE))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pComp = NULL ;)",
    "insertText": "if((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (level = level_and_flags& 0 xF ;)",
    "insertText": "if((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))"
  },
  {
    "label": "MZ_FOPEN()",
    "kind": "Method",
    "detail": "Function (pSrc_file =)",
    "insertText": "MZ_FOPEN(pSrc_filename, \"rb\")"
  },
  {
    "label": "MZ_FSEEK64()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_FSEEK64(pSrc_file, 0, SEEK_END)"
  },
  {
    "label": "MZ_FTELL64()",
    "kind": "Method",
    "detail": "Function (uncomp_size =)",
    "insertText": "MZ_FTELL64(pSrc_file)"
  },
  {
    "label": "MZ_FSEEK64()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_FSEEK64(pSrc_file, 0, SEEK_SET)"
  },
  {
    "label": "MZ_FCLOSE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_FCLOSE(pSrc_file)"
  },
  {
    "label": "m_pAlloc()",
    "kind": "Method",
    "detail": "Function (mz_uint64 uncomp_remaining = uncomp_size ; void* pRead_buf = pZip ->)",
    "insertText": "m_pAlloc(pZip->m_pAlloc_opaque, 1, MZ_ZIP_MAX_IO_BUF_SIZE)"
  },
  {
    "label": "n()",
    "kind": "Method",
    "detail": "Function (mz_uint)",
    "insertText": "n(mz_uint)MZ_MIN((mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE, uncomp_remaining)"
  },
  {
    "label": "m_pFree()",
    "kind": "Method",
    "detail": "Function (pZip ->)",
    "insertText": "m_pFree(pZip->m_pAlloc_opaque, pRead_buf)"
  },
  {
    "label": "pComp()",
    "kind": "Method",
    "detail": "Function (uncomp_remaining - = n ; cur_archive_file_ofs + = n ; } comp_size = uncomp_size ; } else { mz_bool result = MZ_FALSE ; mz_zip_writer_add_state state ; tdefl_compressor*)",
    "insertText": "pComp(tdefl_compressor *)pZip->m_pAlloc( pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor))"
  },
  {
    "label": "in_buf_size()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "in_buf_size(mz_uint32)MZ_MIN(uncomp_remaining, (mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (tdefl_status status ;)",
    "insertText": "if(MZ_FREAD(pRead_buf, 1, in_buf_size, pSrc_file) != in_buf_size)"
  },
  {
    "label": "uncomp_crc32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uncomp_crc32(mz_uint32)mz_crc32( uncomp_crc32, (const mz_uint8 *)pRead_buf, in_buf_size)"
  },
  {
    "label": "tdefl_compress_buffer()",
    "kind": "Method",
    "detail": "Function (uncomp_remaining - = in_buf_size ; status =)",
    "insertText": "tdefl_compress_buffer(pComp, pRead_buf, in_buf_size, uncomp_remaining ? TDEFL_NO_FLUSH : TDEFL_FINISH)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (result = MZ_TRUE ; break ; } else)",
    "insertText": "if(status != TDEFL_STATUS_OKAY)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mz_uint8 central_header [ MZ_ZIP_CENTRAL_DIR_HEADER_SIZE ] ; size_t orig_central_dir_size ; mz_zip_internal_state* pState ; void* pBuf ; const mz_uint8* pSrc_central_header ;)",
    "insertText": "if((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))"
  },
  {
    "label": "MZ_READ_LE32()",
    "kind": "Method",
    "detail": "Function (cur_src_file_ofs =)",
    "insertText": "MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (cur_dst_file_ofs = pZip -> m_archive_size ;)",
    "insertText": "if(pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (cur_src_file_ofs + = MZ_ZIP_LOCAL_DIR_HEADER_SIZE ;)",
    "insertText": "if(!mz_zip_writer_write_zeros(pZip, cur_dst_file_ofs, num_alignment_padding_bytes))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (cur_dst_file_ofs + = num_alignment_padding_bytes ; local_dir_header_ofs = cur_dst_file_ofs ;)",
    "insertText": "if(pZip->m_file_offset_alignment)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)"
  },
  {
    "label": "MZ_READ_LE32()",
    "kind": "Method",
    "detail": "Function (comp_bytes_remaining = n +)",
    "insertText": "MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS)"
  },
  {
    "label": "n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "n(mz_uint)MZ_MIN((mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE, comp_bytes_remaining)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (orig_central_dir_size = pState -> m_central_dir . m_size ;)",
    "insertText": "memcpy(central_header, pSrc_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)"
  },
  {
    "label": "MZ_WRITE_LE32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE32(central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_dir_header_ofs)"
  },
  {
    "label": "MZ_READ_LE16()",
    "kind": "Method",
    "detail": "Function (n =)",
    "insertText": "MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS) + MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_COMMENT_LEN_OFS)"
  },
  {
    "label": "n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "n(mz_uint32)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pState = pZip -> m_pState ;)",
    "insertText": "if((pZip->m_total_files > 0xFFFF) || ((pZip->m_archive_size + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (central_dir_ofs = pZip -> m_archive_size ; central_dir_size = pState -> m_central_dir . m_size ; pZip -> m_central_directory_file_ofs = central_dir_ofs ;)",
    "insertText": "if(pZip->m_pWrite(pZip->m_pIO_opaque, central_dir_ofs, pState->m_central_dir.m_p, (size_t)central_dir_size) != central_dir_size)"
  },
  {
    "label": "MZ_CLEAR_OBJ()",
    "kind": "Method",
    "detail": "Function (pZip -> m_archive_size + = central_dir_size ; })",
    "insertText": "MZ_CLEAR_OBJ(hdr)"
  },
  {
    "label": "MZ_WRITE_LE32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_SIG_OFS, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG)"
  },
  {
    "label": "MZ_WRITE_LE16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, pZip->m_total_files)"
  },
  {
    "label": "MZ_WRITE_LE16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS, pZip->m_total_files)"
  },
  {
    "label": "MZ_WRITE_LE32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_SIZE_OFS, central_dir_size)"
  },
  {
    "label": "MZ_WRITE_LE32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_OFS_OFS, central_dir_ofs)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifndef MINIZ_NO_STDIO)",
    "insertText": "if((pState->m_pFile) && (MZ_FFLUSH(pState->m_pFile) == EOF))"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (# endif pZip -> m_archive_size + =)",
    "insertText": "sizeof(hdr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mz_zip_internal_state* pState ; mz_bool status = MZ_TRUE ;)",
    "insertText": "if((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || ((pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) && (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pState -> m_pFile = NULL ; } # endif)",
    "insertText": "if((pZip->m_pWrite == mz_zip_heap_write_func) && (pState->m_pMem))"
  },
  {
    "label": "m_pFree()",
    "kind": "Method",
    "detail": "Function (pZip ->)",
    "insertText": "m_pFree(pZip->m_pAlloc_opaque, pState->m_pMem)"
  },
  {
    "label": "MZ_CLEAR_OBJ()",
    "kind": "Method",
    "detail": "Function (mz_bool status,created_new_archive = MZ_FALSE ; mz_zip_archive zip_archive ; struct MZ_FILE_STAT_STRUCT file_stat ;)",
    "insertText": "MZ_CLEAR_OBJ(zip_archive)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (created_new_archive = MZ_TRUE ; } else {)",
    "insertText": "if(!mz_zip_reader_init_file( &zip_archive, pZip_filename, level_and_flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY))"
  },
  {
    "label": "mz_zip_reader_end()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mz_zip_reader_end(&zip_archive)"
  },
  {
    "label": "MZ_DELETE_FILE()",
    "kind": "Method",
    "detail": "Function (int ignoredStatus =)",
    "insertText": "MZ_DELETE_FILE(pZip_filename)"
  },
  {
    "label": "mz_zip_extract_archive_file_to_heap()",
    "kind": "Method",
    "detail": "Function (} return status ; } void*)",
    "insertText": "mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint flags)"
  },
  {
    "label": "_WIN32()",
    "kind": "Method",
    "detail": "Function (# ifdef)",
    "insertText": "_WIN32(*err) = _strdup(msg.c_str())"
  },
  {
    "label": "else()",
    "kind": "Method",
    "detail": "Function (#)",
    "insertText": "else(*err) = strdup(msg.c_str())"
  },
  {
    "label": "cpy2()",
    "kind": "Method",
    "detail": "Function (# endif } } const int kEXRVersionSize = 8 ; void)",
    "insertText": "cpy2(unsigned short *dst_val, const unsigned short *src_val)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (unsigned char* dst = reinterpret_cast<unsigned)",
    "insertText": "char(dst_val)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (const unsigned char* src = reinterpret_cast<const unsigned)",
    "insertText": "char(src_val)"
  },
  {
    "label": "swap2()",
    "kind": "Method",
    "detail": "Function (dst [ 0 ] = src [ 0 ] ; dst [ 1 ] = src [ 1 ] ; } void)",
    "insertText": "swap2(unsigned short *val)"
  },
  {
    "label": "MINIZ_LITTLE_ENDIAN()",
    "kind": "Method",
    "detail": "Function (# ifdef)",
    "insertText": "MINIZ_LITTLE_ENDIAN(void)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (# else unsigned short tmp =* val ; unsigned char* dst = reinterpret_cast<unsigned)",
    "insertText": "char(val)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (unsigned char* src = reinterpret_cast<unsigned)",
    "insertText": "char(&tmp)"
  },
  {
    "label": "cpy4()",
    "kind": "Method",
    "detail": "Function (dst [ 0 ] = src [ 1 ] ; dst [ 1 ] = src [ 0 ] ; # endif } # ifdef __clang__ # pragma clang diagnostic push # pragma clang diagnostic ignored \" - Wunused - function \" # endif # ifdef __GNUC__ # pragma GCC diagnostic push # pragma GCC diagnostic ignored \" - Wunused - function \" # endif void)",
    "insertText": "cpy4(int *dst_val, const int *src_val)"
  },
  {
    "label": "cpy4()",
    "kind": "Method",
    "detail": "Function (dst [ 0 ] = src [ 0 ] ; dst [ 1 ] = src [ 1 ] ; dst [ 2 ] = src [ 2 ] ; dst [ 3 ] = src [ 3 ] ; } void)",
    "insertText": "cpy4(unsigned int *dst_val, const unsigned int *src_val)"
  },
  {
    "label": "cpy4()",
    "kind": "Method",
    "detail": "Function (dst [ 0 ] = src [ 0 ] ; dst [ 1 ] = src [ 1 ] ; dst [ 2 ] = src [ 2 ] ; dst [ 3 ] = src [ 3 ] ; } void)",
    "insertText": "cpy4(float *dst_val, const float *src_val)"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (dst [ 0 ] = src [ 0 ] ; dst [ 1 ] = src [ 1 ] ; dst [ 2 ] = src [ 2 ] ; dst [ 3 ] = src [ 3 ] ; } # ifdef __clang__ # pragma clang diagnostic pop # endif # ifdef __GNUC__ # pragma GCC diagnostic pop # endif void)",
    "insertText": "swap4(unsigned int *val)"
  },
  {
    "label": "cpy8()",
    "kind": "Method",
    "detail": "Function (dst [ 0 ] = src [ 3 ] ; dst [ 1 ] = src [ 2 ] ; dst [ 2 ] = src [ 1 ] ; dst [ 3 ] = src [ 0 ] ; # endif } # if 0 void)",
    "insertText": "cpy8(tinyexr::tinyexr_uint64 *dst_val, const tinyexr::tinyexr_uint64 *src_val)"
  },
  {
    "label": "swap8()",
    "kind": "Method",
    "detail": "Function (dst [ 0 ] = src [ 0 ] ; dst [ 1 ] = src [ 1 ] ; dst [ 2 ] = src [ 2 ] ; dst [ 3 ] = src [ 3 ] ; dst [ 4 ] = src [ 4 ] ; dst [ 5 ] = src [ 5 ] ; dst [ 6 ] = src [ 6 ] ; dst [ 7 ] = src [ 7 ] ; } # endif void)",
    "insertText": "swap8(tinyexr::tinyexr_uint64 *val)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (# else tinyexr::tinyexr_uint64)",
    "insertText": "tmp(*val)"
  },
  {
    "label": "half_to_float()",
    "kind": "Method",
    "detail": "Function (dst [ 0 ] = src [ 7 ] ; dst [ 1 ] = src [ 6 ] ; dst [ 2 ] = src [ 5 ] ; dst [ 3 ] = src [ 4 ] ; dst [ 4 ] = src [ 3 ] ; dst [ 5 ] = src [ 2 ] ; dst [ 6 ] = src [ 1 ] ; dst [ 7 ] = src [ 0 ] ; # endif } union FP32 { unsigned int u ; float f ; struct { # if MINIZ_LITTLE_ENDIAN unsigned int Mantissa : 2 3 ; unsigned int Exponent : 8 ; unsigned int Sign : 1 ; # else unsigned int Sign : 1 ; unsigned int Exponent : 8 ; unsigned int Mantissa : 2 3 ; # endif } s ; } ; # ifdef __clang__ # pragma clang diagnostic push # pragma clang diagnostic ignored \" - Wpadded \" # endif union FP16 { unsigned short u ; struct { # if MINIZ_LITTLE_ENDIAN unsigned int Mantissa : 1 0 ; unsigned int Exponent : 5 ; unsigned int Sign : 1 ; # else unsigned int Sign : 1 ; unsigned int Exponent : 5 ; unsigned int Mantissa : 1 0 ; # endif } s ; } ; # ifdef __clang__ # pragma clang diagnostic pop # endif FP32)",
    "insertText": "half_to_float(FP16 h)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (const FP32 magic = { 1 1 3<<2 3 } ; const unsigned int shifted_exp = 0 x7c00<<1 3 ; FP32 o ; o .)",
    "insertText": "u(h.u & 0x7fffU)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (unsigned int exp_ = shifted_exp& o . u ; o .)",
    "insertText": "u(127 - 15)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (o . u + = 1<<2 3 ; o . f - = magic . f ; } o .)",
    "insertText": "u(h.u & 0x8000U)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FP16 o = { 0 } ;)",
    "insertText": "if(f.s.Exponent == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (o . s . Exponent = 3 1 ; o . s . Mantissa = f . s . Mantissa ? 0 x200 : 0 ; } else { int newexp = f . s . Exponent - 1 2 7 + 1 5 ;)",
    "insertText": "if(newexp >= 31)"
  },
  {
    "label": "mant()",
    "kind": "Method",
    "detail": "Function (unsigned int mant = f . s . Mantissa | 0 x800000 ; o . s . Mantissa =)",
    "insertText": "mant(14 - newexp)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} } else { o . s . Exponent = static_cast<unsigned)",
    "insertText": "int(newexp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (o . s . Mantissa = f . s . Mantissa>> 1 3 ;)",
    "insertText": "if(f.s.Mantissa & 0x1000)"
  },
  {
    "label": "__has_warning()",
    "kind": "Method",
    "detail": "Function (} } o . s . Sign = f . s . Sign ; return o ; } # ifdef __clang__ # pragma clang diagnostic push # if)",
    "insertText": "__has_warning(\"-Wzero-as-null-pointer-constant\") #pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\" #endif #endif static const char *ReadString(std::string *s, const char *ptr, size_t len)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const char* p = ptr ; const char* q = ptr ;)",
    "insertText": "while((size_t(q - ptr) < len) && (*q) != 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (q + + ; })",
    "insertText": "if(size_t(q - ptr) >= len)"
  },
  {
    "label": "strnlen()",
    "kind": "Method",
    "detail": "Function (size_t name_len =)",
    "insertText": "strnlen(marker, size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (marker + = type_len + 1 ; size - = type_len + 1 ;)",
    "insertText": "if(size < sizeof(uint32_t))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&data_len))"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (marker + =)",
    "insertText": "sizeof(uint32_t)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (data ->)",
    "insertText": "resize(1)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&data->at(0), marker, static_cast<size_t>(data_len))"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (out ->)",
    "insertText": "insert(out->end(), name, name + strlen(name) + 1)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (out ->)",
    "insertText": "insert(out->end(), type, type + strlen(type) + 1)"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (int outLen = len ;)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&outLen))"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (out ->)",
    "insertText": "insert(out->end(), reinterpret_cast<unsigned char *>(&outLen), reinterpret_cast<unsigned char *>(&outLen) + sizeof(int))"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (out ->)",
    "insertText": "insert(out->end(), data, data + len)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} struct ChannelInfo { std::string name ; int pixel_type ; int x_sampling ; int y_sampling ; unsigned char p_linear ; unsigned char pad [ 3 ] ; } ; struct HeaderInfo { std::vector<tinyexr::ChannelInfo> channels ; std::vector<EXRAttribute> attributes ; int data_window [ 4 ] ; int line_order ; int display_window [ 4 ] ; float screen_window_center [ 2 ] ; float screen_window_width ; float pixel_aspect_ratio ; int chunk_count ; int tile_size_x ; int tile_size_y ; int tile_level_mode ; int tile_rounding_mode ; unsigned int header_len ; int compression_type ; void)",
    "insertText": "clear()"
  },
  {
    "label": "ReadChannelInfo()",
    "kind": "Method",
    "detail": "Function (data_window [ 0 ] = 0 ; data_window [ 1 ] = 0 ; data_window [ 2 ] = 0 ; data_window [ 3 ] = 0 ; line_order = 0 ; display_window [ 0 ] = 0 ; display_window [ 1 ] = 0 ; display_window [ 2 ] = 0 ; display_window [ 3 ] = 0 ; screen_window_center [ 0 ] = 0 . 0 f ; screen_window_center [ 1 ] = 0 . 0 f ; screen_window_width = 0 . 0 f ; pixel_aspect_ratio = 0 . 0 f ; chunk_count = 0 ; tile_size_x = 0 ; tile_size_y = 0 ; tile_level_mode = 0 ; tile_rounding_mode = 0 ; header_len = 0 ; compression_type = 0 ; } } ; bool)",
    "insertText": "ReadChannelInfo(std::vector<ChannelInfo> &channels, const std::vector<unsigned char> &data)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (const char* p = reinterpret_cast<const)",
    "insertText": "char(&data.at(0))"
  },
  {
    "label": "tinyexr_int64()",
    "kind": "Method",
    "detail": "Function (break ; } ChannelInfo info ; tinyexr_int64 data_len = static_cast<)",
    "insertText": "tinyexr_int64(data.size()) - (p - reinterpret_cast<const char *>(data.data()))"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (p + = 4 ; info . p_linear = static_cast<unsigned)",
    "insertText": "char(p[0])"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (p + = 1 + 3 ;)",
    "insertText": "memcpy(&info.x_sampling, p, sizeof(int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (p + = 4 ;)",
    "insertText": "memcpy(&info.y_sampling, p, sizeof(int))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (p + = 4 ;)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&info.pixel_type))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&info.x_sampling))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&info.y_sampling))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (channels .)",
    "insertText": "push_back(info)"
  },
  {
    "label": "WriteChannelInfo()",
    "kind": "Method",
    "detail": "Function (} return true ; } void)",
    "insertText": "WriteChannelInfo(std::vector<unsigned char> &data, const std::vector<ChannelInfo> &channels)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t sz = 0 ;)",
    "insertText": "for(size_t c = 0; c < channels.size(); c++)"
  },
  {
    "label": "strlen()",
    "kind": "Method",
    "detail": "Function (sz + =)",
    "insertText": "strlen(channels[c].name.c_str())"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (sz + = 1 6 ; } data .)",
    "insertText": "resize(sz + 1)"
  },
  {
    "label": "at()",
    "kind": "Method",
    "detail": "Function (unsigned char* p =& data .)",
    "insertText": "at(0)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(p, channels[c].name.c_str(), strlen(channels[c].name.c_str()))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (p + + ; int pixel_type = channels [ c ] . pixel_type ; int x_sampling = channels [ c ] . x_sampling ; int y_sampling = channels [ c ] . y_sampling ;)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&pixel_type))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&x_sampling))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&y_sampling))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(p, &pixel_type, sizeof(int))"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (p + =)",
    "insertText": "sizeof(int)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (p + = 4 ;)",
    "insertText": "memcpy(p, &x_sampling, sizeof(int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(p, &y_sampling, sizeof(int))"
  },
  {
    "label": "CompressZip()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CompressZip(unsigned char *dst, tinyexr::tinyexr_uint64 &compressedSize, const unsigned char *src, unsigned long src_size)"
  },
  {
    "label": "tmpBuf()",
    "kind": "Method",
    "detail": "Function (std::vector<unsigned char>)",
    "insertText": "tmpBuf(src_size)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (const char* srcPtr = reinterpret_cast<const)",
    "insertText": "char(src)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function ({ char* t1 = reinterpret_cast<)",
    "insertText": "char(&tmpBuf.at(0))"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (char* t2 = reinterpret_cast<)",
    "insertText": "char(&tmpBuf.at(0)) + (src_size + 1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int p = t [ - 1 ] ;)",
    "insertText": "while(t < stop)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (int d =)",
    "insertText": "int(t[0]) - p + (128 + 256)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (p = t [ 0 ] ; t [ 0 ] = static_cast<unsigned)",
    "insertText": "char(d)"
  },
  {
    "label": "mz_compressBound()",
    "kind": "Method",
    "detail": "Function (+ + t ; } } # if TINYEXR_USE_MINIZ miniz::mz_ulong outSize =)",
    "insertText": "mz_compressBound(src_size)"
  },
  {
    "label": "mz_compress()",
    "kind": "Method",
    "detail": "Function (int ret =)",
    "insertText": "mz_compress(dst, &outSize, static_cast<const unsigned char *>(&tmpBuf.at(0)), src_size)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT(ret == miniz::MZ_OK)"
  },
  {
    "label": "compressBound()",
    "kind": "Method",
    "detail": "Function (compressedSize = outSize ; # else uLong outSize =)",
    "insertText": "compressBound(static_cast<uLong>(src_size))"
  },
  {
    "label": "compress()",
    "kind": "Method",
    "detail": "Function (int ret =)",
    "insertText": "compress(dst, &outSize, static_cast<const Bytef *>(&tmpBuf.at(0)), src_size)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT(ret == Z_OK)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (compressedSize = outSize ; # endif)",
    "insertText": "if(compressedSize >= src_size)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (compressedSize = src_size ;)",
    "insertText": "memcpy(dst, src, src_size)"
  },
  {
    "label": "DecompressZip()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "DecompressZip(unsigned char *dst, unsigned long *uncompressed_size , const unsigned char *src, unsigned long src_size)"
  },
  {
    "label": "mz_uncompress()",
    "kind": "Method",
    "detail": "Function (# if TINYEXR_USE_MINIZ int ret =)",
    "insertText": "mz_uncompress(&tmpBuf.at(0), uncompressed_size, src, src_size)"
  },
  {
    "label": "at()",
    "kind": "Method",
    "detail": "Function (unsigned char* stop =& tmpBuf .)",
    "insertText": "at(0) + (*uncompressed_size)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (int d =)",
    "insertText": "int(t[-1]) + int(t[0])"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (const char* t2 = reinterpret_cast<const)",
    "insertText": "char(&tmpBuf.at(0)) + (*uncompressed_size + 1)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (char* s = reinterpret_cast<)",
    "insertText": "char(dst)"
  },
  {
    "label": "s()",
    "kind": "Method",
    "detail": "Function (char* stop =)",
    "insertText": "s(*uncompressed_size)"
  },
  {
    "label": "rleCompress()",
    "kind": "Method",
    "detail": "Function (const int MAX_RUN_LENGTH = 1 2 7 ; int)",
    "insertText": "rleCompress(int inLength, const char in[], signed char out[])"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const char* inEnd = in + inLength ; const char* runStart = in ; const char* runEnd = in + 1 ; signed char* outWrite = out ;)",
    "insertText": "while(runStart < inEnd)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + runEnd ; })",
    "insertText": "if(runEnd - runStart >= MIN_RUN_LENGTH)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (* outWrite + + = static_cast<)",
    "insertText": "char(runEnd - runStart)"
  },
  {
    "label": "outWrite()",
    "kind": "Method",
    "detail": "Function (*)",
    "insertText": "outWrite(reinterpret_cast<const signed char *>(runStart))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (runStart = runEnd ; } else {)",
    "insertText": "while(runEnd < inEnd && ((runEnd + 1 >= inEnd || *runEnd != *(runEnd + 1)) || (runEnd + 2 >= inEnd || *(runEnd + 1) != *(runEnd + 2))) && runEnd - runStart < MAX_RUN_LENGTH)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (+ + runEnd ; }* outWrite + + = static_cast<)",
    "insertText": "char(runStart - runEnd)"
  },
  {
    "label": "outWrite()",
    "kind": "Method",
    "detail": "Function (*)",
    "insertText": "outWrite(reinterpret_cast<const signed char *>(runStart++))"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} } + + runEnd ; } return static_cast<)",
    "insertText": "int(outWrite - out)"
  },
  {
    "label": "rleUncompress()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "rleUncompress(int inLength, int maxLength, const signed char in[], char out[])"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (char* outStart = out ;)",
    "insertText": "while(inLength > 0)"
  },
  {
    "label": "count()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "count(static_cast<int>(*in++))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (inLength - = count + 1 ;)",
    "insertText": "if((0 > (maxLength -= count)) || (inLength < 0))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(out, in, count)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (out + = count ; in + = count ; } else { int count =* in + + ; inLength - = 2 ;)",
    "insertText": "if(0 > (maxLength -= count + 1))"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(out, *reinterpret_cast<const char *>(in), count + 1)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (out + = count + 1 ; in + + ; } } return static_cast<)",
    "insertText": "int(out - outStart)"
  },
  {
    "label": "CompressRle()",
    "kind": "Method",
    "detail": "Function (} # ifdef __clang__ # pragma clang diagnostic pop # endif void)",
    "insertText": "CompressRle(unsigned char *dst, tinyexr::tinyexr_uint64 &compressedSize, const unsigned char *src, unsigned long src_size)"
  },
  {
    "label": "rleCompress()",
    "kind": "Method",
    "detail": "Function (+ + t ; } } int outSize =)",
    "insertText": "rleCompress(static_cast<int>(src_size), reinterpret_cast<const char *>(&tmpBuf.at(0)), reinterpret_cast<signed char *>(dst))"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT(outSize > 0)"
  },
  {
    "label": "tinyexr_uint64()",
    "kind": "Method",
    "detail": "Function (compressedSize = static_cast<)",
    "insertText": "tinyexr_uint64(outSize)"
  },
  {
    "label": "DecompressRle()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "DecompressRle(unsigned char *dst, const unsigned long uncompressed_size, const unsigned char *src, unsigned long src_size)"
  },
  {
    "label": "rleUncompress()",
    "kind": "Method",
    "detail": "Function (int ret =)",
    "insertText": "rleUncompress(static_cast<int>(src_size), static_cast<int>(uncompressed_size), reinterpret_cast<const signed char *>(src), reinterpret_cast<char *>(&tmpBuf.at(0)))"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (const char* t2 = reinterpret_cast<const)",
    "insertText": "char(&tmpBuf.at(0)) + (uncompressed_size + 1)"
  },
  {
    "label": "wenc14()",
    "kind": "Method",
    "detail": "Function (unsigned short* start ; unsigned short* end ; int nx ; int ny ; int ys ; int size ; } ; void)",
    "insertText": "wenc14(unsigned short a, unsigned short b, unsigned short &l, unsigned short &h)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (short as = static_cast<)",
    "insertText": "short(a)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (short bs = static_cast<)",
    "insertText": "short(b)"
  },
  {
    "label": "ms()",
    "kind": "Method",
    "detail": "Function (short)",
    "insertText": "ms(as + bs)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (short ds = as - bs ; l = static_cast<unsigned)",
    "insertText": "short(ms)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (h = static_cast<unsigned)",
    "insertText": "short(ds)"
  },
  {
    "label": "wdec14()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "wdec14(unsigned short l, unsigned short h, unsigned short &a, unsigned short &b)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (short ls = static_cast<)",
    "insertText": "short(l)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (short hs = static_cast<)",
    "insertText": "short(h)"
  },
  {
    "label": "ls()",
    "kind": "Method",
    "detail": "Function (int hi = hs ; int ai =)",
    "insertText": "ls(hi & 1) + (hi >> 1)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (short as = static_cast<)",
    "insertText": "short(ai)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (short bs = static_cast<)",
    "insertText": "short(ai - hi)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (a = static_cast<unsigned)",
    "insertText": "short(as)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (b = static_cast<unsigned)",
    "insertText": "short(bs)"
  },
  {
    "label": "A_OFFSET()",
    "kind": "Method",
    "detail": "Function (} const int NBITS = 1 6 ; const int)",
    "insertText": "A_OFFSET(NBITS - 1)"
  },
  {
    "label": "M_OFFSET()",
    "kind": "Method",
    "detail": "Function (const int)",
    "insertText": "M_OFFSET(NBITS - 1)"
  },
  {
    "label": "MOD_MASK()",
    "kind": "Method",
    "detail": "Function (const int)",
    "insertText": "MOD_MASK(1 << NBITS)"
  },
  {
    "label": "wenc16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wenc16(unsigned short a, unsigned short b, unsigned short &l, unsigned short &h)"
  },
  {
    "label": "ao()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "ao(a + A_OFFSET)"
  },
  {
    "label": "m()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "m((ao + b) >> 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int d = ao - b ;)",
    "insertText": "if(d < 0) m = (m + M_OFFSET)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (d& = MOD_MASK ; l = static_cast<unsigned)",
    "insertText": "short(m)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (h = static_cast<unsigned)",
    "insertText": "short(d)"
  },
  {
    "label": "wdec16()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "wdec16(unsigned short l, unsigned short h, unsigned short &a, unsigned short &b)"
  },
  {
    "label": "bb()",
    "kind": "Method",
    "detail": "Function (int m = l ; int d = h ; int)",
    "insertText": "bb(m - (d >> 1))"
  },
  {
    "label": "aa()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "aa(d + bb - A_OFFSET)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (b = static_cast<unsigned)",
    "insertText": "short(bb)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (a = static_cast<unsigned)",
    "insertText": "short(aa)"
  },
  {
    "label": "wav2Encode()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "wav2Encode(unsigned short *in, int nx, int ox, int ny, int oy, unsigned short mx)"
  },
  {
    "label": "w14()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "w14(mx < (1 << 14))"
  },
  {
    "label": "n()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "n(nx > ny)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int p = 1 ; int p2 = 2 ;)",
    "insertText": "while(p2 <= n)"
  },
  {
    "label": "oy()",
    "kind": "Method",
    "detail": "Function (unsigned short* py = in ; unsigned short* ey = in +)",
    "insertText": "oy(ny - p2)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int oy1 = oy* p ; int oy2 = oy* p2 ; int ox1 = ox* p ; int ox2 = ox* p2 ; unsigned short i00,i01,i10,i11 ;)",
    "insertText": "for(; py <= ey; py += oy2)"
  },
  {
    "label": "ox()",
    "kind": "Method",
    "detail": "Function (unsigned short* px = py ; unsigned short* ex = py +)",
    "insertText": "ox(nx - p2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unsigned short* p01 = px + ox1 ; unsigned short* p10 = px + oy1 ; unsigned short* p11 = p10 + ox1 ;)",
    "insertText": "if(w14)"
  },
  {
    "label": "wenc14()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wenc14(*px, *p01, i00, i01)"
  },
  {
    "label": "wenc14()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wenc14(*p10, *p11, i10, i11)"
  },
  {
    "label": "wenc14()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wenc14(i00, i10, *px, *p10)"
  },
  {
    "label": "wenc14()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wenc14(i01, i11, *p01, *p11)"
  },
  {
    "label": "wenc16()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "wenc16(*px, *p01, i00, i01)"
  },
  {
    "label": "wenc16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wenc16(*p10, *p11, i10, i11)"
  },
  {
    "label": "wenc16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wenc16(i00, i10, *px, *p10)"
  },
  {
    "label": "wenc16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wenc16(i01, i11, *p01, *p11)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(nx & p)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unsigned short* p10 = px + oy1 ;)",
    "insertText": "if(w14) wenc14(*px, *p10, i00, *p10)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* px = i00 ; } })",
    "insertText": "if(ny & p)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unsigned short* p01 = px + ox1 ;)",
    "insertText": "if(w14) wenc14(*px, *p01, i00, *p01)"
  },
  {
    "label": "wav2Decode()",
    "kind": "Method",
    "detail": "Function (* px = i00 ; } } p = p2 ; p2<<= 1 ; } } void)",
    "insertText": "wav2Decode(unsigned short *in, int nx, int ox, int ny, int oy, unsigned short mx)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int p = 1 ; int p2 ;)",
    "insertText": "while(p <= n)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (p>> = 1 ; p2 = p ; p>> = 1 ;)",
    "insertText": "while(p >= 1)"
  },
  {
    "label": "wdec14()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wdec14(*px, *p10, i00, i10)"
  },
  {
    "label": "wdec14()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wdec14(*p01, *p11, i01, i11)"
  },
  {
    "label": "wdec14()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wdec14(i00, i01, *px, *p01)"
  },
  {
    "label": "wdec14()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wdec14(i10, i11, *p10, *p11)"
  },
  {
    "label": "wdec16()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "wdec16(*px, *p10, i00, i10)"
  },
  {
    "label": "wdec16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wdec16(*p01, *p11, i01, i11)"
  },
  {
    "label": "wdec16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wdec16(i00, i01, *px, *p01)"
  },
  {
    "label": "wdec16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wdec16(i10, i11, *p10, *p11)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unsigned short* p10 = px + oy1 ;)",
    "insertText": "if(w14) wdec14(*px, *p10, i00, *p10)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unsigned short* p01 = px + ox1 ;)",
    "insertText": "if(w14) wdec14(*px, *p01, i00, *p01)"
  },
  {
    "label": "HUF_ENCSIZE()",
    "kind": "Method",
    "detail": "Function (* px = i00 ; } } p2 = p ; p>> = 1 ; } } const int HUF_ENCBITS = 1 6 ; const int HUF_DECBITS = 1 4 ; const int)",
    "insertText": "HUF_ENCSIZE(1 << HUF_ENCBITS)"
  },
  {
    "label": "hufLength()",
    "kind": "Method",
    "detail": "Function (const int HUF_DECSIZE = 1<<HUF_DECBITS ; const int HUF_DECMASK = HUF_DECSIZE - 1 ; struct HufDec { int len : 8 ; int lit : 2 4 ; int* p ; } ; long long)",
    "insertText": "hufLength(long long code)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (c<<= nBits ; lc + = nBits ; c | = bits ;)",
    "insertText": "while(lc >= 8) *out++ = static_cast<char>((c >> (lc -= 8)))"
  },
  {
    "label": "getBits()",
    "kind": "Method",
    "detail": "Function (} long long)",
    "insertText": "getBits(int nBits, long long &c, int &lc, const char *&in)"
  },
  {
    "label": "c()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "c(c << 8) | *(reinterpret_cast<const unsigned char *>(in++))"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (lc + = 8 ; } lc - = nBits ;)",
    "insertText": "return(c >> lc) & ((1 << nBits) - 1)"
  },
  {
    "label": "hufCanonicalCodeTable()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "hufCanonicalCodeTable(long long hcode[HUF_ENCSIZE])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (long long n [ 5 9 ] ;)",
    "insertText": "for(int i = 0; i <= 58; ++i)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (long long c = 0 ;)",
    "insertText": "for(int i = 58; i > 0; --i)"
  },
  {
    "label": "nc()",
    "kind": "Method",
    "detail": "Function (long long)",
    "insertText": "nc((c + n[i]) >> 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (n [ i ] = c ; c = nc ; })",
    "insertText": "for(int i = 0; i < HUF_ENCSIZE; ++i)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (int l = static_cast<)",
    "insertText": "int(hcode[i])"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } struct FHeapCompare { bool)",
    "insertText": "operator()(long long *a, long long *b)"
  },
  {
    "label": "hlink()",
    "kind": "Method",
    "detail": "Function (std::vector<int>)",
    "insertText": "hlink(HUF_ENCSIZE)"
  },
  {
    "label": "fHeap()",
    "kind": "Method",
    "detail": "Function (std::vector<long long*>)",
    "insertText": "fHeap(HUF_ENCSIZE)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (* im = 0 ;)",
    "insertText": "while(!frq[*im]) (*im)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int nf = 0 ;)",
    "insertText": "for(int i = *im; i < HUF_ENCSIZE; i++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (hlink [ i ] = i ;)",
    "insertText": "if(frq[i])"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (fHeap [ nf ] =& frq [ i ] ; nf + + ;* iM =)",
    "insertText": "i(*iM)"
  },
  {
    "label": "make_heap()",
    "kind": "Method",
    "detail": "Function (frq [* iM ] = 1 ; fHeap [ nf ] =& frq [* iM ] ; nf + + ;)",
    "insertText": "make_heap(&fHeap[0], &fHeap[nf], FHeapCompare())"
  },
  {
    "label": "scode()",
    "kind": "Method",
    "detail": "Function (std::vector<long long>)",
    "insertText": "scode(HUF_ENCSIZE)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(scode.data(), 0, sizeof(long long) * HUF_ENCSIZE)"
  },
  {
    "label": "pop_heap()",
    "kind": "Method",
    "detail": "Function (int mm = fHeap [ 0 ] - frq ;)",
    "insertText": "pop_heap(&fHeap[0], &fHeap[nf], FHeapCompare())"
  },
  {
    "label": "push_heap()",
    "kind": "Method",
    "detail": "Function (frq [ m ] + = frq [ mm ] ;)",
    "insertText": "push_heap(&fHeap[0], &fHeap[nf], FHeapCompare())"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (scode [ j ] + + ;)",
    "insertText": "TEXR_ASSERT(scode[j] <= 58)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (hlink [ j ] = mm ; break ; } })",
    "insertText": "for(int j = mm;; j = hlink[j])"
  },
  {
    "label": "hufCanonicalCodeTable()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "hufCanonicalCodeTable(scode.data())"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(frq, scode.data(), sizeof(long long) * HUF_ENCSIZE)"
  },
  {
    "label": "hufPackEncTable()",
    "kind": "Method",
    "detail": "Function (} const int SHORT_ZEROCODE_RUN = 5 9 ; const int LONG_ZEROCODE_RUN = 6 3 ; const int SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN ; const int LONGEST_LONG_RUN = 2 5 5 + SHORTEST_LONG_RUN ; void)",
    "insertText": "hufPackEncTable(const long long *hcode, int im, int iM, char **pcode)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (char* p =* pcode ; long long c = 0 ; int lc = 0 ;)",
    "insertText": "for(; im <= iM; im++)"
  },
  {
    "label": "hufLength()",
    "kind": "Method",
    "detail": "Function (int l =)",
    "insertText": "hufLength(hcode[im])"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int zerun = 1 ;)",
    "insertText": "while((im < iM) && (zerun < LONGEST_LONG_RUN))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (im + + ; zerun + + ; })",
    "insertText": "if(zerun >= 2)"
  },
  {
    "label": "outputBits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "outputBits(6, LONG_ZEROCODE_RUN, c, lc, p)"
  },
  {
    "label": "outputBits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "outputBits(8, zerun - SHORTEST_LONG_RUN, c, lc, p)"
  },
  {
    "label": "outputBits()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "outputBits(6, SHORT_ZEROCODE_RUN + zerun - 2, c, lc, p)"
  },
  {
    "label": "outputBits()",
    "kind": "Method",
    "detail": "Function (} continue ; } })",
    "insertText": "outputBits(6, l, c, lc, p)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(lc > 0) *p++ = (unsigned char)(c << (8 - lc))"
  },
  {
    "label": "hufUnpackEncTable()",
    "kind": "Method",
    "detail": "Function (* pcode = p ; } bool)",
    "insertText": "hufUnpackEncTable(const char **pcode, int ni, int im, int iM, long long *hcode)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(hcode, 0, sizeof(long long) * HUF_ENCSIZE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (im - - ; } else)",
    "insertText": "if(l >= (long long)SHORT_ZEROCODE_RUN)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int zerun = l - SHORT_ZEROCODE_RUN + 2 ;)",
    "insertText": "if(im + zerun > iM + 1)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (im - - ; } }* pcode = const_cast<)",
    "insertText": "char(p)"
  },
  {
    "label": "hufCanonicalCodeTable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "hufCanonicalCodeTable(hcode)"
  },
  {
    "label": "hufBuildDecTable()",
    "kind": "Method",
    "detail": "Function (hdecod [ i ] . len = 0 ; hdecod [ i ] . lit = 0 ; hdecod [ i ] . p = NULL ; } } bool)",
    "insertText": "hufBuildDecTable(const long long *hcode, int im, int iM, HufDec *hdecod)"
  },
  {
    "label": "hufCode()",
    "kind": "Method",
    "detail": "Function (long long c =)",
    "insertText": "hufCode(hcode[im])"
  },
  {
    "label": "hdecod()",
    "kind": "Method",
    "detail": "Function (HufDec* pl =)",
    "insertText": "hdecod(c >> (l - HUF_DECBITS))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (p[i] = p[i])",
    "insertText": "for(int i = 0; i < pl->lit - 1; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (delete [ ] p ; } else { pl -> p = new int [ 1 ] ; } pl -> p [ pl -> lit - 1 ] = im ; } else)",
    "insertText": "if(l)"
  },
  {
    "label": "hdecod()",
    "kind": "Method",
    "detail": "Function (HufDec* pl =)",
    "insertText": "hdecod(c << (HUF_DECBITS - l))"
  },
  {
    "label": "outputCode()",
    "kind": "Method",
    "detail": "Function (delete [ ] hdecod [ i ] . p ; hdecod [ i ] . p = 0 ; } } } void)",
    "insertText": "outputCode(long long code, long long &c, int &lc, char *&out)"
  },
  {
    "label": "outputBits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "outputBits(hufLength(code), hufCode(code), c, lc, out)"
  },
  {
    "label": "sendCode()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "sendCode(long long sCode, int runCount, long long runCode, long long &c, int &lc, char *&out)"
  },
  {
    "label": "outputCode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "outputCode(sCode, c, lc, out)"
  },
  {
    "label": "outputCode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "outputCode(runCode, c, lc, out)"
  },
  {
    "label": "outputBits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "outputBits(8, runCount, c, lc, out)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "while(runCount-- >= 0) outputCode(sCode, c, lc, out)"
  },
  {
    "label": "hufEncode()",
    "kind": "Method",
    "detail": "Function (} } int)",
    "insertText": "hufEncode(const long long *hcode, const unsigned short *in, const int ni, int rlc, char *out)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (char* outStart = out ; long long c = 0 ; int lc = 0 ; int s = in [ 0 ] ; int cs = 0 ;)",
    "insertText": "for(int i = 1; i < ni; i++)"
  },
  {
    "label": "sendCode()",
    "kind": "Method",
    "detail": "Function (cs + + ; } else {)",
    "insertText": "sendCode(hcode[s], cs, hcode[rlc], c, lc, out)"
  },
  {
    "label": "getChar()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "getChar(c, lc, in)"
  },
  {
    "label": "c()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "c(c << 8) | *(unsigned char *)(in++)"
  },
  {
    "label": "getCode()",
    "kind": "Method",
    "detail": "Function (\\ lc + = 8 ; \\ } # if 0 # define)",
    "insertText": "getCode(po, rlc, c, lc, in, out, ob, oe)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(po == rlc)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(lc < 8) getChar(c, lc, in)"
  },
  {
    "label": "cs()",
    "kind": "Method",
    "detail": "Function (\\ \\ lc - = 8 ; \\ \\ unsigned char)",
    "insertText": "cs(c >> lc)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\ \\)",
    "insertText": "if(out + cs > oe)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ \\ \\ unsigned short s = out [ - 1 ] ; \\ \\)",
    "insertText": "while(cs-- > 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\ } else)",
    "insertText": "if(out < oe)"
  },
  {
    "label": "getCode()",
    "kind": "Method",
    "detail": "Function (\\* out + + = po ; \\ } else { \\ return false ; \\ } \\ } # else bool)",
    "insertText": "getCode(int po, int rlc, long long &c, int &lc, const char *&in, const char *in_end, unsigned short *&out, const unsigned short *ob, const unsigned short *oe)"
  },
  {
    "label": "hufDecode()",
    "kind": "Method",
    "detail": "Function (* out + + = po ; } else { return false ; } return true ; } # endif bool)",
    "insertText": "hufDecode(const long long *hcode, const HufDec *hdecod, const char *in, int ni, int rlc, int no, unsigned short *out)"
  },
  {
    "label": "in()",
    "kind": "Method",
    "detail": "Function (long long c = 0 ; int lc = 0 ; unsigned short* outb = out ; unsigned short* oe = out + no ; const char* ie =)",
    "insertText": "in(ni + 7)"
  },
  {
    "label": "hdecod()",
    "kind": "Method",
    "detail": "Function (const HufDec pl =)",
    "insertText": "hdecod(c >> (lc - HUF_DECBITS))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lc - = pl . len ;)",
    "insertText": "if(!getCode(pl.lit, rlc, c, lc, in, ie, out, outb, oe))"
  },
  {
    "label": "hufLength()",
    "kind": "Method",
    "detail": "Function (int l =)",
    "insertText": "hufLength(hcode[pl.p[j]])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lc - = l ;)",
    "insertText": "if(!getCode(pl.p[j], rlc, c, lc, in, ie, out, outb, oe))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (c>> = i ; lc - = i ;)",
    "insertText": "while(lc > 0)"
  },
  {
    "label": "hdecod()",
    "kind": "Method",
    "detail": "Function (const HufDec pl =)",
    "insertText": "hdecod(c << (HUF_DECBITS - lc))"
  },
  {
    "label": "writeUInt()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "writeUInt(char buf[4], unsigned int i)"
  },
  {
    "label": "b()",
    "kind": "Method",
    "detail": "Function (unsigned char*)",
    "insertText": "b(unsigned char *)"
  },
  {
    "label": "readUInt()",
    "kind": "Method",
    "detail": "Function (b [ 0 ] = i ; b [ 1 ] = i>> 8 ; b [ 2 ] = i>> 1 6 ; b [ 3 ] = i>> 2 4 ; } unsigned int)",
    "insertText": "readUInt(const char buf[4])"
  },
  {
    "label": "b()",
    "kind": "Method",
    "detail": "Function (const unsigned char*)",
    "insertText": "b(const unsigned char *)"
  },
  {
    "label": "hufCompress()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "hufCompress(const unsigned short raw[], int nRaw, char compressed[])"
  },
  {
    "label": "freq()",
    "kind": "Method",
    "detail": "Function (std::vector<long long>)",
    "insertText": "freq(HUF_ENCSIZE)"
  },
  {
    "label": "countFrequencies()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "countFrequencies(freq, raw, nRaw)"
  },
  {
    "label": "hufBuildEncTable()",
    "kind": "Method",
    "detail": "Function (int im = 0 ; int iM = 0 ;)",
    "insertText": "hufBuildEncTable(freq.data(), &im, &iM)"
  },
  {
    "label": "hufPackEncTable()",
    "kind": "Method",
    "detail": "Function (char* tableStart = compressed + 2 0 ; char* tableEnd = tableStart ;)",
    "insertText": "hufPackEncTable(freq.data(), im, iM, &tableEnd)"
  },
  {
    "label": "hufEncode()",
    "kind": "Method",
    "detail": "Function (int tableLength = tableEnd - tableStart ; char* dataStart = tableEnd ; int nBits =)",
    "insertText": "hufEncode(freq.data(), raw, nRaw, iM, dataStart)"
  },
  {
    "label": "data_length()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "data_length(nBits + 7)"
  },
  {
    "label": "writeUInt()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeUInt(compressed, im)"
  },
  {
    "label": "writeUInt()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeUInt(compressed + 4, iM)"
  },
  {
    "label": "writeUInt()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeUInt(compressed + 8, tableLength)"
  },
  {
    "label": "writeUInt()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeUInt(compressed + 12, nBits)"
  },
  {
    "label": "writeUInt()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeUInt(compressed + 16, 0)"
  },
  {
    "label": "readUInt()",
    "kind": "Method",
    "detail": "Function (int iM =)",
    "insertText": "readUInt(compressed + 4)"
  },
  {
    "label": "readUInt()",
    "kind": "Method",
    "detail": "Function (int nBits =)",
    "insertText": "readUInt(compressed + 12)"
  },
  {
    "label": "hdec()",
    "kind": "Method",
    "detail": "Function (std::vector<HufDec>)",
    "insertText": "hdec(HUF_DECSIZE)"
  },
  {
    "label": "hufClearDecTable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "hufClearDecTable(&hdec.at(0))"
  },
  {
    "label": "hufUnpackEncTable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "hufUnpackEncTable(&ptr, nCompressed - (ptr - compressed), im, iM, &freq.at(0))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function ({)",
    "insertText": "if(nBits > 8 * (nCompressed - (ptr - compressed)))"
  },
  {
    "label": "hufDecode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "hufDecode(&freq.at(0), &hdec.at(0), ptr, nBits, iM, raw->size(), raw->data())"
  },
  {
    "label": "hufFreeDecTable()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "hufFreeDecTable(&hdec.at(0))"
  },
  {
    "label": "USHORT_RANGE()",
    "kind": "Method",
    "detail": "Function (} return true ; } const int)",
    "insertText": "USHORT_RANGE(1 << 16)"
  },
  {
    "label": "BITMAP_SIZE()",
    "kind": "Method",
    "detail": "Function (const int)",
    "insertText": "BITMAP_SIZE(USHORT_RANGE >> 3)"
  },
  {
    "label": "bitmapFromData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bitmapFromData(const unsigned short data[ ], int nData, unsigned char bitmap[BITMAP_SIZE], unsigned short &minNonZero, unsigned short &maxNonZero)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bitmap [ 0 ]& = ~ 1 ; minNonZero = BITMAP_SIZE - 1 ; maxNonZero = 0 ;)",
    "insertText": "for(int i = 0; i < BITMAP_SIZE; ++i)"
  },
  {
    "label": "forwardLutFromBitmap()",
    "kind": "Method",
    "detail": "Function (} } } unsigned short)",
    "insertText": "forwardLutFromBitmap(const unsigned char bitmap[BITMAP_SIZE], unsigned short lut[USHORT_RANGE])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int k = 0 ;)",
    "insertText": "for(int i = 0; i < USHORT_RANGE; ++i)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} int n = k - 1 ;)",
    "insertText": "while(k < USHORT_RANGE)"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (} # ifdef __clang__ # pragma clang diagnostic pop # endif # ifdef _MSC_VER # pragma)",
    "insertText": "warning(pop) #endif static bool CompressPiz(unsigned char *outPtr, unsigned int *outSize, const unsigned char *inPtr, size_t inSize, const std::vector<ChannelInfo> &channelInfo, int data_width, int num_lines)"
  },
  {
    "label": "bitmap()",
    "kind": "Method",
    "detail": "Function (std::vector<unsigned char>)",
    "insertText": "bitmap(BITMAP_SIZE)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (unsigned short minNonZero ; unsigned short maxNonZero ; # if ! MINIZ_LITTLE_ENDIAN)",
    "insertText": "TEXR_ASSERT(0)"
  },
  {
    "label": "channelData()",
    "kind": "Method",
    "detail": "Function (std::vector<PIZChannelData>)",
    "insertText": "channelData(channelInfo.size())"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (pixelSize =)",
    "insertText": "sizeof(short)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} cd . size = static_cast<)",
    "insertText": "int(pixelSize / sizeof(short))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (tmpBufferEnd + = cd . nx* cd . ny* cd . size ; } const unsigned char* ptr = inPtr ;)",
    "insertText": "for(int y = 0; y < num_lines; ++y)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (PIZChannelData& cd = channelData [ i ] ; size_t n = static_cast<)",
    "insertText": "size_t(cd.nx * cd.size)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(cd.end, ptr, n * sizeof(unsigned short))"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (ptr + = n*)",
    "insertText": "sizeof(unsigned short)"
  },
  {
    "label": "bitmapFromData()",
    "kind": "Method",
    "detail": "Function (cd . end + = n ; } })",
    "insertText": "bitmapFromData(&tmpBuffer.at(0), static_cast<int>(tmpBuffer.size()), bitmap.data(), minNonZero, maxNonZero)"
  },
  {
    "label": "lut()",
    "kind": "Method",
    "detail": "Function (std::vector<unsigned short>)",
    "insertText": "lut(USHORT_RANGE)"
  },
  {
    "label": "forwardLutFromBitmap()",
    "kind": "Method",
    "detail": "Function (unsigned short maxValue =)",
    "insertText": "forwardLutFromBitmap(bitmap.data(), lut.data())"
  },
  {
    "label": "applyLut()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "applyLut(lut.data(), &tmpBuffer.at(0), static_cast<int>(tmpBuffer.size()))"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (char* buf = reinterpret_cast<)",
    "insertText": "char(outPtr)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(buf, &minNonZero, sizeof(unsigned short))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(buf, &maxNonZero, sizeof(unsigned short))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(buf, reinterpret_cast<char *>(&bitmap[0] + minNonZero), maxNonZero - minNonZero + 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (buf + = maxNonZero - minNonZero + 1 ; })",
    "insertText": "for(size_t i = 0; i < channelData.size(); ++i)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (PIZChannelData& cd = channelData [ i ] ;)",
    "insertText": "for(int j = 0; j < cd.size; ++j)"
  },
  {
    "label": "wav2Encode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wav2Encode(cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (} } char* lengthPtr = buf ; int zero = 0 ;)",
    "insertText": "memcpy(buf, &zero, sizeof(int))"
  },
  {
    "label": "hufCompress()",
    "kind": "Method",
    "detail": "Function (int length =)",
    "insertText": "hufCompress(&tmpBuffer.at(0), static_cast<int>(tmpBuffer.size()), buf)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(lengthPtr, &length, sizeof(int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(outPtr, inPtr, inSize)"
  },
  {
    "label": "DecompressPiz()",
    "kind": "Method",
    "detail": "Function (} return true ; } bool)",
    "insertText": "DecompressPiz(unsigned char *outPtr, const unsigned char *inPtr, size_t tmpBufSize, size_t inLen, int num_channels, const EXRChannelInfo *channels, int data_width, int num_lines)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(outPtr, inPtr, inLen)"
  },
  {
    "label": "cpy2()",
    "kind": "Method",
    "detail": "Function (const unsigned char* ptr = inPtr ;)",
    "insertText": "cpy2(&minNonZero, reinterpret_cast<const unsigned short *>(ptr))"
  },
  {
    "label": "cpy2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cpy2(&maxNonZero, reinterpret_cast<const unsigned short *>(ptr + 2))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ptr + = 4 ;)",
    "insertText": "if(maxNonZero >= BITMAP_SIZE)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(reinterpret_cast<char *>(&bitmap[0] + minNonZero), ptr, maxNonZero - minNonZero + 1)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(lut.data(), 0, sizeof(unsigned short) * USHORT_RANGE)"
  },
  {
    "label": "reverseLutFromBitmap()",
    "kind": "Method",
    "detail": "Function (unsigned short maxValue =)",
    "insertText": "reverseLutFromBitmap(bitmap.data(), lut.data())"
  },
  {
    "label": "cpy4()",
    "kind": "Method",
    "detail": "Function (int length ;)",
    "insertText": "cpy4(&length, reinterpret_cast<const int *>(ptr))"
  },
  {
    "label": "hufUncompress()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "hufUncompress(reinterpret_cast<const char *>(ptr), length, &tmpBuffer)"
  },
  {
    "label": "channelData()",
    "kind": "Method",
    "detail": "Function (std::vector<PIZChannelData>)",
    "insertText": "channelData(static_cast<size_t>(num_channels))"
  },
  {
    "label": "wav2Decode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wav2Decode(cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue)"
  },
  {
    "label": "applyLut()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "applyLut(lut.data(), &tmpBuffer.at(0), static_cast<int>(tmpBufSize))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(outPtr, cd.end, static_cast<size_t>(n * sizeof(unsigned short)))"
  },
  {
    "label": "ZFPCompressionParam()",
    "kind": "Method",
    "detail": "Function (cd . end + = n ; } } return true ; } # endif # if TINYEXR_USE_ZFP struct ZFPCompressionParam { double rate ; int precision ; double tolerance ; int type ;)",
    "insertText": "ZFPCompressionParam()"
  },
  {
    "label": "FindZFPCompressionParam()",
    "kind": "Method",
    "detail": "Function (type = TINYEXR_ZFP_COMPRESSIONTYPE_RATE ; rate = 2 . 0 ; precision = 0 ; tolerance = 0 . 0 f ; } } ; bool)",
    "insertText": "FindZFPCompressionParam(ZFPCompressionParam *param, const EXRAttribute *attributes, int num_attributes)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool foundType = false ;)",
    "insertText": "for(int i = 0; i < num_attributes; i++)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (param -> type = static_cast<)",
    "insertText": "int(attributes[i].value[0])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (foundType = true ; } })",
    "insertText": "if(!foundType)"
  },
  {
    "label": "rate()",
    "kind": "Method",
    "detail": "Function (param ->)",
    "insertText": "rate(reinterpret_cast<double *>(attributes[i].value))"
  },
  {
    "label": "rate()",
    "kind": "Method",
    "detail": "Function (param ->)",
    "insertText": "rate(reinterpret_cast<int *>(attributes[i].value))"
  },
  {
    "label": "tolerance()",
    "kind": "Method",
    "detail": "Function (param ->)",
    "insertText": "tolerance(reinterpret_cast<double *>(attributes[i].value))"
  },
  {
    "label": "DecompressZfp()",
    "kind": "Method",
    "detail": "Function (} return false ; } bool)",
    "insertText": "DecompressZfp(float *dst, int dst_width, int dst_num_lines, int num_channels, const unsigned char *src, unsigned long src_size, const ZFPCompressionParam &param)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t uncompressed_size = dst_width* dst_num_lines* num_channels ;)",
    "insertText": "if(uncompressed_size == src_size)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (} zfp_stream* zfp = NULL ; zfp_field* field = NULL ;)",
    "insertText": "TEXR_ASSERT((dst_width % 4) == 0)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT((dst_num_lines % 4) == 0)"
  },
  {
    "label": "zfp_stream_open()",
    "kind": "Method",
    "detail": "Function (zfp =)",
    "insertText": "zfp_stream_open(NULL)"
  },
  {
    "label": "zfp_stream_set_rate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "zfp_stream_set_rate(zfp, param.rate, zfp_type_float, 2, 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(param.type == TINYEXR_ZFP_COMPRESSIONTYPE_PRECISION)"
  },
  {
    "label": "zfp_stream_set_precision()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "zfp_stream_set_precision(zfp, param.precision, zfp_type_float)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(param.type == TINYEXR_ZFP_COMPRESSIONTYPE_ACCURACY)"
  },
  {
    "label": "zfp_stream_set_accuracy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "zfp_stream_set_accuracy(zfp, param.tolerance, zfp_type_float)"
  },
  {
    "label": "zfp_stream_maximum_size()",
    "kind": "Method",
    "detail": "Function (} size_t buf_size =)",
    "insertText": "zfp_stream_maximum_size(zfp, field)"
  },
  {
    "label": "buf()",
    "kind": "Method",
    "detail": "Function (std::vector<unsigned char>)",
    "insertText": "buf(buf_size)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&buf.at(0), src, src_size)"
  },
  {
    "label": "stream_open()",
    "kind": "Method",
    "detail": "Function (bitstream* stream =)",
    "insertText": "stream_open(&buf.at(0), buf_size)"
  },
  {
    "label": "zfp_stream_set_bit_stream()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "zfp_stream_set_bit_stream(zfp, stream)"
  },
  {
    "label": "zfp_stream_rewind()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "zfp_stream_rewind(zfp)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t image_size = dst_width* dst_num_lines ;)",
    "insertText": "for(int c = 0; c < num_channels; c++)"
  },
  {
    "label": "zfp_decode_block_float_2()",
    "kind": "Method",
    "detail": "Function (float fblock [ 1 6 ] ;)",
    "insertText": "zfp_decode_block_float_2(zfp, fblock)"
  },
  {
    "label": "image_size()",
    "kind": "Method",
    "detail": "Function (dst [ c*)",
    "insertText": "image_size((y + j) * dst_width + (x + i))"
  },
  {
    "label": "zfp_field_free()",
    "kind": "Method",
    "detail": "Function (} } } } })",
    "insertText": "zfp_field_free(field)"
  },
  {
    "label": "zfp_stream_close()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "zfp_stream_close(zfp)"
  },
  {
    "label": "stream_close()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stream_close(stream)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (zfp_stream* zfp = NULL ; zfp_field* field = NULL ;)",
    "insertText": "TEXR_ASSERT((width % 4) == 0)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT((num_lines % 4) == 0)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (outBuf ->)",
    "insertText": "resize(buf_size)"
  },
  {
    "label": "stream_open()",
    "kind": "Method",
    "detail": "Function (bitstream* stream =)",
    "insertText": "stream_open(&outBuf->at(0), buf_size)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (float fblock [ 1 6 ] ;)",
    "insertText": "for(int j = 0; j < 4; j++)"
  },
  {
    "label": "image_size()",
    "kind": "Method",
    "detail": "Function (fblock [ j* 4 + i ] = inPtr [ c*)",
    "insertText": "image_size((y + j) * width + (x + i))"
  },
  {
    "label": "zfp_encode_block_float_2()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "zfp_encode_block_float_2(zfp, fblock)"
  },
  {
    "label": "zfp_stream_flush()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "zfp_stream_flush(zfp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if TINYEXR_USE_PIZ)",
    "insertText": "if((width == 0) || (num_lines == 0) || (pixel_data_size == 0))"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (size_t tmpBufLen = outBuf .)",
    "insertText": "size()"
  },
  {
    "label": "DecompressPiz()",
    "kind": "Method",
    "detail": "Function (bool ret =)",
    "insertText": "DecompressPiz(reinterpret_cast<unsigned char *>(&outBuf.at(0)), data_ptr, tmpBufLen, data_len, static_cast<int>(num_channels), channels, width, num_lines)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (const unsigned short* line_ptr = reinterpret_cast<unsigned)",
    "insertText": "short(&outBuf.at(v * pixel_data_size * static_cast<size_t>(width) + channel_offset_list[c] * static_cast<size_t>(width)))"
  },
  {
    "label": "cpy2()",
    "kind": "Method",
    "detail": "Function (FP16 hf ;)",
    "insertText": "cpy2(&(hf.u), line_ptr + u)"
  },
  {
    "label": "swap2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap2(reinterpret_cast<unsigned short *>(&hf.u))"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (unsigned short* image = reinterpret_cast<unsigned)",
    "insertText": "short(out_images)"
  },
  {
    "label": "image()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "image(static_cast<size_t>(line_no) + v) * static_cast<size_t>(x_stride)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (} else { image + = static_cast<)",
    "insertText": "size_t((height - 1 - (line_no + static_cast<int>(v)))) * static_cast<size_t>(x_stride)"
  },
  {
    "label": "half_to_float()",
    "kind": "Method",
    "detail": "Function (}* image = hf . u ; } else { FP32 f32 =)",
    "insertText": "half_to_float(hf)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (float* image = reinterpret_cast<)",
    "insertText": "float(out_images)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t offset = 0 ;)",
    "insertText": "if(line_order == 0)"
  },
  {
    "label": "offset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "offset(static_cast<size_t>(line_no) + v) * static_cast<size_t>(x_stride)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} image + = offset ;* image = f32 . f ; } } } } else)",
    "insertText": "if(channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT(requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (const unsigned int* line_ptr = reinterpret_cast<unsigned)",
    "insertText": "int(&outBuf.at(v * pixel_data_size * static_cast<size_t>(width) + channel_offset_list[c] * static_cast<size_t>(width)))"
  },
  {
    "label": "cpy4()",
    "kind": "Method",
    "detail": "Function (unsigned int val ;)",
    "insertText": "cpy4(&val, line_ptr + u)"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(&val)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (unsigned int* image = reinterpret_cast<unsigned)",
    "insertText": "int(out_images)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (}* image = val ; } } } else)",
    "insertText": "if(channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (const float* line_ptr = reinterpret_cast<)",
    "insertText": "float(&outBuf.at( v * pixel_data_size * static_cast<size_t>(x_stride) + channel_offset_list[c] * static_cast<size_t>(x_stride)))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&val))"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (} } # else)",
    "insertText": "TEXR_ASSERT(0 && \"PIZ is enabled in this build\")"
  },
  {
    "label": "outBuf()",
    "kind": "Method",
    "detail": "Function (std::vector<unsigned char>)",
    "insertText": "outBuf(static_cast<size_t>(width) * static_cast<size_t>(num_lines) * pixel_data_size)"
  },
  {
    "label": "long()",
    "kind": "Method",
    "detail": "Function (unsigned long dstLen = static_cast<unsigned)",
    "insertText": "long(outBuf.size())"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT(dstLen > 0)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (const unsigned short* line_ptr = reinterpret_cast<unsigned)",
    "insertText": "short(&outBuf.at(v * static_cast<size_t>(pixel_data_size) * static_cast<size_t>(width) + channel_offset_list[c] * static_cast<size_t>(width)))"
  },
  {
    "label": "image()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "image(static_cast<size_t>(height) - 1U - (static_cast<size_t>(line_no) + v)) * static_cast<size_t>(x_stride)"
  },
  {
    "label": "offset()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "offset(static_cast<size_t>(height) - 1U - (static_cast<size_t>(line_no) + v)) * static_cast<size_t>(x_stride)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (const float* line_ptr = reinterpret_cast<)",
    "insertText": "float(&outBuf.at(v * pixel_data_size * static_cast<size_t>(width) + channel_offset_list[c] * static_cast<size_t>(width)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if TINYEXR_USE_ZFP tinyexr::ZFPCompressionParam zfp_compression_param ;)",
    "insertText": "if(!FindZFPCompressionParam(&zfp_compression_param, attributes, num_attributes))"
  },
  {
    "label": "DecompressZfp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DecompressZfp(reinterpret_cast<float *>(&outBuf.at(0)), width, num_lines, num_channels, data_ptr, static_cast<unsigned long>(data_len), zfp_compression_param)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT(channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (const unsigned short* line_ptr = reinterpret_cast<const unsigned)",
    "insertText": "short(data_ptr + v * pixel_data_size * size_t(width) + channel_offset_list[c] * static_cast<size_t>(width))"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (unsigned short* outLine = reinterpret_cast<unsigned)",
    "insertText": "short(out_images[c])"
  },
  {
    "label": "outLine()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "outLine(size_t(y) + v) * size_t(x_stride)"
  },
  {
    "label": "outLine()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "outLine(size_t(height) - 1 - (size_t(y) + v)) * size_t(x_stride)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int u = 0; u < width; u++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (outLine [ u ] = hf . u ; } } else)",
    "insertText": "if(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (float* outLine = reinterpret_cast<)",
    "insertText": "float(out_images[c])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(reinterpret_cast<const unsigned char *>(line_ptr + width) > (data_ptr + data_len))"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (const float* line_ptr = reinterpret_cast<const)",
    "insertText": "float(data_ptr + v * pixel_data_size * size_t(width) + channel_offset_list[c] * static_cast<size_t>(width))"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (const unsigned int* line_ptr = reinterpret_cast<const unsigned)",
    "insertText": "int(data_ptr + v * pixel_data_size * size_t(width) + channel_offset_list[c] * static_cast<size_t>(width))"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (unsigned int* outLine = reinterpret_cast<unsigned)",
    "insertText": "int(out_images[c])"
  },
  {
    "label": "DecodeTiledPixelData()",
    "kind": "Method",
    "detail": "Function (outLine [ u ] = val ; } } } } } return true ; } bool)",
    "insertText": "DecodeTiledPixelData(unsigned char **out_images, int *width, int *height, const int *requested_pixel_types, const unsigned char *data_ptr, size_t data_len, int compression_type, int line_order, int data_width, int data_height, int tile_offset_x, int tile_offset_y, int tile_size_x, int tile_size_y, size_t pixel_data_size, size_t num_attributes, const EXRAttribute *attributes, size_t num_channels, const EXRChannelInfo *channels, const std::vector<size_t> &channel_offset_list)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT(tile_offset_x * tile_size_x < data_width)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT(tile_offset_y * tile_size_y < data_height)"
  },
  {
    "label": "else()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "else(*width)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if((tile_offset_y + 1) * tile_size_y >= data_height)"
  },
  {
    "label": "else()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "else(*height)"
  },
  {
    "label": "DecodePixelData()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "DecodePixelData(out_images, requested_pixel_types, data_ptr, data_len, compression_type, line_order, (*width), tile_size_y, tile_size_x, 0, 0, (*height), pixel_data_size, num_attributes, attributes, num_channels, channels, channel_offset_list)"
  },
  {
    "label": "ComputeChannelLayout()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ComputeChannelLayout(std::vector<size_t> *channel_offset_list, int *pixel_data_size, size_t *channel_offset, int num_channels, const EXRChannelInfo *channels)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (channel_offset_list ->)",
    "insertText": "resize(static_cast<size_t>(num_channels))"
  },
  {
    "label": "AllocateImage()",
    "kind": "Method",
    "detail": "Function (} else { return false ; } } return true ; } unsigned char**)",
    "insertText": "AllocateImage(int num_channels, const EXRChannelInfo *channels, const int *requested_pixel_types, int data_width, int data_height)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (unsigned char** images = reinterpret_cast<unsigned)",
    "insertText": "char(static_cast<float **>( malloc(sizeof(float *) * static_cast<size_t>(num_channels))))"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (size_t data_len = static_cast<)",
    "insertText": "size_t(data_width) * static_cast<size_t>(data_height)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (images [ c ] = reinterpret_cast<unsigned)",
    "insertText": "char(static_cast<unsigned short *>( malloc(sizeof(unsigned short) * data_len)))"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (images [ c ] = reinterpret_cast<unsigned)",
    "insertText": "char(static_cast<float *>(malloc(sizeof(float) * data_len)))"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (images [ c ] = reinterpret_cast<unsigned)",
    "insertText": "char(static_cast<unsigned int *>(malloc(sizeof(unsigned int) * data_len)))"
  },
  {
    "label": "ParseEXRHeader()",
    "kind": "Method",
    "detail": "Function (} } return images ; } int)",
    "insertText": "ParseEXRHeader(HeaderInfo *info, bool *empty_header, const EXRVersion *version, std::string *err, const unsigned char *buf, size_t size)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (const char* marker = reinterpret_cast<const)",
    "insertText": "char(&buf[0])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(version->multipart)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t orig_size = size ;)",
    "insertText": "for(size_t nattr = 0; nattr < TINYEXR_MAX_HEADER_ATTRIBUTES; nattr++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} return TINYEXR_ERROR_INVALID_DATA ; } else)",
    "insertText": "if(marker[0] == '\\0')"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size - - ; break ; } std::string attr_name ; std::string attr_type ; std::vector<unsigned char> data ; size_t marker_size ;)",
    "insertText": "if(!tinyexr::ReadAttribute(&attr_name, &attr_type, &data, &marker_size, marker, size))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} return TINYEXR_ERROR_INVALID_DATA ; } marker + = marker_size ; size - = marker_size ;)",
    "insertText": "if(version->tiled && attr_name.compare(\"tiles\") == 0)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (unsigned int x_size,y_size ; unsigned char tile_mode ;)",
    "insertText": "TEXR_ASSERT(data.size() == 9)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&x_size, &data.at(0), sizeof(int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&y_size, &data.at(4), sizeof(int))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (tile_mode = data [ 8 ] ;)",
    "insertText": "swap4(&x_size)"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(&y_size)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (info -> tile_size_x = static_cast<)",
    "insertText": "int(x_size)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (info -> tile_size_y = static_cast<)",
    "insertText": "int(y_size)"
  },
  {
    "label": "tile_rounding_mode()",
    "kind": "Method",
    "detail": "Function (info -> tile_level_mode = tile_mode& 0 x3 ; info ->)",
    "insertText": "tile_rounding_mode(tile_mode >> 4)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(attr_name.compare(\"compression\") == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool ok = false ;)",
    "insertText": "if(data[0] < TINYEXR_COMPRESSIONTYPE_PIZ)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ok = true ; })",
    "insertText": "if(data[0] == TINYEXR_COMPRESSIONTYPE_PIZ)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if TINYEXR_USE_PIZ ok = true ; # else)",
    "insertText": "if(err)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} return TINYEXR_ERROR_UNSUPPORTED_FORMAT ; # endif })",
    "insertText": "if(data[0] == TINYEXR_COMPRESSIONTYPE_ZFP)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} return TINYEXR_ERROR_UNSUPPORTED_FORMAT ; # endif })",
    "insertText": "if(!ok)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} return TINYEXR_ERROR_UNSUPPORTED_FORMAT ; } info -> compression_type = static_cast<)",
    "insertText": "int(data[0])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (has_compression = true ; } else)",
    "insertText": "if(attr_name.compare(\"channels\") == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} return TINYEXR_ERROR_INVALID_DATA ; })",
    "insertText": "if(info->channels.size() < 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} return TINYEXR_ERROR_INVALID_DATA ; } has_channels = true ; } else)",
    "insertText": "if(attr_name.compare(\"dataWindow\") == 0)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&info->data_window[0], &data.at(0), sizeof(int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&info->data_window[1], &data.at(4), sizeof(int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&info->data_window[2], &data.at(8), sizeof(int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&info->data_window[3], &data.at(12), sizeof(int))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&info->data_window[0]))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&info->data_window[1]))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&info->data_window[2]))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&info->data_window[3]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (has_data_window = true ; } } else)",
    "insertText": "if(attr_name.compare(\"displayWindow\") == 0)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&info->display_window[0], &data.at(0), sizeof(int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&info->display_window[1], &data.at(4), sizeof(int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&info->display_window[2], &data.at(8), sizeof(int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&info->display_window[3], &data.at(12), sizeof(int))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&info->display_window[0]))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&info->display_window[1]))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&info->display_window[2]))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&info->display_window[3]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (has_display_window = true ; } } else)",
    "insertText": "if(attr_name.compare(\"lineOrder\") == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (has_line_order = true ; } } else)",
    "insertText": "if(attr_name.compare(\"pixelAspectRatio\") == 0)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&info->pixel_aspect_ratio, &data.at(0), sizeof(float))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&info->pixel_aspect_ratio))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (has_pixel_aspect_ratio = true ; } } else)",
    "insertText": "if(attr_name.compare(\"screenWindowCenter\") == 0)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&info->screen_window_center[0], &data.at(0), sizeof(float))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&info->screen_window_center[1], &data.at(4), sizeof(float))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&info->screen_window_center[0]))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&info->screen_window_center[1]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (has_screen_window_center = true ; } } else)",
    "insertText": "if(attr_name.compare(\"screenWindowWidth\") == 0)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&info->screen_window_width, &data.at(0), sizeof(float))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&info->screen_window_width))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (has_screen_window_width = true ; } } else)",
    "insertText": "if(attr_name.compare(\"chunkCount\") == 0)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&info->chunk_count, &data.at(0), sizeof(int))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&info->chunk_count))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "if(info->attributes.size() < TINYEXR_MAX_CUSTOM_ATTRIBUTES)"
  },
  {
    "label": "strncpy_s()",
    "kind": "Method",
    "detail": "Function (EXRAttribute attrib ; # ifdef _MSC_VER)",
    "insertText": "strncpy_s(attrib.name, attr_name.c_str(), 255)"
  },
  {
    "label": "strncpy_s()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "strncpy_s(attrib.type, attr_type.c_str(), 255)"
  },
  {
    "label": "strncpy()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "strncpy(attrib.name, attr_name.c_str(), 255)"
  },
  {
    "label": "strncpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "strncpy(attrib.type, attr_type.c_str(), 255)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (# endif attrib . name [ 2 5 5 ] = ' \\ 0 ' ; attrib . type [ 2 5 5 ] = ' \\ 0 ' ; attrib . size = static_cast<)",
    "insertText": "int(data.size())"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (attrib . value = static_cast<unsigned)",
    "insertText": "char(malloc(data.size()))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(reinterpret_cast<char *>(attrib.value), &data.at(0), data.size())"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (info -> attributes .)",
    "insertText": "push_back(attrib)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } { std::stringstream ss_err ;)",
    "insertText": "if(!has_compression)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ss_err<<\" \\ \" compression \\ \" attribute not found in the header . \"<<std::endl ; })",
    "insertText": "if(!has_channels)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ss_err<<\" \\ \" channels \\ \" attribute not found in the header . \"<<std::endl ; })",
    "insertText": "if(!has_line_order)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ss_err<<\" \\ \" lineOrder \\ \" attribute not found in the header . \"<<std::endl ; })",
    "insertText": "if(!has_display_window)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ss_err<<\" \\ \" displayWindow \\ \" attribute not found in the header . \"<<std::endl ; })",
    "insertText": "if(!has_data_window)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ss_err<<\" \\ \" dataWindow \\ \" attribute not found in the header or invalid . \"<<std::endl ; })",
    "insertText": "if(!has_pixel_aspect_ratio)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ss_err<<\" \\ \" pixelAspectRatio \\ \" attribute not found in the header . \"<<std::endl ; })",
    "insertText": "if(!has_screen_window_width)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ss_err<<\" \\ \" screenWindowWidth \\ \" attribute not found in the header . \"<<std::endl ; })",
    "insertText": "if(!has_screen_window_center)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ss_err<<\" \\ \" screenWindowCenter \\ \" attribute not found in the header . \"<<std::endl ; })",
    "insertText": "if(!(ss_err.str().empty()))"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} return TINYEXR_ERROR_INVALID_HEADER ; } } info -> header_len = static_cast<unsigned)",
    "insertText": "int(orig_size - size)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (exr_header -> pixel_aspect_ratio = info . pixel_aspect_ratio ; exr_header -> screen_window_center [ 0 ] = info . screen_window_center [ 0 ] ; exr_header -> screen_window_center [ 1 ] = info . screen_window_center [ 1 ] ; exr_header -> screen_window_width = info . screen_window_width ; exr_header -> chunk_count = info . chunk_count ; exr_header -> display_window [ 0 ] = info . display_window [ 0 ] ; exr_header -> display_window [ 1 ] = info . display_window [ 1 ] ; exr_header -> display_window [ 2 ] = info . display_window [ 2 ] ; exr_header -> display_window [ 3 ] = info . display_window [ 3 ] ; exr_header -> data_window [ 0 ] = info . data_window [ 0 ] ; exr_header -> data_window [ 1 ] = info . data_window [ 1 ] ; exr_header -> data_window [ 2 ] = info . data_window [ 2 ] ; exr_header -> data_window [ 3 ] = info . data_window [ 3 ] ; exr_header -> line_order = info . line_order ; exr_header -> compression_type = info . compression_type ; exr_header -> tile_size_x = info . tile_size_x ; exr_header -> tile_size_y = info . tile_size_y ; exr_header -> tile_level_mode = info . tile_level_mode ; exr_header -> tile_rounding_mode = info . tile_rounding_mode ; exr_header -> num_channels = static_cast<)",
    "insertText": "int(info.channels.size())"
  },
  {
    "label": "EXRChannelInfo()",
    "kind": "Method",
    "detail": "Function (exr_header -> channels = static_cast<)",
    "insertText": "EXRChannelInfo(malloc( sizeof(EXRChannelInfo) * static_cast<size_t>(exr_header->num_channels)))"
  },
  {
    "label": "strncpy_s()",
    "kind": "Method",
    "detail": "Function (# ifdef _MSC_VER)",
    "insertText": "strncpy_s(exr_header->channels[c].name, info.channels[c].name.c_str(), 255)"
  },
  {
    "label": "strncpy()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "strncpy(exr_header->channels[c].name, info.channels[c].name.c_str(), 255)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (# endif exr_header -> channels [ c ] . name [ 2 5 5 ] = ' \\ 0 ' ; exr_header -> channels [ c ] . pixel_type = info . channels [ c ] . pixel_type ; exr_header -> channels [ c ] . p_linear = info . channels [ c ] . p_linear ; exr_header -> channels [ c ] . x_sampling = info . channels [ c ] . x_sampling ; exr_header -> channels [ c ] . y_sampling = info . channels [ c ] . y_sampling ; } exr_header -> pixel_types = static_cast<)",
    "insertText": "int(malloc(sizeof(int) * static_cast<size_t>(exr_header->num_channels)))"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (exr_header -> requested_pixel_types [ c ] = info . channels [ c ] . pixel_type ; } exr_header -> num_custom_attributes = static_cast<)",
    "insertText": "int(info.attributes.size())"
  },
  {
    "label": "EXRAttribute()",
    "kind": "Method",
    "detail": "Function (exr_header -> num_custom_attributes = TINYEXR_MAX_CUSTOM_ATTRIBUTES ; } exr_header -> custom_attributes = static_cast<)",
    "insertText": "EXRAttribute(malloc( sizeof(EXRAttribute) * size_t(exr_header->num_custom_attributes)))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(exr_header->custom_attributes[i].name, info.attributes[i].name, 256)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(exr_header->custom_attributes[i].type, info.attributes[i].type, 256)"
  },
  {
    "label": "DecodeChunk()",
    "kind": "Method",
    "detail": "Function (exr_header -> custom_attributes [ i ] . size = info . attributes [ i ] . size ; exr_header -> custom_attributes [ i ] . value = info . attributes [ i ] . value ; } } else { exr_header -> custom_attributes = NULL ; } exr_header -> header_len = info . header_len ; } int)",
    "insertText": "DecodeChunk(EXRImage *exr_image, const EXRHeader *exr_header, const std::vector<tinyexr::tinyexr_uint64> &offsets, const unsigned char *head, const size_t size, std::string *err)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int num_channels = exr_header -> num_channels ; int num_scanline_blocks = 1 ;)",
    "insertText": "if(exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIP)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (num_scanline_blocks = 1 6 ; } else)",
    "insertText": "if(exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (num_scanline_blocks = 3 2 ; } else)",
    "insertText": "if(exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (num_scanline_blocks = 1 6 ; } int data_width = exr_header -> data_window [ 2 ] - exr_header -> data_window [ 0 ] + 1 ; int data_height = exr_header -> data_window [ 3 ] - exr_header -> data_window [ 1 ] + 1 ;)",
    "insertText": "if((data_width < 0) || (data_height < 0))"
  },
  {
    "label": "endl()",
    "kind": "Method",
    "detail": "Function (std::stringstream ss ; ss<<\" Invalid data width or data height : \"<<data_width<<\",\"<<data_height<<)",
    "insertText": "endl(*err) += ss.str()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} return TINYEXR_ERROR_INVALID_DATA ; } { const int threshold = 1 0 2 4* 8 1 9 2 ;)",
    "insertText": "if((data_width > threshold) || (data_height > threshold))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (std::vector<size_t> channel_offset_list ; int pixel_data_size = 0 ; size_t channel_offset = 0 ;)",
    "insertText": "if(!tinyexr::ComputeChannelLayout(&channel_offset_list, &pixel_data_size, &channel_offset, num_channels, exr_header->channels))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} return TINYEXR_ERROR_INVALID_DATA ; } bool invalid_data = false ;)",
    "insertText": "if(exr_header->tiled)"
  },
  {
    "label": "n()",
    "kind": "Method",
    "detail": "Function (std::stringstream ss ; ss<<\" Invalid tile size x : \"<<exr_header -> tile_size_x<<\" \\)",
    "insertText": "n(*err) += ss.str()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} return TINYEXR_ERROR_INVALID_HEADER ; })",
    "insertText": "if(exr_header->tile_size_y < 0)"
  },
  {
    "label": "EXRTile()",
    "kind": "Method",
    "detail": "Function (exr_image -> tiles = static_cast<)",
    "insertText": "EXRTile(calloc(sizeof(EXRTile), static_cast<size_t>(num_tiles)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int err_code = TINYEXR_SUCCESS ; #)",
    "insertText": "if(__cplusplus > 199711L) && (TINYEXR_USE_THREAD > 0)"
  },
  {
    "label": "tile_count()",
    "kind": "Method",
    "detail": "Function (std::atomic<size_t>)",
    "insertText": "tile_count(0)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (int num_threads =)",
    "insertText": "max(1, int(std::thread::hardware_concurrency()))"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (num_threads =)",
    "insertText": "int(num_tiles)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int t = 0; t < num_threads; t++)"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (workers .)",
    "insertText": "emplace_back(std::thread([&]() { size_t tile_idx = 0; while ((tile_idx = tile_count++) < num_tiles) { #else for (size_t tile_idx = 0; tile_idx < num_tiles; tile_idx++) { #endif exr_image->tiles[tile_idx].images = tinyexr::AllocateImage( num_channels, exr_header->channels, exr_header->requested_pixel_types, exr_header->tile_size_x, exr_header->tile_size_y); if (offsets[tile_idx] + sizeof(int) * 5 > size) { if (err) { (*err) += \"Insufficient data size.\\n\"; } err_code = TINYEXR_ERROR_INVALID_DATA; break; } size_t data_size = size_t(size - (offsets[tile_idx] + sizeof(int) * 5)); const unsigned char *data_ptr = reinterpret_cast<const unsigned char *>(head + offsets[tile_idx]); int tile_coordinates[4]; memcpy(tile_coordinates, data_ptr, sizeof(int) * 4); tinyexr::swap4( reinterpret_cast<unsigned int *>(&tile_coordinates[0])); tinyexr::swap4( reinterpret_cast<unsigned int *>(&tile_coordinates[1])); tinyexr::swap4( reinterpret_cast<unsigned int *>(&tile_coordinates[2])); tinyexr::swap4( reinterpret_cast<unsigned int *>(&tile_coordinates[3])); if (tile_coordinates[2] != 0) { err_code = TINYEXR_ERROR_UNSUPPORTED_FEATURE; break; } if (tile_coordinates[3] != 0) { err_code = TINYEXR_ERROR_UNSUPPORTED_FEATURE; break; } int data_len; memcpy(&data_len, data_ptr + 16, sizeof(int)); tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len)); if (data_len < 4 || size_t(data_len) > data_size) { if (err) { (*err) += \"Insufficient data length.\\n\"; } err_code = TINYEXR_ERROR_INVALID_DATA; break; } data_ptr += 20; bool ret = tinyexr::DecodeTiledPixelData( exr_image->tiles[tile_idx].images, &(exr_image->tiles[tile_idx].width), &(exr_image->tiles[tile_idx].height), exr_header->requested_pixel_types, data_ptr, static_cast<size_t>(data_len), exr_header->compression_type, exr_header->line_order, data_width, data_height, tile_coordinates[0], tile_coordinates[1], exr_header->tile_size_x, exr_header->tile_size_y, static_cast<size_t>(pixel_data_size), static_cast<size_t>(exr_header->num_custom_attributes), exr_header->custom_attributes, static_cast<size_t>(exr_header->num_channels), exr_header->channels, channel_offset_list); if (!ret) { if (err) { (*err) += \"Failed to decode tile data.\\n\"; } err_code = TINYEXR_ERROR_INVALID_DATA; } exr_image->tiles[tile_idx].offset_x = tile_coordinates[0]; exr_image->tiles[tile_idx].offset_y = tile_coordinates[1]; exr_image->tiles[tile_idx].level_x = tile_coordinates[2]; exr_image->tiles[tile_idx].level_y = tile_coordinates[3]; #if (__cplusplus > 199711L) && (TINYEXR_USE_THREAD > 0) } }))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(auto &t : workers)"
  },
  {
    "label": "join()",
    "kind": "Method",
    "detail": "Function (t .)",
    "insertText": "join()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # else } # endif)",
    "insertText": "if(err_code != TINYEXR_SUCCESS)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (} else { size_t total_data_len =)",
    "insertText": "size_t(data_width) * size_t(data_height) * size_t(num_channels)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (const bool total_data_len_overflown =)",
    "insertText": "sizeof(void *) == 8 ? (total_data_len >= 0x4000000000)"
  },
  {
    "label": "AllocateImage()",
    "kind": "Method",
    "detail": "Function (} return TINYEXR_ERROR_INVALID_DATA ; } exr_image -> images =)",
    "insertText": "AllocateImage(num_channels, exr_header->channels, exr_header->requested_pixel_types, data_width, data_height)"
  },
  {
    "label": "y_count()",
    "kind": "Method",
    "detail": "Function (std::atomic<int>)",
    "insertText": "y_count(0)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (num_threads =)",
    "insertText": "int(num_blocks)"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (workers .)",
    "insertText": "emplace_back(std::thread([&]() { int y = 0; while ((y = y_count++) < int(num_blocks)) { #else #if TINYEXR_USE_OPENMP #pragma omp parallel for #endif for (int y = 0; y < static_cast<int>(num_blocks); y++) { #endif size_t y_idx = static_cast<size_t>(y); if (offsets[y_idx] + sizeof(int) * 2 > size) { invalid_data = true; } else { size_t data_size = size_t(size - (offsets[y_idx] + sizeof(int) * 2)); const unsigned char *data_ptr = reinterpret_cast<const unsigned char *>(head + offsets[y_idx]); int line_no; memcpy(&line_no, data_ptr, sizeof(int)); int data_len; memcpy(&data_len, data_ptr + 4, sizeof(int)); tinyexr::swap4(reinterpret_cast<unsigned int *>(&line_no)); tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len)); if (size_t(data_len) > data_size) { invalid_data = true; } else if ((line_no > (2 << 20)) || (line_no < -(2 << 20))) { invalid_data = true; } else if (data_len == 0) { invalid_data = true; } else { int end_line_no = (std::min)(line_no + num_scanline_blocks, (exr_header->data_window[3] + 1)); int num_lines = end_line_no - line_no; if (num_lines <= 0) { invalid_data = true; } else { data_ptr += 8; tinyexr_int64 lno = static_cast<tinyexr_int64>(line_no) - static_cast<tinyexr_int64>(exr_header->data_window[1]); if (lno > std::numeric_limits<int>::max()) { line_no = -1; } else if (lno < -std::numeric_limits<int>::max()) { line_no = -1; } else { line_no -= exr_header->data_window[1]; } if (line_no < 0) { invalid_data = true; } else { if (!tinyexr::DecodePixelData( exr_image->images, exr_header->requested_pixel_types, data_ptr, static_cast<size_t>(data_len), exr_header->compression_type, exr_header->line_order, data_width, data_height, data_width, y, line_no, num_lines, static_cast<size_t>(pixel_data_size), static_cast<size_t>( exr_header->num_custom_attributes), exr_header->custom_attributes, static_cast<size_t>(exr_header->num_channels), exr_header->channels, channel_offset_list)) { invalid_data = true; } } } } } #if (__cplusplus > 199711L) && (TINYEXR_USE_THREAD > 0) } }))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # else } # endif })",
    "insertText": "if(invalid_data)"
  },
  {
    "label": "ss()",
    "kind": "Method",
    "detail": "Function (std::stringstream)",
    "insertText": "ss(*err)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} return TINYEXR_ERROR_INVALID_DATA ; } {)",
    "insertText": "for(int c = 0; c < exr_header->num_channels; c++)"
  },
  {
    "label": "ReconstructLineOffsets()",
    "kind": "Method",
    "detail": "Function (exr_header -> pixel_types [ c ] = exr_header -> requested_pixel_types [ c ] ; } } { exr_image -> num_channels = num_channels ; exr_image -> width = data_width ; exr_image -> height = data_height ; } return TINYEXR_SUCCESS ; } bool)",
    "insertText": "ReconstructLineOffsets(std::vector<tinyexr::tinyexr_uint64> *offsets, size_t n, const unsigned char *head, const unsigned char *marker, const size_t size)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT(head < marker)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT(offsets->size() == n)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (size_t offset = static_cast<)",
    "insertText": "size_t(marker - head)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&data_len, marker + 4, sizeof(unsigned int))"
  },
  {
    "label": "DecodeEXRImage()",
    "kind": "Method",
    "detail": "Function (marker + = data_len + 8 ; } return true ; } int)",
    "insertText": "DecodeEXRImage(EXRImage *exr_image, const EXRHeader *exr_header, const unsigned char *head, const unsigned char *marker, const size_t size, const char **err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid argument for DecodeEXRImage().\", err)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (num_scanline_blocks = 1 6 ; } int data_width = exr_header -> data_window [ 2 ] - exr_header -> data_window [ 0 ] ;)",
    "insertText": "if(data_width >= std::numeric_limits<int>::max())"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid data width value\", err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid data height value\", err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"data width or data height is negative.\", err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"data width too large.\", err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"data height too large.\", err)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (num_blocks = static_cast<)",
    "insertText": "size_t(exr_header->chunk_count)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (size_t num_x_tiles = static_cast<)",
    "insertText": "size_t(data_width) / static_cast<size_t>(exr_header->tile_size_x)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (num_x_tiles + + ; } size_t num_y_tiles = static_cast<)",
    "insertText": "size_t(data_height) / static_cast<size_t>(exr_header->tile_size_y)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (num_y_tiles + + ; } num_blocks = num_x_tiles* num_y_tiles ; } else { num_blocks = static_cast<)",
    "insertText": "size_t(data_height) / static_cast<size_t>(num_scanline_blocks)"
  },
  {
    "label": "offsets()",
    "kind": "Method",
    "detail": "Function (num_blocks + + ; } } std::vector<tinyexr::tinyexr_uint64>)",
    "insertText": "offsets(num_blocks)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (tinyexr::tinyexr_uint64 offset ;)",
    "insertText": "if((marker + sizeof(tinyexr_uint64)) >= (head + size))"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Insufficient data size in offset table.\", err)"
  },
  {
    "label": "swap8()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap8(&offset)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid offset value in DecodeEXRImage.\", err)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (offsets [ y ] = offset ; })",
    "insertText": "for(size_t y = 0; y < num_blocks; y++)"
  },
  {
    "label": "ReconstructLineOffsets()",
    "kind": "Method",
    "detail": "Function (bool ret =)",
    "insertText": "ReconstructLineOffsets(&offsets, num_blocks, head, marker, size)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (break ; } else {)",
    "insertText": "SetErrorMessage(\"Cannot reconstruct lineOffset table in DecodeEXRImage.\", err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(e, err)"
  },
  {
    "label": "FreeEXRImage()",
    "kind": "Method",
    "detail": "Function (} # if 1)",
    "insertText": "FreeEXRImage(exr_image)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "if((exr_header->num_channels > 0) && exr_image && exr_image->images)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(exr_image->images[c])"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (exr_image -> images [ c ] = NULL ; } })",
    "insertText": "free(exr_image->images)"
  },
  {
    "label": "GetLayers()",
    "kind": "Method",
    "detail": "Function (exr_image -> images = NULL ; } # endif } return ret ; } } void)",
    "insertText": "GetLayers(const EXRHeader& exr_header, std::vector<std::string>& layer_names)"
  },
  {
    "label": "full_name()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "full_name(exr_header.channels[c].name)"
  },
  {
    "label": "find_last_of()",
    "kind": "Method",
    "detail": "Function (const size_t pos = full_name .)",
    "insertText": "find_last_of('.')"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (full_name .)",
    "insertText": "erase(pos)"
  },
  {
    "label": "LayerChannel()",
    "kind": "Method",
    "detail": "Function (} } } struct LayerChannel {)",
    "insertText": "LayerChannel(size_t i, std::string n) : index(i) , name(n)"
  },
  {
    "label": "ChannelsInLayer()",
    "kind": "Method",
    "detail": "Function (} size_t index ; std::string name ; } ; void)",
    "insertText": "ChannelsInLayer(const EXRHeader& exr_header, const std::string layer_name, std::vector<LayerChannel>& channels)"
  },
  {
    "label": "ch_name()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "ch_name(exr_header.channels[c].name)"
  },
  {
    "label": "substr()",
    "kind": "Method",
    "detail": "Function (ch_name = ch_name .)",
    "insertText": "substr(pos + 1)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (} } else { const size_t pos = ch_name .)",
    "insertText": "find(layer_name + '.')"
  },
  {
    "label": "substr()",
    "kind": "Method",
    "detail": "Function (ch_name = ch_name .)",
    "insertText": "substr(layer_name.size() + 1)"
  },
  {
    "label": "ch()",
    "kind": "Method",
    "detail": "Function (} } LayerChannel)",
    "insertText": "ch(size_t(c), ch_name)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (channels .)",
    "insertText": "push_back(ch)"
  },
  {
    "label": "InitEXRHeader()",
    "kind": "Method",
    "detail": "Function (EXRVersion exr_version ; EXRHeader exr_header ;)",
    "insertText": "InitEXRHeader(&exr_header)"
  },
  {
    "label": "ParseEXRVersionFromFile()",
    "kind": "Method",
    "detail": "Function ({ int ret =)",
    "insertText": "ParseEXRVersionFromFile(&exr_version, filename)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid EXR header.\", err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Loading multipart or DeepImage is not supported in LoadEXR() API\", err)"
  },
  {
    "label": "FreeEXRHeader()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeEXRHeader(&exr_header)"
  },
  {
    "label": "_MSC_VER()",
    "kind": "Method",
    "detail": "Function (# ifdef)",
    "insertText": "_MSC_VER(*layer_names)[c] = _strdup(layer_vec[c].c_str())"
  },
  {
    "label": "else()",
    "kind": "Method",
    "detail": "Function (#)",
    "insertText": "else(*layer_names)[c] = strdup(layer_vec[c].c_str())"
  },
  {
    "label": "LoadEXRWithLayer()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "LoadEXRWithLayer(float **out_rgba, int *width, int *height, const char *filename, const char *layername, const char **err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid argument for LoadEXR()\", err)"
  },
  {
    "label": "InitEXRImage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitEXRImage(&exr_image)"
  },
  {
    "label": "code()",
    "kind": "Method",
    "detail": "Function (std::stringstream ss ; ss<<\" Failed to open EXR file or read version info from EXR file .)",
    "insertText": "code(\" << ret << \")"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(ss.str(), err)"
  },
  {
    "label": "LoadEXRImageFromFile()",
    "kind": "Method",
    "detail": "Function (exr_header . requested_pixel_types [ i ] = TINYEXR_PIXELTYPE_FLOAT ; } } { int ret =)",
    "insertText": "LoadEXRImageFromFile(&exr_image, &exr_header, filename, err)"
  },
  {
    "label": "ChannelsInLayer()",
    "kind": "Method",
    "detail": "Function (std::vector<tinyexr::LayerChannel> channels ;)",
    "insertText": "ChannelsInLayer(exr_header, layername == NULL ? \"\" : std::string(layername), channels)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Layer Not Found\", err)"
  },
  {
    "label": "FreeEXRImage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeEXRImage(&exr_image)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const tinyexr::LayerChannel& ch = channels [ c ] ;)",
    "insertText": "if(ch.name == \"R\")"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (idxR =)",
    "insertText": "int(ch.index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(ch.name == \"G\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(ch.name == \"B\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(ch.name == \"A\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(channels.size() == 1)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (int chIdx =)",
    "insertText": "int(channels.front().index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int ii = exr_image . tiles [ it ] . offset_x* exr_header . tile_size_x + i ; const int jj = exr_image . tiles [ it ] . offset_y* exr_header . tile_size_y + j ; const int idx = ii + jj* exr_image . width ;)",
    "insertText": "if(ii >= exr_image.width)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(jj >= exr_image.height)"
  },
  {
    "label": "images()",
    "kind": "Method",
    "detail": "Function (continue ; } const int srcIdx = i + j* exr_header . tile_size_x ; unsigned char** src = exr_image . tiles [ it ] .)",
    "insertText": "images(*out_rgba)[4 * idx + 0] = reinterpret_cast<float **>(src)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } } } else {)",
    "insertText": "for(int i = 0; i < exr_image.width * exr_image.height; i++)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (const float val = reinterpret_cast<)",
    "insertText": "float(exr_image.images)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } else {)",
    "insertText": "if(idxR == -1)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"R channel not found\", err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"G channel not found\", err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"B channel not found\", err)"
  },
  {
    "label": "else()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "else(*out_rgba)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid argument. `memory` or `exr_header` argument is null in \" \"ParseEXRHeaderFromMemory()\", err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Insufficient header/data size.\\n\", err)"
  },
  {
    "label": "ParseEXRHeader()",
    "kind": "Method",
    "detail": "Function (std::string err_str ; int ret =)",
    "insertText": "ParseEXRHeader(&info, NULL, version, &err_str, marker, marker_size)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(err_str, err)"
  },
  {
    "label": "ConvertHeader()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "ConvertHeader(exr_header, info)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid argument for LoadEXRFromMemory\", err)"
  },
  {
    "label": "ParseEXRVersionFromMemory()",
    "kind": "Method",
    "detail": "Function (int ret =)",
    "insertText": "ParseEXRVersionFromMemory(&exr_version, memory, size)"
  },
  {
    "label": "LoadEXRImageFromMemory()",
    "kind": "Method",
    "detail": "Function (ret =)",
    "insertText": "LoadEXRImageFromMemory(&exr_image, &exr_header, memory, size, err)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (idxR = c ; } else)",
    "insertText": "if(strcmp(exr_header.channels[c].name, \"G\") == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (idxG = c ; } else)",
    "insertText": "if(strcmp(exr_header.channels[c].name, \"B\") == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (idxB = c ; } else)",
    "insertText": "if(strcmp(exr_header.channels[c].name, \"A\") == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (idxA = c ; } })",
    "insertText": "if(exr_header.num_channels == 1)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid argument for LoadEXRImageFromFile\", err)"
  },
  {
    "label": "fopen()",
    "kind": "Method",
    "detail": "Function (# else FILE* fp =)",
    "insertText": "fopen(filename, \"rb\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(!fp)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Cannot read file \" + std::string(filename), err)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (filesize = static_cast<)",
    "insertText": "size_t(ftell(fp))"
  },
  {
    "label": "fseek()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fseek(fp, 0, SEEK_SET)"
  },
  {
    "label": "fclose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fclose(fp)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"File size too short \" + std::string(filename), err)"
  },
  {
    "label": "fread()",
    "kind": "Method",
    "detail": "Function ({ size_t ret ; ret =)",
    "insertText": "fread(&buf[0], 1, filesize, fp)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT(ret == filesize)"
  },
  {
    "label": "LoadEXRImageFromMemory()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "LoadEXRImageFromMemory(exr_image, exr_header, &buf.at(0), filesize, err)"
  },
  {
    "label": "LoadEXRImageFromMemory()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "LoadEXRImageFromMemory(EXRImage *exr_image, const EXRHeader *exr_header, const unsigned char *memory, const size_t size, const char **err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid argument for LoadEXRImageFromMemory\", err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"EXRHeader variable is not initialized.\", err)"
  },
  {
    "label": "SaveEXRImageToMemory()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "SaveEXRImageToMemory(const EXRImage *exr_image, const EXRHeader *exr_header, unsigned char **memory_out, const char **err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid argument for SaveEXRImageToMemory\", err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"PIZ compression is not supported in this build\", err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"ZFP compression is not supported in this build\", err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Pixel type must be FLOAT for ZFP compression\", err)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} { char marker [ ] = { 2,0,0,0 } ; memory .)",
    "insertText": "insert(memory.end(), marker, marker + 4)"
  },
  {
    "label": "string()",
    "kind": "Method",
    "detail": "Function (tinyexr::ChannelInfo info ; info . p_linear = 0 ; info . pixel_type = exr_header -> requested_pixel_types [ c ] ; info . x_sampling = 1 ; info . y_sampling = 1 ; info . name =)",
    "insertText": "string(exr_header->channels[c].name)"
  },
  {
    "label": "WriteChannelInfo()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "WriteChannelInfo(data, channels)"
  },
  {
    "label": "WriteAttributeToMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteAttributeToMemory(&memory, \"channels\", \"chlist\", &data.at(0), static_cast<int>(data.size()))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (} { int comp = exr_header -> compression_type ;)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&comp))"
  },
  {
    "label": "WriteAttributeToMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteAttributeToMemory(&memory, \"compression\", \"compression\", reinterpret_cast<const unsigned char *>(&comp), 1)"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (} { int data [ 4 ] = { 0,0,exr_image -> width - 1,exr_image -> height - 1 } ;)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&data[0]))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&data[1]))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&data[2]))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&data[3]))"
  },
  {
    "label": "WriteAttributeToMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteAttributeToMemory(&memory, \"dataWindow\", \"box2i\", reinterpret_cast<const unsigned char *>(data), sizeof(int) * 4)"
  },
  {
    "label": "WriteAttributeToMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteAttributeToMemory(&memory, \"displayWindow\", \"box2i\", reinterpret_cast<const unsigned char *>(data), sizeof(int) * 4)"
  },
  {
    "label": "WriteAttributeToMemory()",
    "kind": "Method",
    "detail": "Function (} { unsigned char line_order = 0 ;)",
    "insertText": "WriteAttributeToMemory(&memory, \"lineOrder\", \"lineOrder\", &line_order, 1)"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (} { float aspectRatio = 1 . 0 f ;)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&aspectRatio))"
  },
  {
    "label": "WriteAttributeToMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteAttributeToMemory(&memory, \"pixelAspectRatio\", \"float\", reinterpret_cast<const unsigned char *>(&aspectRatio), sizeof(float))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (} { float center [ 2 ] = { 0 . 0 f,0 . 0 f } ;)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&center[0]))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&center[1]))"
  },
  {
    "label": "WriteAttributeToMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteAttributeToMemory(&memory, \"screenWindowCenter\", \"v2f\", reinterpret_cast<const unsigned char *>(center), 2 * sizeof(float))"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (} { float w = static_cast<)",
    "insertText": "float(exr_image->width)"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&w))"
  },
  {
    "label": "WriteAttributeToMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteAttributeToMemory(&memory, \"screenWindowWidth\", \"float\", reinterpret_cast<const unsigned char *>(&w), sizeof(float))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(exr_header->num_custom_attributes > 0)"
  },
  {
    "label": "WriteAttributeToMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteAttributeToMemory(&memory, exr_header->custom_attributes[i].name, exr_header->custom_attributes[i].type, reinterpret_cast<const unsigned char *>( exr_header->custom_attributes[i].value), exr_header->custom_attributes[i].size)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} } { unsigned char e = 0 ; memory .)",
    "insertText": "push_back(e)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} int num_blocks = exr_image -> height / num_scanlines ;)",
    "insertText": "if(num_blocks * num_scanlines < exr_image->height)"
  },
  {
    "label": "offsets()",
    "kind": "Method",
    "detail": "Function (num_blocks + + ; } std::vector<tinyexr::tinyexr_uint64>)",
    "insertText": "offsets(static_cast<size_t>(num_blocks))"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (tinyexr::tinyexr_uint64 offset = headerSize + static_cast<)",
    "insertText": "size_t(num_blocks) * sizeof( tinyexr::tinyexr_int64)"
  },
  {
    "label": "data_list()",
    "kind": "Method",
    "detail": "Function (std::vector<std::vector<unsigned char>>)",
    "insertText": "data_list(static_cast<size_t>(num_blocks))"
  },
  {
    "label": "channel_offset_list()",
    "kind": "Method",
    "detail": "Function (std::vector<size_t>)",
    "insertText": "channel_offset_list(static_cast<size_t>(exr_header->num_channels))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int pixel_data_size = 0 ; size_t channel_offset = 0 ;)",
    "insertText": "for(size_t c = 0; c < static_cast<size_t>(exr_header->num_channels); c++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (channel_offset_list [ c ] = channel_offset ;)",
    "insertText": "if(exr_header->requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(exr_header->requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (pixel_data_size + =)",
    "insertText": "sizeof(float)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(exr_header->requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (pixel_data_size + =)",
    "insertText": "sizeof(unsigned int)"
  },
  {
    "label": "FindZFPCompressionParam()",
    "kind": "Method",
    "detail": "Function (} } # if TINYEXR_USE_ZFP tinyexr::ZFPCompressionParam zfp_compression_param ; { bool ret =)",
    "insertText": "FindZFPCompressionParam(&zfp_compression_param, exr_header->custom_attributes, exr_header->num_custom_attributes)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (zfp_compression_param . type = 0 ; zfp_compression_param . rate = 2 ; } } # endif # if TINYEXR_USE_OPENMP # pragma omp parallel for # endif)",
    "insertText": "for(int i = 0; i < num_blocks; i++)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (size_t ii = static_cast<)",
    "insertText": "size_t(i)"
  },
  {
    "label": "endY()",
    "kind": "Method",
    "detail": "Function (int start_y = num_scanlines* i ; int)",
    "insertText": "endY(std::min)(num_scanlines * (i + 1), exr_image->height)"
  },
  {
    "label": "buf()",
    "kind": "Method",
    "detail": "Function (int h = endY - start_y ; std::vector<unsigned char>)",
    "insertText": "buf(static_cast<size_t>(exr_image->width * h * pixel_data_size))"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (float* line_ptr = reinterpret_cast<)",
    "insertText": "float(&buf.at( static_cast<size_t>(pixel_data_size * y * exr_image->width) + channel_offset_list[c] * static_cast<size_t>(exr_image->width)))"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (width + x])",
    "insertText": "short(exr_image->images)[c][(y + start_y)"
  },
  {
    "label": "half_to_float()",
    "kind": "Method",
    "detail": "Function (tinyexr::FP32 f32 =)",
    "insertText": "half_to_float(h16)"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&f32.f))"
  },
  {
    "label": "cpy4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cpy4(line_ptr + x, &(f32.f))"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (unsigned short* line_ptr = reinterpret_cast<unsigned)",
    "insertText": "short(&buf.at(static_cast<size_t>(pixel_data_size * y * exr_image->width) + channel_offset_list[c] * static_cast<size_t>(exr_image->width)))"
  },
  {
    "label": "swap2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap2(&val)"
  },
  {
    "label": "cpy2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cpy2(line_ptr + x, &val)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(exr_header->pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (width + x])",
    "insertText": "float(exr_image->images)[c][(y + start_y)"
  },
  {
    "label": "float_to_half_full()",
    "kind": "Method",
    "detail": "Function (tinyexr::FP16 h16 ; h16 =)",
    "insertText": "float_to_half_full(f32)"
  },
  {
    "label": "swap2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap2(reinterpret_cast<unsigned short *>(&h16.u))"
  },
  {
    "label": "cpy2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cpy2(line_ptr + x, &(h16.u))"
  },
  {
    "label": "cpy4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cpy4(line_ptr + x, &val)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(exr_header->pixel_types[c] == TINYEXR_PIXELTYPE_UINT)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (unsigned int* line_ptr = reinterpret_cast<unsigned)",
    "insertText": "int(&buf.at( static_cast<size_t>(pixel_data_size * y * exr_image->width) + channel_offset_list[c] * static_cast<size_t>(exr_image->width)))"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (width + x])",
    "insertText": "int(exr_image->images)[c][(y + start_y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } })",
    "insertText": "if(exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_NONE)"
  },
  {
    "label": "header()",
    "kind": "Method",
    "detail": "Function (std::vector<unsigned char>)",
    "insertText": "header(8)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (unsigned int data_len = static_cast<unsigned)",
    "insertText": "int(buf.size())"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&header.at(0), &start_y, sizeof(int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&header.at(4), &data_len, sizeof(unsigned int))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&header.at(0)))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&header.at(4)))"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (data_list [ ii ] .)",
    "insertText": "insert(data_list[ii].end(), header.begin(), header.end())"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (data_list [ ii ] .)",
    "insertText": "insert(data_list[ii].end(), buf.begin(), buf.begin() + data_len)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIPS) || (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIP))"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (# if TINYEXR_USE_MINIZ std::vector<unsigned char>)",
    "insertText": "block(tinyexr::miniz::mz_compressBound( static_cast<unsigned long>(buf.size())))"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (# else std::vector<unsigned char>)",
    "insertText": "block(compressBound(static_cast<uLong>(buf.size())))"
  },
  {
    "label": "CompressZip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CompressZip(&block.at(0), outSize, reinterpret_cast<const unsigned char *>(&buf.at(0)), static_cast<unsigned long>(buf.size()))"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (unsigned int data_len = static_cast<unsigned)",
    "insertText": "int(outSize)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (data_list [ ii ] .)",
    "insertText": "insert(data_list[ii].end(), block.begin(), block.begin() + data_len)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_RLE)"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (std::vector<unsigned char>)",
    "insertText": "block((buf.size() * 3) / 2)"
  },
  {
    "label": "CompressRle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CompressRle(&block.at(0), outSize, reinterpret_cast<const unsigned char *>(&buf.at(0)), static_cast<unsigned long>(buf.size()))"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (# if TINYEXR_USE_PIZ unsigned int bufLen = 8 1 9 2 + static_cast<unsigned)",
    "insertText": "int(2 * static_cast<unsigned int>( buf.size()))"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (std::vector<unsigned char>)",
    "insertText": "block(bufLen)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (unsigned int outSize = static_cast<unsigned)",
    "insertText": "int(block.size())"
  },
  {
    "label": "CompressPiz()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CompressPiz(&block.at(0), &outSize, reinterpret_cast<const unsigned char *>(&buf.at(0)), buf.size(), channels, exr_image->width, h)"
  },
  {
    "label": "CompressZfp()",
    "kind": "Method",
    "detail": "Function (# if TINYEXR_USE_ZFP std::vector<unsigned char> block ; unsigned int outSize ;)",
    "insertText": "CompressZfp(&block, &outSize, reinterpret_cast<const float *>(&buf.at(0)), exr_image->width, h, exr_header->num_channels, zfp_compression_param)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(size_t i = 0; i < static_cast<size_t>(num_blocks); i++)"
  },
  {
    "label": "swap8()",
    "kind": "Method",
    "detail": "Function (offsets [ i ] = offset ;)",
    "insertText": "swap8(reinterpret_cast<tinyexr::tinyexr_uint64 *>(&offsets[i]))"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (} size_t totalSize = static_cast<)",
    "insertText": "size_t(offset)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function ({ memory .)",
    "insertText": "insert(memory.end(), reinterpret_cast<unsigned char *>(&offsets.at(0)), reinterpret_cast<unsigned char *>(&offsets.at(0)) + sizeof(tinyexr::tinyexr_uint64) * static_cast<size_t>(num_blocks))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(memory.size() == 0)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Output memory size is zero\", err)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy((*memory_out), &memory.at(0), memory.size())"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(memory_ptr, &data_list[i].at(0), data_list[i].size())"
  },
  {
    "label": "SaveEXRImageToFile()",
    "kind": "Method",
    "detail": "Function (} return totalSize ; } int)",
    "insertText": "SaveEXRImageToFile(const EXRImage *exr_image, const EXRHeader *exr_header, const char *filename, const char **err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid argument for SaveEXRImageToFile\", err)"
  },
  {
    "label": "fopen()",
    "kind": "Method",
    "detail": "Function (# else FILE* fp =)",
    "insertText": "fopen(filename, \"wb\")"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Cannot write a file\", err)"
  },
  {
    "label": "fwrite()",
    "kind": "Method",
    "detail": "Function (written_size =)",
    "insertText": "fwrite(mem, 1, mem_size, fp)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "free(mem)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid argument for LoadDeepEXR\", err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Cannot read a file \" + std::string(filename), err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"File size is zero : \" + std::string(filename), err)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const char* head =& buf [ 0 ] ; const char* marker =& buf [ 0 ] ; { const char header [ ] = { 0 x76,0 x2f,0 x31,0 x01 } ;)",
    "insertText": "if(memcmp(marker, header, 4) != 0)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid magic number\", err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Unsupported version or scanline\", err)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (compression_type = data [ 0 ] ;)",
    "insertText": "if(compression_type > TINYEXR_COMPRESSIONTYPE_PIZ)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Failed to parse channel info\", err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid channels format\", err)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&dx, &data.at(0), sizeof(int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&dy, &data.at(4), sizeof(int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&dw, &data.at(8), sizeof(int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&dh, &data.at(12), sizeof(int))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&dx))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&dy))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&dw))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&dh))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (int x ; int y ; int w ; int h ;)",
    "insertText": "memcpy(&x, &data.at(0), sizeof(int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&y, &data.at(4), sizeof(int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&w, &data.at(8), sizeof(int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&h, &data.at(12), sizeof(int))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&x))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&y))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&h))"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "TEXR_ASSERT(dx >= 0)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT(dy >= 0)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT(dw >= 0)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT(dh >= 0)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT(num_channels >= 1)"
  },
  {
    "label": "image()",
    "kind": "Method",
    "detail": "Function (int data_width = dw - dx + 1 ; int data_height = dh - dy + 1 ; std::vector<float>)",
    "insertText": "image(static_cast<size_t>(data_width * data_height * 4))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int num_blocks = data_height / num_scanline_blocks ;)",
    "insertText": "if(num_blocks * num_scanline_blocks < data_height)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (tinyexr::tinyexr_int64 offset ;)",
    "insertText": "memcpy(&offset, marker, sizeof(tinyexr::tinyexr_int64))"
  },
  {
    "label": "swap8()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap8(reinterpret_cast<tinyexr::tinyexr_uint64 *>(&offset))"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (marker + =)",
    "insertText": "sizeof(tinyexr::tinyexr_int64)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (offsets [ y ] = offset ; } # if TINYEXR_USE_PIZ)",
    "insertText": "if((compression_type == TINYEXR_COMPRESSIONTYPE_NONE) || (compression_type == TINYEXR_COMPRESSIONTYPE_RLE) || (compression_type == TINYEXR_COMPRESSIONTYPE_ZIPS) || (compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) || (compression_type == TINYEXR_COMPRESSIONTYPE_PIZ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "if((compression_type == TINYEXR_COMPRESSIONTYPE_NONE) || (compression_type == TINYEXR_COMPRESSIONTYPE_RLE) || (compression_type == TINYEXR_COMPRESSIONTYPE_ZIPS) || (compression_type == TINYEXR_COMPRESSIONTYPE_ZIP))"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (# endif } else {)",
    "insertText": "SetErrorMessage(\"Unsupported compression format\", err)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (deep_image -> image [ c ] = static_cast<)",
    "insertText": "float(malloc(sizeof(float *) * static_cast<size_t>(data_height)))"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} } deep_image -> offset_table = static_cast<)",
    "insertText": "int(malloc(sizeof(int *) * static_cast<size_t>(data_height)))"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (deep_image -> offset_table [ y ] = static_cast<)",
    "insertText": "int(malloc(sizeof(int) * static_cast<size_t>(data_width)))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(size_t y = 0; y < static_cast<size_t>(num_blocks); y++)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (const unsigned char* data_ptr = reinterpret_cast<const unsigned)",
    "insertText": "char(head + offsets[y])"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (int line_no ; tinyexr::tinyexr_int64 packedOffsetTableSize ; tinyexr::tinyexr_int64 packedSampleDataSize ; tinyexr::tinyexr_int64 unpackedSampleDataSize ;)",
    "insertText": "memcpy(&line_no, data_ptr, sizeof(int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&packedOffsetTableSize, data_ptr + 4, sizeof(tinyexr::tinyexr_int64))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&packedSampleDataSize, data_ptr + 12, sizeof(tinyexr::tinyexr_int64))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&unpackedSampleDataSize, data_ptr + 20, sizeof(tinyexr::tinyexr_int64))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(reinterpret_cast<unsigned int *>(&line_no))"
  },
  {
    "label": "swap8()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap8(reinterpret_cast<tinyexr::tinyexr_uint64 *>(&packedOffsetTableSize))"
  },
  {
    "label": "swap8()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap8(reinterpret_cast<tinyexr::tinyexr_uint64 *>(&packedSampleDataSize))"
  },
  {
    "label": "swap8()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap8(reinterpret_cast<tinyexr::tinyexr_uint64 *>(&unpackedSampleDataSize))"
  },
  {
    "label": "pixelOffsetTable()",
    "kind": "Method",
    "detail": "Function (std::vector<int>)",
    "insertText": "pixelOffsetTable(static_cast<size_t>(data_width))"
  },
  {
    "label": "long()",
    "kind": "Method",
    "detail": "Function ({ unsigned long dstLen = static_cast<unsigned)",
    "insertText": "long(pixelOffsetTable.size() * sizeof(int))"
  },
  {
    "label": "sample_data()",
    "kind": "Method",
    "detail": "Function (deep_image -> offset_table [ y ] [ i ] = pixelOffsetTable [ i ] ; } } std::vector<unsigned char>)",
    "insertText": "sample_data(static_cast<size_t>(unpackedSampleDataSize))"
  },
  {
    "label": "long()",
    "kind": "Method",
    "detail": "Function ({ unsigned long dstLen = static_cast<unsigned)",
    "insertText": "long(unpackedSampleDataSize)"
  },
  {
    "label": "channel_offset_list()",
    "kind": "Method",
    "detail": "Function (} } int sampleSize = - 1 ; std::vector<int>)",
    "insertText": "channel_offset_list(static_cast<size_t>(num_channels))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function ({ int channel_offset = 0 ;)",
    "insertText": "for(size_t i = 0; i < static_cast<size_t>(num_channels); i++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (channel_offset_list [ i ] = channel_offset ;)",
    "insertText": "if(channels[i].pixel_type == TINYEXR_PIXELTYPE_UINT)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (channel_offset + = 4 ; } else)",
    "insertText": "if(channels[i].pixel_type == TINYEXR_PIXELTYPE_HALF)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (channel_offset + = 2 ; } else)",
    "insertText": "if(channels[i].pixel_type == TINYEXR_PIXELTYPE_FLOAT)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (} } sampleSize = channel_offset ; })",
    "insertText": "TEXR_ASSERT(sampleSize >= 2)"
  },
  {
    "label": "TEXR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TEXR_ASSERT(static_cast<size_t>( pixelOffsetTable[static_cast<size_t>(data_width - 1)] * sampleSize) == sample_data.size())"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (int samples_per_line = static_cast<)",
    "insertText": "int(sample_data.size())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function ({ tinyexr::tinyexr_uint64 data_offset = 0 ;)",
    "insertText": "for(size_t c = 0; c < static_cast<size_t>(num_channels); c++)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (deep_image -> image [ c ] [ y ] = static_cast<)",
    "insertText": "float(malloc(sizeof(float) * static_cast<size_t>(samples_per_line)))"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (unsigned int ui ; unsigned int* src_ptr = reinterpret_cast<unsigned)",
    "insertText": "int(&sample_data.at(size_t(data_offset) + x * sizeof(int)))"
  },
  {
    "label": "cpy4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cpy4(&ui, src_ptr)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (deep_image -> image [ c ] [ y ] [ x ] = static_cast<)",
    "insertText": "float(ui)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} data_offset + =)",
    "insertText": "sizeof(unsigned int) * static_cast<size_t>(samples_per_line)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(channels[c].pixel_type == 1)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (tinyexr::FP16 f16 ; const unsigned short* src_ptr = reinterpret_cast<unsigned)",
    "insertText": "short(&sample_data.at(size_t(data_offset) + x * sizeof(short)))"
  },
  {
    "label": "cpy2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cpy2(&(f16.u), src_ptr)"
  },
  {
    "label": "half_to_float()",
    "kind": "Method",
    "detail": "Function (tinyexr::FP32 f32 =)",
    "insertText": "half_to_float(f16)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (deep_image -> image [ c ] [ y ] [ x ] = f32 . f ; } data_offset + =)",
    "insertText": "sizeof(short) * static_cast<size_t>(samples_per_line)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "for(size_t x = 0; x < static_cast<size_t>(samples_per_line); x++)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (float f ; const float* src_ptr = reinterpret_cast<)",
    "insertText": "float(&sample_data.at(size_t(data_offset) + x * sizeof(float)))"
  },
  {
    "label": "cpy4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cpy4(&f, src_ptr)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (deep_image -> image [ c ] [ y ] [ x ] = f ; } data_offset + =)",
    "insertText": "sizeof(float) * static_cast<size_t>(samples_per_line)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (} } } } deep_image -> width = data_width ; deep_image -> height = data_height ; deep_image -> channel_names = static_cast<const)",
    "insertText": "char(malloc(sizeof(const char *) * static_cast<size_t>(num_channels)))"
  },
  {
    "label": "_strdup()",
    "kind": "Method",
    "detail": "Function (# ifdef _WIN32 deep_image -> channel_names [ c ] =)",
    "insertText": "_strdup(channels[c].name.c_str())"
  },
  {
    "label": "strdup()",
    "kind": "Method",
    "detail": "Function (# else deep_image -> channel_names [ c ] =)",
    "insertText": "strdup(channels[c].name.c_str())"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(reinterpret_cast<void *>(const_cast<char *>(msg)))"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(exr_header->channels)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(exr_header->pixel_types)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(exr_header->pixel_types)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(exr_header->requested_pixel_types)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(exr_header->requested_pixel_types)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int i = 0; i < exr_header->num_custom_attributes; i++)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(exr_header->custom_attributes[i].value)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(exr_header->custom_attributes)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(exr_header->custom_attributes)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(exr_image->images[i])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(exr_image->images)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(exr_image->tiles)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(exr_image->tiles[tid].images[i])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(exr_image->tiles[tid].images)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(exr_image->tiles[tid].images)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "free(exr_image->tiles)"
  },
  {
    "label": "ParseEXRHeaderFromFile()",
    "kind": "Method",
    "detail": "Function (} return TINYEXR_SUCCESS ; } int)",
    "insertText": "ParseEXRHeaderFromFile(EXRHeader *exr_header, const EXRVersion *exr_version, const char *filename, const char **err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid argument for ParseEXRHeaderFromFile\", err)"
  },
  {
    "label": "buf()",
    "kind": "Method",
    "detail": "Function (std::vector<unsigned char>)",
    "insertText": "buf(filesize)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"fread() error on \" + std::string(filename), err)"
  },
  {
    "label": "ParseEXRMultipartHeaderFromMemory()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "ParseEXRMultipartHeaderFromMemory(EXRHeader ***exr_headers, int *num_headers, const EXRVersion *exr_version, const unsigned char *memory, size_t size, const char **err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid argument for ParseEXRMultipartHeaderFromMemory\", err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Data size too short\", err)"
  },
  {
    "label": "ParseEXRHeader()",
    "kind": "Method",
    "detail": "Function (std::string err_str ; bool empty_header = false ; int ret =)",
    "insertText": "ParseEXRHeader(&info, &empty_header, exr_version, &err_str, marker, marker_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (marker + = 1 ; break ; })",
    "insertText": "if(info.chunk_count == 0)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"`chunkCount' attribute is not found in the header.\", err)"
  },
  {
    "label": "header_len()",
    "kind": "Method",
    "detail": "Function (marker + = info . header_len ; size - = info .)",
    "insertText": "header_len(*exr_headers) = static_cast<EXRHeader **>(malloc(sizeof(EXRHeader *) * infos.size()))"
  },
  {
    "label": "EXRHeader()",
    "kind": "Method",
    "detail": "Function (EXRHeader* exr_header = static_cast<)",
    "insertText": "EXRHeader(malloc(sizeof(EXRHeader)))"
  },
  {
    "label": "ConvertHeader()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConvertHeader(exr_header, infos[i])"
  },
  {
    "label": "tiled()",
    "kind": "Method",
    "detail": "Function (exr_header -> tiled = exr_version ->)",
    "insertText": "tiled(*exr_headers)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid argument for ParseEXRMultipartHeaderFromFile()\", err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"`fread' error. file may be corrupted.\", err)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (version -> tiled = true ; })",
    "insertText": "if(marker[1] & 0x4)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (version -> long_name = true ; })",
    "insertText": "if(marker[1] & 0x8)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (version -> non_image = true ; })",
    "insertText": "if(marker[1] & 0x10)"
  },
  {
    "label": "LoadEXRMultipartImageFromMemory()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "LoadEXRMultipartImageFromMemory(EXRImage *exr_images, const EXRHeader **exr_headers, unsigned int num_parts, const unsigned char *memory, const size_t size, const char **err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid argument for LoadEXRMultipartImageFromMemory()\", err)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (marker + = 1 ; std::vector<std::vector<tinyexr::tinyexr_uint64>> chunk_offset_table_list ;)",
    "insertText": "for(size_t i = 0; i < static_cast<size_t>(num_parts); i++)"
  },
  {
    "label": "offset_table()",
    "kind": "Method",
    "detail": "Function (std::vector<tinyexr::tinyexr_uint64>)",
    "insertText": "offset_table(static_cast<size_t>(exr_headers[i]->chunk_count))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (tinyexr::tinyexr_uint64 offset ;)",
    "insertText": "memcpy(&offset, marker, 8)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid offset size in EXR header chunks.\", err)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::vector<tinyexr::tinyexr_uint64>& offset_table = chunk_offset_table_list [ i ] ;)",
    "insertText": "for(size_t c = 0; c < offset_table.size(); c++)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (const unsigned char* part_number_addr = memory + offset_table [ c ] - 4 ; unsigned int part_no ;)",
    "insertText": "memcpy(&part_no, part_number_addr, sizeof(unsigned int))"
  },
  {
    "label": "swap4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap4(&part_no)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid `part number' in EXR header chunks.\", err)"
  },
  {
    "label": "LoadEXRMultipartImageFromFile()",
    "kind": "Method",
    "detail": "Function (} return ret ; } } return TINYEXR_SUCCESS ; } int)",
    "insertText": "LoadEXRMultipartImageFromFile(EXRImage *exr_images, const EXRHeader **exr_headers, unsigned int num_parts, const char *filename, const char **err)"
  },
  {
    "label": "SetErrorMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetErrorMessage(\"Invalid argument for LoadEXRMultipartImageFromFile\", err)"
  },
  {
    "label": "LoadEXRMultipartImageFromMemory()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "LoadEXRMultipartImageFromMemory(exr_images, exr_headers, num_parts, &buf.at(0), filesize, err)"
  },
  {
    "label": "SaveEXR()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "SaveEXR(const float *data, int width, int height, int components, const int save_as_fp16, const char *outfilename, const char **err)"
  },
  {
    "label": "InitEXRImage()",
    "kind": "Method",
    "detail": "Function (header . compression_type = TINYEXR_COMPRESSIONTYPE_NONE ; } else { header . compression_type = TINYEXR_COMPRESSIONTYPE_ZIP ; } EXRImage image ;)",
    "insertText": "InitEXRImage(&image)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (image . num_channels = components ; std::vector<float> images [ 4 ] ;)",
    "insertText": "if(components == 1)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (images [ 0 ] .)",
    "insertText": "resize(static_cast<size_t>(width * height))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(images[0].data(), data, sizeof(float) * size_t(width * height))"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (images [ 0 ] [ i ] = data [ static_cast<)",
    "insertText": "size_t(components)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } float* image_ptr [ 4 ] = { 0,0,0,0 } ;)",
    "insertText": "if(components == 4)"
  },
  {
    "label": "image_ptr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "image_ptr(images[3].at(0))"
  },
  {
    "label": "image_ptr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "image_ptr(images[2].at(0))"
  },
  {
    "label": "image_ptr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "image_ptr(images[1].at(0))"
  },
  {
    "label": "image_ptr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "image_ptr(images[0].at(0))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(components == 3)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (} image . images = reinterpret_cast<unsigned)",
    "insertText": "char(image_ptr)"
  },
  {
    "label": "EXRChannelInfo()",
    "kind": "Method",
    "detail": "Function (image . width = width ; image . height = height ; header . num_channels = components ; header . channels = static_cast<)",
    "insertText": "EXRChannelInfo(malloc( sizeof(EXRChannelInfo) * static_cast<size_t>(header.num_channels)))"
  },
  {
    "label": "strncpy_s()",
    "kind": "Method",
    "detail": "Function (# ifdef _MSC_VER)",
    "insertText": "strncpy_s(header.channels[0].name, \"A\", 255)"
  },
  {
    "label": "strncpy_s()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "strncpy_s(header.channels[1].name, \"B\", 255)"
  },
  {
    "label": "strncpy_s()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "strncpy_s(header.channels[2].name, \"G\", 255)"
  },
  {
    "label": "strncpy_s()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "strncpy_s(header.channels[3].name, \"R\", 255)"
  },
  {
    "label": "strncpy()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "strncpy(header.channels[0].name, \"A\", 255)"
  },
  {
    "label": "strncpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "strncpy(header.channels[1].name, \"B\", 255)"
  },
  {
    "label": "strncpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "strncpy(header.channels[2].name, \"G\", 255)"
  },
  {
    "label": "strncpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "strncpy(header.channels[3].name, \"R\", 255)"
  },
  {
    "label": "strlen()",
    "kind": "Method",
    "detail": "Function (# endif header . channels [ 0 ] . name [)",
    "insertText": "strlen(\"A\")"
  },
  {
    "label": "strlen()",
    "kind": "Method",
    "detail": "Function (header . channels [ 1 ] . name [)",
    "insertText": "strlen(\"B\")"
  },
  {
    "label": "strlen()",
    "kind": "Method",
    "detail": "Function (header . channels [ 2 ] . name [)",
    "insertText": "strlen(\"G\")"
  },
  {
    "label": "strlen()",
    "kind": "Method",
    "detail": "Function (header . channels [ 3 ] . name [)",
    "insertText": "strlen(\"R\")"
  },
  {
    "label": "strncpy_s()",
    "kind": "Method",
    "detail": "Function (# ifdef _MSC_VER)",
    "insertText": "strncpy_s(header.channels[0].name, \"B\", 255)"
  },
  {
    "label": "strncpy_s()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "strncpy_s(header.channels[1].name, \"G\", 255)"
  },
  {
    "label": "strncpy_s()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "strncpy_s(header.channels[2].name, \"R\", 255)"
  },
  {
    "label": "strncpy()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "strncpy(header.channels[0].name, \"B\", 255)"
  },
  {
    "label": "strncpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "strncpy(header.channels[1].name, \"G\", 255)"
  },
  {
    "label": "strncpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "strncpy(header.channels[2].name, \"R\", 255)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} header . pixel_types = static_cast<)",
    "insertText": "int(malloc(sizeof(int) * static_cast<size_t>(header.num_channels)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (header . pixel_types [ i ] = TINYEXR_PIXELTYPE_FLOAT ;)",
    "insertText": "if(save_as_fp16 > 0)"
  },
  {
    "label": "SaveEXRImageToFile()",
    "kind": "Method",
    "detail": "Function (header . requested_pixel_types [ i ] = TINYEXR_PIXELTYPE_HALF ; } else { header . requested_pixel_types [ i ] = TINYEXR_PIXELTYPE_FLOAT ; } } int ret =)",
    "insertText": "SaveEXRImageToFile(&image, &header, outfilename, err)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(header.pixel_types)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(header.requested_pixel_types)"
  }
]