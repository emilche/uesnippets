[
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "RefCounted",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RefCounted"
  },
  {
    "label": "DefaultRefCountedTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DefaultRefCountedTraits"
  },
  {
    "label": "RefCountedThreadSafe",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RefCountedThreadSafe"
  },
  {
    "label": "DefaultRefCountedThreadSafeTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DefaultRefCountedThreadSafeTraits"
  },
  {
    "label": "RefCountedData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RefCountedData"
  },
  {
    "label": "base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "base"
  },
  {
    "label": "RefCountedBase()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_MEMORY_REF_COUNTED_H_ # define BASE_MEMORY_REF_COUNTED_H_ # include<stddef . h> # include<utility> # include \" base / atomic_ref_count . h \" # include \" base / base_export . h \" # include \" base / check . h \" # include \" base / check_op . h \" # include \" base / compiler_specific . h \" # include \" base / dcheck_is_on . h \" # include \" base / gtest_prod_util . h \" # include \" base / memory / scoped_refptr . h \" # include \" base / sequence_checker . h \" # include \" base / template_util . h \" # include \" base / threading / thread_collision_warner . h \" # include \" build / build_config . h \" # include \" third_party / abseil - cpp / absl / utility / utility . h \" namespace base { namespace subtle { class BASE_EXPORT RefCountedBase { public :)",
    "insertText": "RefCountedBase(const RefCountedBase&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (RefCountedBase&)",
    "insertText": "operator(const RefCountedBase&)"
  },
  {
    "label": "HasOneRef()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasOneRef()"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON() sequence_checker_.DetachFromSequence()"
  },
  {
    "label": "RefCountedBase()",
    "kind": "Method",
    "detail": "Function (# endif })",
    "insertText": "RefCountedBase(StartRefCountFromOneTag) : ref_count_(1)"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON()"
  },
  {
    "label": "DetachFromSequence()",
    "kind": "Method",
    "detail": "Function (sequence_checker_ .)",
    "insertText": "DetachFromSequence()"
  },
  {
    "label": "RefCountedBase()",
    "kind": "Method",
    "detail": "Function (# endif } ~)",
    "insertText": "RefCountedBase()"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON() DCHECK(in_dtor_)"
  },
  {
    "label": "AddRef()",
    "kind": "Method",
    "detail": "Function (# endif } void)",
    "insertText": "AddRef()"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON() DCHECK(!in_dtor_)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(!needs_adopt_ref_)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(CalledOnValidSequence())"
  },
  {
    "label": "AddRefImpl()",
    "kind": "Method",
    "detail": "Function (} # endif)",
    "insertText": "AddRefImpl()"
  },
  {
    "label": "Release()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Release()"
  },
  {
    "label": "ReleaseImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseImpl()"
  },
  {
    "label": "IsOnValidSequence()",
    "kind": "Method",
    "detail": "Function (# endif return ref_count_ = = 0 ; } bool)",
    "insertText": "IsOnValidSequence()"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON() return ref_count_ <= 1 || CalledOnValidSequence()"
  },
  {
    "label": "AdoptRef()",
    "kind": "Method",
    "detail": "Function (# else return true ; # endif } private : template<U> scoped_refptr<U>)",
    "insertText": "AdoptRef(U*)"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(RefCountedDeathTest, TestOverflowCheck)"
  },
  {
    "label": "Adopted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Adopted()"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON() DCHECK(needs_adopt_ref_)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (needs_adopt_ref_ = false ; # endif } # if)",
    "insertText": "defined(ARCH_CPU_64_BITS) void AddRefImpl()"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (- - ref_count_ ; } # endif # if)",
    "insertText": "DCHECK_IS_ON() bool CalledOnValidSequence()"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# endif uint32_t ref_count_ = 0 ;)",
    "insertText": "static_assert(std::is_unsigned<decltype(ref_count_)>::value, \"ref_count_ must be an unsigned type.\")"
  },
  {
    "label": "DFAKE_MUTEX()",
    "kind": "Method",
    "detail": "Function (bool in_dtor_ = false ; SequenceChecker sequence_checker_ ; # endif)",
    "insertText": "DFAKE_MUTEX(add_release_)"
  },
  {
    "label": "RefCountedThreadSafeBase()",
    "kind": "Method",
    "detail": "Function (} ; class BASE_EXPORT RefCountedThreadSafeBase { public :)",
    "insertText": "RefCountedThreadSafeBase(const RefCountedThreadSafeBase&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (RefCountedThreadSafeBase&)",
    "insertText": "operator(const RefCountedThreadSafeBase&)"
  },
  {
    "label": "HasAtLeastOneRef()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasAtLeastOneRef()"
  },
  {
    "label": "RefCountedThreadSafeBase()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "RefCountedThreadSafeBase(StartRefCountFromZeroTag)"
  },
  {
    "label": "RefCountedThreadSafeBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RefCountedThreadSafeBase(StartRefCountFromOneTag) : ref_count_(1)"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# endif } # if)",
    "insertText": "DCHECK_IS_ON() ~RefCountedThreadSafeBase()"
  },
  {
    "label": "RefCountedThreadSafeBase()",
    "kind": "Method",
    "detail": "Function (# else ~)",
    "insertText": "RefCountedThreadSafeBase()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # if)",
    "insertText": "defined(ARCH_CPU_X86_FAMILY) || defined(__ARM_FEATURE_ATOMICS) bool Release()"
  },
  {
    "label": "AddRefWithCheck()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddRefWithCheck()"
  },
  {
    "label": "AddRefWithCheckImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddRefWithCheckImpl()"
  },
  {
    "label": "Increment()",
    "kind": "Method",
    "detail": "Function (# endif ref_count_ .)",
    "insertText": "Increment()"
  },
  {
    "label": "CHECK_GT()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "CHECK_GT(ref_count_.Increment(), 0)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(!ref_count_.IsZero())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(!ref_count_.Decrement())"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (bool in_dtor_ = false ; # endif } ; } class BASE_EXPORT ScopedAllowCrossThreadRefCountAccess final { public : # if)",
    "insertText": "DCHECK_IS_ON() ScopedAllowCrossThreadRefCountAccess()"
  },
  {
    "label": "ScopedAllowCrossThreadRefCountAccess()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "ScopedAllowCrossThreadRefCountAccess()"
  },
  {
    "label": "REQUIRE_ADOPTION_FOR_REFCOUNTED_TYPE()",
    "kind": "Method",
    "detail": "Function (} # endif } ; # define)",
    "insertText": "REQUIRE_ADOPTION_FOR_REFCOUNTED_TYPE()"
  },
  {
    "label": "Destruct()",
    "kind": "Method",
    "detail": "Function (template<T> struct DefaultRefCountedTraits { void)",
    "insertText": "Destruct(const T* x)"
  },
  {
    "label": "DeleteInternal()",
    "kind": "Method",
    "detail": "Function (RefCounted<T,DefaultRefCountedTraits)",
    "insertText": "DeleteInternal(x)"
  },
  {
    "label": "RefCounted()",
    "kind": "Method",
    "detail": "Function (} } ; template<class T,Traits = DefaultRefCountedTraits<T>> class RefCounted : public subtle::RefCountedBase { public : subtle::StartRefCountFromZeroTag kRefCountPreference = subtle::kStartRefCountFromZeroTag ;)",
    "insertText": "RefCounted() : subtle::RefCountedBase(T::kRefCountPreference)"
  },
  {
    "label": "RefCounted()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RefCounted(const RefCounted&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (RefCounted&)",
    "insertText": "operator(const RefCounted&)"
  },
  {
    "label": "ANALYZER_SKIP_THIS_PATH()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ANALYZER_SKIP_THIS_PATH()"
  },
  {
    "label": "Destruct()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destruct(static_cast<const T*>(this))"
  },
  {
    "label": "RefCounted()",
    "kind": "Method",
    "detail": "Function (} } protected : ~)",
    "insertText": "RefCounted()"
  },
  {
    "label": "DeleteInternal()",
    "kind": "Method",
    "detail": "Function (private : struct DefaultRefCountedTraits<T> ; template<U> void)",
    "insertText": "DeleteInternal(const U* x)"
  },
  {
    "label": "RefCountedThreadSafe()",
    "kind": "Method",
    "detail": "Function (} } ; template<class T,Traits = DefaultRefCountedThreadSafeTraits<T>> class RefCountedThreadSafe : public subtle::RefCountedThreadSafeBase { public : subtle::StartRefCountFromZeroTag kRefCountPreference = subtle::kStartRefCountFromZeroTag ;)",
    "insertText": "RefCountedThreadSafe() : subtle::RefCountedThreadSafeBase(T::kRefCountPreference)"
  },
  {
    "label": "RefCountedThreadSafe()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RefCountedThreadSafe(const RefCountedThreadSafe&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (RefCountedThreadSafe&)",
    "insertText": "operator(const RefCountedThreadSafe&)"
  },
  {
    "label": "AddRefImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddRefImpl(T::kRefCountPreference)"
  },
  {
    "label": "RefCountedThreadSafe()",
    "kind": "Method",
    "detail": "Function (} } protected : ~)",
    "insertText": "RefCountedThreadSafe()"
  },
  {
    "label": "AddRefImpl()",
    "kind": "Method",
    "detail": "Function (delete x ; } void)",
    "insertText": "AddRefImpl(subtle::StartRefCountFromZeroTag)"
  },
  {
    "label": "AddRefImpl()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddRefImpl(subtle::StartRefCountFromOneTag)"
  },
  {
    "label": "RefCountedData()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> class RefCountedData : public base::RefCountedThreadSafe<base::RefCountedData<T>> { public :)",
    "insertText": "RefCountedData() : data()"
  },
  {
    "label": "RefCountedData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RefCountedData(const T& in_value) : data(in_value)"
  },
  {
    "label": "RefCountedData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RefCountedData(T&& in_value) : data(std::move(in_value))"
  },
  {
    "label": "RefCountedData()",
    "kind": "Method",
    "detail": "Function (} template<. . . Args>)",
    "insertText": "RefCountedData(absl::in_place_t, Args&&... args) : data(std::forward<Args>(args)...)"
  },
  {
    "label": "RefCountedData()",
    "kind": "Method",
    "detail": "Function (} T data ; private : class base::RefCountedThreadSafe<base::RefCountedData<T>> ; ~)",
    "insertText": "RefCountedData()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<T> bool)",
    "insertText": "operator(const RefCountedData<T>& lhs, const RefCountedData<T>& rhs)"
  }
]