[
  {
    "label": "CCritSec",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CCritSec"
  },
  {
    "label": "CAutoLock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CAutoLock"
  },
  {
    "label": "CAMEvent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CAMEvent"
  },
  {
    "label": "CAMMsgEvent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CAMMsgEvent"
  },
  {
    "label": "AM_NOVTABLE",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AM_NOVTABLE"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "CQueue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CQueue"
  },
  {
    "label": "QzCComPtr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "QzCComPtr"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (# ifndef __WXUTIL__ # define __WXUTIL__ # pragma)",
    "insertText": "warning(disable: 4705)"
  },
  {
    "label": "CCritSec()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CCritSec(const CCritSec &refCritSec)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (CCritSec&)",
    "insertText": "operator(const CCritSec &refCritSec)"
  },
  {
    "label": "CCritSec()",
    "kind": "Method",
    "detail": "Function (CRITICAL_SECTION m_CritSec ; # ifdef DEBUG public : DWORD m_currentOwner ; DWORD m_lockCount ; BOOL m_fTrace ; public :)",
    "insertText": "CCritSec()"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Lock()"
  },
  {
    "label": "Unlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unlock()"
  },
  {
    "label": "InitializeCriticalSection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeCriticalSection(&m_CritSec)"
  },
  {
    "label": "DeleteCriticalSection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DeleteCriticalSection(&m_CritSec)"
  },
  {
    "label": "EnterCriticalSection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnterCriticalSection(&m_CritSec)"
  },
  {
    "label": "LeaveCriticalSection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LeaveCriticalSection(&m_CritSec)"
  },
  {
    "label": "CritCheckIn()",
    "kind": "Method",
    "detail": "Function (} ; # endif } ; # ifdef DEBUG BOOL WINAPI)",
    "insertText": "CritCheckIn(CCritSec * pcCrit)"
  },
  {
    "label": "CritCheckIn()",
    "kind": "Method",
    "detail": "Function (BOOL WINAPI)",
    "insertText": "CritCheckIn(const CCritSec * pcCrit)"
  },
  {
    "label": "CritCheckOut()",
    "kind": "Method",
    "detail": "Function (BOOL WINAPI)",
    "insertText": "CritCheckOut(CCritSec * pcCrit)"
  },
  {
    "label": "CritCheckOut()",
    "kind": "Method",
    "detail": "Function (BOOL WINAPI)",
    "insertText": "CritCheckOut(const CCritSec * pcCrit)"
  },
  {
    "label": "DbgLockTrace()",
    "kind": "Method",
    "detail": "Function (void WINAPI)",
    "insertText": "DbgLockTrace(CCritSec * pcCrit, BOOL fTrace)"
  },
  {
    "label": "CritCheckIn()",
    "kind": "Method",
    "detail": "Function (# else # define)",
    "insertText": "CritCheckIn(x) TRUE #define CritCheckOut(x) TRUE #define DbgLockTrace(pc, fT)"
  },
  {
    "label": "CAutoLock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CAutoLock(const CAutoLock &refAutoLock)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (CAutoLock&)",
    "insertText": "operator(const CAutoLock &refAutoLock)"
  },
  {
    "label": "CAutoLock()",
    "kind": "Method",
    "detail": "Function (protected : CCritSec* m_pLock ; public :)",
    "insertText": "CAutoLock(CCritSec * plock)"
  },
  {
    "label": "CAutoLock()",
    "kind": "Method",
    "detail": "Function (} ; ~)",
    "insertText": "CAutoLock()"
  },
  {
    "label": "CAMEvent()",
    "kind": "Method",
    "detail": "Function (} ; } ; class CAMEvent {)",
    "insertText": "CAMEvent(const CAMEvent &refEvent)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (CAMEvent&)",
    "insertText": "operator(const CAMEvent &refEvent)"
  },
  {
    "label": "CAMEvent()",
    "kind": "Method",
    "detail": "Function (protected : HANDLE m_hEvent ; public :)",
    "insertText": "CAMEvent(BOOL fManualReset = FALSE, __inout_opt HRESULT *phr = NULL)"
  },
  {
    "label": "CAMEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CAMEvent(__inout_opt HRESULT *phr)"
  },
  {
    "label": "CAMEvent()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "CAMEvent()"
  },
  {
    "label": "HANDLE()",
    "kind": "Method",
    "detail": "Function (operator)",
    "insertText": "HANDLE()"
  },
  {
    "label": "EXECUTE_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EXECUTE_ASSERT(SetEvent(m_hEvent))"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (} ; BOOL)",
    "insertText": "Wait(DWORD dwTimeout = INFINITE)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} ; void)",
    "insertText": "Reset()"
  },
  {
    "label": "ResetEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetEvent(m_hEvent)"
  },
  {
    "label": "Check()",
    "kind": "Method",
    "detail": "Function (} ; BOOL)",
    "insertText": "Check()"
  },
  {
    "label": "CAMMsgEvent()",
    "kind": "Method",
    "detail": "Function (} ; } ; class CAMMsgEvent : public CAMEvent { public :)",
    "insertText": "CAMMsgEvent(__inout_opt HRESULT *phr = NULL)"
  },
  {
    "label": "WaitMsg()",
    "kind": "Method",
    "detail": "Function (BOOL)",
    "insertText": "WaitMsg(DWORD dwTimeout = INFINITE)"
  },
  {
    "label": "CAMThread()",
    "kind": "Method",
    "detail": "Function (} ; # define CTimeoutEvent CAMEvent # ifdef AM_NOVTABLE class AM_NOVTABLE CAMThread {)",
    "insertText": "CAMThread(const CAMThread &refThread)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (CAMThread&)",
    "insertText": "operator(const CAMThread &refThread)"
  },
  {
    "label": "ThreadProc()",
    "kind": "Method",
    "detail": "Function (CAMEvent m_EventSend ; CAMEvent m_EventComplete ; DWORD m_dwParam ; DWORD m_dwReturnVal ; protected : HANDLE m_hThread ; DWORD)",
    "insertText": "ThreadProc()"
  },
  {
    "label": "CAMThread()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "CAMThread(__inout_opt HRESULT *phr = NULL)"
  },
  {
    "label": "CAMThread()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "CAMThread()"
  },
  {
    "label": "InitialThreadProc()",
    "kind": "Method",
    "detail": "Function (CCritSec m_AccessLock ; CCritSec m_WorkerLock ; DWORD WINAPI)",
    "insertText": "InitialThreadProc(__inout LPVOID pv)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (BOOL)",
    "insertText": "Create()"
  },
  {
    "label": "CallWorker()",
    "kind": "Method",
    "detail": "Function (DWORD)",
    "insertText": "CallWorker(DWORD)"
  },
  {
    "label": "Close()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Close()"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (# pragma)",
    "insertText": "warning(push) #pragma warning(disable: 4312) HANDLE hThread = (HANDLE)InterlockedExchangePointer(&m_hThread, 0)"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (# pragma)",
    "insertText": "warning(pop) if (hThread)"
  },
  {
    "label": "WaitForSingleObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WaitForSingleObject(hThread, INFINITE)"
  },
  {
    "label": "CloseHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CloseHandle(hThread)"
  },
  {
    "label": "ThreadExists()",
    "kind": "Method",
    "detail": "Function (} } ; BOOL)",
    "insertText": "ThreadExists(void)"
  },
  {
    "label": "CheckRequest()",
    "kind": "Method",
    "detail": "Function (BOOL)",
    "insertText": "CheckRequest(__out_opt DWORD * pParam)"
  },
  {
    "label": "Reply()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reply(DWORD)"
  },
  {
    "label": "GetRequestHandle()",
    "kind": "Method",
    "detail": "Function (HANDLE)",
    "insertText": "GetRequestHandle()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (} ; # endif # define DEFAULT_QUEUESIZE 2 template<class T> class CQueue { private : HANDLE hSemPut ; HANDLE hSemGet ; CRITICAL_SECTION CritSect ; int nMax ; int iNextPut ; int iNextGet ; T* QueueObjects ; void)",
    "insertText": "Initialize(int n)"
  },
  {
    "label": "InitializeCriticalSection()",
    "kind": "Method",
    "detail": "Function (iNextPut = iNextGet = 0 ; nMax = n ;)",
    "insertText": "InitializeCriticalSection(&CritSect)"
  },
  {
    "label": "CreateSemaphore()",
    "kind": "Method",
    "detail": "Function (hSemPut =)",
    "insertText": "CreateSemaphore(NULL, n, n, NULL)"
  },
  {
    "label": "CreateSemaphore()",
    "kind": "Method",
    "detail": "Function (hSemGet =)",
    "insertText": "CreateSemaphore(NULL, 0, n, NULL)"
  },
  {
    "label": "CQueue()",
    "kind": "Method",
    "detail": "Function (QueueObjects = new T [ n ] ; } public :)",
    "insertText": "CQueue(int n)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Initialize(n)"
  },
  {
    "label": "CQueue()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CQueue()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Initialize(DEFAULT_QUEUESIZE)"
  },
  {
    "label": "DeleteCriticalSection()",
    "kind": "Method",
    "detail": "Function (delete [ ] QueueObjects ;)",
    "insertText": "DeleteCriticalSection(&CritSect)"
  },
  {
    "label": "CloseHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CloseHandle(hSemPut)"
  },
  {
    "label": "CloseHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CloseHandle(hSemGet)"
  },
  {
    "label": "GetQueueObject()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "GetQueueObject()"
  },
  {
    "label": "WaitForSingleObject()",
    "kind": "Method",
    "detail": "Function (int iSlot ; T Object ; LONG lPrevious ;)",
    "insertText": "WaitForSingleObject(hSemGet, INFINITE)"
  },
  {
    "label": "EnterCriticalSection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnterCriticalSection(&CritSect)"
  },
  {
    "label": "LeaveCriticalSection()",
    "kind": "Method",
    "detail": "Function (iSlot = iNextGet + + % nMax ; Object = QueueObjects [ iSlot ] ;)",
    "insertText": "LeaveCriticalSection(&CritSect)"
  },
  {
    "label": "ReleaseSemaphore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseSemaphore(hSemPut, 1L, &lPrevious)"
  },
  {
    "label": "WaitForSingleObject()",
    "kind": "Method",
    "detail": "Function (int iSlot ; LONG lPrevious ;)",
    "insertText": "WaitForSingleObject(hSemPut, INFINITE)"
  },
  {
    "label": "ReleaseSemaphore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseSemaphore(hSemGet, 1L, &lPrevious)"
  },
  {
    "label": "AMSafeMemMoveOffset()",
    "kind": "Method",
    "detail": "Function (} } ; HRESULT)",
    "insertText": "AMSafeMemMoveOffset(__in_bcount(dst_size) void * dst, __in size_t dst_size, __in DWORD cb_dst_offset, __in_bcount(src_size) const void * src, __in size_t src_size, __in DWORD cb_src_offset, __in size_t count)"
  },
  {
    "label": "memmoveInternal()",
    "kind": "Method",
    "detail": "Function (\" C \" void* __stdcall)",
    "insertText": "memmoveInternal(void *, const void *, size_t)"
  },
  {
    "label": "memchrInternal()",
    "kind": "Method",
    "detail": "Function (void* __cdecl)",
    "insertText": "memchrInternal(const void *buf, int chr, size_t cnt)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (# ifdef _X86_ void* pRet = NULL ; _asm { cld mov ecx,cnt mov edi,buf mov eax,chr repne scasb jnz exit_memchr dec edi mov pRet,edi exit_memchr : } return pRet ; # else)",
    "insertText": "while(cnt && (*(unsigned char *)buf != (unsigned char)chr))"
  },
  {
    "label": "buf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "buf(unsigned char *)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (cnt - - ; })",
    "insertText": "return(cnt ? (void *)buf : NULL)"
  },
  {
    "label": "IntToWstr()",
    "kind": "Method",
    "detail": "Function (# endif } void WINAPI)",
    "insertText": "IntToWstr(int i, __out_ecount(12) LPWSTR wstr)"
  },
  {
    "label": "WstrToInt()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "WstrToInt(sz) _wtoi(sz) #define atoiW(sz) _wtoi(sz) #define atoiA(sz) atoi(sz)"
  },
  {
    "label": "STDAPI_()",
    "kind": "Method",
    "detail": "Function (const DWORD bits565 [ 3 ] ; const DWORD bits888 [ 3 ] ;)",
    "insertText": "STDAPI_(const GUID) GetTrueColorType(const BITMAPINFOHEADER *pbmiHeader)"
  },
  {
    "label": "STDAPI_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STDAPI_(const GUID) GetBitmapSubtype(const BITMAPINFOHEADER *pbmiHeader)"
  },
  {
    "label": "STDAPI_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STDAPI_(WORD) GetBitCount(const GUID *pSubtype)"
  },
  {
    "label": "STDAPI_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STDAPI_(CHAR *) GetSubtypeNameA(const GUID *pSubtype)"
  },
  {
    "label": "STDAPI_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STDAPI_(WCHAR *) GetSubtypeNameW(const GUID *pSubtype)"
  },
  {
    "label": "STDAPI_()",
    "kind": "Method",
    "detail": "Function (# ifdef UNICODE # define GetSubtypeName GetSubtypeNameW # else # define GetSubtypeName GetSubtypeNameA # endif)",
    "insertText": "STDAPI_(LONG) GetBitmapFormatSize(const BITMAPINFOHEADER *pHeader)"
  },
  {
    "label": "STDAPI_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STDAPI_(DWORD) GetBitmapSize(const BITMAPINFOHEADER *pHeader)"
  },
  {
    "label": "STDAPI_()",
    "kind": "Method",
    "detail": "Function (# ifdef __AMVIDEO__)",
    "insertText": "STDAPI_(BOOL) ContainsPalette(const VIDEOINFOHEADER *pVideoInfo)"
  },
  {
    "label": "STDAPI_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STDAPI_(const RGBQUAD *) GetBitmapPalette(const VIDEOINFOHEADER *pVideoInfo)"
  },
  {
    "label": "IsEqualObject()",
    "kind": "Method",
    "detail": "Function (# endif BOOL WINAPI)",
    "insertText": "IsEqualObject(IUnknown *pFirst, IUnknown *pSecond)"
  },
  {
    "label": "EqualPins()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "EqualPins(pPin1, pPin2) IsEqualObject(pPin1, pPin2) LONGLONG WINAPI llMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG rnd)"
  },
  {
    "label": "Int64x32Div32()",
    "kind": "Method",
    "detail": "Function (LONGLONG WINAPI)",
    "insertText": "Int64x32Div32(LONGLONG a, LONG b, LONG c, LONG rnd)"
  },
  {
    "label": "WriteBSTR()",
    "kind": "Method",
    "detail": "Function (STDAPI)",
    "insertText": "WriteBSTR(__deref_out BSTR * pstrDest, LPCWSTR szSrc)"
  },
  {
    "label": "FreeBSTR()",
    "kind": "Method",
    "detail": "Function (STDAPI)",
    "insertText": "FreeBSTR(__deref_in BSTR* pstr)"
  },
  {
    "label": "AMGetWideString()",
    "kind": "Method",
    "detail": "Function (STDAPI)",
    "insertText": "AMGetWideString(LPCWSTR pszString, __deref_out LPWSTR *ppszReturn)"
  },
  {
    "label": "WaitDispatchingMessages()",
    "kind": "Method",
    "detail": "Function (DWORD WINAPI)",
    "insertText": "WaitDispatchingMessages(HANDLE hObject, DWORD dwWait, HWND hwnd = NULL, UINT uMsg = 0, HANDLE hEvent = NULL)"
  },
  {
    "label": "AmHresultFromWin32()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "AmHresultFromWin32(x) (MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, x)) HRESULT AmGetLastErrorToHResult(void)"
  },
  {
    "label": "QzAtlComPtrAssign()",
    "kind": "Method",
    "detail": "Function (IUnknown*)",
    "insertText": "QzAtlComPtrAssign(__deref_inout_opt IUnknown** pp, __in_opt IUnknown* lp)"
  },
  {
    "label": "QzCComPtr()",
    "kind": "Method",
    "detail": "Function (template<class T> class QzCComPtr { public : typedef T _PtrClass ;)",
    "insertText": "QzCComPtr()"
  },
  {
    "label": "QzCComPtr()",
    "kind": "Method",
    "detail": "Function (p = NULL ; })",
    "insertText": "QzCComPtr(T* lp)"
  },
  {
    "label": "QzCComPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "QzCComPtr(const QzCComPtr<T>& lp)"
  },
  {
    "label": "Release()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Release()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (p = NULL ; } operator)",
    "insertText": "T()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "operator()"
  },
  {
    "label": "ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ASSERT(p!=NULL)"
  },
  {
    "label": "ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ASSERT(p==NULL)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} T*)",
    "insertText": "operator(const QzCComPtr<T>& lp)"
  },
  {
    "label": "CompatibleTimeSetEvent()",
    "kind": "Method",
    "detail": "Function (} # endif T* p ; } ; MMRESULT)",
    "insertText": "CompatibleTimeSetEvent(UINT uDelay, UINT uResolution, __in LPTIMECALLBACK lpTimeProc, DWORD_PTR dwUser, UINT fuEvent)"
  },
  {
    "label": "TimeKillSynchronousFlagAvailable()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TimeKillSynchronousFlagAvailable(void)"
  },
  {
    "label": "lstrcmpiLocaleIndependentW()",
    "kind": "Method",
    "detail": "Function (__inline int)",
    "insertText": "lstrcmpiLocaleIndependentW(LPCWSTR lpsz1, LPCWSTR lpsz2)"
  },
  {
    "label": "lstrcmpiLocaleIndependentA()",
    "kind": "Method",
    "detail": "Function (} __inline int)",
    "insertText": "lstrcmpiLocaleIndependentA(LPCSTR lpsz1, LPCSTR lpsz2)"
  }
]