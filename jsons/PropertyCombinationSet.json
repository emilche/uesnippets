[
  {
    "label": "TPropertyCombinationSet",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPropertyCombinationSet"
  },
  {
    "label": "FIterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FIterator"
  },
  {
    "label": "FPropertyCombinationSetTest",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPropertyCombinationSetTest"
  },
  {
    "label": "TPropertyCombinationSetHardcoded",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPropertyCombinationSetHardcoded"
  },
  {
    "label": "FPropertyCombinationPack2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPropertyCombinationPack2"
  },
  {
    "label": "FPropertyCombinationPack3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPropertyCombinationPack3"
  },
  {
    "label": "StorageWordCount()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Algo / IsSorted . h \" # include \" Containers / ArrayView . h \" # include \" Containers / BitArray . h \" # include \" HAL / UnrealMemory . h \" # include \" Misc / AssertionMacros . h \" template<int BitWidth> class TPropertyCombinationSet { public : uint32 StorageBitCount = 1<<BitWidth ; uint32)",
    "insertText": "StorageWordCount(StorageBitCount + NumBitsPerDWORD - 1)"
  },
  {
    "label": "TPropertyCombinationSet()",
    "kind": "Method",
    "detail": "Function (uint32 MaxValue = StorageBitCount - 1 ; public :)",
    "insertText": "TPropertyCombinationSet()"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Construct()"
  },
  {
    "label": "Memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memset(Storage, 0)"
  },
  {
    "label": "AddNoCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddNoCheck(0)"
  },
  {
    "label": "TPropertyCombinationSet()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TPropertyCombinationSet(const TPropertyCombinationSet<BitWidth>& Other)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(Storage, Other.Storage, sizeof(Storage))"
  },
  {
    "label": "TPropertyCombinationSet()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TPropertyCombinationSet(const TBitArray<>& ArchivedBits, uint32 BitOffset = 0)"
  },
  {
    "label": "Load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Load(ArchivedBits, BitOffset)"
  },
  {
    "label": "Load()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Load(const TBitArray<>& ArchiveBits, uint32 BitOffset)"
  },
  {
    "label": "GetRange()",
    "kind": "Method",
    "detail": "Function (ArchiveBits .)",
    "insertText": "GetRange(BitOffset, StorageBitCount, Storage)"
  },
  {
    "label": "Save()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Save(TBitArray<>& ArchiveBits, uint32 BitOffset)"
  },
  {
    "label": "SetRangeFromRange()",
    "kind": "Method",
    "detail": "Function (ArchiveBits .)",
    "insertText": "SetRangeFromRange(BitOffset, StorageBitCount, Storage)"
  },
  {
    "label": "Load()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Load(const uint32* ArchiveBits)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(Storage, ArchiveBits, sizeof(Storage))"
  },
  {
    "label": "Save()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Save(uint32* ArchiveBits)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(ArchiveBits, Storage, sizeof(Storage))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Add(uint32 PropertyCombination)"
  },
  {
    "label": "RemoveRedundantPropertyCombinationsNoCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveRedundantPropertyCombinationsNoCheck(PropertyCombination)"
  },
  {
    "label": "AddRange()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddRange(TPropertyCombinationSet<BitWidth>& Other)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(Value)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "Contains(uint32 Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TPropertyCombinationSet<BitWidth>& Other)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (+ + Value ; uint32 Max = StorageBitCount ;)",
    "insertText": "while(Value < Max && !Array.ContainsNoCheck(Value))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (+ + Value ; } return* this ; } uint32)",
    "insertText": "operator()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} TPropertyCombinationSet& Array ; uint32 Value ; } ; FIterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} FIterator)",
    "insertText": "end()"
  },
  {
    "label": "AddNoCheck()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddNoCheck(uint32 Value)"
  },
  {
    "label": "NumBitsPerDWORD()",
    "kind": "Method",
    "detail": "Function (Storage [ Value /)",
    "insertText": "NumBitsPerDWORD(1 << (Value & (NumBitsPerDWORD - 1)))"
  },
  {
    "label": "RemoveNoCheck()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveNoCheck(uint32 Value)"
  },
  {
    "label": "NumBitsPerDWORD()",
    "kind": "Method",
    "detail": "Function (Storage [ Value /)",
    "insertText": "NumBitsPerDWORD((1 << (Value & (NumBitsPerDWORD - 1))))"
  },
  {
    "label": "ContainsNoCheck()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ContainsNoCheck(uint32 Value)"
  },
  {
    "label": "IsRedundantPropertyCombinationNoCheck()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsRedundantPropertyCombinationNoCheck(uint32 PropertyCombination)"
  },
  {
    "label": "IsRedundantPropertyCombinationRecursive()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsRedundantPropertyCombinationRecursive(uint32 PropertyCombination, uint32 StartBit)"
  },
  {
    "label": "RemoveRedundantPropertyCombinationsRecursive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveRedundantPropertyCombinationsRecursive(PropertyCombination, 0x1)"
  },
  {
    "label": "RemoveRedundantPropertyCombinationsRecursive()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveRedundantPropertyCombinationsRecursive(uint32 PropertyCombination, uint32 StartBit)"
  },
  {
    "label": "RemoveNoCheck()",
    "kind": "Method",
    "detail": "Function (uint32 CombinationToRemove = PropertyCombination& ~ Bit ;)",
    "insertText": "RemoveNoCheck(CombinationToRemove)"
  },
  {
    "label": "RemoveRedundantPropertyCombinationsRecursive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveRedundantPropertyCombinationsRecursive(CombinationToRemove, Bit << 1)"
  },
  {
    "label": "TPropertyCombinationSet()",
    "kind": "Method",
    "detail": "Function (Storage = 0 ; })",
    "insertText": "TPropertyCombinationSet(const TPropertyCombinationSet<1>& Other)"
  },
  {
    "label": "GetRange()",
    "kind": "Method",
    "detail": "Function (ArchiveBits .)",
    "insertText": "GetRange(BitOffset, StorageBitCount, &Storage)"
  },
  {
    "label": "SetRangeFromRange()",
    "kind": "Method",
    "detail": "Function (ArchiveBits .)",
    "insertText": "SetRangeFromRange(BitOffset, StorageBitCount, &Storage)"
  },
  {
    "label": "Storage()",
    "kind": "Method",
    "detail": "Function (Storage =)",
    "insertText": "Storage(PropertyCombination != 0)"
  },
  {
    "label": "AddRange()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddRange(TPropertyCombinationSet<1>& Other)"
  },
  {
    "label": "MaxValue()",
    "kind": "Method",
    "detail": "Function (} private : class FPropertyCombinationSetTest ; uint32 Storage ; } ; template<PackerClass> class TPropertyCombinationSetHardcoded { public : uint32 BitWidth = PackerClass::BitWidth ; uint32 StorageBitCount = PackerClass::StorageBitCount ; uint32 StorageWordCount = 1 ; uint32)",
    "insertText": "MaxValue(1 << BitWidth)"
  },
  {
    "label": "TPropertyCombinationSetHardcoded()",
    "kind": "Method",
    "detail": "Function (uint32 ArrayMax = PackerClass::ArrayMax ; uint32 NumPackedValues = PackerClass::NumPackedValues ;)",
    "insertText": "TPropertyCombinationSetHardcoded()"
  },
  {
    "label": "TPropertyCombinationSetHardcoded()",
    "kind": "Method",
    "detail": "Function (Storage = 0 ; })",
    "insertText": "TPropertyCombinationSetHardcoded(const TPropertyCombinationSetHardcoded<PackerClass>& Other)"
  },
  {
    "label": "TPropertyCombinationSetHardcoded()",
    "kind": "Method",
    "detail": "Function (Storage = Other . Storage ; })",
    "insertText": "TPropertyCombinationSetHardcoded(const TBitArray<>& ArchivedBits, uint32 BitOffset = 0)"
  },
  {
    "label": "Unpack()",
    "kind": "Method",
    "detail": "Function (const uint32* OldValues ; int OldNum ;)",
    "insertText": "Unpack(Storage, OldValues, OldNum)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uint32 NewValues [ ArrayMax ] ; int NewNum ;)",
    "insertText": "if(AddNonRedundant(OldValues, OldNum, PropertyCombination, NewValues, NewNum))"
  },
  {
    "label": "Pack()",
    "kind": "Method",
    "detail": "Function (Storage =)",
    "insertText": "Pack(NewValues, NewNum)"
  },
  {
    "label": "AddRange()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "AddRange(TPropertyCombinationSetHardcoded<PackerClass>& Other)"
  },
  {
    "label": "Unpack()",
    "kind": "Method",
    "detail": "Function (const uint32* ExistingValues ; int ExistingNum ;)",
    "insertText": "Unpack(Storage, ExistingValues, ExistingNum)"
  },
  {
    "label": "Unpack()",
    "kind": "Method",
    "detail": "Function (const uint32* AddingValues ; int AddingNum ;)",
    "insertText": "Unpack(Other.Storage, AddingValues, AddingNum)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (uint32 BufferValues1 [ ArrayMax ] ; uint32 BufferValues2 [ ArrayMax ] ; const uint32* OldValues = ExistingValues ; int OldNum = ExistingNum ; uint32* NewValues = BufferValues1 ; int NewNum ;)",
    "insertText": "for(uint32 AddingValue : TArrayView<const uint32>(AddingValues, AddingNum))"
  },
  {
    "label": "Pack()",
    "kind": "Method",
    "detail": "Function (OldValues = NewValues ; OldNum = NewNum ; NewValues = OldValues = = BufferValues1 ? BufferValues2 : BufferValues1 ; } } Storage =)",
    "insertText": "Pack(OldValues, OldNum)"
  },
  {
    "label": "Unpack()",
    "kind": "Method",
    "detail": "Function (const uint32* Values ; int Num ;)",
    "insertText": "Unpack(Storage, Values, Num)"
  },
  {
    "label": "Unpack()",
    "kind": "Method",
    "detail": "Function (FIterator It ;)",
    "insertText": "Unpack(Storage, It.Values, It.Num)"
  },
  {
    "label": "AddNonRedundant()",
    "kind": "Method",
    "detail": "Function (It . Index = It . Num ; return It ; } private : class FPropertyCombinationSetTest ; bool)",
    "insertText": "AddNonRedundant(const uint32* OldValues, const int OldNum, const uint32 AddingValue, uint32* NewValues, int& NewNum)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bAdded = false ; NewNum = 0 ;)",
    "insertText": "for(const uint32 OldValue : TArrayView<const uint32>(OldValues, OldNum))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const uint32 Overlap = OldValue& AddingValue ;)",
    "insertText": "if(Overlap == AddingValue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NewValues [ NewNum + + ] = AddingValue ; bAdded = true ; })",
    "insertText": "if(Overlap != OldValue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NewValues [ NewNum + + ] = OldValue ; } })",
    "insertText": "if(!bAdded)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (NewValues [ NewNum + + ] = AddingValue ; })",
    "insertText": "check(1 <= NewNum && NewNum <= ArrayMax)"
  },
  {
    "label": "Unpack()",
    "kind": "Method",
    "detail": "Function (uint32 NumPackedValues = 5 ; void)",
    "insertText": "Unpack(const uint32 Compressed, const uint32*& OutValues, int& OutNum)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (uint32 Values [ ] = { 0,1,2,3 } ; OutValues =& Values [ Compressed ] ; OutNum = 1 ; } else {)",
    "insertText": "check(Compressed == 4)"
  },
  {
    "label": "Pack()",
    "kind": "Method",
    "detail": "Function (uint32 Values [ ] = { 1,2 } ; OutValues = Values ; OutNum = 2 ; } } uint32)",
    "insertText": "Pack(const uint32* Values, const int Num)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (uint32 Values [ ] = { 0,1,2,3,4,5,6,7 } ; OutValues =& Values [ Compressed ] ; OutNum = 1 ; } else {)",
    "insertText": "switch(Compressed)"
  }
]