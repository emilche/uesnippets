[
  {
    "label": "IntervalMapInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IntervalMapInfo"
  },
  {
    "label": "IntervalMapHalfOpenInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IntervalMapHalfOpenInfo"
  },
  {
    "label": "LeafNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LeafNode"
  },
  {
    "label": "BranchNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BranchNode"
  },
  {
    "label": "NodeBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "NodeBase"
  },
  {
    "label": "NodeSizer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NodeSizer"
  },
  {
    "label": "NodeRef",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "NodeRef"
  },
  {
    "label": "CacheAlignedPointerTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CacheAlignedPointerTraits"
  },
  {
    "label": "Path",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Path"
  },
  {
    "label": "Entry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Entry"
  },
  {
    "label": "IntervalMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IntervalMap"
  },
  {
    "label": "RootBranchData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RootBranchData"
  },
  {
    "label": "const_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "const_iterator"
  },
  {
    "label": "iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "iterator"
  },
  {
    "label": "IntervalMapOverlaps",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IntervalMapOverlaps"
  },
  {
    "label": "startLess()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_ADT_INTERVALMAP_H # define LLVM_ADT_INTERVALMAP_H # include \" llvm / ADT / PointerIntPair . h \" # include \" llvm / ADT / SmallVector . h \" # include \" llvm / Support / AlignOf . h \" # include \" llvm / Support / Allocator . h \" # include \" llvm / Support / RecyclingAllocator . h \" # include<iterator> namespace llvm { template<T> struct IntervalMapInfo { bool)",
    "insertText": "startLess(const T &x, const T &a)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i + Count <= M && \"Invalid source range\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(j + Count <= N && \"Invalid dest range\")"
  },
  {
    "label": "moveLeft()",
    "kind": "Method",
    "detail": "Function (first [ j ] = Other . first [ i ] ; second [ j ] = Other . second [ i ] ; } } void)",
    "insertText": "moveLeft(unsigned i, unsigned j, unsigned Count)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(j <= i && \"Use moveRight shift elements right\")"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copy(*this, i, j, Count)"
  },
  {
    "label": "moveRight()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "moveRight(unsigned i, unsigned j, unsigned Count)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i <= j && \"Use moveLeft shift elements left\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(j + Count <= N && \"Invalid range\")"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (first [ j + Count ] = first [ i + Count ] ; second [ j + Count ] = second [ i + Count ] ; } } void)",
    "insertText": "erase(unsigned i, unsigned j, unsigned Size)"
  },
  {
    "label": "moveLeft()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "moveLeft(j, i, Size - j)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "erase(unsigned i, unsigned Size)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "erase(i, i+1, Size)"
  },
  {
    "label": "shift()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "shift(unsigned i, unsigned Size)"
  },
  {
    "label": "moveRight()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "moveRight(i, i + 1, Size - i)"
  },
  {
    "label": "transferToLeftSib()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "transferToLeftSib(unsigned Size, NodeBase &Sib, unsigned SSize, unsigned Count)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (Sib .)",
    "insertText": "copy(*this, 0, SSize, Count)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "erase(0, Count, Size)"
  },
  {
    "label": "transferToRightSib()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "transferToRightSib(unsigned Size, NodeBase &Sib, unsigned SSize, unsigned Count)"
  },
  {
    "label": "moveRight()",
    "kind": "Method",
    "detail": "Function (Sib .)",
    "insertText": "moveRight(0, Count, SSize)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (Sib .)",
    "insertText": "copy(*this, Size-Count, 0, Count)"
  },
  {
    "label": "adjustFromLeftSib()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "adjustFromLeftSib(unsigned Size, NodeBase &Sib, unsigned SSize, int Add)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (unsigned Count =)",
    "insertText": "min(std::min(unsigned(Add), SSize), N - Size)"
  },
  {
    "label": "transferToRightSib()",
    "kind": "Method",
    "detail": "Function (Sib .)",
    "insertText": "transferToRightSib(SSize, *this, Size, Count)"
  },
  {
    "label": "transferToLeftSib()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transferToLeftSib(Size, Sib, SSize, Count)"
  },
  {
    "label": "adjustFromLeftSib()",
    "kind": "Method",
    "detail": "Function (int d = Node [ n ] ->)",
    "insertText": "adjustFromLeftSib(CurSize[n], *Node[m], CurSize[m], NewSize[n] - CurSize[n])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CurSize [ m ] - = d ; CurSize [ n ] + = d ;)",
    "insertText": "if(CurSize[n] >= NewSize[n])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(Nodes == 0)"
  },
  {
    "label": "adjustFromLeftSib()",
    "kind": "Method",
    "detail": "Function (int d = Node [ m ] ->)",
    "insertText": "adjustFromLeftSib(CurSize[m], *Node[n], CurSize[n], CurSize[n] - NewSize[n])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } # ifndef NDEBUG)",
    "insertText": "for(unsigned n = 0; n != Nodes; n++) assert(CurSize[n] == NewSize[n] && \"Insufficient element shuffle\")"
  },
  {
    "label": "distribute()",
    "kind": "Method",
    "detail": "Function (# endif } IdxPair)",
    "insertText": "distribute(unsigned Nodes, unsigned Elements, unsigned Capacity, const unsigned *CurSize, unsigned NewSize[], unsigned Position, bool Grow)"
  },
  {
    "label": "unsigned()",
    "kind": "Method",
    "detail": "Function (enum { Log2CacheLine = 6,CacheLineBytes = 1<<Log2CacheLine,DesiredNodeBytes = 3* CacheLineBytes } ; template<KeyT,ValT> struct NodeSizer { enum { DesiredLeafSize = DesiredNodeBytes / static_cast<)",
    "insertText": "unsigned(2*sizeof(KeyT)+sizeof(ValT))"
  },
  {
    "label": "AllocBytes()",
    "kind": "Method",
    "detail": "Function (typedef NodeBase<std::pair<KeyT,KeyT>,ValT,LeafSize> LeafBase ; enum {)",
    "insertText": "AllocBytes(sizeof(LeafBase) + CacheLineBytes-1) & ~(CacheLineBytes-1), BranchSize = AllocBytes / static_cast<unsigned>(sizeof(KeyT) + sizeof(void*))"
  },
  {
    "label": "getAsVoidPointer()",
    "kind": "Method",
    "detail": "Function (typedef RecyclingAllocator<BumpPtrAllocator,char,AllocBytes,CacheLineBytes> Allocator ; } ; class NodeRef { struct CacheAlignedPointerTraits { void*)",
    "insertText": "getAsVoidPointer(void *P)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "NodeRef()",
    "kind": "Method",
    "detail": "Function (} template<NodeT>)",
    "insertText": "NodeRef(NodeT *p, unsigned n) : pip(p, n - 1)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(n <= NodeT::Capacity && \"Size too big for node\")"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "size()"
  },
  {
    "label": "setSize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setSize(unsigned n)"
  },
  {
    "label": "setInt()",
    "kind": "Method",
    "detail": "Function (pip .)",
    "insertText": "setInt(n - 1)"
  },
  {
    "label": "subtree()",
    "kind": "Method",
    "detail": "Function (} NodeRef&)",
    "insertText": "subtree(unsigned i)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} template<NodeT> NodeT&)",
    "insertText": "get()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const NodeRef &RHS)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(pip.getPointer() != RHS.pip.getPointer() && \"Inconsistent NodeRefs\")"
  },
  {
    "label": "start()",
    "kind": "Method",
    "detail": "Function (} } ; template<KeyT,ValT,unsigned N,Traits> class LeafNode : public NodeBase<std::pair<KeyT,KeyT>,ValT,N> { public : const KeyT&)",
    "insertText": "start(unsigned i)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i <= Size && Size <= N && \"Bad indices\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((i == 0 || Traits::stopLess(stop(i - 1), x)) && \"Index is past the needed point\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i < N && \"Bad index\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i < N && \"Unsafe intervals\")"
  },
  {
    "label": "safeFind()",
    "kind": "Method",
    "detail": "Function (unsigned i =)",
    "insertText": "safeFind(0, x)"
  },
  {
    "label": "insertFrom()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "insertFrom(unsigned &Pos, unsigned Size, KeyT a, KeyT b, ValT y)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (unsigned i = Pos ;)",
    "insertText": "assert(i <= Size && Size <= N && \"Invalid index\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!Traits::stopLess(b, a) && \"Invalid interval\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((i == 0 || Traits::stopLess(stop(i - 1), a)))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((i == Size || !Traits::stopLess(stop(i), a)))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((i == Size || Traits::stopLess(b, start(i))) && \"Overlapping insert\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Pos = i - 1 ;)",
    "insertText": "if(i != Size && value(i) == y && Traits::adjacent(b, start(i)))"
  },
  {
    "label": "stop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stop(i - 1) = stop(i)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "erase(i, Size)"
  },
  {
    "label": "start()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "start(i)"
  },
  {
    "label": "stop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stop(i)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "value(i)"
  },
  {
    "label": "shift()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "shift(i, Size)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((i == 0 || Traits::stopLess(stop(i - 1), x)) && \"Index to findFrom is past the needed point\")"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "insert(unsigned i, unsigned Size, NodeRef Node, KeyT Stop)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Size < N && \"branch node overflow\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i <= Size && \"Bad insert position\")"
  },
  {
    "label": "subtree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "subtree(i)"
  },
  {
    "label": "Entry()",
    "kind": "Method",
    "detail": "Function (} } ; class Path { struct Entry { void* node ; unsigned size ; unsigned offset ;)",
    "insertText": "Entry(void *Node, unsigned Size, unsigned Offset) : node(Node), size(Size), offset(Offset)"
  },
  {
    "label": "Entry()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Entry(NodeRef Node, unsigned Offset) : node(&Node.subtree(0)), size(Node.size()), offset(Offset)"
  },
  {
    "label": "node()",
    "kind": "Method",
    "detail": "Function (} } ; SmallVector<Entry,4> path ; public : template<NodeT> NodeT&)",
    "insertText": "node(unsigned Level)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "size(unsigned Level)"
  },
  {
    "label": "leafSize()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "leafSize()"
  },
  {
    "label": "leafOffset()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "leafOffset()"
  },
  {
    "label": "valid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "valid()"
  },
  {
    "label": "height()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "height()"
  },
  {
    "label": "subtree()",
    "kind": "Method",
    "detail": "Function (} NodeRef&)",
    "insertText": "subtree(unsigned Level)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "reset(unsigned Level)"
  },
  {
    "label": "Entry()",
    "kind": "Method",
    "detail": "Function (path [ Level ] =)",
    "insertText": "Entry(subtree(Level - 1), offset(Level))"
  },
  {
    "label": "push()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push(NodeRef Node, unsigned Offset)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (path .)",
    "insertText": "push_back(Entry(Node, Offset))"
  },
  {
    "label": "pop()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "pop()"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (path .)",
    "insertText": "pop_back()"
  },
  {
    "label": "setSize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setSize(unsigned Level, unsigned Size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (path [ Level ] . size = Size ;)",
    "insertText": "if(Level) subtree(Level - 1).setSize(Size)"
  },
  {
    "label": "setRoot()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setRoot(void *Node, unsigned Size, unsigned Offset)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (path .)",
    "insertText": "clear()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (path .)",
    "insertText": "push_back(Entry(Node, Size, Offset))"
  },
  {
    "label": "replaceRoot()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "replaceRoot(void *Root, unsigned Size, IdxPair Offsets)"
  },
  {
    "label": "getLeftSibling()",
    "kind": "Method",
    "detail": "Function (NodeRef)",
    "insertText": "getLeftSibling(unsigned Level)"
  },
  {
    "label": "moveLeft()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "moveLeft(unsigned Level)"
  },
  {
    "label": "fillLeft()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fillLeft(unsigned Height)"
  },
  {
    "label": "getRightSibling()",
    "kind": "Method",
    "detail": "Function (} NodeRef)",
    "insertText": "getRightSibling(unsigned Level)"
  },
  {
    "label": "moveRight()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "moveRight(unsigned Level)"
  },
  {
    "label": "atBegin()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "atBegin()"
  },
  {
    "label": "moveLeft()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "moveLeft(Level)"
  },
  {
    "label": "DesiredRootBranchCap()",
    "kind": "Method",
    "detail": "Function (+ + path [ Level ] . offset ; } } ; } template<KeyT,ValT,unsigned N = IntervalMapImpl::NodeSizer<KeyT,ValT>::LeafSize,Traits = IntervalMapInfo<KeyT>> class IntervalMap { typedef IntervalMapImpl::NodeSizer<KeyT,ValT> Sizer ; typedef IntervalMapImpl::LeafNode<KeyT,ValT,Sizer::LeafSize,Traits> Leaf ; typedef IntervalMapImpl::BranchNode<KeyT,ValT,Sizer::BranchSize,Traits> Branch ; typedef IntervalMapImpl::LeafNode<KeyT,ValT,N,Traits> RootLeaf ; typedef IntervalMapImpl::IdxPair IdxPair ; enum {)",
    "insertText": "DesiredRootBranchCap(sizeof(RootLeaf) - sizeof(KeyT)) / (sizeof(KeyT) + sizeof(IntervalMapImpl::NodeRef))"
  },
  {
    "label": "dataAs()",
    "kind": "Method",
    "detail": "Function (typedef IntervalMapImpl::BranchNode<KeyT,ValT,RootBranchCap,Traits> RootBranch ; struct RootBranchData { KeyT start ; RootBranch node ; } ; public : typedef Sizer::Allocator Allocator ; typedef KeyT KeyType ; typedef ValT ValueType ; typedef Traits KeyTraits ; private : AlignedCharArrayUnion<RootLeaf,RootBranchData> data ; unsigned height ; unsigned rootSize ; Allocator& allocator ; template<T> T&)",
    "insertText": "dataAs()"
  },
  {
    "label": "rootLeaf()",
    "kind": "Method",
    "detail": "Function (union { const char* d ; T* t ; } u ; u . d = data . buffer ; return* u . t ; } const RootLeaf&)",
    "insertText": "rootLeaf()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!branched() && \"Cannot acces leaf data in branched root\")"
  },
  {
    "label": "rootBranchData()",
    "kind": "Method",
    "detail": "Function (} RootBranchData&)",
    "insertText": "rootBranchData()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(branched() && \"Cannot access branch data in non-branched root\")"
  },
  {
    "label": "rootBranch()",
    "kind": "Method",
    "detail": "Function (} const RootBranch&)",
    "insertText": "rootBranch()"
  },
  {
    "label": "rootBranchStart()",
    "kind": "Method",
    "detail": "Function (} KeyT)",
    "insertText": "rootBranchStart()"
  },
  {
    "label": "newNode()",
    "kind": "Method",
    "detail": "Function (} template<NodeT> NodeT*)",
    "insertText": "newNode()"
  },
  {
    "label": "deleteNode()",
    "kind": "Method",
    "detail": "Function (} template<NodeT> void)",
    "insertText": "deleteNode(NodeT *P)"
  },
  {
    "label": "NodeT()",
    "kind": "Method",
    "detail": "Function (P -> ~)",
    "insertText": "NodeT()"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (allocator .)",
    "insertText": "Deallocate(P)"
  },
  {
    "label": "branchRoot()",
    "kind": "Method",
    "detail": "Function (} IdxPair)",
    "insertText": "branchRoot(unsigned Position)"
  },
  {
    "label": "splitRoot()",
    "kind": "Method",
    "detail": "Function (IdxPair)",
    "insertText": "splitRoot(unsigned Position)"
  },
  {
    "label": "switchRootToBranch()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "switchRootToBranch()"
  },
  {
    "label": "rootLeaf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rootLeaf().~RootLeaf()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (height = 1 ;)",
    "insertText": "new(&rootBranchData()) RootBranchData()"
  },
  {
    "label": "switchRootToLeaf()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "switchRootToLeaf()"
  },
  {
    "label": "rootBranchData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rootBranchData().~RootBranchData()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (height = 0 ;)",
    "insertText": "new(&rootLeaf()) RootLeaf()"
  },
  {
    "label": "branched()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "branched()"
  },
  {
    "label": "visitNodes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "visitNodes(void (IntervalMap::*f)(IntervalMapImpl::NodeRef, unsigned Level))"
  },
  {
    "label": "deleteNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deleteNode(IntervalMapImpl::NodeRef Node, unsigned Level)"
  },
  {
    "label": "IntervalMap()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "IntervalMap(Allocator &a) : height(0), rootSize(0), allocator(a)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((uintptr_t(data.buffer) & (alignOf<RootLeaf>() - 1)) == 0 && \"Insufficient alignment\")"
  },
  {
    "label": "IntervalMap()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "IntervalMap()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!empty() && \"Empty IntervalMap has no start\")"
  },
  {
    "label": "stop()",
    "kind": "Method",
    "detail": "Function (} KeyT)",
    "insertText": "stop()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!empty() && \"Empty IntervalMap has no stop\")"
  },
  {
    "label": "lookup()",
    "kind": "Method",
    "detail": "Function (} ValT)",
    "insertText": "lookup(KeyT x, ValT NotFound = ValT())"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "insert(KeyT a, KeyT b, ValT y)"
  },
  {
    "label": "rootLeaf()",
    "kind": "Method",
    "detail": "Function (unsigned p =)",
    "insertText": "rootLeaf().findFrom(0, rootSize, a)"
  },
  {
    "label": "rootLeaf()",
    "kind": "Method",
    "detail": "Function (rootSize =)",
    "insertText": "rootLeaf().insertFrom(p, rootSize, a, b, y)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (class const_iterator ; class iterator ; class const_iterator ; class iterator ; const_iterator)",
    "insertText": "begin()"
  },
  {
    "label": "I()",
    "kind": "Method",
    "detail": "Function (const_iterator)",
    "insertText": "I(*this)"
  },
  {
    "label": "goToBegin()",
    "kind": "Method",
    "detail": "Function (I .)",
    "insertText": "goToBegin()"
  },
  {
    "label": "goToEnd()",
    "kind": "Method",
    "detail": "Function (I .)",
    "insertText": "goToEnd()"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (I .)",
    "insertText": "find(x)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(branched() && \"treeLookup assumes a branched root\")"
  },
  {
    "label": "rootBranch()",
    "kind": "Method",
    "detail": "Function (IntervalMapImpl::NodeRef NR =)",
    "insertText": "rootBranch().safeLookup(x)"
  },
  {
    "label": "NewOffset()",
    "kind": "Method",
    "detail": "Function (using namespace IntervalMapImpl ; const unsigned Nodes = RootLeaf::Capacity / Leaf::Capacity + 1 ; unsigned size [ Nodes ] ; IdxPair)",
    "insertText": "NewOffset(0, Position)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (unsigned pos = 0 ; NodeRef node [ Nodes ] ;)",
    "insertText": "for(unsigned n = 0; n != Nodes; ++n)"
  },
  {
    "label": "Leaf()",
    "kind": "Method",
    "detail": "Function (Leaf* L = newNode<)",
    "insertText": "Leaf()"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (L ->)",
    "insertText": "copy(rootLeaf(), pos, 0, size[n])"
  },
  {
    "label": "NodeRef()",
    "kind": "Method",
    "detail": "Function (node [ n ] =)",
    "insertText": "NodeRef(L, size[n])"
  },
  {
    "label": "rootBranch()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rootBranch().stop(n) = node[n].template get<Leaf>().stop(size[n]-1)"
  },
  {
    "label": "rootBranch()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rootBranch().subtree(n)"
  },
  {
    "label": "rootBranchStart()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "rootBranchStart() = node[0].template get<Leaf>().start(0)"
  },
  {
    "label": "Branch()",
    "kind": "Method",
    "detail": "Function (Branch* B = newNode<)",
    "insertText": "Branch()"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (B ->)",
    "insertText": "copy(rootBranch(), Pos, 0, Size[n])"
  },
  {
    "label": "NodeRef()",
    "kind": "Method",
    "detail": "Function (Node [ n ] =)",
    "insertText": "NodeRef(B, Size[n])"
  },
  {
    "label": "rootBranch()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rootBranch().stop(n) = Node[n].template get<Branch>().stop(Size[n]-1)"
  },
  {
    "label": "visitNodes()",
    "kind": "Method",
    "detail": "Function (} rootSize = Nodes ; + + height ; return NewOffset ; } template<KeyT,ValT,unsigned N,Traits> void IntervalMap<KeyT,ValT,N,Traits)",
    "insertText": "visitNodes(void (IntervalMap::*f)(IntervalMapImpl::NodeRef, unsigned Height))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (SmallVector<IntervalMapImpl::NodeRef,4> Refs,NextRefs ;)",
    "insertText": "for(unsigned i = 0; i != rootSize; ++i) Refs.push_back(rootBranch().subtree(i))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (Refs .)",
    "insertText": "swap(NextRefs)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(unsigned i = 0, e = Refs.size(); i != e; ++i) (this->*f)(Refs[i], 0)"
  },
  {
    "label": "visitNodes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "visitNodes(&IntervalMap::deleteNode)"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (} rootSize = 0 ; } template<KeyT,ValT,unsigned N,Traits> class IntervalMap<KeyT,ValT,N,Traits>::const_iterator { class IntervalMap ; public : using iterator_category = std::bidirectional_iterator_tag ; using value_type = ValT ; using difference_type = std::ptrdiff_t ; using pointer = value_type* ; using reference = value_type& ; protected : IntervalMap* map ; IntervalMapImpl::Path path ;)",
    "insertText": "const_iterator(const IntervalMap &map) : map(const_cast<IntervalMap*>(&map))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(map && \"Invalid iterator\")"
  },
  {
    "label": "setRoot()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setRoot(unsigned Offset)"
  },
  {
    "label": "pathFillFind()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "pathFillFind(KeyT x)"
  },
  {
    "label": "treeFind()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "treeFind(KeyT x)"
  },
  {
    "label": "treeAdvanceTo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "treeAdvanceTo(KeyT x)"
  },
  {
    "label": "unsafeStart()",
    "kind": "Method",
    "detail": "Function (KeyT&)",
    "insertText": "unsafeStart()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(valid() && \"Cannot access invalid iterator\")"
  },
  {
    "label": "unsafeStop()",
    "kind": "Method",
    "detail": "Function (} KeyT&)",
    "insertText": "unsafeStop()"
  },
  {
    "label": "unsafeValue()",
    "kind": "Method",
    "detail": "Function (} ValT&)",
    "insertText": "unsafeValue()"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (} public :)",
    "insertText": "const_iterator() : map(nullptr)"
  },
  {
    "label": "setMap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setMap(const IntervalMap &m)"
  },
  {
    "label": "IntervalMap()",
    "kind": "Method",
    "detail": "Function (map = const_cast<)",
    "insertText": "IntervalMap(&m)"
  },
  {
    "label": "start()",
    "kind": "Method",
    "detail": "Function (} const KeyT&)",
    "insertText": "start()"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} const ValT&)",
    "insertText": "value()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const ValT&)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const const_iterator &RHS)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(map == RHS.map && \"Cannot compare iterators from different maps\")"
  },
  {
    "label": "setRoot()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setRoot(0)"
  },
  {
    "label": "setRoot()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setRoot(map->rootSize)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(valid() && \"Cannot increment end()\")"
  },
  {
    "label": "advanceTo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "advanceTo(KeyT x)"
  },
  {
    "label": "subtree()",
    "kind": "Method",
    "detail": "Function (IntervalMapImpl::NodeRef NR = path .)",
    "insertText": "subtree(path.height())"
  },
  {
    "label": "Branch()",
    "kind": "Method",
    "detail": "Function (unsigned p = NR . get<)",
    "insertText": "Branch().safeFind(0, x)"
  },
  {
    "label": "push()",
    "kind": "Method",
    "detail": "Function (path .)",
    "insertText": "push(NR, p)"
  },
  {
    "label": "subtree()",
    "kind": "Method",
    "detail": "Function (NR = NR .)",
    "insertText": "subtree(p)"
  },
  {
    "label": "push()",
    "kind": "Method",
    "detail": "Function (} path .)",
    "insertText": "push(NR, NR.get<Leaf>().safeFind(0, x))"
  },
  {
    "label": "setRoot()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setRoot(map->rootBranch().findFrom(0, map->rootSize, x))"
  },
  {
    "label": "leafOffset()",
    "kind": "Method",
    "detail": "Function (path .)",
    "insertText": "leafOffset() = path.leaf<Leaf>().safeFind(path.leafOffset(), x)"
  },
  {
    "label": "offset()",
    "kind": "Method",
    "detail": "Function (path .)",
    "insertText": "offset(l + 1) = path.node<Branch>(l + 1).safeFind(path.offset(l + 1), x)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!Traits::stopLess(map->rootBranch().stop(path.offset(0)), x))"
  },
  {
    "label": "offset()",
    "kind": "Method",
    "detail": "Function (path .)",
    "insertText": "offset(1) = path.node<Branch>(1).safeFind(path.offset(1), x)"
  },
  {
    "label": "setRoot()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "setRoot(map->rootBranch().findFrom(path.offset(0), map->rootSize, x))"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (} template<KeyT,ValT,unsigned N,Traits> class IntervalMap<KeyT,ValT,N,Traits>::iterator : public const_iterator { class IntervalMap ; typedef IntervalMapImpl::IdxPair IdxPair ;)",
    "insertText": "iterator(IntervalMap &map) : const_iterator(map)"
  },
  {
    "label": "setNodeStop()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setNodeStop(unsigned Level, KeyT Stop)"
  },
  {
    "label": "insertNode()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "insertNode(unsigned Level, IntervalMapImpl::NodeRef Node, KeyT Stop)"
  },
  {
    "label": "overflow()",
    "kind": "Method",
    "detail": "Function (template<NodeT> bool)",
    "insertText": "overflow(unsigned Level)"
  },
  {
    "label": "treeInsert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "treeInsert(KeyT a, KeyT b, ValT y)"
  },
  {
    "label": "eraseNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eraseNode(unsigned Level)"
  },
  {
    "label": "treeErase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "treeErase(bool UpdateRoot = true)"
  },
  {
    "label": "canCoalesceLeft()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "canCoalesceLeft(KeyT Start, ValT x)"
  },
  {
    "label": "canCoalesceRight()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "canCoalesceRight(KeyT Stop, ValT x)"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "iterator()"
  },
  {
    "label": "setStart()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setStart(KeyT a)"
  },
  {
    "label": "setStop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setStop(KeyT b)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValue(ValT x)"
  },
  {
    "label": "setStartUnchecked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setStartUnchecked(KeyT a)"
  },
  {
    "label": "setStopUnchecked()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setStopUnchecked(KeyT b)"
  },
  {
    "label": "setValueUnchecked()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueUnchecked(ValT x)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "erase()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using namespace IntervalMapImpl ; Path& P = this -> path ;)",
    "insertText": "if(!this->branched())"
  },
  {
    "label": "RootLeaf()",
    "kind": "Method",
    "detail": "Function (RootLeaf& Node = P . leaf<)",
    "insertText": "RootLeaf()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(unsigned i = P.leafOffset())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(NodeRef NR = P.getLeftSibling(P.height()))"
  },
  {
    "label": "canCoalesceRight()",
    "kind": "Method",
    "detail": "Function (} return false ; } template<KeyT,ValT,unsigned N,Traits> bool IntervalMap<KeyT,ValT,N,Traits>::)",
    "insertText": "canCoalesceRight(KeyT Stop, ValT Value)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(i < P.leafSize())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(NodeRef NR = P.getRightSibling(P.height()))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (IntervalMapImpl::Path& P = this -> path ;)",
    "insertText": "while(--Level)"
  },
  {
    "label": "Branch()",
    "kind": "Method",
    "detail": "Function (P . node<)",
    "insertText": "Branch(Level).stop(P.offset(Level))"
  },
  {
    "label": "RootBranch()",
    "kind": "Method",
    "detail": "Function (} P . node<)",
    "insertText": "RootBranch(Level).stop(P.offset(Level))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Traits::stopLess(a, this->stop()) && \"Cannot move start beyond stop\")"
  },
  {
    "label": "setStartUnchecked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setStartUnchecked(a)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Traits::stopLess(this->start(), b) && \"Cannot move stop beyond start\")"
  },
  {
    "label": "setStopUnchecked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setStopUnchecked(b)"
  },
  {
    "label": "setValueUnchecked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueUnchecked(x)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(canCoalesceLeft(this->start(), x))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Level && \"Cannot insert next to the root\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool SplitRoot = false ; IntervalMap& IM =* this -> map ; IntervalMapImpl::Path& P = this -> path ;)",
    "insertText": "if(Level == 1)"
  },
  {
    "label": "rootBranch()",
    "kind": "Method",
    "detail": "Function (IM .)",
    "insertText": "rootBranch().insert(P.offset(0), IM.rootSize, Node, Stop)"
  },
  {
    "label": "setSize()",
    "kind": "Method",
    "detail": "Function (P .)",
    "insertText": "setSize(0, ++IM.rootSize)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (P .)",
    "insertText": "reset(Level)"
  },
  {
    "label": "replaceRoot()",
    "kind": "Method",
    "detail": "Function (P .)",
    "insertText": "replaceRoot(&IM.rootBranch(), IM.rootSize, Offset)"
  },
  {
    "label": "legalizeForInsert()",
    "kind": "Method",
    "detail": "Function (+ + Level ; } P .)",
    "insertText": "legalizeForInsert(--Level)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!SplitRoot && \"Cannot overflow after splitting the root\")"
  },
  {
    "label": "Branch()",
    "kind": "Method",
    "detail": "Function (SplitRoot = overflow<)",
    "insertText": "Branch(Level)"
  },
  {
    "label": "Branch()",
    "kind": "Method",
    "detail": "Function (Level + = SplitRoot ; } P . node<)",
    "insertText": "Branch(Level).insert(P.offset(Level), P.size(Level), Node, Stop)"
  },
  {
    "label": "setSize()",
    "kind": "Method",
    "detail": "Function (P .)",
    "insertText": "setSize(Level, P.size(Level) + 1)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (P .)",
    "insertText": "reset(Level + 1)"
  },
  {
    "label": "rootLeaf()",
    "kind": "Method",
    "detail": "Function (IntervalMap& IM =* this -> map ; IntervalMapImpl::Path& P = this -> path ; unsigned Size = IM .)",
    "insertText": "rootLeaf().insertFrom(P.leafOffset(), IM.rootSize, a, b, y)"
  },
  {
    "label": "setSize()",
    "kind": "Method",
    "detail": "Function (P .)",
    "insertText": "setSize(0, IM.rootSize = Size)"
  },
  {
    "label": "treeInsert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "treeInsert(a, b, y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using namespace IntervalMapImpl ; Path& P = this -> path ;)",
    "insertText": "if(!P.valid()) P.legalizeForInsert(this->map->height)"
  },
  {
    "label": "moveLeft()",
    "kind": "Method",
    "detail": "Function (P .)",
    "insertText": "moveLeft(P.height())"
  },
  {
    "label": "setNodeStop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setNodeStop(P.height(), SibLeaf.stop(SibOfs) = b)"
  },
  {
    "label": "treeErase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "treeErase(false)"
  },
  {
    "label": "Leaf()",
    "kind": "Method",
    "detail": "Function (Size = P . leaf<)",
    "insertText": "Leaf().insertFrom(P.leafOffset(), Size, a, b, y)"
  },
  {
    "label": "Leaf()",
    "kind": "Method",
    "detail": "Function (overflow<)",
    "insertText": "Leaf(P.height())"
  },
  {
    "label": "leafOffset()",
    "kind": "Method",
    "detail": "Function (Grow = P .)",
    "insertText": "leafOffset() == P.leafSize()"
  },
  {
    "label": "Leaf()",
    "kind": "Method",
    "detail": "Function (Size = P . leaf<)",
    "insertText": "Leaf().insertFrom(P.leafOffset(), P.leafSize(), a, b, y)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Size <= Leaf::Capacity && \"overflow() didn't make room\")"
  },
  {
    "label": "setSize()",
    "kind": "Method",
    "detail": "Function (} P .)",
    "insertText": "setSize(P.height(), Size)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (IntervalMap& IM =* this -> map ; IntervalMapImpl::Path& P = this -> path ;)",
    "insertText": "assert(P.valid() && \"Cannot erase end()\")"
  },
  {
    "label": "rootLeaf()",
    "kind": "Method",
    "detail": "Function (IM .)",
    "insertText": "rootLeaf().erase(P.leafOffset(), IM.rootSize)"
  },
  {
    "label": "setSize()",
    "kind": "Method",
    "detail": "Function (P .)",
    "insertText": "setSize(0, --IM.rootSize)"
  },
  {
    "label": "treeErase()",
    "kind": "Method",
    "detail": "Function (} template<KeyT,ValT,unsigned N,Traits> void IntervalMap<KeyT,ValT,N,Traits>::)",
    "insertText": "treeErase(bool UpdateRoot)"
  },
  {
    "label": "deleteNode()",
    "kind": "Method",
    "detail": "Function (IM .)",
    "insertText": "deleteNode(&Node)"
  },
  {
    "label": "eraseNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eraseNode(IM.height)"
  },
  {
    "label": "setSize()",
    "kind": "Method",
    "detail": "Function (P .)",
    "insertText": "setSize(IM.height, NewSize)"
  },
  {
    "label": "setNodeStop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setNodeStop(IM.height, Node.stop(NewSize - 1))"
  },
  {
    "label": "moveRight()",
    "kind": "Method",
    "detail": "Function (P .)",
    "insertText": "moveRight(IM.height)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(UpdateRoot && P.atBegin()) IM.rootBranchStart() = P.leaf<Leaf>().start(0)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Level && \"Cannot erase root node\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (IntervalMap& IM =* this -> map ; IntervalMapImpl::Path& P = this -> path ;)",
    "insertText": "if(--Level == 0)"
  },
  {
    "label": "rootBranch()",
    "kind": "Method",
    "detail": "Function (IM .)",
    "insertText": "rootBranch().erase(P.offset(0), IM.rootSize)"
  },
  {
    "label": "deleteNode()",
    "kind": "Method",
    "detail": "Function (IM .)",
    "insertText": "deleteNode(&Parent)"
  },
  {
    "label": "eraseNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eraseNode(Level)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} else { Parent .)",
    "insertText": "erase(P.offset(Level), P.size(Level))"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (unsigned NewSize = P .)",
    "insertText": "size(Level)"
  },
  {
    "label": "setSize()",
    "kind": "Method",
    "detail": "Function (P .)",
    "insertText": "setSize(Level, NewSize)"
  },
  {
    "label": "setNodeStop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setNodeStop(Level, Parent.stop(NewSize - 1))"
  },
  {
    "label": "moveRight()",
    "kind": "Method",
    "detail": "Function (P .)",
    "insertText": "moveRight(Level)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "if(P.valid())"
  },
  {
    "label": "offset()",
    "kind": "Method",
    "detail": "Function (P .)",
    "insertText": "offset(Level + 1)"
  },
  {
    "label": "offset()",
    "kind": "Method",
    "detail": "Function (using namespace IntervalMapImpl ; Path& P = this -> path ; unsigned CurSize [ 4 ] ; NodeT* Node [ 4 ] ; unsigned Nodes = 0 ; unsigned Elements = 0 ; unsigned Offset = P .)",
    "insertText": "offset(Level)"
  },
  {
    "label": "getLeftSibling()",
    "kind": "Method",
    "detail": "Function (NodeRef LeftSib = P .)",
    "insertText": "getLeftSibling(Level)"
  },
  {
    "label": "NodeT()",
    "kind": "Method",
    "detail": "Function (Node [ Nodes + + ] =& P . node<)",
    "insertText": "NodeT(Level)"
  },
  {
    "label": "getRightSibling()",
    "kind": "Method",
    "detail": "Function (NodeRef RightSib = P .)",
    "insertText": "getRightSibling(Level)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} unsigned NewNode = 0 ;)",
    "insertText": "if(Elements + 1 > Nodes * NodeT::Capacity)"
  },
  {
    "label": "distribute()",
    "kind": "Method",
    "detail": "Function (+ + Nodes ; } unsigned NewSize [ 4 ] ; IdxPair NewOffset =)",
    "insertText": "distribute(Nodes, Elements, NodeT::Capacity, CurSize, NewSize, Offset, true)"
  },
  {
    "label": "adjustSiblingSizes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "adjustSiblingSizes(Node, Nodes, CurSize, NewSize)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool SplitRoot = false ; unsigned Pos = 0 ;)",
    "insertText": "for(;;)"
  },
  {
    "label": "stop()",
    "kind": "Method",
    "detail": "Function (KeyT Stop = Node [ Pos ] ->)",
    "insertText": "stop(NewSize[Pos]-1)"
  },
  {
    "label": "insertNode()",
    "kind": "Method",
    "detail": "Function (SplitRoot =)",
    "insertText": "insertNode(Level, NodeRef(Node[Pos], NewSize[Pos]), Stop)"
  },
  {
    "label": "setSize()",
    "kind": "Method",
    "detail": "Function (Level + = SplitRoot ; } else { P .)",
    "insertText": "setSize(Level, NewSize[Pos])"
  },
  {
    "label": "setNodeStop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setNodeStop(Level, Stop)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Pos + 1 == Nodes)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (+ + Pos ; })",
    "insertText": "while(Pos != NewOffset.first)"
  },
  {
    "label": "advanceTo()",
    "kind": "Method",
    "detail": "Function (posA .)",
    "insertText": "advanceTo(posB.start())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Traits::stopLess(posB.stop(), posA.start()))"
  },
  {
    "label": "advanceTo()",
    "kind": "Method",
    "detail": "Function (posB .)",
    "insertText": "advanceTo(posA.start())"
  },
  {
    "label": "IntervalMapOverlaps()",
    "kind": "Method",
    "detail": "Function (} } public :)",
    "insertText": "IntervalMapOverlaps(const MapA &a, const MapB &b) : posA(b.empty() ? a.end() : a.find(b.start())), posB(posA.valid() ? b.find(posA.start()) : b.end())"
  },
  {
    "label": "advance()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "advance()"
  },
  {
    "label": "a()",
    "kind": "Method",
    "detail": "Function (} const MapA::const_iterator&)",
    "insertText": "a()"
  },
  {
    "label": "a()",
    "kind": "Method",
    "detail": "Function (KeyType ak =)",
    "insertText": "a().start()"
  },
  {
    "label": "b()",
    "kind": "Method",
    "detail": "Function (KeyType bk =)",
    "insertText": "b().start()"
  },
  {
    "label": "a()",
    "kind": "Method",
    "detail": "Function (KeyType ak =)",
    "insertText": "a().stop()"
  },
  {
    "label": "b()",
    "kind": "Method",
    "detail": "Function (KeyType bk =)",
    "insertText": "b().stop()"
  },
  {
    "label": "skipA()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "skipA()"
  },
  {
    "label": "skipB()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "skipB()"
  }
]