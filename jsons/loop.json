[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "HbrLoopSubdivision",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrLoopSubdivision"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENSUBDIV3_HBRLOOP_H # define OPENSUBDIV3_HBRLOOP_H # include<cmath> # include<assert . h> # include<algorithm> # include \" . . / hbr / subdivision . h \" # include \" . . / version . h \" namespace OpenSubdiv { namespace OPENSUBDIV_VERSION { template<class T> class HbrLoopSubdivision : public HbrSubdivision<T> { public : HbrLoopSubdivision<)",
    "insertText": "T() : HbrSubdivision<T>()"
  },
  {
    "label": "Clone()",
    "kind": "Method",
    "detail": "Function (} HbrSubdivision<T>*)",
    "insertText": "Clone()"
  },
  {
    "label": "Refine()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Refine(HbrMesh<T>* mesh, HbrFace<T>* face)"
  },
  {
    "label": "RefineFaceAtVertex()",
    "kind": "Method",
    "detail": "Function (HbrFace<T>*)",
    "insertText": "RefineFaceAtVertex(HbrMesh<T>* mesh, HbrFace<T>* face, HbrVertex<T>* vertex)"
  },
  {
    "label": "GuaranteeNeighbor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GuaranteeNeighbor(HbrMesh<T>* mesh, HbrHalfedge<T>* edge)"
  },
  {
    "label": "GuaranteeNeighbors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GuaranteeNeighbors(HbrMesh<T>* mesh, HbrVertex<T>* vertex)"
  },
  {
    "label": "HasLimit()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasLimit(HbrMesh<T>* mesh, HbrFace<T>* face)"
  },
  {
    "label": "HasLimit()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasLimit(HbrMesh<T>* mesh, HbrHalfedge<T>* edge)"
  },
  {
    "label": "HasLimit()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasLimit(HbrMesh<T>* mesh, HbrVertex<T>* vertex)"
  },
  {
    "label": "Subdivide()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>*)",
    "insertText": "Subdivide(HbrMesh<T>* mesh, HbrFace<T>* face)"
  },
  {
    "label": "Subdivide()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>*)",
    "insertText": "Subdivide(HbrMesh<T>* mesh, HbrHalfedge<T>* edge)"
  },
  {
    "label": "Subdivide()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>*)",
    "insertText": "Subdivide(HbrMesh<T>* mesh, HbrVertex<T>* vertex)"
  },
  {
    "label": "VertexIsExtraordinary()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "VertexIsExtraordinary(HbrMesh<T> const * , HbrVertex<T>* vertex)"
  },
  {
    "label": "FaceIsExtraordinary()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "FaceIsExtraordinary(HbrMesh<T> const * , HbrFace<T>* face)"
  },
  {
    "label": "GetFaceChildrenCount()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "GetFaceChildrenCount(int)"
  },
  {
    "label": "transferEditsToChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transferEditsToChild(HbrFace<T>* face, HbrFace<T>* child, int index)"
  },
  {
    "label": "refineFaceAtMiddle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "refineFaceAtMiddle(HbrMesh<T>* mesh, HbrFace<T>* face)"
  },
  {
    "label": "transferFVarToChild()",
    "kind": "Method",
    "detail": "Function (} ; template<class T> void HbrLoopSubdivision<T)",
    "insertText": "transferFVarToChild(HbrMesh<T>* mesh, HbrFace<T>* face, HbrFace<T>* child, int index)"
  },
  {
    "label": "GetFVarInterpolateBoundaryMethod()",
    "kind": "Method",
    "detail": "Function (HbrMesh<T>::InterpolateBoundaryMethod fvarinterp = mesh ->)",
    "insertText": "GetFVarInterpolateBoundaryMethod()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>* childVertex ;)",
    "insertText": "if(index == 3)"
  },
  {
    "label": "GetFVarCount()",
    "kind": "Method",
    "detail": "Function (const int fvarcount = mesh ->)",
    "insertText": "GetFVarCount()"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* edge = face ->)",
    "insertText": "GetEdge(i)"
  },
  {
    "label": "GuaranteeNeighbor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GuaranteeNeighbor(mesh, edge)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (childVertex = child ->)",
    "insertText": "GetVertex((i + 2) % 3)"
  },
  {
    "label": "IsFVarInfiniteSharpAnywhere()",
    "kind": "Method",
    "detail": "Function (bool fvIsSmooth = ! edge ->)",
    "insertText": "IsFVarInfiniteSharpAnywhere()"
  },
  {
    "label": "NewFVarData()",
    "kind": "Method",
    "detail": "Function (childVertex ->)",
    "insertText": "NewFVarData(child)"
  },
  {
    "label": "GetFVarData()",
    "kind": "Method",
    "detail": "Function (} HbrFVarData<T>& fv = childVertex ->)",
    "insertText": "GetFVarData(child)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int fvarindex = 0 ;)",
    "insertText": "for(int fvaritem = 0; fvaritem < fvarcount; ++fvaritem)"
  },
  {
    "label": "GetFVarWidths()",
    "kind": "Method",
    "detail": "Function (const int fvarwidth = mesh ->)",
    "insertText": "GetFVarWidths()"
  },
  {
    "label": "SetWithWeight()",
    "kind": "Method",
    "detail": "Function (fv .)",
    "insertText": "SetWithWeight(face->GetFVarData(i), fvarindex, fvarwidth, 0.5f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv .)",
    "insertText": "AddWithWeight(face->GetFVarData((i + 1) % 3), fvarindex, fvarwidth, 0.5f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(!fvIsSmooth || !fv.IsInitialized())"
  },
  {
    "label": "SetWithWeight()",
    "kind": "Method",
    "detail": "Function (fv .)",
    "insertText": "SetWithWeight(face->GetFVarData(i), fvarindex, fvarwidth, 0.375f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv .)",
    "insertText": "AddWithWeight(face->GetFVarData((i + 1) % 3), fvarindex, fvarwidth, 0.375f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv .)",
    "insertText": "AddWithWeight(face->GetFVarData((i + 2) % 3), fvarindex, fvarwidth, 0.125f)"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (HbrFace<T>* oppFace = face ->)",
    "insertText": "GetEdge(i)->GetRightFace()"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv .)",
    "insertText": "AddWithWeight(oppFace->GetFVarData((j+1)%oppFace->GetNumVertices()), fvarindex, fvarwidth, 0.125f)"
  },
  {
    "label": "SetInitialized()",
    "kind": "Method",
    "detail": "Function (break ; } } } fvarindex + = fvarwidth ; } fv .)",
    "insertText": "SetInitialized()"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (} return ; } HbrHalfedge<T>* edge ; HbrVertex<T>* v = face ->)",
    "insertText": "GetVertex(index)"
  },
  {
    "label": "GuaranteeNeighbors()",
    "kind": "Method",
    "detail": "Function (v ->)",
    "insertText": "GuaranteeNeighbors()"
  },
  {
    "label": "IsFVarAllSmooth()",
    "kind": "Method",
    "detail": "Function (fv0IsSmooth = v ->)",
    "insertText": "IsFVarAllSmooth()"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (edge = face ->)",
    "insertText": "GetEdge(index)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(edge->GetOrgVertex() == v)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (childVertex = child ->)",
    "insertText": "GetVertex((index + 1) % 3)"
  },
  {
    "label": "GetPrev()",
    "kind": "Method",
    "detail": "Function (edge = edge ->)",
    "insertText": "GetPrev()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(edge == face->GetEdge((index + 2) % 3))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(edge->GetDestVertex() == v)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (childVertex = child ->)",
    "insertText": "GetVertex((index + 2) % 3)"
  },
  {
    "label": "GetFVarMask()",
    "kind": "Method",
    "detail": "Function (const char fvarmask = v ->)",
    "insertText": "GetFVarMask(fvaritem)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (infcorner = true ; } else)",
    "insertText": "if(mesh->GetFVarPropagateCorners())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (infcorner = true ; } } else {)",
    "insertText": "if(face->GetEdge(index)->GetFVarSharpness(fvaritem, true) && face->GetEdge(index)->GetPrev()->GetFVarSharpness(fvaritem, true))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (infcorner = true ; } } })",
    "insertText": "if(fvarinterp == HbrMesh<T>::k_InterpolateBoundaryNone || (fvarinterp == HbrMesh<T>::k_InterpolateBoundaryAlwaysSharp && fvarmask >= 1) || v->GetSharpness() > HbrVertex<T>::k_Smooth || infcorner)"
  },
  {
    "label": "SetWithWeight()",
    "kind": "Method",
    "detail": "Function (fv0 .)",
    "insertText": "SetWithWeight(face->GetFVarData(index), fvarindex, fvarwidth, 1.0f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(fvarmask == 1)"
  },
  {
    "label": "SetWithWeight()",
    "kind": "Method",
    "detail": "Function (fv0 .)",
    "insertText": "SetWithWeight(face->GetFVarData(index), fvarindex, fvarwidth, 0.75f)"
  },
  {
    "label": "GetIncidentEdge()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* start = v ->)",
    "insertText": "GetIncidentEdge()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (edge = start ;)",
    "insertText": "while(edge)"
  },
  {
    "label": "GetNextEdge()",
    "kind": "Method",
    "detail": "Function (break ; } nextedge = v ->)",
    "insertText": "GetNextEdge(edge)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } else)",
    "insertText": "if(!nextedge)"
  },
  {
    "label": "GetDestVertex()",
    "kind": "Method",
    "detail": "Function (break ; } else { edge = nextedge ; } } HbrVertex<T>* w = edge ->)",
    "insertText": "GetDestVertex()"
  },
  {
    "label": "GetLeftFace()",
    "kind": "Method",
    "detail": "Function (HbrFace<T>* bestface = edge ->)",
    "insertText": "GetLeftFace()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int j ;)",
    "insertText": "for(j = 0; j < bestface->GetNumVertices(); ++j)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "assert(j != bestface->GetNumVertices())"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv0 .)",
    "insertText": "AddWithWeight(bestface->GetFVarData(j), fvarindex, fvarwidth, 0.125f)"
  },
  {
    "label": "GetRightFace()",
    "kind": "Method",
    "detail": "Function (bestface = edge ->)",
    "insertText": "GetRightFace()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(fvarmask != 0)"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (HbrFace<T>* bestface = face ; HbrHalfedge<T>* bestedge = face ->)",
    "insertText": "GetEdge(index)->GetPrev()"
  },
  {
    "label": "GetOpposite()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* starte = bestedge ->)",
    "insertText": "GetOpposite()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>* w = 0 ;)",
    "insertText": "if(!starte)"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (w = face ->)",
    "insertText": "GetEdge(index)->GetPrev()->GetOrgVertex()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (} else { HbrHalfedge<T>* e = starte,* next ;)",
    "insertText": "assert(starte->GetOrgVertex() == v)"
  },
  {
    "label": "GetNextEdge()",
    "kind": "Method",
    "detail": "Function (bestedge = e ; break ; } next = v ->)",
    "insertText": "GetNextEdge(e)"
  },
  {
    "label": "GetPrev()",
    "kind": "Method",
    "detail": "Function (w = e ->)",
    "insertText": "GetPrev()->GetOrgVertex()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (break ; } e = next ; })",
    "insertText": "while(e && e != starte)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!w) w = bestedge->GetDestVertex()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (starte = bestedge ; w = 0 ;)",
    "insertText": "if(HbrHalfedge<T>* e = starte)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (bestedge = e ; break ; })",
    "insertText": "assert(e->GetOpposite())"
  },
  {
    "label": "GetPreviousEdge()",
    "kind": "Method",
    "detail": "Function (e = v ->)",
    "insertText": "GetPreviousEdge(e)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(!fv0IsSmooth || !fv0.IsInitialized())"
  },
  {
    "label": "GetValence()",
    "kind": "Method",
    "detail": "Function (int valence = v ->)",
    "insertText": "GetValence()"
  },
  {
    "label": "cosf()",
    "kind": "Method",
    "detail": "Function (float invvalence = 1 . 0 f / valence ; float beta = 0 . 2 5 f*)",
    "insertText": "cosf((float)M_PI * 2.0f * invvalence)"
  },
  {
    "label": "beta()",
    "kind": "Method",
    "detail": "Function (beta = beta* beta ;)",
    "insertText": "beta(0.625f - beta)"
  },
  {
    "label": "SetWithWeight()",
    "kind": "Method",
    "detail": "Function (fv0 .)",
    "insertText": "SetWithWeight(face->GetFVarData(index), fvarindex, fvarwidth, 1 - (beta * valence))"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv0 .)",
    "insertText": "AddWithWeight(g->GetFVarData((j + 1) % g->GetNumVertices()), fvarindex, fvarwidth, beta)"
  },
  {
    "label": "SetWithWeight()",
    "kind": "Method",
    "detail": "Function (fv1 .)",
    "insertText": "SetWithWeight(face->GetFVarData(index), fvarindex, fvarwidth, 0.5f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv1 .)",
    "insertText": "AddWithWeight(face->GetFVarData((index + 1) % 3), fvarindex, fvarwidth, 0.5f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(!fv1IsSmooth || !fv1.IsInitialized())"
  },
  {
    "label": "SetWithWeight()",
    "kind": "Method",
    "detail": "Function (fv1 .)",
    "insertText": "SetWithWeight(face->GetFVarData(index), fvarindex, fvarwidth, 0.375f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv1 .)",
    "insertText": "AddWithWeight(face->GetFVarData((index + 1) % 3), fvarindex, fvarwidth, 0.375f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv1 .)",
    "insertText": "AddWithWeight(face->GetFVarData((index + 2) % 3), fvarindex, fvarwidth, 0.125f)"
  },
  {
    "label": "SetWithWeight()",
    "kind": "Method",
    "detail": "Function (fv2 .)",
    "insertText": "SetWithWeight(face->GetFVarData((index + 2) % 3), fvarindex, fvarwidth, 0.5f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv2 .)",
    "insertText": "AddWithWeight(face->GetFVarData(index), fvarindex, fvarwidth, 0.5f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(!fv2IsSmooth || !fv2.IsInitialized())"
  },
  {
    "label": "SetWithWeight()",
    "kind": "Method",
    "detail": "Function (fv2 .)",
    "insertText": "SetWithWeight(face->GetFVarData((index + 2) % 3), fvarindex, fvarwidth, 0.375f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv2 .)",
    "insertText": "AddWithWeight(face->GetFVarData(index), fvarindex, fvarwidth, 0.375f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv2 .)",
    "insertText": "AddWithWeight(face->GetFVarData((index + 1) % 3), fvarindex, fvarwidth, 0.125f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (fv2 .)",
    "insertText": "AddWithWeight(oppFace->GetFVarData((j+2)%oppFace->GetNumVertices()), fvarindex, fvarwidth, 0.125f)"
  },
  {
    "label": "SetHole()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "SetHole(face->IsHole())"
  },
  {
    "label": "SetHierarchicalEdits()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "SetHierarchicalEdits(edits)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" \\ n \\ nRefining face \"<<* face<<\" \\ n \" ; # endif)",
    "insertText": "assert(face->GetNumVertices() == 3)"
  },
  {
    "label": "GetFirstEdge()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* edge = face ->)",
    "insertText": "GetFirstEdge()"
  },
  {
    "label": "GetOrgVertex()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>* vertex = edge ->)",
    "insertText": "GetOrgVertex()"
  },
  {
    "label": "Subdivide()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" Kid \"<<i<<\" \\ n \" ; # endif HbrFace<T>* child ; HbrVertex<T>* vertices [ 3 ] ; vertices [ i ] = vertex ->)",
    "insertText": "Subdivide()"
  },
  {
    "label": "vertices()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vertices(i + 1) % 3] = edge->Subdivide()"
  },
  {
    "label": "vertices()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vertices(i + 2) % 3] = prevedge->Subdivide()"
  },
  {
    "label": "NewFace()",
    "kind": "Method",
    "detail": "Function (child = mesh ->)",
    "insertText": "NewFace(3, vertices, face, i)"
  },
  {
    "label": "SubdivideCreaseWeight()",
    "kind": "Method",
    "detail": "Function (HbrSubdivision<T)",
    "insertText": "SubdivideCreaseWeight(edge, edge->GetOrgVertex(), childedge)"
  },
  {
    "label": "CopyFVarInfiniteSharpness()",
    "kind": "Method",
    "detail": "Function (} childedge ->)",
    "insertText": "CopyFVarInfiniteSharpness(edge)"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (childedge = child ->)",
    "insertText": "GetEdge((i+2)%3)"
  },
  {
    "label": "SubdivideCreaseWeight()",
    "kind": "Method",
    "detail": "Function (HbrSubdivision<T)",
    "insertText": "SubdivideCreaseWeight(prevedge, prevedge->GetDestVertex(), childedge)"
  },
  {
    "label": "CopyFVarInfiniteSharpness()",
    "kind": "Method",
    "detail": "Function (} childedge ->)",
    "insertText": "CopyFVarInfiniteSharpness(prevedge)"
  },
  {
    "label": "transferFVarToChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transferFVarToChild(mesh, face, child, i)"
  },
  {
    "label": "transferEditsToChild()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "transferEditsToChild(face, child, i)"
  },
  {
    "label": "GetNext()",
    "kind": "Method",
    "detail": "Function (} prevedge = edge ; edge = edge ->)",
    "insertText": "GetNext()"
  },
  {
    "label": "refineFaceAtMiddle()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "refineFaceAtMiddle(mesh, face)"
  },
  {
    "label": "GetDestVertex()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* parentEdge2 = edge ->)",
    "insertText": "GetDestVertex()->GetParentEdge()"
  },
  {
    "label": "GetFace()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" two parent edge situation \\ n \" ; # endif HbrFace<T>* parentFace = parentEdge1 ->)",
    "insertText": "GetFace()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(parentFace == parentEdge2->GetFace())"
  },
  {
    "label": "refineFaceAtMiddle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "refineFaceAtMiddle(mesh, parentFace)"
  },
  {
    "label": "RefineFaceAtVertex()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "RefineFaceAtVertex(mesh, parentFace, parentEdge1->GetOrgVertex())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "assert(edge->GetOpposite())"
  },
  {
    "label": "GetDestVertex()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" parent edge 1 \"<<* parentEdge1<<\" \\ n \" ; # endif HbrVertex<T>* parentVertex2 = edge ->)",
    "insertText": "GetDestVertex()->GetParentVertex()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(parentVertex2)"
  },
  {
    "label": "RefineFaceAtVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefineFaceAtVertex(mesh, parentEdge1->GetLeftFace(), parentVertex2)"
  },
  {
    "label": "RefineFaceAtVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefineFaceAtVertex(mesh, parentEdge1->GetRightFace(), parentVertex2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(parentEdge2)"
  },
  {
    "label": "GetOrgVertex()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" parent edge 2 \"<<* parentEdge2<<\" \\ n \" ; # endif HbrVertex<T>* parentVertex1 = edge ->)",
    "insertText": "GetOrgVertex()->GetParentVertex()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(parentVertex1)"
  },
  {
    "label": "RefineFaceAtVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefineFaceAtVertex(mesh, parentEdge2->GetLeftFace(), parentVertex1)"
  },
  {
    "label": "RefineFaceAtVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefineFaceAtVertex(mesh, parentEdge2->GetRightFace(), parentVertex1)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" \\ n \\ nneighbor guarantee at \"<<* vertex<<\" invoked \\ n \" ; # endif)",
    "insertText": "assert(vertex->GetParentFace() == 0)"
  },
  {
    "label": "GetParentEdge()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* parentEdge = vertex ->)",
    "insertText": "GetParentEdge()"
  },
  {
    "label": "GuaranteeNeighbor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GuaranteeNeighbor(mesh, parentEdge)"
  },
  {
    "label": "RefineFaceAtVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefineFaceAtVertex(mesh, parentFace, dest)"
  },
  {
    "label": "RefineFaceAtVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefineFaceAtVertex(mesh, parentFace, org)"
  },
  {
    "label": "GetParentVertex()",
    "kind": "Method",
    "detail": "Function (} return ; } HbrVertex<T>* parentVertex = vertex ->)",
    "insertText": "GetParentVertex()"
  },
  {
    "label": "RefineFaceAtVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefineFaceAtVertex(mesh, f, parentVertex)"
  },
  {
    "label": "HasLimit()",
    "kind": "Method",
    "detail": "Function (} template<class T> bool HbrLoopSubdivision<T)",
    "insertText": "HasLimit(HbrMesh<T>* , HbrVertex<T>* vertex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case HbrVertex<T>::k_Crease : case HbrVertex<T>::k_Corner : default :)",
    "insertText": "if(vertex->IsVolatile())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } else)",
    "insertText": "if(!next)"
  },
  {
    "label": "GetSharpness()",
    "kind": "Method",
    "detail": "Function (float esharp = edge ->)",
    "insertText": "GetSharpness()"
  },
  {
    "label": "NewVertex()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>* v = mesh ->)",
    "insertText": "NewVertex()"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (T& data = v ->)",
    "insertText": "GetData()"
  },
  {
    "label": "GetOrgVertex()",
    "kind": "Method",
    "detail": "Function (edge ->)",
    "insertText": "GetOrgVertex()->GuaranteeNeighbors()"
  },
  {
    "label": "GetDestVertex()",
    "kind": "Method",
    "detail": "Function (edge ->)",
    "insertText": "GetDestVertex()->GuaranteeNeighbors()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!edge->IsBoundary() && esharp <= 1.0f)"
  },
  {
    "label": "esharp()",
    "kind": "Method",
    "detail": "Function (} float endPtWeight = 0 . 3 7 5 f +)",
    "insertText": "esharp(0.5f - 0.375f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "AddWithWeight(edge->GetOrgVertex()->GetData(), endPtWeight)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "AddWithWeight(edge->GetDestVertex()->GetData(), endPtWeight)"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (float oppPtWeight = 0 . 1 2 5)",
    "insertText": "f(1 - esharp)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "AddWithWeight(ee->GetDestVertex()->GetData(), oppPtWeight)"
  },
  {
    "label": "GetOpposite()",
    "kind": "Method",
    "detail": "Function (ee = edge ->)",
    "insertText": "GetOpposite()->GetNext()"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (} else { data .)",
    "insertText": "AddWithWeight(edge->GetOrgVertex()->GetData(), 0.5f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "AddWithWeight(edge->GetDestVertex()->GetData(), 0.5f)"
  },
  {
    "label": "AddVaryingWithWeight()",
    "kind": "Method",
    "detail": "Function (} data .)",
    "insertText": "AddVaryingWithWeight(edge->GetOrgVertex()->GetData(), 0.5f)"
  },
  {
    "label": "AddVaryingWithWeight()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "AddVaryingWithWeight(edge->GetDestVertex()->GetData(), 0.5f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" created \"<<* v<<\" \\ n \" ; # endif)",
    "insertText": "if(edge->IsBoundary())"
  },
  {
    "label": "SetExtraordinary()",
    "kind": "Method",
    "detail": "Function (v ->)",
    "insertText": "SetExtraordinary()"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (float valence = static_cast<)",
    "insertText": "float(vertex->GetValence())"
  },
  {
    "label": "GetMask()",
    "kind": "Method",
    "detail": "Function (int masks [ 2 ] ; float weights [ 2 ] ; int passes ; masks [ 0 ] = vertex ->)",
    "insertText": "GetMask(false)"
  },
  {
    "label": "GetMask()",
    "kind": "Method",
    "detail": "Function (masks [ 1 ] = vertex ->)",
    "insertText": "GetMask(true)"
  },
  {
    "label": "GetFractionalMask()",
    "kind": "Method",
    "detail": "Function (weights [ 1 ] = vertex ->)",
    "insertText": "GetFractionalMask()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (weights [ 0 ] = 1 . 0 f - weights [ 1 ] ; passes = 2 ; } else { weights [ 0 ] = 1 . 0 f ; weights [ 1 ] = 0 . 0 f ; passes = 1 ; })",
    "insertText": "for(int i = 0; i < passes; ++i)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (data .)",
    "insertText": "AddWithWeight(vertex->GetData(), weights[i] * (1 - (beta * valence)))"
  },
  {
    "label": "AddSurroundingVerticesWithWeight()",
    "kind": "Method",
    "detail": "Function (HbrSubdivision<T)",
    "insertText": "AddSurroundingVerticesWithWeight(mesh, vertex, weights[i] * beta, &data)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (break ; } case HbrVertex<T>::k_Crease : { data .)",
    "insertText": "AddWithWeight(vertex->GetData(), weights[i] * 0.75f)"
  },
  {
    "label": "AddCreaseEdgesWithWeight()",
    "kind": "Method",
    "detail": "Function (HbrSubdivision<T)",
    "insertText": "AddCreaseEdgesWithWeight(mesh, vertex, i == 1, weights[i] * 0.125f, &data)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (break ; } case HbrVertex<T>::k_Corner : default : { data .)",
    "insertText": "AddWithWeight(vertex->GetData(), weights[i])"
  },
  {
    "label": "AddVaryingWithWeight()",
    "kind": "Method",
    "detail": "Function (break ; } } } data .)",
    "insertText": "AddVaryingWithWeight(vertex->GetData(), 1.0f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" Subdividing at \"<<* vertex<<\" \\ n \" ; std::cerr<<\" created \"<<* v<<\" \\ n \" ; # endif)",
    "insertText": "if(vertex->IsExtraordinary()) v->SetExtraordinary()"
  },
  {
    "label": "SetSharpness()",
    "kind": "Method",
    "detail": "Function (v ->)",
    "insertText": "SetSharpness(HbrVertex<T>::k_InfinitelySharp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(sharp > HbrVertex<T>::k_Smooth)"
  },
  {
    "label": "SetSharpness()",
    "kind": "Method",
    "detail": "Function (v ->)",
    "insertText": "SetSharpness(std::max((float) HbrVertex<T>::k_Smooth, sharp - 1.0f))"
  },
  {
    "label": "SetSharpness()",
    "kind": "Method",
    "detail": "Function (} else { v ->)",
    "insertText": "SetSharpness(HbrVertex<T>::k_Smooth)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" Refining middle face of \"<<* face<<\" \\ n \" ; # endif)",
    "insertText": "if(!face->GetChild(3))"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (HbrFace<T>* child ; HbrVertex<T>* vertices [ 3 ] ; vertices [ 0 ] = face ->)",
    "insertText": "GetEdge(1)->Subdivide()"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (vertices [ 1 ] = face ->)",
    "insertText": "GetEdge(2)->Subdivide()"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (vertices [ 2 ] = face ->)",
    "insertText": "GetEdge(0)->Subdivide()"
  },
  {
    "label": "NewFace()",
    "kind": "Method",
    "detail": "Function (child = mesh ->)",
    "insertText": "NewFace(3, vertices, face, 3)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_DEBUG std::cerr<<\" Creating face \"<<* child<<\" \\ n \" ; # endif)",
    "insertText": "if(mesh->GetTotalFVarWidth())"
  },
  {
    "label": "transferFVarToChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transferFVarToChild(mesh, face, child, 3)"
  },
  {
    "label": "transferEditsToChild()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "transferEditsToChild(face, child, 3)"
  }
]