[
  {
    "label": "Notification",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Notification"
  },
  {
    "label": "Notification()",
    "kind": "Method",
    "detail": "Function (# ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PORT_H_ # define GOOGLETEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PORT_H_ # define GTEST_HAS_NOTIFICATION_ 1 namespace testing { namespace internal { class Notification { public :)",
    "insertText": "Notification()"
  },
  {
    "label": "Notification()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Notification(const Notification&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Notification&)",
    "insertText": "operator(const Notification&)"
  },
  {
    "label": "WaitForNotification()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WaitForNotification()"
  }
]    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Derived"
  },
  {
    "label": "Base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Base"
  },
  {
    "label": "ThreadWithParamBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ThreadWithParamBase"
  },
  {
    "label": "ThreadWithParam",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ThreadWithParam"
  },
  {
    "label": "MutexType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "MutexType"
  },
  {
    "label": "StaticConstructorSelector",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "StaticConstructorSelector"
  },
  {
    "label": "GTestMutexLock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GTestMutexLock"
  },
  {
    "label": "ThreadLocalValueHolderBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ThreadLocalValueHolderBase"
  },
  {
    "label": "ThreadLocalBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ThreadLocalBase"
  },
  {
    "label": "Runnable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Runnable"
  },
  {
    "label": "RunnableImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RunnableImpl"
  },
  {
    "label": "ThreadLocal",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ThreadLocal"
  },
  {
    "label": "ValueHolder",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueHolder"
  },
  {
    "label": "ValueHolderFactory",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueHolderFactory"
  },
  {
    "label": "DefaultValueHolderFactory",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DefaultValueHolderFactory"
  },
  {
    "label": "InstanceValueHolderFactory",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "InstanceValueHolderFactory"
  },
  {
    "label": "MutexBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MutexBase"
  },
  {
    "label": "Mutex",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Mutex"
  },
  {
    "label": "_stat",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_stat"
  },
  {
    "label": "stat",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "stat"
  },
  {
    "label": "wchar_codecvt",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "wchar_codecvt"
  },
  {
    "label": "TypeWithSize",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TypeWithSize"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_ # define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_ # include<ctype . h> # include<stddef . h> # include<stdio . h> # include<stdlib . h> # include<string . h> # include<cerrno> # include<cstdint> # include<iostream> # include<limits> # include<locale> # include<memory> # include<string> # include<tuple> # include<type_traits> # include<vector> # ifndef _WIN32_WCE # include<sys / stat . h> # include<sys / types . h> # endif # if defined __APPLE__ # include<AvailabilityMacros . h> # include<TargetConditionals . h> # endif # include \" gtest / internal / custom / gtest - port . h \" # include \" gtest / internal / gtest - port - arch . h \" # if GTEST_HAS_ABSL # include \" absl / flags / declare . h \" # include \" absl / flags / flag . h \" # include \" absl / flags / reflection . h \" # endif # if !)",
    "insertText": "defined(GTEST_DEV_EMAIL_) #define GTEST_DEV_EMAIL_ \"googletestframework@@googlegroups.com\" #define GTEST_FLAG_PREFIX_ \"gtest_\" #define GTEST_FLAG_PREFIX_DASH_ \"gtest-\" #define GTEST_FLAG_PREFIX_UPPER_ \"GTEST_\" #define GTEST_NAME_ \"Google Test\" #define GTEST_PROJECT_URL_ \"https: #endif #if !defined(GTEST_INIT_GOOGLE_TEST_NAME_) #define GTEST_INIT_GOOGLE_TEST_NAME_ \"testing::InitGoogleTest\" #endif #ifdef __GNUC__ #define GTEST_GCC_VER_ \\ (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) #endif #if defined(_MSC_VER) #define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings) \\ __pragma(warning(push)) __pragma(warning(disable : warnings)) #define GTEST_DISABLE_MSC_WARNINGS_POP_() __pragma(warning(pop)) #else #define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings) #define GTEST_DISABLE_MSC_WARNINGS_POP_() #endif #ifdef __clang__ #define GTEST_DISABLE_MSC_DEPRECATED_PUSH_() \\ _Pragma(\"clang diagnostic push\") \\ _Pragma(\"clang diagnostic ignored \\\"-Wdeprecated-declarations\\\"\") \\ _Pragma(\"clang diagnostic ignored \\\"-Wdeprecated-implementations\\\"\") #define GTEST_DISABLE_MSC_DEPRECATED_POP_() _Pragma(\"clang diagnostic pop\") #else #define GTEST_DISABLE_MSC_DEPRECATED_PUSH_() \\ GTEST_DISABLE_MSC_WARNINGS_PUSH_(4996) #define GTEST_DISABLE_MSC_DEPRECATED_POP_() GTEST_DISABLE_MSC_WARNINGS_POP_() #endif #if GTEST_OS_WINDOWS #if !GTEST_OS_WINDOWS_MOBILE #include <direct.h> #include <io.h> #endif #if GTEST_OS_WINDOWS_MINGW && !defined(__MINGW64_VERSION_MAJOR)"
  },
  {
    "label": "GTEST_HAS_POSIX_RE()",
    "kind": "Method",
    "detail": "Function (# else typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION ; # endif # elif GTEST_OS_XTENSA # include<unistd . h> # else # include<strings . h> # include<unistd . h> # endif # if GTEST_OS_LINUX_ANDROID # include<android / api - level . h> # endif # ifndef GTEST_HAS_POSIX_RE # if GTEST_OS_LINUX_ANDROID # define)",
    "insertText": "GTEST_HAS_POSIX_RE(__ANDROID_API__ >= 9) #else #define GTEST_HAS_POSIX_RE (!GTEST_OS_WINDOWS && !GTEST_OS_XTENSA) #endif #endif #if GTEST_HAS_ABSL #include \"absl/strings/string_view.h\" #include \"re2/re2.h\" #define GTEST_USES_RE2 1 #elif GTEST_HAS_POSIX_RE #include <regex.h> #define GTEST_USES_POSIX_RE 1 #else #define GTEST_USES_SIMPLE_RE 1 #endif #ifndef GTEST_HAS_EXCEPTIONS #if defined(_MSC_VER) && defined(_CPPUNWIND) #define GTEST_HAS_EXCEPTIONS 1 #elif defined(__BORLANDC__) #ifndef _HAS_EXCEPTIONS #define _HAS_EXCEPTIONS 1 #endif #define GTEST_HAS_EXCEPTIONS _HAS_EXCEPTIONS #elif defined(__clang__) #define GTEST_HAS_EXCEPTIONS (__EXCEPTIONS && __has_feature(cxx_exceptions)) #elif defined(__GNUC__) && __EXCEPTIONS #define GTEST_HAS_EXCEPTIONS 1 #elif defined(__SUNPRO_CC) #define GTEST_HAS_EXCEPTIONS 1 #elif defined(__IBMCPP__) && __EXCEPTIONS #define GTEST_HAS_EXCEPTIONS 1 #elif defined(__HP_aCC) #define GTEST_HAS_EXCEPTIONS 1 #else #define GTEST_HAS_EXCEPTIONS 0 #endif #endif #ifndef GTEST_HAS_STD_WSTRING #define GTEST_HAS_STD_WSTRING \\ (!(GTEST_OS_LINUX_ANDROID || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS || \\ GTEST_OS_HAIKU || GTEST_OS_ESP32 || GTEST_OS_ESP8266 || GTEST_OS_XTENSA)) #endif #ifndef GTEST_HAS_RTTI #ifdef _MSC_VER #ifdef _CPPRTTI #define GTEST_HAS_RTTI 1 #else #define GTEST_HAS_RTTI 0 #endif #elif defined(__GNUC__) #ifdef __GXX_RTTI #if GTEST_OS_LINUX_ANDROID && defined(_STLPORT_MAJOR) && !defined(__EXCEPTIONS) #define GTEST_HAS_RTTI 0 #else #define GTEST_HAS_RTTI 1 #endif #else #define GTEST_HAS_RTTI 0 #endif #elif defined(__clang__) #define GTEST_HAS_RTTI __has_feature(cxx_rtti) #elif defined(__IBMCPP__) && (__IBMCPP__ >= 900) #ifdef __RTTI_ALL__ #define GTEST_HAS_RTTI 1 #else #define GTEST_HAS_RTTI 0 #endif #else #define GTEST_HAS_RTTI 1 #endif #endif #if GTEST_HAS_RTTI #include <typeinfo> #endif #ifndef GTEST_HAS_PTHREAD #define GTEST_HAS_PTHREAD \\ (GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_HPUX || GTEST_OS_QNX || \\ GTEST_OS_FREEBSD || GTEST_OS_NACL || GTEST_OS_NETBSD || GTEST_OS_FUCHSIA || \\ GTEST_OS_DRAGONFLY || GTEST_OS_GNU_KFREEBSD || GTEST_OS_OPENBSD || \\ GTEST_OS_HAIKU || GTEST_OS_GNU_HURD) #endif #if GTEST_HAS_PTHREAD #include <pthread.h> #include <time.h> #endif #ifndef GTEST_HAS_CLONE #if GTEST_OS_LINUX && !defined(__ia64__) #if GTEST_OS_LINUX_ANDROID #if defined(__LP64__) || (defined(__arm__) && __ANDROID_API__ >= 9) || \\ (defined(__mips__) && __ANDROID_API__ >= 12) || \\ (defined(__i386__) && __ANDROID_API__ >= 17) #define GTEST_HAS_CLONE 1 #else #define GTEST_HAS_CLONE 0 #endif #else #define GTEST_HAS_CLONE 1 #endif #else #define GTEST_HAS_CLONE 0 #endif #endif #ifndef GTEST_HAS_STREAM_REDIRECTION #if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE || \\ GTEST_OS_WINDOWS_RT || GTEST_OS_ESP8266 || GTEST_OS_XTENSA #define GTEST_HAS_STREAM_REDIRECTION 0 #else #define GTEST_HAS_STREAM_REDIRECTION 1 #endif #endif #if (GTEST_OS_LINUX || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS || \\ (GTEST_OS_MAC && !GTEST_OS_IOS) || \\ (GTEST_OS_WINDOWS_DESKTOP && _MSC_VER) || GTEST_OS_WINDOWS_MINGW || \\ GTEST_OS_AIX || GTEST_OS_HPUX || GTEST_OS_OPENBSD || GTEST_OS_QNX || \\ GTEST_OS_FREEBSD || GTEST_OS_NETBSD || GTEST_OS_FUCHSIA || \\ GTEST_OS_DRAGONFLY || GTEST_OS_GNU_KFREEBSD || GTEST_OS_HAIKU || \\ GTEST_OS_GNU_HURD) #define GTEST_HAS_DEATH_TEST 1 #endif #if defined(__GNUC__) || defined(_MSC_VER) || defined(__SUNPRO_CC) || \\ defined(__IBMCPP__) || defined(__HP_aCC) #define GTEST_HAS_TYPED_TEST 1 #define GTEST_HAS_TYPED_TEST_P 1 #endif #define GTEST_WIDE_STRING_USES_UTF16_ \\ (GTEST_OS_WINDOWS || GTEST_OS_CYGWIN || GTEST_OS_AIX || GTEST_OS_OS2) #if GTEST_OS_LINUX || GTEST_OS_GNU_KFREEBSD || GTEST_OS_DRAGONFLY || \\ GTEST_OS_FREEBSD || GTEST_OS_NETBSD || GTEST_OS_OPENBSD || \\ GTEST_OS_GNU_HURD #define GTEST_CAN_STREAM_RESULTS_ 1 #endif #ifdef __INTEL_COMPILER #define GTEST_AMBIGUOUS_ELSE_BLOCKER_ #else #define GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\ switch (0) \\ case 0: \\ default: #endif #if defined(__GNUC__) && !defined(COMPILER_ICC) #define GTEST_ATTRIBUTE_UNUSED_ __attribute__((unused)) #elif defined(__clang__) #if __has_attribute(unused) #define GTEST_ATTRIBUTE_UNUSED_ __attribute__((unused)) #endif #endif #ifndef GTEST_ATTRIBUTE_UNUSED_ #define GTEST_ATTRIBUTE_UNUSED_ #endif #if (defined(__GNUC__) || defined(__clang__)) && !defined(COMPILER_ICC) #if defined(__MINGW_PRINTF_FORMAT) #define GTEST_ATTRIBUTE_PRINTF_(string_index, first_to_check) \\ __attribute__(( \\ __format__(__MINGW_PRINTF_FORMAT, string_index, first_to_check))) #else #define GTEST_ATTRIBUTE_PRINTF_(string_index, first_to_check) \\ __attribute__((__format__(__printf__, string_index, first_to_check))) #endif #else #define GTEST_ATTRIBUTE_PRINTF_(string_index, first_to_check) #endif #if defined(__GNUC__) && !defined(COMPILER_ICC) #define GTEST_MUST_USE_RESULT_ __attribute__((warn_unused_result)) #else #define GTEST_MUST_USE_RESULT_ #endif #define GTEST_INTENTIONAL_CONST_COND_PUSH_() \\ GTEST_DISABLE_MSC_WARNINGS_PUSH_(4127) #define GTEST_INTENTIONAL_CONST_COND_POP_() GTEST_DISABLE_MSC_WARNINGS_POP_() #ifndef GTEST_HAS_SEH #if defined(_MSC_VER) || defined(__BORLANDC__) #define GTEST_HAS_SEH 1 #else #define GTEST_HAS_SEH 0 #endif #endif #ifndef GTEST_IS_THREADSAFE #define GTEST_IS_THREADSAFE \\ (GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ || \\ (GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT) || \\ GTEST_HAS_PTHREAD) #endif #if GTEST_IS_THREADSAFE #include <condition_variable> #include <mutex> #endif #ifndef GTEST_API_ #ifdef _MSC_VER #if GTEST_LINKED_AS_SHARED_LIBRARY #define GTEST_API_ __declspec(dllimport) #elif GTEST_CREATE_SHARED_LIBRARY #define GTEST_API_ __declspec(dllexport) #endif #elif __GNUC__ >= 4 || defined(__clang__) #define GTEST_API_ __attribute__((visibility(\"default\"))) #endif #endif #ifndef GTEST_API_ #define GTEST_API_ #endif #ifndef GTEST_DEFAULT_DEATH_TEST_STYLE #define GTEST_DEFAULT_DEATH_TEST_STYLE \"fast\" #endif #ifdef __GNUC__ #define GTEST_NO_INLINE_ __attribute__((noinline)) #else #define GTEST_NO_INLINE_ #endif #if defined(__clang__) #if __has_attribute(disable_tail_calls) #define GTEST_NO_TAIL_CALL_ __attribute__((disable_tail_calls)) #endif #elif __GNUC__ #define GTEST_NO_TAIL_CALL_ \\ __attribute__((optimize(\"no-optimize-sibling-calls\"))) #else #define GTEST_NO_TAIL_CALL_ #endif #if !defined(GTEST_HAS_CXXABI_H_) #if defined(__GLIBCXX__) || (defined(_LIBCPP_VERSION) && !defined(_MSC_VER)) #define GTEST_HAS_CXXABI_H_ 1 #else #define GTEST_HAS_CXXABI_H_ 0 #endif #endif #if defined(__clang__) #if __has_feature(memory_sanitizer) #define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_ __attribute__((no_sanitize_memory)) #else #define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_ #endif #else #define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_ #endif #if defined(__clang__) #if __has_feature(address_sanitizer) #define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_ \\ __attribute__((no_sanitize_address)) #else #define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_ #endif #else #define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_ #endif #if defined(__clang__) #if __has_feature(hwaddress_sanitizer) #define GTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_ \\ __attribute__((no_sanitize(\"hwaddress\"))) #else #define GTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_ #endif #else #define GTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_ #endif #if defined(__clang__) #if __has_feature(thread_sanitizer) #define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_ __attribute__((no_sanitize_thread))"
  },
  {
    "label": "IsTrue()",
    "kind": "Method",
    "detail": "Function (class Message ; using std::get ; using std::make_tuple ; using std::tuple ; using std::tuple_element ; using std::tuple_size ; namespace internal { class Secret ; GTEST_API_ bool)",
    "insertText": "IsTrue(bool condition)"
  },
  {
    "label": "RE()",
    "kind": "Method",
    "detail": "Function (# if GTEST_USES_RE2 class GTEST_API_ RE { public :)",
    "insertText": "RE(absl::string_view regex) : regex_(regex)"
  },
  {
    "label": "RE()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RE(const char* regex) : RE(absl::string_view(regex))"
  },
  {
    "label": "RE()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RE(const std::string& regex) : RE(absl::string_view(regex))"
  },
  {
    "label": "RE()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RE(const RE& other) : RE(other.pattern())"
  },
  {
    "label": "pattern()",
    "kind": "Method",
    "detail": "Function (} const std::string&)",
    "insertText": "pattern()"
  },
  {
    "label": "FullMatch()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "FullMatch(absl::string_view str, const RE& re)"
  },
  {
    "label": "PartialMatch()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "PartialMatch(absl::string_view str, const RE& re)"
  },
  {
    "label": "RE()",
    "kind": "Method",
    "detail": "Function (} private : RE2 regex_ ; } ; # elif GTEST_USES_POSIX_RE | | GTEST_USES_SIMPLE_RE class GTEST_API_ RE { public :)",
    "insertText": "RE(const RE& other)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(other.pattern())"
  },
  {
    "label": "RE()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RE(const ::std::string& regex)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(regex.c_str())"
  },
  {
    "label": "RE()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RE(const char* regex)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(regex)"
  },
  {
    "label": "RE()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "RE()"
  },
  {
    "label": "PartialMatch()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "PartialMatch(const ::std::string& str, const RE& re)"
  },
  {
    "label": "FullMatch()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "FullMatch(const char* str, const RE& re)"
  },
  {
    "label": "PartialMatch()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "PartialMatch(const char* str, const RE& re)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "Init(const char* regex)"
  },
  {
    "label": "FormatFileLocation()",
    "kind": "Method",
    "detail": "Function (const char* pattern_ ; bool is_valid_ ; # if GTEST_USES_POSIX_RE regex_t full_regex_ ; regex_t partial_regex_ ; # else const char* full_pattern_ ; # endif } ; # endif GTEST_API_::std::string)",
    "insertText": "FormatFileLocation(const char* file, int line)"
  },
  {
    "label": "FormatCompilerIndependentFileLocation()",
    "kind": "Method",
    "detail": "Function (GTEST_API_::std::string)",
    "insertText": "FormatCompilerIndependentFileLocation(const char* file, int line)"
  },
  {
    "label": "GTestLog()",
    "kind": "Method",
    "detail": "Function (enum GTestLogSeverity { GTEST_INFO,GTEST_WARNING,GTEST_ERROR,GTEST_FATAL } ; class GTEST_API_ GTestLog { public :)",
    "insertText": "GTestLog(GTestLogSeverity severity, const char* file, int line)"
  },
  {
    "label": "GTestLog()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "GTestLog()"
  },
  {
    "label": "GetStream()",
    "kind": "Method",
    "detail": "Function (::std::ostream&)",
    "insertText": "GetStream()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (GTestLog&)",
    "insertText": "operator(const GTestLog&)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} ; # if !)",
    "insertText": "defined(GTEST_LOG_) #define GTEST_LOG_(severity) \\ ::testing::internal::GTestLog(::testing::internal::GTEST_##severity, \\ __FILE__, __LINE__) \\ .GetStream() inline void LogToStderr()"
  },
  {
    "label": "FlushInfoLog()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "FlushInfoLog()"
  },
  {
    "label": "fflush()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fflush(nullptr)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # endif # if !)",
    "insertText": "defined(GTEST_CHECK_) #define GTEST_CHECK_(condition) \\ GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\ if (::testing::internal::IsTrue(condition))"
  },
  {
    "label": "GTEST_LOG_()",
    "kind": "Method",
    "detail": "Function (\\ else \\)",
    "insertText": "GTEST_LOG_(FATAL) << \"Condition \" #condition \" failed. \" #endif #define GTEST_CHECK_POSIX_SUCCESS_(posix_call) \\ if (const int gtest_error = (posix_call)) \\ GTEST_LOG_(FATAL)"
  },
  {
    "label": "GTEST_REFERENCE_TO_CONST_()",
    "kind": "Method",
    "detail": "Function (typedef const T& type ; } ; template<T> struct ConstRef<T&> { typedef T& type ; } ; # define)",
    "insertText": "GTEST_REFERENCE_TO_CONST_(T) \\ typename ::testing::internal::ConstRef<T>::type template <typename To> inline To ImplicitCast_(To x)"
  },
  {
    "label": "GTEST_INTENTIONAL_CONST_COND_PUSH_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GTEST_INTENTIONAL_CONST_COND_PUSH_() if (false)"
  },
  {
    "label": "GTEST_INTENTIONAL_CONST_COND_POP_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GTEST_INTENTIONAL_CONST_COND_POP_()"
  },
  {
    "label": "From()",
    "kind": "Method",
    "detail": "Function (::testing::internal::ImplicitCast_<)",
    "insertText": "From(to)"
  },
  {
    "label": "GTEST_CHECK_()",
    "kind": "Method",
    "detail": "Function (} # if GTEST_HAS_RTTI)",
    "insertText": "GTEST_CHECK_(f == nullptr || dynamic_cast<To>(f) != nullptr)"
  },
  {
    "label": "To()",
    "kind": "Method",
    "detail": "Function (# endif return static_cast<)",
    "insertText": "To(f)"
  },
  {
    "label": "CheckedDowncastToActualType()",
    "kind": "Method",
    "detail": "Function (} template<class Derived,class Base> Derived*)",
    "insertText": "CheckedDowncastToActualType(Base* base)"
  },
  {
    "label": "GTEST_CHECK_()",
    "kind": "Method",
    "detail": "Function (# if GTEST_HAS_RTTI)",
    "insertText": "GTEST_CHECK_(typeid(*base) == typeid(Derived))"
  },
  {
    "label": "Derived()",
    "kind": "Method",
    "detail": "Function (# endif # if GTEST_HAS_DOWNCAST_ return::down_cast<)",
    "insertText": "Derived(base)"
  },
  {
    "label": "CaptureStdout()",
    "kind": "Method",
    "detail": "Function (# endif } # if GTEST_HAS_STREAM_REDIRECTION GTEST_API_ void)",
    "insertText": "CaptureStdout()"
  },
  {
    "label": "GetCapturedStdout()",
    "kind": "Method",
    "detail": "Function (GTEST_API_ std::string)",
    "insertText": "GetCapturedStdout()"
  },
  {
    "label": "CaptureStderr()",
    "kind": "Method",
    "detail": "Function (GTEST_API_ void)",
    "insertText": "CaptureStderr()"
  },
  {
    "label": "GetCapturedStderr()",
    "kind": "Method",
    "detail": "Function (GTEST_API_ std::string)",
    "insertText": "GetCapturedStderr()"
  },
  {
    "label": "GetFileSize()",
    "kind": "Method",
    "detail": "Function (# endif GTEST_API_ size_t)",
    "insertText": "GetFileSize(FILE* file)"
  },
  {
    "label": "ReadEntireFile()",
    "kind": "Method",
    "detail": "Function (GTEST_API_ std::string)",
    "insertText": "ReadEntireFile(FILE* file)"
  },
  {
    "label": "GetArgvs()",
    "kind": "Method",
    "detail": "Function (GTEST_API_ std::vector<std::string>)",
    "insertText": "GetArgvs()"
  },
  {
    "label": "GetInjectableArgvs()",
    "kind": "Method",
    "detail": "Function (# if GTEST_HAS_DEATH_TEST std::vector<std::string>)",
    "insertText": "GetInjectableArgvs()"
  },
  {
    "label": "SetInjectableArgvs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetInjectableArgvs(const std::vector<std::string>* new_argvs)"
  },
  {
    "label": "SetInjectableArgvs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetInjectableArgvs(const std::vector<std::string>& new_argvs)"
  },
  {
    "label": "ClearInjectableArgvs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearInjectableArgvs()"
  },
  {
    "label": "AutoHandle()",
    "kind": "Method",
    "detail": "Function (# endif # if GTEST_IS_THREADSAFE # if GTEST_OS_WINDOWS class GTEST_API_ AutoHandle { public : typedef void* Handle ;)",
    "insertText": "AutoHandle()"
  },
  {
    "label": "AutoHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AutoHandle(Handle handle)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (Handle)",
    "insertText": "Get()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset(Handle handle)"
  },
  {
    "label": "IsCloseable()",
    "kind": "Method",
    "detail": "Function (private : bool)",
    "insertText": "IsCloseable()"
  },
  {
    "label": "AutoHandle()",
    "kind": "Method",
    "detail": "Function (Handle handle_ ;)",
    "insertText": "AutoHandle(const AutoHandle&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (AutoHandle&)",
    "insertText": "operator(const AutoHandle&)"
  },
  {
    "label": "GTEST_DISABLE_MSC_WARNINGS_PUSH_()",
    "kind": "Method",
    "detail": "Function (} ; # endif # if GTEST_HAS_NOTIFICATION_ # else)",
    "insertText": "GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\)"
  },
  {
    "label": "Notification()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "Notification() : notified_(false)"
  },
  {
    "label": "Notification()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Notification(const Notification&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Notification&)",
    "insertText": "operator(const Notification&)"
  },
  {
    "label": "Notify()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Notify()"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (std::lock_guard<std::mutex>)",
    "insertText": "lock(mu_)"
  },
  {
    "label": "notify_all()",
    "kind": "Method",
    "detail": "Function (notified_ = true ; cv_ .)",
    "insertText": "notify_all()"
  },
  {
    "label": "WaitForNotification()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "WaitForNotification()"
  },
  {
    "label": "wait()",
    "kind": "Method",
    "detail": "Function (cv_ .)",
    "insertText": "wait(lock, [this]() { return notified_; })"
  },
  {
    "label": "GTEST_DISABLE_MSC_WARNINGS_POP_()",
    "kind": "Method",
    "detail": "Function (} private : std::mutex mu_ ; std::condition_variable cv_ ; bool notified_ ; } ;)",
    "insertText": "GTEST_DISABLE_MSC_WARNINGS_POP_()"
  },
  {
    "label": "ThreadWithParamBase()",
    "kind": "Method",
    "detail": "Function (public : ~)",
    "insertText": "ThreadWithParamBase()"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Run()"
  },
  {
    "label": "ThreadFuncWithCLinkage()",
    "kind": "Method",
    "detail": "Function (} ; \" C \" void*)",
    "insertText": "ThreadFuncWithCLinkage(void* thread)"
  },
  {
    "label": "ThreadWithParamBase()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "ThreadWithParamBase(thread)->Run()"
  },
  {
    "label": "ThreadWithParam()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start) : func_(func), param_(param), thread_can_start_(thread_can_start), finished_(false)"
  },
  {
    "label": "GTEST_CHECK_POSIX_SUCCESS_()",
    "kind": "Method",
    "detail": "Function (ThreadWithParamBase* const base = this ;)",
    "insertText": "GTEST_CHECK_POSIX_SUCCESS_(pthread_create(&thread_, nullptr, &ThreadFuncWithCLinkage, base))"
  },
  {
    "label": "ThreadWithParam()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ThreadWithParam()"
  },
  {
    "label": "Join()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Join()"
  },
  {
    "label": "GTEST_CHECK_POSIX_SUCCESS_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GTEST_CHECK_POSIX_SUCCESS_(pthread_join(thread_, nullptr))"
  },
  {
    "label": "func_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "func_(param_)"
  },
  {
    "label": "ThreadWithParam()",
    "kind": "Method",
    "detail": "Function (} private : UserThreadFunc* const func_ ; const T param_ ; Notification* const thread_can_start_ ; bool finished_ ; pthread_t thread_ ;)",
    "insertText": "ThreadWithParam(const ThreadWithParam&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ThreadWithParam&)",
    "insertText": "operator(const ThreadWithParam&)"
  },
  {
    "label": "Mutex()",
    "kind": "Method",
    "detail": "Function (} ; # endif # if GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ # elif GTEST_OS_WINDOWS&& ! GTEST_OS_WINDOWS_PHONE&& ! GTEST_OS_WINDOWS_RT class GTEST_API_ Mutex { public : enum MutexType { kStatic = 0,kDynamic = 1 } ; enum StaticConstructorSelector { kStaticMutex = 0 } ;)",
    "insertText": "Mutex(StaticConstructorSelector)"
  },
  {
    "label": "Mutex()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Mutex()"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Lock()"
  },
  {
    "label": "Unlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unlock()"
  },
  {
    "label": "AssertHeld()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AssertHeld()"
  },
  {
    "label": "ThreadSafeLazyInit()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "ThreadSafeLazyInit()"
  },
  {
    "label": "Mutex()",
    "kind": "Method",
    "detail": "Function (unsigned int owner_thread_id_ ; MutexType type_ ; long critical_section_init_phase_ ; GTEST_CRITICAL_SECTION* critical_section_ ;)",
    "insertText": "Mutex(const Mutex&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Mutex&)",
    "insertText": "operator(const Mutex&)"
  },
  {
    "label": "GTEST_DECLARE_STATIC_MUTEX_()",
    "kind": "Method",
    "detail": "Function (} ; # define)",
    "insertText": "GTEST_DECLARE_STATIC_MUTEX_(mutex) \\ extern ::testing::internal::Mutex mutex #define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\ ::testing::internal::Mutex mutex(::testing::internal::Mutex::kStaticMutex)"
  },
  {
    "label": "GTestMutexLock()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "GTestMutexLock(Mutex* mutex) : mutex_(mutex)"
  },
  {
    "label": "GTestMutexLock()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "GTestMutexLock()"
  },
  {
    "label": "GTestMutexLock()",
    "kind": "Method",
    "detail": "Function (} private : Mutex* const mutex_ ;)",
    "insertText": "GTestMutexLock(const GTestMutexLock&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (GTestMutexLock&)",
    "insertText": "operator(const GTestMutexLock&)"
  },
  {
    "label": "ThreadLocalValueHolderBase()",
    "kind": "Method",
    "detail": "Function (} ; typedef GTestMutexLock MutexLock ; class ThreadLocalValueHolderBase { public : ~)",
    "insertText": "ThreadLocalValueHolderBase()"
  },
  {
    "label": "NewValueForCurrentThread()",
    "kind": "Method",
    "detail": "Function (} } ; class ThreadLocalBase { public : ThreadLocalValueHolderBase*)",
    "insertText": "NewValueForCurrentThread()"
  },
  {
    "label": "ThreadLocalBase()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "ThreadLocalBase()"
  },
  {
    "label": "ThreadLocalBase()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "ThreadLocalBase(const ThreadLocalBase&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ThreadLocalBase&)",
    "insertText": "operator(const ThreadLocalBase&)"
  },
  {
    "label": "GetValueOnCurrentThread()",
    "kind": "Method",
    "detail": "Function (} ; class GTEST_API_ ThreadLocalRegistry { public : ThreadLocalValueHolderBase*)",
    "insertText": "GetValueOnCurrentThread(const ThreadLocalBase* thread_local_instance)"
  },
  {
    "label": "OnThreadLocalDestroyed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnThreadLocalDestroyed(const ThreadLocalBase* thread_local_instance)"
  },
  {
    "label": "Runnable()",
    "kind": "Method",
    "detail": "Function (protected : class Runnable { public : ~)",
    "insertText": "Runnable()"
  },
  {
    "label": "ThreadWithParamBase()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "ThreadWithParamBase(Runnable* runnable, Notification* thread_can_start)"
  },
  {
    "label": "UserThreadFunc()",
    "kind": "Method",
    "detail": "Function (private : AutoHandle thread_ ; } ; template<T> class ThreadWithParam : public ThreadWithParamBase { public : typedef void)",
    "insertText": "UserThreadFunc(T)"
  },
  {
    "label": "ThreadWithParam()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start) : ThreadWithParamBase(new RunnableImpl(func, param), thread_can_start)"
  },
  {
    "label": "RunnableImpl()",
    "kind": "Method",
    "detail": "Function (} private : class RunnableImpl : public Runnable { public :)",
    "insertText": "RunnableImpl(UserThreadFunc* func, T param) : func_(func), param_(param)"
  },
  {
    "label": "RunnableImpl()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "RunnableImpl()"
  },
  {
    "label": "RunnableImpl()",
    "kind": "Method",
    "detail": "Function (} private : UserThreadFunc* const func_ ; const T param_ ;)",
    "insertText": "RunnableImpl(const RunnableImpl&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (RunnableImpl&)",
    "insertText": "operator(const RunnableImpl&)"
  },
  {
    "label": "ThreadLocal()",
    "kind": "Method",
    "detail": "Function (} ; template<T> class ThreadLocal : public ThreadLocalBase { public :)",
    "insertText": "ThreadLocal() : default_factory_(new DefaultValueHolderFactory())"
  },
  {
    "label": "ThreadLocal()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ThreadLocal(const T& value) : default_factory_(new InstanceValueHolderFactory(value))"
  },
  {
    "label": "ThreadLocal()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ThreadLocal()"
  },
  {
    "label": "OnThreadLocalDestroyed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnThreadLocalDestroyed(this)"
  },
  {
    "label": "pointer()",
    "kind": "Method",
    "detail": "Function (} T*)",
    "insertText": "pointer()"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} const T&)",
    "insertText": "get()"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set(const T& value)"
  },
  {
    "label": "ValueHolder()",
    "kind": "Method",
    "detail": "Function (} private : class ValueHolder : public ThreadLocalValueHolderBase { public :)",
    "insertText": "ValueHolder() : value_()"
  },
  {
    "label": "ValueHolder()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ValueHolder(const T& value) : value_(value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ValueHolder&)",
    "insertText": "operator(const ValueHolder&)"
  },
  {
    "label": "GetOrCreateValue()",
    "kind": "Method",
    "detail": "Function (} ; T*)",
    "insertText": "GetOrCreateValue()"
  },
  {
    "label": "ValueHolderFactory()",
    "kind": "Method",
    "detail": "Function (} class ValueHolderFactory { public :)",
    "insertText": "ValueHolderFactory()"
  },
  {
    "label": "MakeNewHolder()",
    "kind": "Method",
    "detail": "Function (} ValueHolder*)",
    "insertText": "MakeNewHolder()"
  },
  {
    "label": "ValueHolderFactory()",
    "kind": "Method",
    "detail": "Function (private :)",
    "insertText": "ValueHolderFactory(const ValueHolderFactory&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ValueHolderFactory&)",
    "insertText": "operator(const ValueHolderFactory&)"
  },
  {
    "label": "DefaultValueHolderFactory()",
    "kind": "Method",
    "detail": "Function (} ; class DefaultValueHolderFactory : public ValueHolderFactory { public :)",
    "insertText": "DefaultValueHolderFactory()"
  },
  {
    "label": "DefaultValueHolderFactory()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "DefaultValueHolderFactory(const DefaultValueHolderFactory&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (DefaultValueHolderFactory&)",
    "insertText": "operator(const DefaultValueHolderFactory&)"
  },
  {
    "label": "InstanceValueHolderFactory()",
    "kind": "Method",
    "detail": "Function (} ; class InstanceValueHolderFactory : public ValueHolderFactory { public :)",
    "insertText": "InstanceValueHolderFactory(const T& value) : value_(value)"
  },
  {
    "label": "InstanceValueHolderFactory()",
    "kind": "Method",
    "detail": "Function (} private : const T value_ ;)",
    "insertText": "InstanceValueHolderFactory(const InstanceValueHolderFactory&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (InstanceValueHolderFactory&)",
    "insertText": "operator(const InstanceValueHolderFactory&)"
  },
  {
    "label": "ThreadLocal()",
    "kind": "Method",
    "detail": "Function (} ; std::unique_ptr<ValueHolderFactory> default_factory_ ;)",
    "insertText": "ThreadLocal(const ThreadLocal&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ThreadLocal&)",
    "insertText": "operator(const ThreadLocal&)"
  },
  {
    "label": "GTEST_CHECK_POSIX_SUCCESS_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_lock(&mutex_))"
  },
  {
    "label": "pthread_self()",
    "kind": "Method",
    "detail": "Function (owner_ =)",
    "insertText": "pthread_self()"
  },
  {
    "label": "GTEST_CHECK_POSIX_SUCCESS_()",
    "kind": "Method",
    "detail": "Function (has_owner_ = false ;)",
    "insertText": "GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_unlock(&mutex_))"
  },
  {
    "label": "GTEST_CHECK_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GTEST_CHECK_(has_owner_ && pthread_equal(owner_, pthread_self()))"
  },
  {
    "label": "GTEST_DECLARE_STATIC_MUTEX_()",
    "kind": "Method",
    "detail": "Function (} public : pthread_mutex_t mutex_ ; bool has_owner_ ; pthread_t owner_ ; } ; # define)",
    "insertText": "GTEST_DECLARE_STATIC_MUTEX_(mutex) \\ extern ::testing::internal::MutexBase mutex #define GTEST_DEFINE_STATIC_MUTEX_(mutex)"
  },
  {
    "label": "GTEST_CHECK_POSIX_SUCCESS_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&mutex_, nullptr))"
  },
  {
    "label": "GTEST_CHECK_POSIX_SUCCESS_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_destroy(&mutex_))"
  },
  {
    "label": "GTestMutexLock()",
    "kind": "Method",
    "detail": "Function (} ; class GTestMutexLock { public :)",
    "insertText": "GTestMutexLock(MutexBase* mutex) : mutex_(mutex)"
  },
  {
    "label": "DeleteThreadLocalValue()",
    "kind": "Method",
    "detail": "Function (} } ; \" C \" void)",
    "insertText": "DeleteThreadLocalValue(void* value_holder)"
  },
  {
    "label": "ThreadLocalValueHolderBase()",
    "kind": "Method",
    "detail": "Function (delete static_cast<)",
    "insertText": "ThreadLocalValueHolderBase(value_holder)"
  },
  {
    "label": "ThreadLocal()",
    "kind": "Method",
    "detail": "Function (} template<T> class GTEST_API_ ThreadLocal { public :)",
    "insertText": "ThreadLocal() : key_(CreateKey()), default_factory_(new DefaultValueHolderFactory())"
  },
  {
    "label": "ThreadLocal()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ThreadLocal(const T& value) : key_(CreateKey()), default_factory_(new InstanceValueHolderFactory(value))"
  },
  {
    "label": "DeleteThreadLocalValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DeleteThreadLocalValue(pthread_getspecific(key_))"
  },
  {
    "label": "GTEST_CHECK_POSIX_SUCCESS_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GTEST_CHECK_POSIX_SUCCESS_(pthread_key_delete(key_))"
  },
  {
    "label": "CreateKey()",
    "kind": "Method",
    "detail": "Function (} ; pthread_key_t)",
    "insertText": "CreateKey()"
  },
  {
    "label": "GTEST_CHECK_POSIX_SUCCESS_()",
    "kind": "Method",
    "detail": "Function (pthread_key_t key ;)",
    "insertText": "GTEST_CHECK_POSIX_SUCCESS_(pthread_key_create(&key, &DeleteThreadLocalValue))"
  },
  {
    "label": "ThreadLocalValueHolderBase()",
    "kind": "Method",
    "detail": "Function (ThreadLocalValueHolderBase* const holder = static_cast<)",
    "insertText": "ThreadLocalValueHolderBase(pthread_getspecific(key_))"
  },
  {
    "label": "GTEST_CHECK_POSIX_SUCCESS_()",
    "kind": "Method",
    "detail": "Function (ThreadLocalValueHolderBase* const holder_base = new_holder ;)",
    "insertText": "GTEST_CHECK_POSIX_SUCCESS_(pthread_setspecific(key_, holder_base))"
  },
  {
    "label": "GTEST_DECLARE_STATIC_MUTEX_()",
    "kind": "Method",
    "detail": "Function (} } ; # define)",
    "insertText": "GTEST_DECLARE_STATIC_MUTEX_(mutex) \\ extern ::testing::internal::Mutex mutex #define GTEST_DEFINE_STATIC_MUTEX_(mutex)"
  },
  {
    "label": "GTestMutexLock()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "GTestMutexLock(Mutex*)"
  },
  {
    "label": "ThreadLocal()",
    "kind": "Method",
    "detail": "Function (} } ; typedef GTestMutexLock MutexLock ; template<T> class GTEST_API_ ThreadLocal { public :)",
    "insertText": "ThreadLocal() : value_()"
  },
  {
    "label": "ThreadLocal()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ThreadLocal(const T& value) : value_(value)"
  },
  {
    "label": "GetThreadCount()",
    "kind": "Method",
    "detail": "Function (value_ = value ; } private : T value_ ; } ; # endif GTEST_API_ size_t)",
    "insertText": "GetThreadCount()"
  },
  {
    "label": "IsAlpha()",
    "kind": "Method",
    "detail": "Function (# if GTEST_OS_WINDOWS # define GTEST_PATH_SEP_ \" \\ \\ \" # define GTEST_HAS_ALT_PATH_SEP_ 1 # else # define GTEST_PATH_SEP_ \" / \" # define GTEST_HAS_ALT_PATH_SEP_ 0 # endif bool)",
    "insertText": "IsAlpha(char ch)"
  },
  {
    "label": "IsAlNum()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsAlNum(char ch)"
  },
  {
    "label": "IsDigit()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsDigit(char ch)"
  },
  {
    "label": "IsLower()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsLower(char ch)"
  },
  {
    "label": "IsSpace()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsSpace(char ch)"
  },
  {
    "label": "IsUpper()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsUpper(char ch)"
  },
  {
    "label": "IsXDigit()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsXDigit(char ch)"
  },
  {
    "label": "IsXDigit()",
    "kind": "Method",
    "detail": "Function (} # ifdef __cpp_char8_t bool)",
    "insertText": "IsXDigit(char8_t ch)"
  },
  {
    "label": "IsXDigit()",
    "kind": "Method",
    "detail": "Function (} # endif bool)",
    "insertText": "IsXDigit(char16_t ch)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (const unsigned char low_byte = static_cast<unsigned)",
    "insertText": "char(ch)"
  },
  {
    "label": "IsXDigit()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsXDigit(char32_t ch)"
  },
  {
    "label": "IsXDigit()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsXDigit(wchar_t ch)"
  },
  {
    "label": "ToLower()",
    "kind": "Method",
    "detail": "Function (} char)",
    "insertText": "ToLower(char ch)"
  },
  {
    "label": "ToUpper()",
    "kind": "Method",
    "detail": "Function (} char)",
    "insertText": "ToUpper(char ch)"
  },
  {
    "label": "StripTrailingSpaces()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "StripTrailingSpaces(std::string str)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (std::string::iterator it = str .)",
    "insertText": "end()"
  },
  {
    "label": "StrCaseCmp()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "StrCaseCmp(const char* s1, const char* s2)"
  },
  {
    "label": "StrDup()",
    "kind": "Method",
    "detail": "Function (} char*)",
    "insertText": "StrDup(const char* src)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # else # if GTEST_OS_WINDOWS_MOBILE | | GTEST_OS_ZOS | | GTEST_OS_IOS | | \\ GTEST_OS_WINDOWS_PHONE | | GTEST_OS_WINDOWS_RT | |)",
    "insertText": "defined(ESP_PLATFORM) inline int DoIsATTY(int)"
  },
  {
    "label": "FileNo()",
    "kind": "Method",
    "detail": "Function (} # endif # if GTEST_OS_WINDOWS_MOBILE int)",
    "insertText": "FileNo(FILE* file)"
  },
  {
    "label": "Stat()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "Stat(const char* path, StatStruct* buf)"
  },
  {
    "label": "RmDir()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "RmDir(const char* dir)"
  },
  {
    "label": "IsDir()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsDir(const StatStruct& st)"
  },
  {
    "label": "DoIsATTY()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "DoIsATTY(int fd)"
  },
  {
    "label": "IsATTY()",
    "kind": "Method",
    "detail": "Function (} # endif int)",
    "insertText": "IsATTY(int fd)"
  },
  {
    "label": "DoIsATTY()",
    "kind": "Method",
    "detail": "Function (int savedErrno = errno ; int isAttyValue =)",
    "insertText": "DoIsATTY(fd)"
  },
  {
    "label": "GTEST_DISABLE_MSC_DEPRECATED_PUSH_()",
    "kind": "Method",
    "detail": "Function (errno = savedErrno ; return isAttyValue ; })",
    "insertText": "GTEST_DISABLE_MSC_DEPRECATED_PUSH_() #if !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_WINDOWS_PHONE && \\ !GTEST_OS_WINDOWS_RT && !GTEST_OS_ESP8266 && !GTEST_OS_XTENSA inline int ChDir(const char* dir)"
  },
  {
    "label": "FOpen()",
    "kind": "Method",
    "detail": "Function (} # endif FILE*)",
    "insertText": "FOpen(const char* path, const char* mode)"
  },
  {
    "label": "from_bytes()",
    "kind": "Method",
    "detail": "Function (# if GTEST_OS_WINDOWS&& ! GTEST_OS_WINDOWS_MINGW struct wchar_codecvt : public std::codecvt<wchar_t,char,std::mbstate_t> { } ; std::wstring_convert<wchar_codecvt> converter ; std::wstring wide_path = converter .)",
    "insertText": "from_bytes(path)"
  },
  {
    "label": "from_bytes()",
    "kind": "Method",
    "detail": "Function (std::wstring wide_mode = converter .)",
    "insertText": "from_bytes(mode)"
  },
  {
    "label": "fopen()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "fopen(path, mode)"
  },
  {
    "label": "FReopen()",
    "kind": "Method",
    "detail": "Function (# endif } # if ! GTEST_OS_WINDOWS_MOBILE FILE*)",
    "insertText": "FReopen(const char* path, const char* mode, FILE* stream)"
  },
  {
    "label": "FDOpen()",
    "kind": "Method",
    "detail": "Function (} FILE*)",
    "insertText": "FDOpen(int fd, const char* mode)"
  },
  {
    "label": "FClose()",
    "kind": "Method",
    "detail": "Function (} # endif int)",
    "insertText": "FClose(FILE* fp)"
  },
  {
    "label": "Read()",
    "kind": "Method",
    "detail": "Function (} # if ! GTEST_OS_WINDOWS_MOBILE int)",
    "insertText": "Read(int fd, void* buf, unsigned int count)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "Write(int fd, const void* buf, unsigned int count)"
  },
  {
    "label": "Close()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "Close(int fd)"
  },
  {
    "label": "StrError()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "StrError(int errnum)"
  },
  {
    "label": "GetEnv()",
    "kind": "Method",
    "detail": "Function (} # endif const char*)",
    "insertText": "GetEnv(const char* name)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (# if GTEST_OS_WINDOWS_MOBILE | | GTEST_OS_WINDOWS_PHONE | | \\ GTEST_OS_WINDOWS_RT | | GTEST_OS_ESP8266 | | GTEST_OS_XTENSA static_cast<)",
    "insertText": "void(name)"
  },
  {
    "label": "getenv()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "getenv(name)"
  },
  {
    "label": "GTEST_DISABLE_MSC_DEPRECATED_POP_()",
    "kind": "Method",
    "detail": "Function (# endif })",
    "insertText": "GTEST_DISABLE_MSC_DEPRECATED_POP_() #if GTEST_OS_WINDOWS_MOBILE [[noreturn]] void Abort()"
  },
  {
    "label": "Abort()",
    "kind": "Method",
    "detail": "Function (# else [ [ noreturn ] ] void)",
    "insertText": "Abort()"
  },
  {
    "label": "abort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "abort()"
  },
  {
    "label": "GTEST_SNPRINTF_()",
    "kind": "Method",
    "detail": "Function (} # endif } # if _MSC_VER&& ! GTEST_OS_WINDOWS_MOBILE # define)",
    "insertText": "GTEST_SNPRINTF_(buffer, size, format, ...) \\ _snprintf_s(buffer, size, size, format, __VA_ARGS__) #elif defined(_MSC_VER)"
  },
  {
    "label": "kMaxBiggestInt()",
    "kind": "Method",
    "detail": "Function (BiggestInt)",
    "insertText": "kMaxBiggestInt(std::numeric_limits<BiggestInt>::max)()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (template<size_t size> class TypeWithSize { public : using UInt = void ; } ; template<> class TypeWithSize<4> { public : using Int = std::int32_t ; using UInt = std::uint32_t ; } ; template<> class TypeWithSize<8> { public : using Int = std::int64_t ; using UInt = std::uint64_t ; } ; using TimeInMillis = int64_t ; # if !)",
    "insertText": "defined(GTEST_FLAG) #define GTEST_FLAG_NAME_(name) gtest_##name #define GTEST_FLAG(name) FLAGS_gtest_##name #endif #if GTEST_HAS_ABSL #define GTEST_DEFINE_bool_(name, default_val, doc) \\ ABSL_FLAG(bool, GTEST_FLAG_NAME_(name), default_val, doc) #define GTEST_DEFINE_int32_(name, default_val, doc) \\ ABSL_FLAG(int32_t, GTEST_FLAG_NAME_(name), default_val, doc) #define GTEST_DEFINE_string_(name, default_val, doc) \\ ABSL_FLAG(std::string, GTEST_FLAG_NAME_(name), default_val, doc) #define GTEST_DECLARE_bool_(name) \\ ABSL_DECLARE_FLAG(bool, GTEST_FLAG_NAME_(name)) #define GTEST_DECLARE_int32_(name) \\ ABSL_DECLARE_FLAG(int32_t, GTEST_FLAG_NAME_(name)) #define GTEST_DECLARE_string_(name) \\ ABSL_DECLARE_FLAG(std::string, GTEST_FLAG_NAME_(name)) #define GTEST_FLAG_SAVER_ ::absl::FlagSaver #define GTEST_FLAG_GET(name) ::absl::GetFlag(GTEST_FLAG(name)) #define GTEST_FLAG_SET(name, value) \\ (void)(::absl::SetFlag(&GTEST_FLAG(name), value)) #define GTEST_USE_OWN_FLAGFILE_FLAG_ 0 #else #define GTEST_DEFINE_bool_(name, default_val, doc)"
  },
  {
    "label": "GTEST_FLAG()",
    "kind": "Method",
    "detail": "Function (\\ GTEST_API_ bool)",
    "insertText": "GTEST_FLAG(name) = (default_val)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (\\ } \\)",
    "insertText": "static_assert(true, \"no-op to require trailing semicolon\") #define GTEST_DEFINE_int32_(name, default_val, doc)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (\\ } \\)",
    "insertText": "static_assert(true, \"no-op to require trailing semicolon\") #define GTEST_DEFINE_string_(name, default_val, doc)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (\\ } \\)",
    "insertText": "static_assert(true, \"no-op to require trailing semicolon\") #define GTEST_DECLARE_bool_(name)"
  },
  {
    "label": "GTEST_FLAG()",
    "kind": "Method",
    "detail": "Function (\\ GTEST_API_ bool)",
    "insertText": "GTEST_FLAG(name)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (\\ } \\)",
    "insertText": "static_assert(true, \"no-op to require trailing semicolon\") #define GTEST_DECLARE_int32_(name)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (\\ } \\)",
    "insertText": "static_assert(true, \"no-op to require trailing semicolon\") #define GTEST_DECLARE_string_(name)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (\\ } \\)",
    "insertText": "static_assert(true, \"no-op to require trailing semicolon\") #define GTEST_FLAG_SAVER_ ::testing::internal::GTestFlagSaver #define GTEST_FLAG_GET(name) ::testing::GTEST_FLAG(name) #define GTEST_FLAG_SET(name, value) (void)(::testing::GTEST_FLAG(name) = value) #define GTEST_USE_OWN_FLAGFILE_FLAG_ 1 #endif #if !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_) #define GTEST_EXCLUSIVE_LOCK_REQUIRED_(locks) #define GTEST_LOCK_EXCLUDED_(locks) #endif GTEST_API_ bool ParseInt32(const Message& src_text, const char* str, int32_t* value)"
  },
  {
    "label": "BoolFromGTestEnv()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "BoolFromGTestEnv(const char* flag, bool default_val)"
  },
  {
    "label": "Int32FromGTestEnv()",
    "kind": "Method",
    "detail": "Function (GTEST_API_ int32_t)",
    "insertText": "Int32FromGTestEnv(const char* flag, int32_t default_val)"
  },
  {
    "label": "OutputFlagAlsoCheckEnvVar()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "OutputFlagAlsoCheckEnvVar()"
  },
  {
    "label": "StringFromGTestEnv()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "StringFromGTestEnv(const char* flag, const char* default_val)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } # if !)",
    "insertText": "defined(GTEST_INTERNAL_DEPRECATED) #if defined(_MSC_VER) #define GTEST_INTERNAL_DEPRECATED(message) __declspec(deprecated(message)) #elif defined(__GNUC__) #define GTEST_INTERNAL_DEPRECATED(message) __attribute__((deprecated(message))) #else #define GTEST_INTERNAL_DEPRECATED(message)"
  },
  {
    "label": "__has_include()",
    "kind": "Method",
    "detail": "Function (namespace internal { using Any =::absl::any ; } } # else # ifdef __has_include # if)",
    "insertText": "__has_include(<any>)"
  },
  {
    "label": "Nullopt()",
    "kind": "Method",
    "detail": "Function (namespace internal { using Any =::std::any ; } } # endif # endif # endif # if GTEST_HAS_ABSL # define GTEST_INTERNAL_HAS_OPTIONAL 1 # include \" absl / types / optional . h \" namespace testing { namespace internal { template<T> using Optional =::absl::optional<T> ;::absl::nullopt_t)",
    "insertText": "Nullopt()"
  },
  {
    "label": "__has_include()",
    "kind": "Method",
    "detail": "Function (namespace internal { using StringView =::std::string_view ; } } # endif # endif # endif # if GTEST_HAS_ABSL # define GTEST_INTERNAL_HAS_VARIANT 1 # include \" absl / types / variant . h \" namespace testing { namespace internal { template<. . . T> using Variant =::absl::variant<T . . .> ; } } # else # ifdef __has_include # if)",
    "insertText": "__has_include(<variant>)"
  }
]