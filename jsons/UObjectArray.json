[
  {
    "label": "VCell",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VCell"
  },
  {
    "label": "FGCFlags",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FGCFlags"
  },
  {
    "label": "FUObjectArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FUObjectArray"
  },
  {
    "label": "UE",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UE"
  },
  {
    "label": "UObjectBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UObjectBase"
  },
  {
    "label": "FFixedUObjectArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FFixedUObjectArray"
  },
  {
    "label": "FChunkedFixedUObjectArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FChunkedFixedUObjectArray"
  },
  {
    "label": "UObject",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UObject"
  },
  {
    "label": "ESerialNumberConstants",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ESerialNumberConstants"
  },
  {
    "label": "FUObjectCreateListener",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FUObjectCreateListener"
  },
  {
    "label": "FUObjectDeleteListener",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FUObjectDeleteListener"
  },
  {
    "label": "TIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TIterator"
  },
  {
    "label": "EEndTagType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EEndTagType"
  },
  {
    "label": "FUObjectCluster",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FUObjectCluster"
  },
  {
    "label": "FUObjectClusterContainer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FUObjectClusterContainer"
  },
  {
    "label": "FIndexToObject",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FIndexToObject"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" AutoRTFM / AutoRTFM . h \" # include \" HAL / ThreadSafeCounter . h \" # include \" Containers / LockFreeList . h \" # include \" Misc / TransactionallySafeCriticalSection . h \" # include \" UObject / GarbageCollectionGlobals . h \" # include \" UObject / UObjectBase . h \" # include \" Misc / TransactionallySafeScopeLock . h \" # if WITH_VERSE_VM | |)",
    "insertText": "defined(__INTELLISENSE__)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (struct VCell ; } # endif # if !)",
    "insertText": "defined(UE_GC_TRACK_OBJ_AVAILABLE) #define UE_GC_TRACK_OBJ_AVAILABLE UE_DEPRECATED_MACRO(5.2, \"The UE_GC_TRACK_OBJ_AVAILABLE macro has been deprecated because it is no longer necessary.\")"
  },
  {
    "label": "GCC_PACK()",
    "kind": "Method",
    "detail": "Function (class FGCFlags ; } struct # if ! STATS&& ! ENABLE_STATNAMEDEVENTS_UOBJECT)",
    "insertText": "GCC_PACK(4)"
  },
  {
    "label": "FUObjectItem()",
    "kind": "Method",
    "detail": "Function (class FUObjectArray ; class UE::GC::Private::FGCFlags ; class UObjectBase* Object ; private : int32 Flags ; public : int32 ClusterRootIndex ; int32 SerialNumber ; int32 RefCount ; # if STATS | | ENABLE_STATNAMEDEVENTS_UOBJECT TStatId StatID ; # if ENABLE_STATNAMEDEVENTS_UOBJECT PROFILER_CHAR* StatIDStringStorage ; # endif # endif)",
    "insertText": "FUObjectItem() : Object(nullptr) , Flags(0) , ClusterRootIndex(0) , SerialNumber(0) , RefCount(0) #if ENABLE_STATNAMEDEVENTS_UOBJECT , StatIDStringStorage(nullptr)"
  },
  {
    "label": "FUObjectItem()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FUObjectItem()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if ENABLE_STATNAMEDEVENTS_UOBJECT)",
    "insertText": "if(PROFILER_CHAR* Storage = StatIDStringStorage)"
  },
  {
    "label": "PopOnAbortHandler()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PopOnAbortHandler(Storage)"
  },
  {
    "label": "FUObjectItem()",
    "kind": "Method",
    "detail": "Function (delete [ ] Storage ; } # endif })",
    "insertText": "FUObjectItem(FUObjectItem&&)"
  },
  {
    "label": "FUObjectItem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FUObjectItem(const FUObjectItem&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FUObjectItem&)",
    "insertText": "operator(FUObjectItem&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FUObjectItem&)",
    "insertText": "operator(const FUObjectItem&)"
  },
  {
    "label": "GetOwnerIndex()",
    "kind": "Method",
    "detail": "Function (ClusterRootIndex = OwnerIndex ; } int32)",
    "insertText": "GetOwnerIndex()"
  },
  {
    "label": "GetClusterIndex()",
    "kind": "Method",
    "detail": "Function (ClusterRootIndex = - ClusterIndex - 1 ; } int32)",
    "insertText": "GetClusterIndex()"
  },
  {
    "label": "ThisThreadAtomicallySetFlag()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ThisThreadAtomicallySetFlag(FlagsToSet)"
  },
  {
    "label": "GetFlags()",
    "kind": "Method",
    "detail": "Function (} EInternalObjectFlags)",
    "insertText": "GetFlags()"
  },
  {
    "label": "ClearFlags()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ClearFlags(EInternalObjectFlags FlagsToClear)"
  },
  {
    "label": "ThisThreadAtomicallyClearedFlag()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ThisThreadAtomicallyClearedFlag(FlagsToClear)"
  },
  {
    "label": "ThisThreadAtomicallyClearedFlag()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ThisThreadAtomicallyClearedFlag(EInternalObjectFlags FlagToClear)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool Result = false ; UE_AUTORTFM_OPEN { FlagToClear& = ~ EInternalObjectFlags_ReachabilityFlags ; FlagToClear& = ~ EInternalObjectFlags::RefCounted ;)",
    "insertText": "if(!!(FlagToClear & EInternalObjectFlags_RootFlags))"
  },
  {
    "label": "ClearRootFlags()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "ClearRootFlags(FlagToClear)"
  },
  {
    "label": "AtomicallyClearFlag_ForGC()",
    "kind": "Method",
    "detail": "Function (} else { Result =)",
    "insertText": "AtomicallyClearFlag_ForGC(FlagToClear)"
  },
  {
    "label": "ThisThreadAtomicallySetFlag()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ThisThreadAtomicallySetFlag(EInternalObjectFlags FlagToSet)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool Result = false ; UE_AUTORTFM_OPEN { FlagToSet& = ~ EInternalObjectFlags_ReachabilityFlags ; FlagToSet& = ~ EInternalObjectFlags::RefCounted ;)",
    "insertText": "if(!!(FlagToSet & EInternalObjectFlags_RootFlags))"
  },
  {
    "label": "SetRootFlags()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "SetRootFlags(FlagToSet)"
  },
  {
    "label": "AtomicallySetFlag_ForGC()",
    "kind": "Method",
    "detail": "Function (} else { Result =)",
    "insertText": "AtomicallySetFlag_ForGC(FlagToSet)"
  },
  {
    "label": "HasAnyFlags()",
    "kind": "Method",
    "detail": "Function (} } ; return Result ; } bool)",
    "insertText": "HasAnyFlags(EInternalObjectFlags InFlags)"
  },
  {
    "label": "HasAllFlags()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasAllFlags(EInternalObjectFlags InFlags)"
  },
  {
    "label": "AtomicallySetFlag_ForGC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AtomicallySetFlag_ForGC(EInternalObjectFlags::Unreachable)"
  },
  {
    "label": "AtomicallyClearFlag_ForGC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AtomicallyClearFlag_ForGC(EInternalObjectFlags::Unreachable)"
  },
  {
    "label": "IsUnreachable()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsUnreachable()"
  },
  {
    "label": "SetGarbage()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetGarbage()"
  },
  {
    "label": "AtomicallySetFlag_ForGC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AtomicallySetFlag_ForGC(EInternalObjectFlags::Garbage)"
  },
  {
    "label": "ClearGarbage()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ClearGarbage()"
  },
  {
    "label": "AtomicallyClearFlag_ForGC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AtomicallyClearFlag_ForGC(EInternalObjectFlags::Garbage)"
  },
  {
    "label": "IsGarbage()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsGarbage()"
  },
  {
    "label": "SetRootSet()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetRootSet()"
  },
  {
    "label": "ThisThreadAtomicallySetFlag()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ThisThreadAtomicallySetFlag(EInternalObjectFlags::RootSet)"
  },
  {
    "label": "ClearRootSet()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ClearRootSet()"
  },
  {
    "label": "ThisThreadAtomicallyClearedFlag()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ThisThreadAtomicallyClearedFlag(EInternalObjectFlags::RootSet)"
  },
  {
    "label": "IsRootSet()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsRootSet()"
  },
  {
    "label": "GetRefCount()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetRefCount()"
  },
  {
    "label": "InterlockedIncrement()",
    "kind": "Method",
    "detail": "Function (UE_AUTORTFM_OPEN {)",
    "insertText": "InterlockedIncrement(&RefCount)"
  },
  {
    "label": "SetRootFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetRootFlags(EInternalObjectFlags::RefCounted)"
  },
  {
    "label": "ReleaseRef()",
    "kind": "Method",
    "detail": "Function (} } ; } void)",
    "insertText": "ReleaseRef()"
  },
  {
    "label": "InterlockedDecrement()",
    "kind": "Method",
    "detail": "Function (UE_AUTORTFM_OPEN { const int32 NewRefCount =)",
    "insertText": "InterlockedDecrement(&RefCount)"
  },
  {
    "label": "ClearRootFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearRootFlags(EInternalObjectFlags::RefCounted)"
  },
  {
    "label": "CreateStatID()",
    "kind": "Method",
    "detail": "Function (} } ; } # if STATS | | ENABLE_STATNAMEDEVENTS_UOBJECT void)",
    "insertText": "CreateStatID()"
  },
  {
    "label": "GetFlagsInternal()",
    "kind": "Method",
    "detail": "Function (} private : int32)",
    "insertText": "GetFlagsInternal()"
  },
  {
    "label": "GetRefCountInternal()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetRefCountInternal()"
  },
  {
    "label": "SetRootFlags()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "SetRootFlags(EInternalObjectFlags FlagsToSet)"
  },
  {
    "label": "ClearRootFlags()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ClearRootFlags(EInternalObjectFlags FlagsToClear)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (bool bIChangedIt = false ;)",
    "insertText": "while(1)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (break ; } int32 NewValue = StartValue |)",
    "insertText": "int32(FlagToSet)"
  },
  {
    "label": "AtomicallyClearFlag_ForGC()",
    "kind": "Method",
    "detail": "Function (bIChangedIt = true ; break ; } } return bIChangedIt ; } bool)",
    "insertText": "AtomicallyClearFlag_ForGC(EInternalObjectFlags FlagToClear)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (break ; } int32 NewValue = StartValue& ~)",
    "insertText": "int32(FlagToClear)"
  },
  {
    "label": "FailMaxUObjectCountExceeded()",
    "kind": "Method",
    "detail": "Function (bIChangedIt = true ; break ; } } return bIChangedIt ; } } ; namespace UE::UObjectArrayPrivate { void)",
    "insertText": "FailMaxUObjectCountExceeded(const int32 MaxUObjects, const int32 NewUObjectCount)"
  },
  {
    "label": "FailMaxUObjectCountExceeded()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FailMaxUObjectCountExceeded(MaxUObjects, NewUObjectCount)"
  },
  {
    "label": "FFixedUObjectArray()",
    "kind": "Method",
    "detail": "Function (} } } ; class FFixedUObjectArray { FUObjectItem* Objects ; int32 MaxElements ; int32 NumElements ; public :)",
    "insertText": "FFixedUObjectArray() TSAN_SAFE : Objects(nullptr) , MaxElements(0) , NumElements(0)"
  },
  {
    "label": "FFixedUObjectArray()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FFixedUObjectArray()"
  },
  {
    "label": "PreAllocate()",
    "kind": "Method",
    "detail": "Function (delete [ ] Objects ; } void)",
    "insertText": "PreAllocate(int32 InMaxElements)"
  },
  {
    "label": "AddSingle()",
    "kind": "Method",
    "detail": "Function (Objects = new FUObjectItem [ InMaxElements ] ; MaxElements = InMaxElements ; } int32)",
    "insertText": "AddSingle()"
  },
  {
    "label": "CheckUObjectLimitReached()",
    "kind": "Method",
    "detail": "Function (int32 Result = NumElements ; UE::)",
    "insertText": "CheckUObjectLimitReached(NumElements, MaxElements, 1)"
  },
  {
    "label": "MemoryBarrier()",
    "kind": "Method",
    "detail": "Function (+ + NumElements ;)",
    "insertText": "MemoryBarrier()"
  },
  {
    "label": "CheckUObjectLimitReached()",
    "kind": "Method",
    "detail": "Function (int32 Result = NumElements + Count - 1 ; UE::)",
    "insertText": "CheckUObjectLimitReached(NumElements, MaxElements, Count)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FUObjectItem const&)",
    "insertText": "operator(int32 Index)"
  },
  {
    "label": "GetObjectPtr()",
    "kind": "Method",
    "detail": "Function (FUObjectItem const* ItemPtr =)",
    "insertText": "GetObjectPtr(Index)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int32 ChunkIndex = Index / NumElementsPerChunk ;)",
    "insertText": "while(ChunkIndex >= NumChunks)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FUObjectItem** Chunk =& Objects [ NumChunks ] ; FUObjectItem* NewChunk = new FUObjectItem [ NumElementsPerChunk ] ;)",
    "insertText": "if(FPlatformAtomics::InterlockedCompareExchangePointer((void**)Chunk, NewChunk, nullptr))"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} else { NumChunks + + ;)",
    "insertText": "check(NumChunks <= MaxChunks)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "check(ChunkIndex < NumChunks && Objects[ChunkIndex])"
  },
  {
    "label": "FChunkedFixedUObjectArray()",
    "kind": "Method",
    "detail": "Function (} public :)",
    "insertText": "FChunkedFixedUObjectArray() TSAN_SAFE : Objects(nullptr) , PreAllocatedObjects(nullptr) , MaxElements(0) , NumElements(0) , MaxChunks(0) , NumChunks(0)"
  },
  {
    "label": "FChunkedFixedUObjectArray()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FChunkedFixedUObjectArray()"
  },
  {
    "label": "PreAllocate()",
    "kind": "Method",
    "detail": "Function (delete [ ] Objects [ ChunkIndex ] ; } } else { delete [ ] PreAllocatedObjects ; } delete [ ] Objects ; } void)",
    "insertText": "PreAllocate(int32 InMaxElements, bool bPreAllocateChunks)"
  },
  {
    "label": "Memzero()",
    "kind": "Method",
    "detail": "Function (MaxChunks = InMaxElements / NumElementsPerChunk + 1 ; MaxElements = MaxChunks* NumElementsPerChunk ; Objects = new FUObjectItem* [ MaxChunks ] ;)",
    "insertText": "Memzero(Objects, sizeof(FUObjectItem*) * MaxChunks)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (PreAllocatedObjects = new FUObjectItem [ MaxElements ] ;)",
    "insertText": "for(int32 ChunkIndex = 0; ChunkIndex < MaxChunks; ++ChunkIndex)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (Objects [ ChunkIndex ] = PreAllocatedObjects + ChunkIndex* NumElementsPerChunk ; } NumChunks = MaxChunks ; } } int32)",
    "insertText": "Num()"
  },
  {
    "label": "GetObjectPtr()",
    "kind": "Method",
    "detail": "Function (} FUObjectItem const*)",
    "insertText": "GetObjectPtr(int32 Index)"
  },
  {
    "label": "ChunkIndex()",
    "kind": "Method",
    "detail": "Function (const uint32)",
    "insertText": "ChunkIndex(uint32)"
  },
  {
    "label": "WithinChunkIndex()",
    "kind": "Method",
    "detail": "Function (const uint32)",
    "insertText": "WithinChunkIndex(uint32)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (FUObjectItem* Chunk = Objects [ ChunkIndex ] ;)",
    "insertText": "check(Chunk)"
  },
  {
    "label": "Prefetch()",
    "kind": "Method",
    "detail": "Function (const FUObjectItem* Chunk = Objects [ ChunkIndex ] ;)",
    "insertText": "Prefetch(Chunk + WithinChunkIndex)"
  },
  {
    "label": "CheckUObjectLimitReached()",
    "kind": "Method",
    "detail": "Function (int32 Result = NumElements ; UE::)",
    "insertText": "CheckUObjectLimitReached(Result, MaxElements, NumToAdd)"
  },
  {
    "label": "ExpandChunksToIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpandChunksToIndex(Result + NumToAdd - 1)"
  },
  {
    "label": "GetRootBlockForDebuggerVisualizers()",
    "kind": "Method",
    "detail": "Function (} FUObjectItem***)",
    "insertText": "GetRootBlockForDebuggerVisualizers()"
  },
  {
    "label": "StaticAllocateObject()",
    "kind": "Method",
    "detail": "Function (} } ; class FUObjectArray { class UObject ; UObject*)",
    "insertText": "StaticAllocateObject(const UClass*, UObject*, FName, EObjectFlags, EInternalObjectFlags, bool, bool*, UPackage*)"
  },
  {
    "label": "ResetSerialNumber()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "ResetSerialNumber(UObjectBase* Object)"
  },
  {
    "label": "FUObjectCreateListener()",
    "kind": "Method",
    "detail": "Function (public : enum ESerialNumberConstants { START_SERIAL_NUMBER = 1 0 0 0,} ; class FUObjectCreateListener { public : ~)",
    "insertText": "FUObjectCreateListener()"
  },
  {
    "label": "NotifyUObjectCreated()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "NotifyUObjectCreated(const class UObjectBase *Object, int32 Index)"
  },
  {
    "label": "OnUObjectArrayShutdown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnUObjectArrayShutdown()"
  },
  {
    "label": "FUObjectDeleteListener()",
    "kind": "Method",
    "detail": "Function (} ; class FUObjectDeleteListener { public : ~)",
    "insertText": "FUObjectDeleteListener()"
  },
  {
    "label": "NotifyUObjectDeleted()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "NotifyUObjectDeleted(const class UObjectBase *Object, int32 Index)"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (SIZE_T)",
    "insertText": "GetAllocatedSize()"
  },
  {
    "label": "AllocateObjectPool()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AllocateObjectPool(int32 MaxUObjects, int32 MaxObjectsNotConsideredByGC, bool bPreAllocateObjectArray)"
  },
  {
    "label": "DisableDisregardForGC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisableDisregardForGC()"
  },
  {
    "label": "OpenDisregardForGC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OpenDisregardForGC()"
  },
  {
    "label": "CloseDisregardForGC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CloseDisregardForGC()"
  },
  {
    "label": "IsOpenForDisregardForGC()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsOpenForDisregardForGC()"
  },
  {
    "label": "FreeUObjectIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeUObjectIndex(class UObjectBase* Object)"
  },
  {
    "label": "IndexToObjectUnsafeForGC()",
    "kind": "Method",
    "detail": "Function (} return nullptr ; } FUObjectItem*)",
    "insertText": "IndexToObjectUnsafeForGC(int32 Index)"
  },
  {
    "label": "IndexToObject()",
    "kind": "Method",
    "detail": "Function (} FUObjectItem*)",
    "insertText": "IndexToObject(int32 Index, bool bEvenIfGarbage)"
  },
  {
    "label": "IndexToObject()",
    "kind": "Method",
    "detail": "Function (FUObjectItem* ObjectItem =)",
    "insertText": "IndexToObject(Index)"
  },
  {
    "label": "ObjectToObjectItem()",
    "kind": "Method",
    "detail": "Function (ObjectItem = nullptr ; ; } } return ObjectItem ; } FUObjectItem*)",
    "insertText": "ObjectToObjectItem(const UObjectBase* Object)"
  },
  {
    "label": "IndexToObject()",
    "kind": "Method",
    "detail": "Function (FUObjectItem* ObjectItem =)",
    "insertText": "IndexToObject(Object->InternalIndex)"
  },
  {
    "label": "IndexToValidObject()",
    "kind": "Method",
    "detail": "Function (} return false ; } FUObjectItem*)",
    "insertText": "IndexToValidObject(int32 Index, bool bEvenIfGarbage)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValid(int32 Index, bool bEvenIfGarbage)"
  },
  {
    "label": "IsStale()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsStale(FUObjectItem* ObjectItem, bool bIncludingGarbage)"
  },
  {
    "label": "IsStale()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsStale(int32 Index, bool bIncludingGarbage)"
  },
  {
    "label": "GetFirstGCIndex()",
    "kind": "Method",
    "detail": "Function (} return true ; } int32)",
    "insertText": "GetFirstGCIndex()"
  },
  {
    "label": "RemoveUObjectCreateListener()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveUObjectCreateListener(FUObjectCreateListener* Listener)"
  },
  {
    "label": "AddUObjectDeleteListener()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddUObjectDeleteListener(FUObjectDeleteListener* Listener)"
  },
  {
    "label": "RemoveUObjectDeleteListener()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveUObjectDeleteListener(FUObjectDeleteListener* Listener)"
  },
  {
    "label": "RemoveObjectFromDeleteListeners()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveObjectFromDeleteListeners(UObjectBase* Object)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsValid(const UObjectBase* Object)"
  },
  {
    "label": "IsDisregardForGC()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsDisregardForGC(const class UObjectBase* Object)"
  },
  {
    "label": "GetObjectArrayNumMinusPermanent()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetObjectArrayNumMinusPermanent()"
  },
  {
    "label": "GetObjectArrayNumPermanent()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetObjectArrayNumPermanent()"
  },
  {
    "label": "GetObjectArrayEstimatedAvailable()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetObjectArrayEstimatedAvailable()"
  },
  {
    "label": "GetObjectArrayCapacity()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetObjectArrayCapacity()"
  },
  {
    "label": "ShutdownUObjectArray()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ShutdownUObjectArray()"
  },
  {
    "label": "AllocateSerialNumber()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "AllocateSerialNumber(int32 Index)"
  },
  {
    "label": "LockInternalArray()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "LockInternalArray()"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (# if THREADSAFE_UOBJECTS ObjObjectsCritical .)",
    "insertText": "Lock()"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "check(IsInGameThread())"
  },
  {
    "label": "UnlockInternalArray()",
    "kind": "Method",
    "detail": "Function (# endif } void)",
    "insertText": "UnlockInternalArray()"
  },
  {
    "label": "Unlock()",
    "kind": "Method",
    "detail": "Function (# if THREADSAFE_UOBJECTS ObjObjectsCritical .)",
    "insertText": "Unlock()"
  },
  {
    "label": "TIterator()",
    "kind": "Method",
    "detail": "Function (# endif } class TIterator { public : enum EEndTagType { EndTag } ;)",
    "insertText": "TIterator(const FUObjectArray& InArray, bool bOnlyGCedObjects = false ) : Array(InArray), Index(-1), CurrentObject(nullptr)"
  },
  {
    "label": "Advance()",
    "kind": "Method",
    "detail": "Function (Index = Array . ObjLastNonGCIndex ; })",
    "insertText": "Advance()"
  },
  {
    "label": "TIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TIterator(EEndTagType, const TIterator& InIter ) : Array (InIter.Array), Index(Array.ObjObjects.Num())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TIterator& Rhs)"
  },
  {
    "label": "GetIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetIndex()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (FUObjectItem* NextObject = nullptr ; CurrentObject = nullptr ;)",
    "insertText": "while(++Index < Array.GetObjectArrayNum())"
  },
  {
    "label": "FUObjectItem()",
    "kind": "Method",
    "detail": "Function (NextObject = const_cast<)",
    "insertText": "FUObjectItem(&Array.ObjObjects[Index])"
  },
  {
    "label": "GetIteratedArray()",
    "kind": "Method",
    "detail": "Function (CurrentObject = NextObject ; return true ; } } return false ; } const FUObjectArray&)",
    "insertText": "GetIteratedArray()"
  },
  {
    "label": "ObjListLock()",
    "kind": "Method",
    "detail": "Function (FTransactionallySafeScopeLock)",
    "insertText": "ObjListLock(&ObjObjectsCritical)"
  },
  {
    "label": "ListenersLock()",
    "kind": "Method",
    "detail": "Function (# if THREADSAFE_UOBJECTS FTransactionallySafeScopeLock)",
    "insertText": "ListenersLock(&UObjectDeleteListenersCritical)"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (# endif return ObjObjects .)",
    "insertText": "GetAllocatedSize() + ObjAvailableList.GetAllocatedSize() + UObjectCreateListeners.GetAllocatedSize() + UObjectDeleteListeners.GetAllocatedSize()"
  },
  {
    "label": "GetDeleteListenersAllocatedSize()",
    "kind": "Method",
    "detail": "Function (} SIZE_T)",
    "insertText": "GetDeleteListenersAllocatedSize(int32* OutNumListeners = nullptr)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# endif SIZE_T AllocatedSize = 0 ;)",
    "insertText": "for(FUObjectDeleteListener* Listener : UObjectDeleteListeners)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(OutNumListeners)"
  },
  {
    "label": "DumpUObjectCountsToLog()",
    "kind": "Method",
    "detail": "Function (} return AllocatedSize ; } void)",
    "insertText": "DumpUObjectCountsToLog()"
  },
  {
    "label": "FUObjectCluster()",
    "kind": "Method",
    "detail": "Function (} ; struct FUObjectCluster {)",
    "insertText": "FUObjectCluster() : RootIndex(INDEX_NONE) , bNeedsDissolving(false)"
  },
  {
    "label": "DissolveCluster()",
    "kind": "Method",
    "detail": "Function (# endif bool bNeedsDissolving ; } ; class FUObjectClusterContainer { TArray<FUObjectCluster> Clusters ; TArray<int32> FreeClusterIndices ; int32 NumAllocatedClusters ; bool bClustersNeedDissolving ; void)",
    "insertText": "DissolveCluster(FUObjectCluster& Cluster)"
  },
  {
    "label": "FUObjectClusterContainer()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "FUObjectClusterContainer()"
  },
  {
    "label": "FreeCluster()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeCluster(int32 InClusterIndex)"
  },
  {
    "label": "GetObjectCluster()",
    "kind": "Method",
    "detail": "Function (FUObjectCluster*)",
    "insertText": "GetObjectCluster(UObjectBaseUtility* ClusterRootOrObjectFromCluster)"
  },
  {
    "label": "DissolveCluster()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DissolveCluster(UObjectBaseUtility* ClusterRootOrObjectFromCluster)"
  },
  {
    "label": "DissolveClusters()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DissolveClusters(bool bForceDissolveAllClusters = false)"
  },
  {
    "label": "DissolveClusterAndMarkObjectsAsUnreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DissolveClusterAndMarkObjectsAsUnreachable(FUObjectItem* RootObjectItem)"
  },
  {
    "label": "GetMinClusterSize()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetMinClusterSize()"
  },
  {
    "label": "GetClustersUnsafe()",
    "kind": "Method",
    "detail": "Function (TArray<FUObjectCluster>&)",
    "insertText": "GetClustersUnsafe()"
  },
  {
    "label": "ClustersNeedDissolving()",
    "kind": "Method",
    "detail": "Function (bClustersNeedDissolving = true ; } bool)",
    "insertText": "ClustersNeedDissolving()"
  },
  {
    "label": "IndexToObject()",
    "kind": "Method",
    "detail": "Function (FUObjectItem* ObjectItem = GUObjectArray .)",
    "insertText": "IndexToObject(Index, bEvenIfGarbage)"
  }
]