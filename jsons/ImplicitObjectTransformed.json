[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TImplicitObjectTransformed",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TImplicitObjectTransformed"
  },
  {
    "label": "FClusterUnionManager",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FClusterUnionManager"
  },
  {
    "label": "TImplicitObjectTransformSerializeHelper()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Box . h \" # include \" Chaos / ImplicitObject . h \" # include \" Chaos / ShapeInstanceFwd . h \" # include \" Chaos / Transform . h \" # include \" ChaosArchive . h \" # include \" Templates / EnableIf . h \" # include \" AABB . h \" namespace Chaos { void)",
    "insertText": "TImplicitObjectTransformSerializeHelper(FChaosArchive& Ar, FImplicitObjectPtr& Obj)"
  },
  {
    "label": "TImplicitObjectTransformSerializeHelper()",
    "kind": "Method",
    "detail": "Function (Ar<<Obj ; } void)",
    "insertText": "TImplicitObjectTransformSerializeHelper(FChaosArchive& Ar, TSerializablePtr<FImplicitObject>& Obj)"
  },
  {
    "label": "TImplicitObjectTransformSerializeHelper()",
    "kind": "Method",
    "detail": "Function (Ar<<Obj ; } void)",
    "insertText": "TImplicitObjectTransformSerializeHelper(FChaosArchive& Ar, const FImplicitObject* Obj)"
  },
  {
    "label": "TImplicitObjectTransformed()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TImplicitObjectTransformed(Chaos::FImplicitObjectPtr&& Object, const TRigidTransform<T, d>& InTransform) : FImplicitObject(EImplicitObject::HasBoundingBox, ImplicitObjectType::Transformed) , MObject(MoveTemp(Object)) , MTransform(InTransform)"
  },
  {
    "label": "BoundingBox()",
    "kind": "Method",
    "detail": "Function (this -> MLocalBoundingBox = MObject ->)",
    "insertText": "BoundingBox().TransformedAABB(InTransform)"
  },
  {
    "label": "IsConvex()",
    "kind": "Method",
    "detail": "Function (this -> bIsConvex = MObject ->)",
    "insertText": "IsConvex()"
  },
  {
    "label": "GetDoCollide()",
    "kind": "Method",
    "detail": "Function (this -> bDoCollide = MObject ->)",
    "insertText": "GetDoCollide()"
  },
  {
    "label": "TImplicitObjectTransformed()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TImplicitObjectTransformed(const Chaos::FImplicitObjectPtr& Object, const TRigidTransform<T, d>& InTransform) : FImplicitObject(EImplicitObject::HasBoundingBox, ImplicitObjectType::Transformed) , MObject(Object) , MTransform(InTransform)"
  },
  {
    "label": "TImplicitObjectTransformed()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TImplicitObjectTransformed(const TImplicitObjectTransformed<T, d, bSerializable>& Other)"
  },
  {
    "label": "TImplicitObjectTransformed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TImplicitObjectTransformed(TImplicitObjectTransformed<T, d, bSerializable>&& Other) : FImplicitObject(EImplicitObject::HasBoundingBox, ImplicitObjectType::Transformed) , MObject(Other.MObject) , MTransform(Other.MTransform) , MLocalBoundingBox(MoveTemp(Other.MLocalBoundingBox))"
  },
  {
    "label": "GetNestedType()",
    "kind": "Method",
    "detail": "Function (} EImplicitObjectType)",
    "insertText": "GetNestedType()"
  },
  {
    "label": "CopyGeometry()",
    "kind": "Method",
    "detail": "Function (} Chaos::FImplicitObjectPtr)",
    "insertText": "CopyGeometry()"
  },
  {
    "label": "CopyGeometryWithScale()",
    "kind": "Method",
    "detail": "Function (} Chaos::FImplicitObjectPtr)",
    "insertText": "CopyGeometryWithScale(const FVec3& Scale)"
  },
  {
    "label": "ScaleTranslation()",
    "kind": "Method",
    "detail": "Function (FRigidTransform3 AdjustedTransform { MTransform } ; AdjustedTransform .)",
    "insertText": "ScaleTranslation(Scale)"
  },
  {
    "label": "ScaledObject()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectPtr)",
    "insertText": "ScaledObject(MObject->CopyGeometryWithScale(Scale))"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "check(false)"
  },
  {
    "label": "ObjectCopy()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectPtr)",
    "insertText": "ObjectCopy(MObject->DeepCopyGeometry())"
  },
  {
    "label": "ScaledObject()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectPtr)",
    "insertText": "ScaledObject(MObject->DeepCopyGeometryWithScale(Scale))"
  },
  {
    "label": "StaticType()",
    "kind": "Method",
    "detail": "Function (} EImplicitObjectType)",
    "insertText": "StaticType()"
  },
  {
    "label": "GetMargin()",
    "kind": "Method",
    "detail": "Function (} FReal)",
    "insertText": "GetMargin()"
  },
  {
    "label": "GetRadius()",
    "kind": "Method",
    "detail": "Function (} FReal)",
    "insertText": "GetRadius()"
  },
  {
    "label": "PhiWithNormal()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "PhiWithNormal(const TVector<T, d>& x, TVector<T, d>& Normal)"
  },
  {
    "label": "InverseTransformPosition()",
    "kind": "Method",
    "detail": "Function (auto TransformedX = MTransform .)",
    "insertText": "InverseTransformPosition(x)"
  },
  {
    "label": "PhiWithNormal()",
    "kind": "Method",
    "detail": "Function (auto Phi = MObject ->)",
    "insertText": "PhiWithNormal(TransformedX, Normal)"
  },
  {
    "label": "TransformVector()",
    "kind": "Method",
    "detail": "Function (Normal = MTransform .)",
    "insertText": "TransformVector(Normal)"
  },
  {
    "label": "InverseTransformPosition()",
    "kind": "Method",
    "detail": "Function (const TVector<T,d> LocalStart = MTransform .)",
    "insertText": "InverseTransformPosition(StartPoint)"
  },
  {
    "label": "InverseTransformVector()",
    "kind": "Method",
    "detail": "Function (const TVector<T,d> LocalDir = MTransform .)",
    "insertText": "InverseTransformVector(Dir)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TVector<T,d> LocalPosition ; TVector<T,d> LocalNormal ;)",
    "insertText": "if(MObject->Raycast(LocalStart, LocalDir, Length, Thickness, OutTime, LocalPosition, LocalNormal, OutFaceIndex))"
  },
  {
    "label": "TransformPosition()",
    "kind": "Method",
    "detail": "Function (OutPosition = MTransform .)",
    "insertText": "TransformPosition(LocalPosition)"
  },
  {
    "label": "TransformVector()",
    "kind": "Method",
    "detail": "Function (OutNormal = MTransform .)",
    "insertText": "TransformVector(LocalNormal)"
  },
  {
    "label": "FindMostOpposingFace()",
    "kind": "Method",
    "detail": "Function (} return true ; } return false ; } int32)",
    "insertText": "FindMostOpposingFace(const TVector<T, 3>& Position, const TVector<T, 3>& UnitDir, int32 HintFaceIndex, T SearchDistance)"
  },
  {
    "label": "InverseTransformPositionNoScale()",
    "kind": "Method",
    "detail": "Function (const TVector<T,d> LocalPosition = MTransform .)",
    "insertText": "InverseTransformPositionNoScale(Position)"
  },
  {
    "label": "InverseTransformVectorNoScale()",
    "kind": "Method",
    "detail": "Function (const TVector<T,d> LocalDir = MTransform .)",
    "insertText": "InverseTransformVectorNoScale(UnitDir)"
  },
  {
    "label": "FindGeometryOpposingNormal()",
    "kind": "Method",
    "detail": "Function (} TVector<T,3>)",
    "insertText": "FindGeometryOpposingNormal(const TVector<T, d>& DenormDir, int32 FaceIndex, const TVector<T, d>& OriginalNormal)"
  },
  {
    "label": "InverseTransformVectorNoScale()",
    "kind": "Method",
    "detail": "Function (const TVector<T,d> LocalDenormDir = MTransform .)",
    "insertText": "InverseTransformVectorNoScale(DenormDir)"
  },
  {
    "label": "InverseTransformVectorNoScale()",
    "kind": "Method",
    "detail": "Function (const TVector<T,d> LocalOriginalNormal = MTransform .)",
    "insertText": "InverseTransformVectorNoScale(OriginalNormal)"
  },
  {
    "label": "FindGeometryOpposingNormal()",
    "kind": "Method",
    "detail": "Function (const TVector<T,d> LocalNormal = MObject ->)",
    "insertText": "FindGeometryOpposingNormal(LocalDenormDir, FaceIndex, LocalOriginalNormal)"
  },
  {
    "label": "Overlap()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Overlap(const TVector<T, d>& Point, const T Thickness)"
  },
  {
    "label": "InverseTransformPosition()",
    "kind": "Method",
    "detail": "Function (const TVector<T,d> LocalPoint = MTransform .)",
    "insertText": "InverseTransformPosition(Point)"
  },
  {
    "label": "FindClosestIntersectionImp()",
    "kind": "Method",
    "detail": "Function (} Pair<TVector<T,d>,bool>)",
    "insertText": "FindClosestIntersectionImp(const TVector<T, d>& StartPoint, const TVector<T, d>& EndPoint, const T Thickness)"
  },
  {
    "label": "InverseTransformPosition()",
    "kind": "Method",
    "detail": "Function (auto TransformedEnd = MTransform .)",
    "insertText": "InverseTransformPosition(EndPoint)"
  },
  {
    "label": "FindClosestIntersection()",
    "kind": "Method",
    "detail": "Function (auto ClosestIntersection = MObject ->)",
    "insertText": "FindClosestIntersection(TransformedStart, TransformedEnd, Thickness)"
  },
  {
    "label": "TransformPosition()",
    "kind": "Method",
    "detail": "Function (ClosestIntersection . First = MTransform .)",
    "insertText": "TransformPosition(ClosestIntersection.First)"
  },
  {
    "label": "FindClosestFaceAndVertices()",
    "kind": "Method",
    "detail": "Function (} return ClosestIntersection ; } int32)",
    "insertText": "FindClosestFaceAndVertices(const FVec3& Position, TArray<FVec3>& FaceVertices, FReal SearchDist = 0.01f)"
  },
  {
    "label": "InverseTransformPosition()",
    "kind": "Method",
    "detail": "Function (const FVec3 LocalPoint = MTransform .)",
    "insertText": "InverseTransformPosition(Position)"
  },
  {
    "label": "FindClosestFaceAndVertices()",
    "kind": "Method",
    "detail": "Function (int32 FaceIndex = MObject ->)",
    "insertText": "FindClosestFaceAndVertices(LocalPoint, FaceVertices, SearchDist)"
  },
  {
    "label": "TransformPosition()",
    "kind": "Method",
    "detail": "Function (Vec = MTransform .)",
    "insertText": "TransformPosition(Vec)"
  },
  {
    "label": "GetTransform()",
    "kind": "Method",
    "detail": "Function (} } return FaceIndex ; } const TRigidTransform<T,d>&)",
    "insertText": "GetTransform()"
  },
  {
    "label": "AccumulateAllImplicitObjects()",
    "kind": "Method",
    "detail": "Function (MTransform = InTransform ; } void)",
    "insertText": "AccumulateAllImplicitObjects(TArray<Pair<const FImplicitObject*, TRigidTransform<T, d>>>& Out, const TRigidTransform<T, d>& ParentTM)"
  },
  {
    "label": "AccumulateAllImplicitObjects()",
    "kind": "Method",
    "detail": "Function (const TRigidTransform<T,d> NewTM = MTransform* ParentTM ; MObject ->)",
    "insertText": "AccumulateAllImplicitObjects(Out, NewTM)"
  },
  {
    "label": "FindAllIntersectingObjects()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "FindAllIntersectingObjects(TArray < Pair<const FImplicitObject*, TRigidTransform<T, d>>>& Out, const TAABB<T, d>& LocalBounds)"
  },
  {
    "label": "TransformedAABB()",
    "kind": "Method",
    "detail": "Function (const TAABB<T,d> SubobjectBounds = LocalBounds .)",
    "insertText": "TransformedAABB(MTransform.Inverse())"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (int32 NumOut = Out .)",
    "insertText": "Num()"
  },
  {
    "label": "FindAllIntersectingObjects()",
    "kind": "Method",
    "detail": "Function (MObject ->)",
    "insertText": "FindAllIntersectingObjects(Out, SubobjectBounds)"
  },
  {
    "label": "BoundingBox()",
    "kind": "Method",
    "detail": "Function (Out [ NumOut ] . Second = Out [ NumOut ] . Second* MTransform ; } } const TAABB<T,d>)",
    "insertText": "BoundingBox()"
  },
  {
    "label": "GetVolume()",
    "kind": "Method",
    "detail": "Function (} const FReal)",
    "insertText": "GetVolume()"
  },
  {
    "label": "GetInertiaTensor()",
    "kind": "Method",
    "detail": "Function (} const FMatrix33)",
    "insertText": "GetInertiaTensor(const FReal Mass)"
  },
  {
    "label": "GetCenterOfMass()",
    "kind": "Method",
    "detail": "Function (} const FVec3)",
    "insertText": "GetCenterOfMass()"
  },
  {
    "label": "ScopedMemory()",
    "kind": "Method",
    "detail": "Function (FChaosArchiveScopedMemory)",
    "insertText": "ScopedMemory(Ar, GetTypeName(), false)"
  },
  {
    "label": "SerializeImp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SerializeImp(Ar)"
  },
  {
    "label": "TImplicitObjectTransformSerializeHelper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TImplicitObjectTransformSerializeHelper(Ar, MObject)"
  },
  {
    "label": "SerializeAsAABB()",
    "kind": "Method",
    "detail": "Function (Ar<<MTransform ; TBox<T,d)",
    "insertText": "SerializeAsAABB(Ar, MLocalBoundingBox)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetTypeHash()"
  },
  {
    "label": "GetMaterialIndex()",
    "kind": "Method",
    "detail": "Function (} uint16)",
    "insertText": "GetMaterialIndex(uint32 HintIndex)"
  },
  {
    "label": "GetGeometry()",
    "kind": "Method",
    "detail": "Function (} const Chaos::FImplicitObjectRef)",
    "insertText": "GetGeometry()"
  },
  {
    "label": "SetGeometry()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetGeometry(const Chaos::FImplicitObjectPtr& ImplicitObject)"
  },
  {
    "label": "CountObjectsInHierarchyImpl()",
    "kind": "Method",
    "detail": "Function (MObject = ImplicitObject ; } protected : int32)",
    "insertText": "CountObjectsInHierarchyImpl()"
  },
  {
    "label": "CountLeafObjectsInHierarchyImpl()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "CountLeafObjectsInHierarchyImpl()"
  },
  {
    "label": "VisitOverlappingLeafObjectsImpl()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VisitOverlappingLeafObjectsImpl(const FAABB3& InLocalBounds, const FRigidTransform3& ObjectTransform, const int32 RootObjectIndex, int32& ObjectIndex, int32& LeafObjectIndex, const FImplicitHierarchyVisitor& VisitorFunc)"
  },
  {
    "label": "InverseTransformedAABB()",
    "kind": "Method",
    "detail": "Function (+ + ObjectIndex ; const FAABB3 LocalBounds = InLocalBounds .)",
    "insertText": "InverseTransformedAABB(MTransform)"
  },
  {
    "label": "VisitOverlappingLeafObjectsImpl()",
    "kind": "Method",
    "detail": "Function (MObject ->)",
    "insertText": "VisitOverlappingLeafObjectsImpl(LocalBounds, MTransform * ObjectTransform, RootObjectIndex, ObjectIndex, LeafObjectIndex, VisitorFunc)"
  },
  {
    "label": "VisitLeafObjectsImpl()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VisitLeafObjectsImpl(const FRigidTransform3& ObjectTransform, const int32 RootObjectIndex, int32& ObjectIndex, int32& LeafObjectIndex, const FImplicitHierarchyVisitor& VisitorFunc)"
  },
  {
    "label": "VisitLeafObjectsImpl()",
    "kind": "Method",
    "detail": "Function (+ + ObjectIndex ; MObject ->)",
    "insertText": "VisitLeafObjectsImpl(MTransform * ObjectTransform, RootObjectIndex, ObjectIndex, LeafObjectIndex, VisitorFunc)"
  },
  {
    "label": "VisitObjectsImpl()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "VisitObjectsImpl(const FRigidTransform3& ObjectTransform, const int32 RootObjectIndex, int32& ObjectIndex, int32& LeafObjectIndex, const FImplicitHierarchyVisitorBool& VisitorFunc)"
  },
  {
    "label": "VisitorFunc()",
    "kind": "Method",
    "detail": "Function (bool bContinue =)",
    "insertText": "VisitorFunc(this, ObjectTransform, RootObjectIndex, ObjectIndex, INDEX_NONE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + ObjectIndex ;)",
    "insertText": "if(bContinue)"
  },
  {
    "label": "VisitObjectsImpl()",
    "kind": "Method",
    "detail": "Function (bContinue = MObject ->)",
    "insertText": "VisitObjectsImpl(MTransform * ObjectTransform, RootObjectIndex, ObjectIndex, LeafObjectIndex, VisitorFunc)"
  },
  {
    "label": "IsOverlappingBoundsImpl()",
    "kind": "Method",
    "detail": "Function (} return bContinue ; } bool)",
    "insertText": "IsOverlappingBoundsImpl(const FAABB3& InLocalBounds)"
  },
  {
    "label": "TImplicitObjectTransformed()",
    "kind": "Method",
    "detail": "Function (} private : Chaos::FImplicitObjectPtr MObject ; TRigidTransform<T,d> MTransform ; TAABB<T,d> MLocalBoundingBox ; class FClusterUnionManager ;)",
    "insertText": "TImplicitObjectTransformed() : FImplicitObject(EImplicitObject::HasBoundingBox, ImplicitObjectType::Transformed)"
  },
  {
    "label": "DeepCopyGeometry()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectPtr NewTransformed = InObject ->)",
    "insertText": "DeepCopyGeometry()"
  },
  {
    "label": "FReal()",
    "kind": "Method",
    "detail": "Function (TImplicitObjectTransformed<FReal,3>* InnerTransformed = static_cast<TImplicitObjectTransformed<)",
    "insertText": "FReal(NewTransformed.GetReference())"
  },
  {
    "label": "SetTransform()",
    "kind": "Method",
    "detail": "Function (InnerTransformed ->)",
    "insertText": "SetTransform(NewTransform)"
  }
]