[
  {
    "label": "TVector2",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TVector2"
  },
  {
    "label": "TVector",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TVector"
  },
  {
    "label": "GlobalInit()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Math / MathFwd . h \" # include \" VectorTypes . h \" # include \" Misc / CoreMiscDefines . h \" namespace UE { namespace Math { template<T> struct TVector2 ; } namespace Math { template<T> struct TVector ; } namespace Geometry { namespace ExactPredicates { using namespace UE::Math ; void)",
    "insertText": "GlobalInit()"
  },
  {
    "label": "Orient2DInexact()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "Orient2DInexact(const float* PA, const float* PB, const float* PC)"
  },
  {
    "label": "Orient2D()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "Orient2D(const float* PA, const float* PB, const float* PC)"
  },
  {
    "label": "Orient2DOrigin()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "Orient2DOrigin(float ax, float ay, float bx, float by)"
  },
  {
    "label": "Orient3DInexact()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "Orient3DInexact(const float* PA, const float* PB, const float* PC, const float* PD)"
  },
  {
    "label": "Orient3D()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "Orient3D(const float* PA, const float* PB, const float* PC, const float* PD)"
  },
  {
    "label": "Facing3D()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "Facing3D(const float* PA, const float* PB, const float* PC, const float* Direction)"
  },
  {
    "label": "Facing2D()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "Facing2D(const float* PA, const float* PB, const float* PC)"
  },
  {
    "label": "InCircleInexact()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "InCircleInexact(const float* PA, const float* PB, const float* PC, const float* PD)"
  },
  {
    "label": "InCircle()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "InCircle(const float* PA, const float* PB, const float* PC, const float* PD)"
  },
  {
    "label": "Orient2()",
    "kind": "Method",
    "detail": "Function (template<RealType> RealType)",
    "insertText": "Orient2(const TVector2<RealType>& A, const TVector2<RealType>& B, const TVector2<RealType>& C)"
  },
  {
    "label": "Orient2D()",
    "kind": "Method",
    "detail": "Function (RealType PA [ 2 ] { A . X,A . Y } ; RealType PB [ 2 ] { B . X,B . Y } ; RealType PC [ 2 ] { C . X,C . Y } ; return)",
    "insertText": "Orient2D(PA, PB, PC)"
  },
  {
    "label": "Orient2Origin()",
    "kind": "Method",
    "detail": "Function (} template<RealType> RealType)",
    "insertText": "Orient2Origin(const TVector2<RealType>& A, const TVector2<RealType>& B)"
  },
  {
    "label": "Orient3()",
    "kind": "Method",
    "detail": "Function (} template<RealType> RealType)",
    "insertText": "Orient3(const TVector<RealType>& A, const TVector<RealType>& B, const TVector<RealType>& C, const TVector<RealType>& D)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "return(RealType)FMath::Sign(Orient3D(PA, PB, PC, PD))"
  },
  {
    "label": "Facing2()",
    "kind": "Method",
    "detail": "Function (} } template<RealType> RealType)",
    "insertText": "Facing2(const TVector2<RealType>& A, const TVector2<RealType>& B, const TVector2<RealType>& Direction)"
  },
  {
    "label": "Facing2D()",
    "kind": "Method",
    "detail": "Function (RealType PA [ 2 ] { A . X,A . Y } ; RealType PB [ 2 ] { B . X,B . Y } ; RealType Dir [ 2 ] { Direction . X,Direction . Y } ; return)",
    "insertText": "Facing2D(PA, PB, Dir)"
  },
  {
    "label": "Facing3()",
    "kind": "Method",
    "detail": "Function (} template<RealType> RealType)",
    "insertText": "Facing3(const TVector<RealType>& A, const TVector<RealType>& B, const TVector<RealType>& C, const TVector<RealType>& Direction)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "return(RealType)FMath::Sign(Facing3D(PA, PB, PC, Dir))"
  },
  {
    "label": "InCircle2()",
    "kind": "Method",
    "detail": "Function (} } template<RealType> RealType)",
    "insertText": "InCircle2(const TVector2<RealType>& A, const TVector2<RealType>& B, const TVector2<RealType>& C, const TVector2<RealType>& D)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "return(RealType)FMath::Sign(InCircle(PA, PB, PC, PD))"
  },
  {
    "label": "InSphere3()",
    "kind": "Method",
    "detail": "Function (} } template<RealType> RealType)",
    "insertText": "InSphere3(const TVector<RealType>& A, const TVector<RealType>& B, const TVector<RealType>& C, const TVector<RealType>& D, const TVector<RealType>& E)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "return(RealType)FMath::Sign(InSphere(PA, PB, PC, PD, PE))"
  }
]