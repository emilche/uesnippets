[
  {
    "label": "FChunkCacheWorker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FChunkCacheWorker"
  },
  {
    "label": "FFileIoStore",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FFileIoStore"
  },
  {
    "label": "FFilePackageStoreBackend",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FFilePackageStoreBackend"
  },
  {
    "label": "FOutputDevice",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FOutputDevice"
  },
  {
    "label": "IAsyncReadFileHandle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IAsyncReadFileHandle"
  },
  {
    "label": "IMappedFileHandle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IMappedFileHandle"
  },
  {
    "label": "FPakFileDirectoryVisitorBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPakFileDirectoryVisitorBase"
  },
  {
    "label": "FIoContainerHeader",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FIoContainerHeader"
  },
  {
    "label": "FPakChunkSignatureCheckFailedData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPakChunkSignatureCheckFailedData"
  },
  {
    "label": "FPakInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPakInfo"
  },
  {
    "label": "FPakCompressedBlock",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPakCompressedBlock"
  },
  {
    "label": "FPakEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPakEntry"
  },
  {
    "label": "FPakEntryLocation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPakEntryLocation"
  },
  {
    "label": "FPakFile",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPakFile"
  },
  {
    "label": "FSharedPakReader",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSharedPakReader"
  },
  {
    "label": "FPakEntryPair",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPakEntryPair"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FScopedPakDirectoryIndexAccess",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FScopedPakDirectoryIndexAccess"
  },
  {
    "label": "FArchiveAndLastAccessTime",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FArchiveAndLastAccessTime"
  },
  {
    "label": "FPakPlatformFile",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPakPlatformFile"
  },
  {
    "label": "FRefCountBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRefCountBase"
  },
  {
    "label": "ContainerType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ContainerType"
  },
  {
    "label": "FBaseIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FBaseIterator"
  },
  {
    "label": "FPakEntryIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPakEntryIterator"
  },
  {
    "label": "FFilenameIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FFilenameIterator"
  },
  {
    "label": "FIndexSettings",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FIndexSettings"
  },
  {
    "label": "FPakNoEncryption",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPakNoEncryption"
  },
  {
    "label": "FPakReaderPolicy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPakReaderPolicy"
  },
  {
    "label": "FPakFileHandle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPakFileHandle"
  },
  {
    "label": "FPakListEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPakListEntry"
  },
  {
    "label": "FPakListDeferredEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPakListDeferredEntry"
  },
  {
    "label": "FPakSignatureFile",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPakSignatureFile"
  },
  {
    "label": "FPakSigningFailureHandlerData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPakSigningFailureHandlerData"
  },
  {
    "label": "DECLARE_LOG_CATEGORY_EXTERN()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" Containers / ArrayView . h \" # include \" Containers / Map . h \" # include \" Containers / Set . h \" # include \" Containers / SparseArray . h \" # include \" Containers / StringConv . h \" # include \" Containers / Ticker . h \" # include \" Containers / UnrealString . h \" # include \" CoreMinimal . h \" # include \" Delegates / Delegate . h \" # include \" GenericPlatform / GenericPlatformChunkInstall . h \" # include \" GenericPlatform / GenericPlatformFile . h \" # include \" HAL / CriticalSection . h \" # include \" HAL / PlatformCrt . h \" # include \" HAL / PlatformTime . h \" # include \" HAL / UnrealMemory . h \" # include \" IO / IoContainerId . h \" # include \" Logging / LogCategory . h \" # include \" Logging / LogMacros . h \" # include \" Math / BigInt . h \" # include \" Math / NumericLimits . h \" # include \" Math / UnrealMathSSE . h \" # include \" Misc / AES . h \" # include \" Misc / AssertionMacros . h \" # include \" Misc / CString . h \" # include \" Misc / CompressionFlags . h \" # include \" Misc / DateTime . h \" # include \" Misc / Guid . h \" # include \" Misc / IEngineCrypto . h \" # include \" Misc / Paths . h \" # include \" Misc / ScopeLock . h \" # include \" Misc / ScopeRWLock . h \" # include \" Misc / SecureHash . h \" # include \" RSA . h \" # include \" Serialization / Archive . h \" # include \" Serialization / MemoryImage . h \" # include \" Stats / Stats . h \" # include \" Stats / Stats2 . h \" # include \" Templates / Function . h \" # include \" Templates / RefCounting . h \" # include \" Templates / SharedPointer . h \" # include \" Templates / UniquePtr . h \" # include \" Templates / UnrealTemplate . h \" # include \" Trace / Detail / Channel . h \" # include \" UObject / NameTypes . h \" # include \" UObject / UnrealNames . h \" class FChunkCacheWorker ; class FFileIoStore ; class FFilePackageStoreBackend ; class FOutputDevice ; class IAsyncReadFileHandle ; class IMappedFileHandle ; namespace UE::PakFile::Private { class FPakFileDirectoryVisitorBase ; } struct FIoContainerHeader ;)",
    "insertText": "DECLARE_LOG_CATEGORY_EXTERN(LogPakFile, Log, All)"
  },
  {
    "label": "DECLARE_FLOAT_ACCUMULATOR_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_FLOAT_ACCUMULATOR_STAT_EXTERN(TEXT(\"Total pak file read time\"), STAT_PakFile_Read, STATGROUP_PakFile, PAKFILE_API)"
  },
  {
    "label": "DECLARE_DWORD_ACCUMULATOR_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_DWORD_ACCUMULATOR_STAT_EXTERN(TEXT(\"Num open pak file handles\"), STAT_PakFile_NumOpenHandles, STATGROUP_PakFile, PAKFILE_API)"
  },
  {
    "label": "ComputePakChunkHash()",
    "kind": "Method",
    "detail": "Function (# define PAK_TRACKER 0 # ifndef ENABLE_PAKFILE_RUNTIME_PRUNING # define ENABLE_PAKFILE_RUNTIME_PRUNING 1 # endif # define ENABLE_PAKFILE_RUNTIME_PRUNING_VALIDATE ENABLE_PAKFILE_RUNTIME_PRUNING&& ! UE_BUILD_SHIPPING # define PAKHASH_USE_CRC 1 # if PAKHASH_USE_CRC typedef uint32 TPakChunkHash ; # else typedef FSHAHash TPakChunkHash ; # endif TPakChunkHash)",
    "insertText": "ComputePakChunkHash(const void* InData, int64 InDataSizeInBytes)"
  },
  {
    "label": "Printf()",
    "kind": "Method",
    "detail": "Function (# if PAKHASH_USE_CRC return)",
    "insertText": "Printf(TEXT(\"%08X\"), InHash)"
  },
  {
    "label": "LexToString()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "LexToString(InHash)"
  },
  {
    "label": "FPakChunkSignatureCheckFailedData()",
    "kind": "Method",
    "detail": "Function (# endif } struct FPakChunkSignatureCheckFailedData {)",
    "insertText": "FPakChunkSignatureCheckFailedData(const FString& InPakFilename, const TPakChunkHash& InExpectedHash, const TPakChunkHash& InReceivedHash, int32 InChunkIndex) : PakFilename(InPakFilename) , ChunkIndex(InChunkIndex) , ExpectedHash(InExpectedHash) , ReceivedHash(InReceivedHash)"
  },
  {
    "label": "FPakChunkSignatureCheckFailedData()",
    "kind": "Method",
    "detail": "Function (} FString PakFilename ; int32 ChunkIndex ; TPakChunkHash ExpectedHash ; TPakChunkHash ReceivedHash ;)",
    "insertText": "FPakChunkSignatureCheckFailedData() : ChunkIndex(0)"
  },
  {
    "label": "DECLARE_DELEGATE_RetVal_OneParam()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "DECLARE_DELEGATE_RetVal_OneParam(bool, FFilenameSecurityDelegate, const TCHAR*)"
  },
  {
    "label": "DECLARE_DELEGATE_ThreeParams()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_DELEGATE_ThreeParams(FPakCustomEncryptionDelegate, uint8* , uint32 , FGuid)"
  },
  {
    "label": "DECLARE_MULTICAST_DELEGATE_OneParam()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_MULTICAST_DELEGATE_OneParam(FPakChunkSignatureCheckFailedHandler, const FPakChunkSignatureCheckFailedData&)"
  },
  {
    "label": "DECLARE_MULTICAST_DELEGATE_OneParam()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_MULTICAST_DELEGATE_OneParam(FPakPrincipalSignatureTableCheckFailureHandler, const FString&)"
  },
  {
    "label": "DECLARE_DELEGATE_ThreeParams()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_DELEGATE_ThreeParams(FPakSetIndexSettings, bool& , bool& , bool&)"
  },
  {
    "label": "FPakInfo()",
    "kind": "Method",
    "detail": "Function (struct FPakInfo { enum { PakFile_Magic = 0 x5A6F12E1,MaxChunkDataSize = 6 4* 1 0 2 4,CompressionMethodNameLen = 3 2,MaxNumCompressionMethods = 5,} ; enum { PakFile_Version_Initial = 1,PakFile_Version_NoTimestamps = 2,PakFile_Version_CompressionEncryption = 3,PakFile_Version_IndexEncryption = 4,PakFile_Version_RelativeChunkOffsets = 5,PakFile_Version_DeleteRecords = 6,PakFile_Version_EncryptionKeyGuid = 7,PakFile_Version_FNameBasedCompressionMethod = 8,PakFile_Version_FrozenIndex = 9,PakFile_Version_PathHashIndex = 1 0,PakFile_Version_Fnv64BugFix = 1 1,PakFile_Version_Last,PakFile_Version_Invalid,PakFile_Version_Latest = PakFile_Version_Last - 1 } ; uint32 Magic ; int32 Version ; int64 IndexOffset ; int64 IndexSize ; FSHAHash IndexHash ; uint8 bEncryptedIndex ; FGuid EncryptionKeyGuid ; TArray<FName> CompressionMethods ;)",
    "insertText": "FPakInfo() : Magic(PakFile_Magic) , Version(PakFile_Version_Latest) , IndexOffset(-1) , IndexSize(0) , bEncryptedIndex(0)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (CompressionMethods .)",
    "insertText": "Add(NAME_None)"
  },
  {
    "label": "GetSerializedSize()",
    "kind": "Method",
    "detail": "Function (} int64)",
    "insertText": "GetSerializedSize(int32 InVersion = PakFile_Version_Latest)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (int64 Size =)",
    "insertText": "sizeof(Magic) + sizeof(Version) + sizeof(IndexOffset) + sizeof(IndexSize) + sizeof(IndexHash) + sizeof(bEncryptedIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Magic = 0 ; return ; })",
    "insertText": "if(Ar.IsSaving() || InVersion >= PakFile_Version_EncryptionKeyGuid)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Ar<<EncryptionKeyGuid ; } Ar<<bEncryptedIndex ; Ar<<Magic ;)",
    "insertText": "if(Magic != PakFile_Magic)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Magic = 0 ; return ; } Ar<<Version ; Ar<<IndexOffset ; Ar<<IndexSize ; Ar<<IndexHash ;)",
    "insertText": "if(Ar.IsLoading())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bEncryptedIndex = false ; })",
    "insertText": "if(Version < PakFile_Version_EncryptionKeyGuid)"
  },
  {
    "label": "Invalidate()",
    "kind": "Method",
    "detail": "Function (EncryptionKeyGuid .)",
    "insertText": "Invalidate()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(Version >= PakFile_Version_FrozenIndex && Version < PakFile_Version_PathHashIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bIndexIsFrozen = false ; Ar<<bIndexIsFrozen ;)",
    "insertText": "if(bIndexIsFrozen)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(Version < PakFile_Version_FNameBasedCompressionMethod)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (CompressionMethods .)",
    "insertText": "Add(NAME_Zlib)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (CompressionMethods .)",
    "insertText": "Add(NAME_Gzip)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (CompressionMethods .)",
    "insertText": "Add(TEXT(\"Oodle\"))"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Serialize(Methods, BufferSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ANSICHAR* MethodString =& Methods [ Index* CompressionMethodNameLen ] ;)",
    "insertText": "if(MethodString[0] != 0)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (MethodString [ CompressionMethodNameLen - 1 ] = 0 ; CompressionMethods .)",
    "insertText": "Add(FName(MethodString))"
  },
  {
    "label": "Memzero()",
    "kind": "Method",
    "detail": "Function (} } } else {)",
    "insertText": "Memzero(Methods, BufferSize)"
  },
  {
    "label": "Methods()",
    "kind": "Method",
    "detail": "Function (ANSICHAR* MethodString =&)",
    "insertText": "Methods(Index - 1)"
  },
  {
    "label": "Strcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Strcpy(MethodString, CompressionMethodNameLen, TCHAR_TO_ANSI(*CompressionMethods[Index].ToString()))"
  },
  {
    "label": "GetCompressionMethodIndex()",
    "kind": "Method",
    "detail": "Function (} } } int32)",
    "insertText": "GetCompressionMethodIndex(FName CompressionMethod)"
  },
  {
    "label": "GetCompressionMethod()",
    "kind": "Method",
    "detail": "Function (} FName)",
    "insertText": "GetCompressionMethod(uint32 Index)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "return(int32)Index >= CompressionMethods.Num() ? TOptional<FName>() : TOptional<FName>(CompressionMethods[(int32)Index])"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; struct FPakCompressedBlock { int64 CompressedStart ; int64 CompressedEnd ; bool)",
    "insertText": "operator(const FPakCompressedBlock& B)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; FArchive&)",
    "insertText": "operator(FArchive& Ar, FPakCompressedBlock& Block)"
  },
  {
    "label": "FPakEntry()",
    "kind": "Method",
    "detail": "Function (Ar<<Block . CompressedStart ; Ar<<Block . CompressedEnd ; return Ar ; } struct FPakEntry { const uint8 Flag_None = 0 x00 ; const uint8 Flag_Encrypted = 0 x01 ; const uint8 Flag_Deleted = 0 x02 ; int64 Offset ; int64 Size ; int64 UncompressedSize ; uint8 Hash [ 2 0 ] ; TArray<FPakCompressedBlock> CompressionBlocks ; uint32 CompressionBlockSize ; uint32 CompressionMethodIndex ; uint8 Flags ; bool Verified ;)",
    "insertText": "FPakEntry()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "GetSerializedSize()",
    "kind": "Method",
    "detail": "Function (} int64)",
    "insertText": "GetSerializedSize(int32 Version)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (int64 SerializedSize =)",
    "insertText": "sizeof(Offset) + sizeof(Size) + sizeof(UncompressedSize) + sizeof(Hash)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (SerializedSize + =)",
    "insertText": "sizeof(CompressionMethodIndex)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} else { SerializedSize + =)",
    "insertText": "sizeof(int32)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Version >= FPakInfo::PakFile_Version_CompressionEncryption)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (SerializedSize + =)",
    "insertText": "sizeof(Flags) + sizeof(CompressionBlockSize)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (SerializedSize + =)",
    "insertText": "sizeof(FPakCompressedBlock) * CompressionBlocks.Num() + sizeof(int32)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(Version < FPakInfo::PakFile_Version_NoTimestamps)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (SerializedSize + =)",
    "insertText": "sizeof(int64)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return SerializedSize ; } bool)",
    "insertText": "operator(const FPakEntry& B)"
  },
  {
    "label": "IndexDataEquals()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IndexDataEquals(const FPakEntry& B)"
  },
  {
    "label": "Memset()",
    "kind": "Method",
    "detail": "Function (Offset = - 1 ; Size = 0 ; UncompressedSize = 0 ;)",
    "insertText": "Memset(Hash, 0, sizeof(Hash))"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (CompressionBlockSize = 0 ; CompressionMethodIndex = 0 ; Flags = Flag_None ; Verified = false ; } void)",
    "insertText": "Serialize(FArchive& Ar, int32 Version)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Ar<<Offset ; Ar<<Size ; Ar<<UncompressedSize ;)",
    "insertText": "if(Version < FPakInfo::PakFile_Version_FNameBasedCompressionMethod)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 LegacyCompressionMethod ; Ar<<LegacyCompressionMethod ;)",
    "insertText": "if(LegacyCompressionMethod == COMPRESS_None)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CompressionMethodIndex = 0 ; } else)",
    "insertText": "if(LegacyCompressionMethod & COMPRESS_ZLIB_DEPRECATED)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CompressionMethodIndex = 1 ; } else)",
    "insertText": "if(LegacyCompressionMethod & COMPRESS_GZIP_DEPRECATED)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CompressionMethodIndex = 2 ; } else)",
    "insertText": "if(LegacyCompressionMethod & COMPRESS_Custom_DEPRECATED)"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (CompressionMethodIndex = 3 ; } else {)",
    "insertText": "UE_LOG(LogPakFile, Fatal, TEXT(\"Found an unknown compression type in pak file, will need to be supported for legacy files\"))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else { Ar<<CompressionMethodIndex ; })",
    "insertText": "if(Version <= FPakInfo::PakFile_Version_Initial)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (FDateTime Timestamp ; Ar<<Timestamp ; } Ar .)",
    "insertText": "Serialize(Hash, sizeof(Hash))"
  },
  {
    "label": "SetFlag()",
    "kind": "Method",
    "detail": "Function (Ar<<CompressionBlocks ; } Ar<<Flags ; Ar<<CompressionBlockSize ; } } void)",
    "insertText": "SetFlag(uint8 InFlag, bool bValue)"
  },
  {
    "label": "GetFlag()",
    "kind": "Method",
    "detail": "Function (Flags | = InFlag ; } else { Flags& = ~ InFlag ; } } bool)",
    "insertText": "GetFlag(uint8 InFlag)"
  },
  {
    "label": "IsEncrypted()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEncrypted()"
  },
  {
    "label": "SetEncrypted()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetEncrypted(bool bEncrypted)"
  },
  {
    "label": "SetFlag()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetFlag(Flag_Encrypted, bEncrypted)"
  },
  {
    "label": "IsDeleteRecord()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsDeleteRecord()"
  },
  {
    "label": "SetDeleteRecord()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetDeleteRecord(bool bDeleteRecord)"
  },
  {
    "label": "SetFlag()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetFlag(Flag_Deleted, bDeleteRecord)"
  },
  {
    "label": "VerifyPakEntriesMatch()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "VerifyPakEntriesMatch(const FPakEntry& FileEntryA, const FPakEntry& FileEntryB)"
  },
  {
    "label": "FPakEntryLocation()",
    "kind": "Method",
    "detail": "Function (} ; struct FPakEntryLocation { public : const int32 Invalid = MIN_int32 ; const int32 MaxIndex = MAX_int32 - 1 ;)",
    "insertText": "FPakEntryLocation() : Index(Invalid)"
  },
  {
    "label": "FPakEntryLocation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FPakEntryLocation(const FPakEntryLocation& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FPakEntryLocation&)",
    "insertText": "operator(const FPakEntryLocation& other)"
  },
  {
    "label": "CreateInvalid()",
    "kind": "Method",
    "detail": "Function (FPakEntryLocation)",
    "insertText": "CreateInvalid()"
  },
  {
    "label": "CreateFromOffsetIntoEncoded()",
    "kind": "Method",
    "detail": "Function (} FPakEntryLocation)",
    "insertText": "CreateFromOffsetIntoEncoded(int32 Offset)"
  },
  {
    "label": "CreateFromListIndex()",
    "kind": "Method",
    "detail": "Function (} FPakEntryLocation)",
    "insertText": "CreateFromListIndex(int32 ListIndex)"
  },
  {
    "label": "IsInvalid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsInvalid()"
  },
  {
    "label": "GetAsOffsetIntoEncoded()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetAsOffsetIntoEncoded()"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} else { return - 1 ; } } void)",
    "insertText": "Serialize(FArchive& Ar)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Ar<<Index ; } bool)",
    "insertText": "operator(const FPakEntryLocation& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} int32 Index ; } ; FArchive&)",
    "insertText": "operator(FArchive& Ar, FPakEntryLocation& PakEntryLocation)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (PakEntryLocation .)",
    "insertText": "Serialize(Ar)"
  },
  {
    "label": "FSharedPakReader()",
    "kind": "Method",
    "detail": "Function (public : ~)",
    "insertText": "FSharedPakReader()"
  },
  {
    "label": "FSharedPakReader()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FSharedPakReader(const FSharedPakReader& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FSharedPakReader&)",
    "insertText": "operator(const FSharedPakReader& Other)"
  },
  {
    "label": "FSharedPakReader()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FSharedPakReader(FSharedPakReader&& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FSharedPakReader&)",
    "insertText": "operator(FSharedPakReader&& Other)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (operator)",
    "insertText": "bool()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if ENABLE_PAKFILE_RUNTIME_PRUNING)",
    "insertText": "if(bRequiresDirectoryIndexLock)"
  },
  {
    "label": "ReadLock()",
    "kind": "Method",
    "detail": "Function (PakFile . DirectoryIndexLock .)",
    "insertText": "ReadLock()"
  },
  {
    "label": "FScopedPakDirectoryIndexAccess()",
    "kind": "Method",
    "detail": "Function (} # endif } # if ENABLE_PAKFILE_RUNTIME_PRUNING ~)",
    "insertText": "FScopedPakDirectoryIndexAccess()"
  },
  {
    "label": "ReadUnlock()",
    "kind": "Method",
    "detail": "Function (PakFile . DirectoryIndexLock .)",
    "insertText": "ReadUnlock()"
  },
  {
    "label": "RecreatePakReaders()",
    "kind": "Method",
    "detail": "Function (} } const FPakFile& PakFile ; bool bRequiresDirectoryIndexLock ; # endif } ; bool)",
    "insertText": "RecreatePakReaders(IPlatformFile* LowerLevel)"
  },
  {
    "label": "CompareFilenameHashes()",
    "kind": "Method",
    "detail": "Function (struct FArchiveAndLastAccessTime { TUniquePtr<FArchive> Archive ; double LastAccessTime ; } ; private : class FPakPlatformFile ; FString PakFilename ; FName PakFilenameName ; TUniquePtr<class FChunkCacheWorker> Decryptor ; TArray<FArchiveAndLastAccessTime> Readers ; std::atomic<int32> CurrentlyUsedReaders = 0 ; FCriticalSection ReadersCriticalSection ; FPakInfo Info ; FString MountPoint ; TArray<FPakEntry> Files ; FDirectoryIndex DirectoryIndex ; # if ENABLE_PAKFILE_RUNTIME_PRUNING FDirectoryIndex PrunedDirectoryIndex ; FRWLock DirectoryIndexLock ; # endif FPathHashIndex PathHashIndex ; TArray<uint8> EncodedPakEntries ; uint64 PathHashSeed ; int32 NumEntries ; FDateTime Timestamp ; int64 CachedTotalSize ; bool bSigned ; bool bIsValid ; bool bHasPathHashIndex ; bool bHasFullDirectoryIndex ; # if ENABLE_PAKFILE_RUNTIME_PRUNING bool bWillPruneDirectoryIndex ; bool bNeedsLegacyPruning ; # endif int32 PakchunkIndex ; class IMappedFileHandle* MappedFileHandle ; FCriticalSection MappedFileHandleCriticalSection ; ECacheType CacheType ; int32 CacheIndex ; bool UnderlyingCacheTrimDisabled ; bool bIsMounted ; TUniquePtr<FIoContainerHeader> IoContainerHeader ; # if WITH_EDITOR TUniquePtr<FIoContainerHeader> OptionalSegmentIoContainerHeader ; # endif int32 CDECL)",
    "insertText": "CompareFilenameHashes(const void* Left, const void* Right)"
  },
  {
    "label": "LeftHash()",
    "kind": "Method",
    "detail": "Function (const uint64*)",
    "insertText": "LeftHash(const uint64*)"
  },
  {
    "label": "RightHash()",
    "kind": "Method",
    "detail": "Function (const uint64*)",
    "insertText": "RightHash(const uint64*)"
  },
  {
    "label": "SetupSignedPakReader()",
    "kind": "Method",
    "detail": "Function (FArchive*)",
    "insertText": "SetupSignedPakReader(FArchive* Reader, const TCHAR* Filename)"
  },
  {
    "label": "PakGetPakFilename()",
    "kind": "Method",
    "detail": "Function (public : const FString&)",
    "insertText": "PakGetPakFilename()"
  },
  {
    "label": "PakGetPakchunkIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "PakGetPakchunkIndex()"
  },
  {
    "label": "CallShouldVisitAndVisit()",
    "kind": "Method",
    "detail": "Function (Visitor .)",
    "insertText": "CallShouldVisitAndVisit(*It.Filename(), false)"
  },
  {
    "label": "PakGetMountPoint()",
    "kind": "Method",
    "detail": "Function (} } const FString&)",
    "insertText": "PakGetMountPoint()"
  },
  {
    "label": "GetUnderlyingCacheTrimDisabled()",
    "kind": "Method",
    "detail": "Function (UnderlyingCacheTrimDisabled = InUnderlyingCacheTrimDisabled ; } bool)",
    "insertText": "GetUnderlyingCacheTrimDisabled(void)"
  },
  {
    "label": "GetCacheType()",
    "kind": "Method",
    "detail": "Function (CacheType = InCacheType ; } ECacheType)",
    "insertText": "GetCacheType(void)"
  },
  {
    "label": "GetCacheIndex()",
    "kind": "Method",
    "detail": "Function (CacheIndex = InCacheIndex ; } int32)",
    "insertText": "GetCacheIndex(void)"
  },
  {
    "label": "GetIsMounted()",
    "kind": "Method",
    "detail": "Function (bIsMounted = bInIsMounted ; } bool)",
    "insertText": "GetIsMounted()"
  },
  {
    "label": "FPakFile()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "FPakFile(IPlatformFile* LowerLevel, const TCHAR* Filename, bool bIsSigned, bool bLoadIndex = true)"
  },
  {
    "label": "FPakFile()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR)",
    "insertText": "FPakFile(FArchive* Archive)"
  },
  {
    "label": "FPakFile()",
    "kind": "Method",
    "detail": "Function (# endif private : ~)",
    "insertText": "FPakFile()"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (class FRefCountBase ; public : bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "GetFilename()",
    "kind": "Method",
    "detail": "Function (const FString&)",
    "insertText": "GetFilename()"
  },
  {
    "label": "GetPrunedFilenamesInChunk()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPrunedFilenamesInChunk(const TArray<int32>& InChunkIDs, TArray<FString>& OutFileList)"
  },
  {
    "label": "GetSharedReader()",
    "kind": "Method",
    "detail": "Function (FSharedPakReader)",
    "insertText": "GetSharedReader(IPlatformFile* LowerLevel)"
  },
  {
    "label": "ReturnSharedReader()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReturnSharedReader(FArchive* SharedReader)"
  },
  {
    "label": "ReleaseOldReaders()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseOldReaders(double MaxAgeSeconds)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (enum class EFindResult : uint8 { NotFound,Found,FoundDeleted,} ; EFindResult)",
    "insertText": "Find(const FString& FullPath, FPakEntry* OutEntry)"
  },
  {
    "label": "SetMountPoint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMountPoint(const TCHAR* Path)"
  },
  {
    "label": "MakeDirectoryFromPath()",
    "kind": "Method",
    "detail": "Function (MountPoint = Path ;)",
    "insertText": "MakeDirectoryFromPath(MountPoint)"
  },
  {
    "label": "GetMountPoint()",
    "kind": "Method",
    "detail": "Function (} const FString&)",
    "insertText": "GetMountPoint()"
  },
  {
    "label": "FindPrunedFilesAtPath()",
    "kind": "Method",
    "detail": "Function (TArray<FString> LocalFiles ;)",
    "insertText": "FindPrunedFilesAtPath(InPath, LocalFiles, bIncludeFiles, bIncludeDirectories, bRecursive)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutFiles .)",
    "insertText": "Add(File)"
  },
  {
    "label": "FindPrunedFilesAtPath()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "FindPrunedFilesAtPath(const TCHAR* InPath, TArray<FString>& OutFiles, bool bIncludeFiles = true, bool bIncludeDirectories = false, bool bRecursive = false)"
  },
  {
    "label": "FindPrunedDirectory()",
    "kind": "Method",
    "detail": "Function (const FPakDirectory*)",
    "insertText": "FindPrunedDirectory(const TCHAR* InPath)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FString RelativePathFromMount ;)",
    "insertText": "if(!NormalizeDirectoryQuery(InPath, RelativePathFromMount))"
  },
  {
    "label": "DirectoryExistsInPruned()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "DirectoryExistsInPruned(const TCHAR* InPath)"
  },
  {
    "label": "Check()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Check()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (class FBaseIterator { private : const FPakFile& PakFile ; FDirectoryIndex::TConstIterator DirectoryIndexIt ; FPakDirectory::TConstIterator DirectoryIt ; FPathHashIndex::TConstIterator PathHashIt ; FString CachedFilename ; FPakEntry PakEntry ; bool bUsePathHash ; bool bIncludeDeleted ; # if ENABLE_PAKFILE_RUNTIME_PRUNING bool bRequiresDirectoryIndexLock ; # endif public : FBaseIterator&)",
    "insertText": "operator()"
  },
  {
    "label": "AdvanceToValid()",
    "kind": "Method",
    "detail": "Function (+ + PathHashIt ; } else { + + DirectoryIt ; })",
    "insertText": "AdvanceToValid()"
  },
  {
    "label": "Info()",
    "kind": "Method",
    "detail": "Function (} const FPakEntry&)",
    "insertText": "Info()"
  },
  {
    "label": "GetPakEntry()",
    "kind": "Method",
    "detail": "Function (PakFile .)",
    "insertText": "GetPakEntry(GetPakEntryIndex(), &PakEntry)"
  },
  {
    "label": "RequiresDirectoryIndexLock()",
    "kind": "Method",
    "detail": "Function (} else { # if ENABLE_PAKFILE_RUNTIME_PRUNING bRequiresDirectoryIndexLock = PakFile .)",
    "insertText": "RequiresDirectoryIndexLock()"
  },
  {
    "label": "TConstIterator()",
    "kind": "Method",
    "detail": "Function (} # endif DirectoryIndexIt . ~)",
    "insertText": "TConstIterator()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&DirectoryIndexIt) FDirectoryIndex::TConstIterator(InPakFile.DirectoryIndex)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&DirectoryIt) FPakDirectory::TConstIterator(DirectoryIndexIt.Value())"
  },
  {
    "label": "FBaseIterator()",
    "kind": "Method",
    "detail": "Function (} # if ENABLE_PAKFILE_RUNTIME_PRUNING ~)",
    "insertText": "FBaseIterator()"
  },
  {
    "label": "Filename()",
    "kind": "Method",
    "detail": "Function (} } # endif const FString&)",
    "insertText": "Filename()"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "checkf(DirectoryIndexIt && DirectoryIt, TEXT(\"It is not legal to call Filename() on an invalid iterator\"))"
  },
  {
    "label": "PakPathCombine()",
    "kind": "Method",
    "detail": "Function (CachedFilename =)",
    "insertText": "PakPathCombine(DirectoryIndexIt.Key(), DirectoryIt.Key())"
  },
  {
    "label": "GetPakEntryIndex()",
    "kind": "Method",
    "detail": "Function (} } return CachedFilename ; } const FPakEntryLocation)",
    "insertText": "GetPakEntryIndex()"
  },
  {
    "label": "Value()",
    "kind": "Method",
    "detail": "Function (} else { return DirectoryIt .)",
    "insertText": "Value()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (+ + PathHashIt ; } } else {)",
    "insertText": "while(DirectoryIndexIt && (!DirectoryIt || (!bIncludeDeleted && Info().IsDeleteRecord())))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + DirectoryIt ; } else { + + DirectoryIndexIt ;)",
    "insertText": "if(DirectoryIndexIt)"
  },
  {
    "label": "FPakEntryIterator()",
    "kind": "Method",
    "detail": "Function (} } } ; class FPakEntryIterator : public FBaseIterator { public :)",
    "insertText": "FPakEntryIterator(const FPakFile& InPakFile, bool bInIncludeDeleted = false) : FBaseIterator(InPakFile, bInIncludeDeleted, !InPakFile.bHasFullDirectoryIndex)"
  },
  {
    "label": "TryGetFilename()",
    "kind": "Method",
    "detail": "Function (} const FString*)",
    "insertText": "TryGetFilename()"
  },
  {
    "label": "FFilenameIterator()",
    "kind": "Method",
    "detail": "Function (} else { return nullptr ; } } } ; class FFilenameIterator : public FBaseIterator { public :)",
    "insertText": "FFilenameIterator(const FPakFile& InPakFile, bool bInIncludeDeleted = false) : FBaseIterator(InPakFile, bInIncludeDeleted, false)"
  },
  {
    "label": "GetInfo()",
    "kind": "Method",
    "detail": "Function (} using FBaseIterator::Filename ; } ; const FPakInfo&)",
    "insertText": "GetInfo()"
  },
  {
    "label": "Memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memset(OutBuffer, 0, sizeof(FPakEntry::Hash))"
  },
  {
    "label": "CreatePakReader()",
    "kind": "Method",
    "detail": "Function (} else { TUniquePtr<FArchive> Reader {)",
    "insertText": "CreatePakReader(nullptr, *GetFilename())"
  },
  {
    "label": "Seek()",
    "kind": "Method",
    "detail": "Function (Reader ->)",
    "insertText": "Seek(PakEntry.Offset)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (FPakEntry SerializedEntry ; SerializedEntry .)",
    "insertText": "Serialize(*Reader, GetInfo().Version)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(OutBuffer, &SerializedEntry.Hash, sizeof(SerializedEntry.Hash))"
  },
  {
    "label": "HashPath()",
    "kind": "Method",
    "detail": "Function (} } uint64)",
    "insertText": "HashPath(const TCHAR* RelativePathFromMount, uint64 Seed, int32 PakFileVersion)"
  },
  {
    "label": "FPakEntryPair()",
    "kind": "Method",
    "detail": "Function (typedef TFunction<)",
    "insertText": "FPakEntryPair()"
  },
  {
    "label": "EncodePakEntriesIntoIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EncodePakEntriesIntoIndex(int32 InNumEntries, const ReadNextEntryFunction& InReadNextEntry, const TCHAR* InPakFilename, const FPakInfo& InPakInfo, const FString& MountPoint, int32& OutNumEncodedEntries, int32& OutNumDeletedEntries, uint64* OutPathHashSeed, FDirectoryIndex* OutDirectoryIndex, FPathHashIndex* OutPathHashIndex, TArray<uint8>& OutEncodedPakEntries, TArray<FPakEntry>& OutNonEncodableEntries, TMap<uint64, FString>* InOutCollisionDetection, int32 PakFileVersion)"
  },
  {
    "label": "FindLocationFromIndex()",
    "kind": "Method",
    "detail": "Function (const FPakEntryLocation*)",
    "insertText": "FindLocationFromIndex(const FString& FullPath, const FString& MountPoint, const FPathHashIndex& PathHashIndex, uint64 PathHashSeed, int32 PakFileVersion)"
  },
  {
    "label": "FindLocationFromIndex()",
    "kind": "Method",
    "detail": "Function (const FPakEntryLocation*)",
    "insertText": "FindLocationFromIndex(const FString& FullPath, const FString& MountPoint, const FDirectoryIndex& DirectoryIndex)"
  },
  {
    "label": "GetPakEntry()",
    "kind": "Method",
    "detail": "Function (EFindResult)",
    "insertText": "GetPakEntry(const FPakEntryLocation& FPakEntryLocation, FPakEntry* OutEntry, const TArray<uint8>& EncodedPakEntries, const TArray<FPakEntry>& Files, const FPakInfo& Info)"
  },
  {
    "label": "PruneDirectoryIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PruneDirectoryIndex(FDirectoryIndex& InOutDirectoryIndex, FDirectoryIndex* PrunedDirectoryIndex, const FString& MountPoint)"
  },
  {
    "label": "MakeDirectoryFromPath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MakeDirectoryFromPath(FString& Path)"
  },
  {
    "label": "TEXT()",
    "kind": "Method",
    "detail": "Function (Path + =)",
    "insertText": "TEXT(\"/\")"
  },
  {
    "label": "IsPathInDirectoryFormat()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "IsPathInDirectoryFormat(const FString& Path)"
  },
  {
    "label": "PakPathCombine()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "PakPathCombine(const FString& Parent, const FString& Child)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (OutFilename .)",
    "insertText": "Empty()"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(OutFilename, InOutPath)"
  },
  {
    "label": "LeftChopInline()",
    "kind": "Method",
    "detail": "Function (InOutPath .)",
    "insertText": "LeftChopInline(1, EAllowShrinking::No)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} int32 Offset = 0 ;)",
    "insertText": "if(InOutPath.FindLastChar(TEXT('/'), Offset))"
  },
  {
    "label": "Mid()",
    "kind": "Method",
    "detail": "Function (int32 FilenameStart = Offset + 1 ; OutFilename = InOutPath .)",
    "insertText": "Mid(FilenameStart)"
  },
  {
    "label": "LeftInline()",
    "kind": "Method",
    "detail": "Function (InOutPath .)",
    "insertText": "LeftInline(FilenameStart, EAllowShrinking::No)"
  },
  {
    "label": "GetRelativePathFromMountInline()",
    "kind": "Method",
    "detail": "Function (} return true ; } } bool)",
    "insertText": "GetRelativePathFromMountInline(FString& Child, const FString& MountPoint)"
  },
  {
    "label": "GetRelativeFilePathFromMountPointer()",
    "kind": "Method",
    "detail": "Function (} return true ; } const TCHAR*)",
    "insertText": "GetRelativeFilePathFromMountPointer(const FString& Child, const FString& MountPoint)"
  },
  {
    "label": "IsPakWritePathHashIndex()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsPakWritePathHashIndex()"
  },
  {
    "label": "IsPakWriteFullDirectoryIndex()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsPakWriteFullDirectoryIndex()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "Initialize(FArchive& Reader, bool bLoadIndex = true)"
  },
  {
    "label": "LoadIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LoadIndex(FArchive& Reader)"
  },
  {
    "label": "GetPakEntry()",
    "kind": "Method",
    "detail": "Function (EFindResult)",
    "insertText": "GetPakEntry(const FPakEntryLocation& FPakEntryLocation, FPakEntry* OutEntry)"
  },
  {
    "label": "GetIndexSettings()",
    "kind": "Method",
    "detail": "Function (struct FIndexSettings ; FIndexSettings&)",
    "insertText": "GetIndexSettings()"
  },
  {
    "label": "IsPakValidatePruning()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsPakValidatePruning()"
  },
  {
    "label": "IsPakDelayPruning()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsPakDelayPruning()"
  },
  {
    "label": "ShouldValidatePrunedDirectory()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldValidatePrunedDirectory()"
  },
  {
    "label": "AddEntryToIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddEntryToIndex(const FString& Filename, const FPakEntryLocation& EntryLocation, const FString& MountPoint, uint64 PathHashSeed, FDirectoryIndex* DirectoryIndex, FPathHashIndex* PathHashIndex, TMap<uint64, FString>* CollisionDetection, int32 PakFileVersion)"
  },
  {
    "label": "EncodePakEntry()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "EncodePakEntry(FArchive& Ar, const FPakEntry& InPakEntry, const FPakInfo& InInfo)"
  },
  {
    "label": "DecodePakEntry()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DecodePakEntry(const uint8* SourcePtr, FPakEntry& OutEntry, const FPakInfo& InInfo)"
  },
  {
    "label": "LoadIndexInternal()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "LoadIndexInternal(FArchive& Reader)"
  },
  {
    "label": "LoadLegacyIndex()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "LoadLegacyIndex(FArchive& Reader)"
  },
  {
    "label": "DecryptAndValidateIndex()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "DecryptAndValidateIndex(FArchive& Reader, TArray<uint8>& IndexData, FSHAHash& InExpectedHash, FSHAHash& OutActualHash)"
  },
  {
    "label": "AddSpecialFile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddSpecialFile(const FPakEntry& Entry, const FString& Filename)"
  },
  {
    "label": "FindPrunedFilesAtPathInternal()",
    "kind": "Method",
    "detail": "Function (template<ShouldVisitFunc,class ContainerType> void)",
    "insertText": "FindPrunedFilesAtPathInternal(const TCHAR* InPath, const ShouldVisitFunc& ShouldVisit, ContainerType& OutFiles, bool bIncludeFiles = true, bool bIncludeDirectories = false, bool bRecursive = false)"
  },
  {
    "label": "FindFilesAtPathInIndex()",
    "kind": "Method",
    "detail": "Function (template<ShouldVisitFunc,class ContainerType> void)",
    "insertText": "FindFilesAtPathInIndex(const FDirectoryIndex& TargetIndex, ContainerType& OutFiles, const FString& Directory, const ShouldVisitFunc& ShouldVisit, bool bIncludeFiles = true, bool bIncludeDirectories = false, bool bRecursive = false)"
  },
  {
    "label": "NormalizeDirectoryQuery()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "NormalizeDirectoryQuery(const TCHAR* InPath, FString& OutRelativePathFromMount)"
  },
  {
    "label": "FindPrunedDirectoryInternal()",
    "kind": "Method",
    "detail": "Function (const FPakDirectory*)",
    "insertText": "FindPrunedDirectoryInternal(const FString& RelativePathFromMount)"
  },
  {
    "label": "ValidateDirectorySearch()",
    "kind": "Method",
    "detail": "Function (# if ENABLE_PAKFILE_RUNTIME_PRUNING_VALIDATE void)",
    "insertText": "ValidateDirectorySearch(const TSet<FString>& FoundFullFiles, const TSet<FString>& PrunedFoundFiles, const TCHAR* InPath)"
  },
  {
    "label": "AlignReadRequest()",
    "kind": "Method",
    "detail": "Function (# endif } ; class FPakNoEncryption { public : enum { Alignment = 1,} ; int64)",
    "insertText": "AlignReadRequest(int64 Size)"
  },
  {
    "label": "FPakReaderPolicy()",
    "kind": "Method",
    "detail": "Function (template<EncryptionPolicy = FPakNoEncryption> class FPakReaderPolicy { public : const FPakFile& PakFile ; FPakEntry PakEntry ; TAcquirePakReaderFunction AcquirePakReader ; int64 OffsetToFile ;)",
    "insertText": "FPakReaderPolicy(const FPakFile& InPakFile,const FPakEntry& InPakEntry, TAcquirePakReaderFunction& InAcquirePakReader) : PakFile(InPakFile) , PakEntry(InPakEntry) , AcquirePakReader(InAcquirePakReader)"
  },
  {
    "label": "GetSerializedSize()",
    "kind": "Method",
    "detail": "Function (OffsetToFile = PakEntry . Offset + PakEntry .)",
    "insertText": "GetSerializedSize(PakFile.GetInfo().Version)"
  },
  {
    "label": "FileSize()",
    "kind": "Method",
    "detail": "Function (} int64)",
    "insertText": "FileSize()"
  },
  {
    "label": "Alignment()",
    "kind": "Method",
    "detail": "Function (const int64)",
    "insertText": "Alignment(int64)"
  },
  {
    "label": "AlignmentMask()",
    "kind": "Method",
    "detail": "Function (const int64)",
    "insertText": "AlignmentMask(Alignment - 1)"
  },
  {
    "label": "AcquirePakReader()",
    "kind": "Method",
    "detail": "Function (uint8 TempBuffer [ Alignment ] ; FSharedPakReader PakReader =)",
    "insertText": "AcquirePakReader()"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (int64 Start = DesiredPosition& AlignmentMask ; int64 Offset = DesiredPosition - Start ; int64 CopySize =)",
    "insertText": "Min(Alignment - Offset, Length)"
  },
  {
    "label": "Seek()",
    "kind": "Method",
    "detail": "Function (PakReader ->)",
    "insertText": "Seek(OffsetToFile + Start)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (PakReader ->)",
    "insertText": "Serialize(TempBuffer, Alignment)"
  },
  {
    "label": "DecryptBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DecryptBlock(TempBuffer, Alignment, EncryptionKeyGuid)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(V, TempBuffer + Offset, CopySize)"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "V(void*)((uint8*)V + CopySize)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (DesiredPosition + = CopySize ; Length - = CopySize ;)",
    "insertText": "check(Length == 0 || DesiredPosition % Alignment == 0)"
  },
  {
    "label": "Seek()",
    "kind": "Method",
    "detail": "Function (} else { PakReader ->)",
    "insertText": "Seek(OffsetToFile + DesiredPosition)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} int64 CopySize = Length& AlignmentMask ; PakReader ->)",
    "insertText": "Serialize(V, CopySize)"
  },
  {
    "label": "DecryptBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DecryptBlock(V, CopySize, EncryptionKeyGuid)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(V, TempBuffer, Length)"
  },
  {
    "label": "FPakFileHandle()",
    "kind": "Method",
    "detail": "Function (} } } ; template<ReaderPolicy = FPakReaderPolicy<>> class FPakFileHandle : public IFileHandle { int64 ReadPos ; ReaderPolicy Reader ; TRefCountPtr<const FPakFile> PakFile ; public :)",
    "insertText": "FPakFileHandle(const TRefCountPtr<const FPakFile>& InPakFile, const FPakEntry& InPakEntry, TAcquirePakReaderFunction& InAcquirePakReaderFunction) : ReadPos(0) , Reader(*InPakFile, InPakEntry, InAcquirePakReaderFunction) , PakFile(InPakFile)"
  },
  {
    "label": "INC_DWORD_STAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "INC_DWORD_STAT(STAT_PakFile_NumOpenHandles)"
  },
  {
    "label": "FPakFileHandle()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FPakFileHandle(const TRefCountPtr<const FPakFile>& InPakFile, const FPakEntry& InPakEntry, FArchive* InPakReader) : ReadPos(0) , Reader(*InPakFile, InPakEntry, InPakReader) , PakFile(InPakFile)"
  },
  {
    "label": "FPakFileHandle()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FPakFileHandle()"
  },
  {
    "label": "DEC_DWORD_STAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DEC_DWORD_STAT(STAT_PakFile_NumOpenHandles)"
  },
  {
    "label": "Tell()",
    "kind": "Method",
    "detail": "Function (} int64)",
    "insertText": "Tell()"
  },
  {
    "label": "Read()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Read(uint8* Destination, int64 BytesToRead)"
  },
  {
    "label": "ReadAt()",
    "kind": "Method",
    "detail": "Function (ReadPos + = BytesToRead ; return true ; } else { return false ; } } bool)",
    "insertText": "ReadAt(uint8* Destination, int64 BytesToRead, int64 Offset)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Write(const uint8* Source, int64 BytesToWrite)"
  },
  {
    "label": "Flush()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Flush(const bool bFullFlush = false)"
  },
  {
    "label": "SCOPE_SECONDS_ACCUMULATOR()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SCOPE_SECONDS_ACCUMULATOR(STAT_PakFile_Read)"
  },
  {
    "label": "Seek()",
    "kind": "Method",
    "detail": "Function (PakReader ->)",
    "insertText": "Seek(Reader.PakEntry.Offset)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (FileHeader .)",
    "insertText": "Serialize(PakReader.GetArchive(), Reader.PakFile.GetInfo().Version)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Reader . PakEntry . Verified = true ; } else { return false ; } })",
    "insertText": "if(Reader.FileSize() >= (Offset + BytesToRead))"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Reader .)",
    "insertText": "Serialize(Offset, Destination, BytesToRead)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} uint32 ReadOrder ; TRefCountPtr<FPakFile> PakFile ; bool)",
    "insertText": "operator(const FPakListEntry& RHS)"
  },
  {
    "label": "ScopedLock()",
    "kind": "Method",
    "detail": "Function (FScopeLock)",
    "insertText": "ScopedLock(&PakListCritical)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (Paks .)",
    "insertText": "Append(PakFiles)"
  },
  {
    "label": "DirectoryExistsInPrunedPakFiles()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "DirectoryExistsInPrunedPakFiles(const TCHAR* Directory)"
  },
  {
    "label": "BufferedCopyFile()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "BufferedCopyFile(IFileHandle& Dest, IFileHandle& Source, const int64 FileSize, uint8* Buffer, const int64 BufferSize)"
  },
  {
    "label": "CreatePakFileHandle()",
    "kind": "Method",
    "detail": "Function (IFileHandle*)",
    "insertText": "CreatePakFileHandle(const TCHAR* Filename, const TRefCountPtr<FPakFile>& PakFile, const FPakEntry* FileEntry)"
  },
  {
    "label": "GetPakOrderFromPakFilePath()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetPakOrderFromPakFilePath(const FString& PakFilePath)"
  },
  {
    "label": "HandleMountPakDelegate()",
    "kind": "Method",
    "detail": "Function (IPakFile*)",
    "insertText": "HandleMountPakDelegate(const FString& PakFilePath, int32 PakOrder)"
  },
  {
    "label": "HandleUnmountPakDelegate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HandleUnmountPakDelegate(const FString& PakFilePath)"
  },
  {
    "label": "FindPakFilesInDirectory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindPakFilesInDirectory(IPlatformFile* LowLevelFile, const TCHAR* Directory, const FString& WildCard, TArray<FString>& OutPakFiles)"
  },
  {
    "label": "FindAllPakFiles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindAllPakFiles(IPlatformFile* LowLevelFile, const TArray<FString>& PakFolders, const FString& WildCard, TArray<FString>& OutPakFiles)"
  },
  {
    "label": "IsNonPakFilenameAllowed()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsNonPakFilenameAllowed(const FString& InFilename)"
  },
  {
    "label": "RegisterEncryptionKey()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterEncryptionKey(const FGuid& InEncryptionKeyGuid, const FAES::FAESKey& InKey)"
  },
  {
    "label": "IsPakFileInstalled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsPakFileInstalled(const FString& InFilename)"
  },
  {
    "label": "GetTypeName()",
    "kind": "Method",
    "detail": "Function (public : using IPlatformFile::IterateDirectory ; using IPlatformFile::IterateDirectoryRecursively ; using IPlatformFile::IterateDirectoryStat ; using IPlatformFile::IterateDirectoryStatRecursively ; const TCHAR*)",
    "insertText": "GetTypeName()"
  },
  {
    "label": "GetMountStartupPaksWildCard()",
    "kind": "Method",
    "detail": "Function (} const TCHAR*)",
    "insertText": "GetMountStartupPaksWildCard()"
  },
  {
    "label": "SetMountStartupPaksWildCard()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMountStartupPaksWildCard(const FString& WildCard)"
  },
  {
    "label": "GetPakChunkLocation()",
    "kind": "Method",
    "detail": "Function (EChunkLocation::Type)",
    "insertText": "GetPakChunkLocation(int32 InPakchunkIndex)"
  },
  {
    "label": "AnyChunksAvailable()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AnyChunksAvailable()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (PakFilenames .)",
    "insertText": "Empty(PakFiles.Num())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (PakFilenames .)",
    "insertText": "Add(Entry.PakFile->GetFilename())"
  },
  {
    "label": "GetMountedPakFilenames()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "GetMountedPakFilenames(TSet<FString>& PakFilenames)"
  },
  {
    "label": "CheckIfPakFilesExist()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "CheckIfPakFilesExist(IPlatformFile* LowLevelFile, const TArray<FString>& PakFolders)"
  },
  {
    "label": "GetPakFolders()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPakFolders(const TCHAR* CmdLine, TArray<FString>& OutPakFolders)"
  },
  {
    "label": "GetPakEncryptionKey()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPakEncryptionKey(FAES::FAESKey& OutKey, const FGuid& InEncryptionKeyGuid)"
  },
  {
    "label": "GetPakSignatureFile()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<const struct FPakSignatureFile,ESPMode::ThreadSafe>)",
    "insertText": "GetPakSignatureFile(const TCHAR* InFilename)"
  },
  {
    "label": "RemoveCachedPakSignaturesFile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveCachedPakSignaturesFile(const TCHAR* InFilename)"
  },
  {
    "label": "FPakPlatformFile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPakPlatformFile()"
  },
  {
    "label": "ShouldBeUsed()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldBeUsed(IPlatformFile* Inner, const TCHAR* CmdLine)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Initialize(IPlatformFile* Inner, const TCHAR* CommandLineParam)"
  },
  {
    "label": "InitializeNewAsyncIO()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeNewAsyncIO()"
  },
  {
    "label": "OptimizeMemoryUsageForMountedPaks()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OptimizeMemoryUsageForMountedPaks()"
  },
  {
    "label": "GetLowerLevel()",
    "kind": "Method",
    "detail": "Function (IPlatformFile*)",
    "insertText": "GetLowerLevel()"
  },
  {
    "label": "GetName()",
    "kind": "Method",
    "detail": "Function (LowerLevel = NewLowerLevel ; } const TCHAR*)",
    "insertText": "GetName()"
  },
  {
    "label": "Tick()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Tick()"
  },
  {
    "label": "Mount()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Mount(const TCHAR* InPakFilename, uint32 PakOrder, const TCHAR* InPath = nullptr, bool bLoadIndex = true, FPakListEntry* OutPakListEntry = nullptr)"
  },
  {
    "label": "Unmount()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Unmount(const TCHAR* InPakFilename)"
  },
  {
    "label": "MountAllPakFiles()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "MountAllPakFiles(const TArray<FString>& PakFolders)"
  },
  {
    "label": "MountAllPakFiles()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "MountAllPakFiles(const TArray<FString>& PakFolders, const FString& WildCard)"
  },
  {
    "label": "ReloadPakReaders()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ReloadPakReaders()"
  },
  {
    "label": "MakeUniquePakFilesForTheseFiles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MakeUniquePakFilesForTheseFiles(const TArray<TArray<FString>>& InFiles)"
  },
  {
    "label": "FindFileInPakFiles()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "FindFileInPakFiles(TArray<FPakListEntry>& Paks, const TCHAR* Filename, TRefCountPtr<FPakFile>* OutPakFile, FPakEntry* OutEntry = nullptr)"
  },
  {
    "label": "FindFileInPakFiles()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "FindFileInPakFiles(const TCHAR* Filename, TRefCountPtr<FPakFile>* OutPakFile = nullptr, FPakEntry* OutEntry = nullptr)"
  },
  {
    "label": "FileExists()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "FileExists(const TCHAR* Filename)"
  },
  {
    "label": "FileExists()",
    "kind": "Method",
    "detail": "Function (Result = LowerLevel ->)",
    "insertText": "FileExists(Filename)"
  },
  {
    "label": "FileSize()",
    "kind": "Method",
    "detail": "Function (} return Result ; } int64)",
    "insertText": "FileSize(const TCHAR* Filename)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FPakEntry FileEntry ;)",
    "insertText": "if(FindFileInPakFiles(Filename, nullptr, &FileEntry))"
  },
  {
    "label": "FileSize()",
    "kind": "Method",
    "detail": "Function (Result = LowerLevel ->)",
    "insertText": "FileSize(Filename)"
  },
  {
    "label": "DeleteFile()",
    "kind": "Method",
    "detail": "Function (} return Result ; } bool)",
    "insertText": "DeleteFile(const TCHAR* Filename)"
  },
  {
    "label": "DeleteFile()",
    "kind": "Method",
    "detail": "Function (Result = LowerLevel ->)",
    "insertText": "DeleteFile(Filename)"
  },
  {
    "label": "IsReadOnly()",
    "kind": "Method",
    "detail": "Function (} return Result ; } bool)",
    "insertText": "IsReadOnly(const TCHAR* Filename)"
  },
  {
    "label": "IsReadOnly()",
    "kind": "Method",
    "detail": "Function (Result = LowerLevel ->)",
    "insertText": "IsReadOnly(Filename)"
  },
  {
    "label": "MoveFile()",
    "kind": "Method",
    "detail": "Function (} return Result ; } bool)",
    "insertText": "MoveFile(const TCHAR* To, const TCHAR* From)"
  },
  {
    "label": "MoveFile()",
    "kind": "Method",
    "detail": "Function (Result = LowerLevel ->)",
    "insertText": "MoveFile(To, From)"
  },
  {
    "label": "SetReadOnly()",
    "kind": "Method",
    "detail": "Function (} return Result ; } bool)",
    "insertText": "SetReadOnly(const TCHAR* Filename, bool bNewReadOnlyValue)"
  },
  {
    "label": "SetReadOnly()",
    "kind": "Method",
    "detail": "Function (Result = LowerLevel ->)",
    "insertText": "SetReadOnly(Filename, bNewReadOnlyValue)"
  },
  {
    "label": "GetTimeStamp()",
    "kind": "Method",
    "detail": "Function (} return Result ; } FDateTime)",
    "insertText": "GetTimeStamp(const TCHAR* Filename)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TRefCountPtr<FPakFile> PakFile = NULL ;)",
    "insertText": "if(FindFileInPakFiles(Filename, &PakFile))"
  },
  {
    "label": "MinValue()",
    "kind": "Method",
    "detail": "Function (} FDateTime Result =)",
    "insertText": "MinValue()"
  },
  {
    "label": "GetTimeStamp()",
    "kind": "Method",
    "detail": "Function (Result = LowerLevel ->)",
    "insertText": "GetTimeStamp(Filename)"
  },
  {
    "label": "GetTimeStampPair()",
    "kind": "Method",
    "detail": "Function (} return Result ; } void)",
    "insertText": "GetTimeStampPair(const TCHAR* FilenameA, const TCHAR* FilenameB, FDateTime& OutTimeStampA, FDateTime& OutTimeStampB)"
  },
  {
    "label": "FindFileInPakFiles()",
    "kind": "Method",
    "detail": "Function (TRefCountPtr<FPakFile> PakFileA ; TRefCountPtr<FPakFile> PakFileB ;)",
    "insertText": "FindFileInPakFiles(FilenameA, &PakFileA)"
  },
  {
    "label": "FindFileInPakFiles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindFileInPakFiles(FilenameB, &PakFileB)"
  },
  {
    "label": "GetTimestamp()",
    "kind": "Method",
    "detail": "Function (OutTimeStampA = PakFileA ! = nullptr ? PakFileA ->)",
    "insertText": "GetTimestamp() : FDateTime::MinValue()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(IsNonPakFilenameAllowed(FilenameA) && IsNonPakFilenameAllowed(FilenameB))"
  },
  {
    "label": "GetTimeStampPair()",
    "kind": "Method",
    "detail": "Function (LowerLevel ->)",
    "insertText": "GetTimeStampPair(FilenameA, FilenameB, OutTimeStampA, OutTimeStampB)"
  },
  {
    "label": "SetTimeStamp()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "SetTimeStamp(const TCHAR* Filename, FDateTime DateTime)"
  },
  {
    "label": "SetTimeStamp()",
    "kind": "Method",
    "detail": "Function (LowerLevel ->)",
    "insertText": "SetTimeStamp(Filename, DateTime)"
  },
  {
    "label": "GetAccessTimeStamp()",
    "kind": "Method",
    "detail": "Function (} } } FDateTime)",
    "insertText": "GetAccessTimeStamp(const TCHAR* Filename)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} FDateTime Result = false ;)",
    "insertText": "if(IsNonPakFilenameAllowed(Filename))"
  },
  {
    "label": "GetAccessTimeStamp()",
    "kind": "Method",
    "detail": "Function (Result = LowerLevel ->)",
    "insertText": "GetAccessTimeStamp(Filename)"
  },
  {
    "label": "GetFilenameOnDisk()",
    "kind": "Method",
    "detail": "Function (} return Result ; } FString)",
    "insertText": "GetFilenameOnDisk(const TCHAR* Filename)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FPakEntry FileEntry ; TRefCountPtr<FPakFile> PakFile ;)",
    "insertText": "if(FindFileInPakFiles(Filename, &PakFile, &FileEntry))"
  },
  {
    "label": "Path()",
    "kind": "Method",
    "detail": "Function (const FString)",
    "insertText": "Path(FPaths::GetPath(Filename))"
  },
  {
    "label": "ScopeAccess()",
    "kind": "Method",
    "detail": "Function (FPakFile::FScopedPakDirectoryIndexAccess)",
    "insertText": "ScopeAccess(*PakFile)"
  },
  {
    "label": "FindPrunedDirectory()",
    "kind": "Method",
    "detail": "Function (const FPakDirectory* PakDirectory = PakFile ->)",
    "insertText": "FindPrunedDirectory(*Path)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FPakEntry PakEntry ;)",
    "insertText": "if(PakFile->GetPakEntry(DirectoryIt.Value(), &PakEntry) != FPakFile::EFindResult::NotFound && PakEntry.Offset == FileEntry.Offset)"
  },
  {
    "label": "Key()",
    "kind": "Method",
    "detail": "Function (const FString& RealFilename = DirectoryIt .)",
    "insertText": "Key()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (TSet<FString> FullFoundFiles ; TSet<FString> PrunedFoundFiles ; FullFoundFiles .)",
    "insertText": "Add(Filename)"
  },
  {
    "label": "ValidateDirectorySearch()",
    "kind": "Method",
    "detail": "Function (PakFile ->)",
    "insertText": "ValidateDirectorySearch(FullFoundFiles, PrunedFoundFiles, Filename)"
  },
  {
    "label": "IsSymlink()",
    "kind": "Method",
    "detail": "Function (} else { return Filename ; } } ESymlinkResult)",
    "insertText": "IsSymlink(const TCHAR* Filename)"
  },
  {
    "label": "OpenRead()",
    "kind": "Method",
    "detail": "Function (} IFileHandle*)",
    "insertText": "OpenRead(const TCHAR* Filename, bool bAllowWrite = false)"
  },
  {
    "label": "OpenWrite()",
    "kind": "Method",
    "detail": "Function (IFileHandle*)",
    "insertText": "OpenWrite(const TCHAR* Filename, bool bAppend = false, bool bAllowRead = false)"
  },
  {
    "label": "DirectoryExists()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "DirectoryExists(const TCHAR* Directory)"
  },
  {
    "label": "CreateDirectory()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CreateDirectory(const TCHAR* Directory)"
  },
  {
    "label": "DeleteDirectory()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "DeleteDirectory(const TCHAR* Directory)"
  },
  {
    "label": "GetStatData()",
    "kind": "Method",
    "detail": "Function (FFileStatData)",
    "insertText": "GetStatData(const TCHAR* FilenameOrDirectory)"
  },
  {
    "label": "IterateDirectory()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IterateDirectory(const TCHAR* Directory, IPlatformFile::FDirectoryVisitor& Visitor)"
  },
  {
    "label": "IterateDirectoryRecursively()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IterateDirectoryRecursively(const TCHAR* Directory, IPlatformFile::FDirectoryVisitor& Visitor)"
  },
  {
    "label": "IterateDirectoryStat()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IterateDirectoryStat(const TCHAR* Directory, IPlatformFile::FDirectoryStatVisitor& Visitor)"
  },
  {
    "label": "IterateDirectoryStatRecursively()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IterateDirectoryStatRecursively(const TCHAR* Directory, IPlatformFile::FDirectoryStatVisitor& Visitor)"
  },
  {
    "label": "FindFiles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindFiles(TArray<FString>& FoundFiles, const TCHAR* Directory, const TCHAR* FileExtension)"
  },
  {
    "label": "FindFilesRecursively()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindFilesRecursively(TArray<FString>& FoundFiles, const TCHAR* Directory, const TCHAR* FileExtension)"
  },
  {
    "label": "DeleteDirectoryRecursively()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "DeleteDirectoryRecursively(const TCHAR* Directory)"
  },
  {
    "label": "CreateDirectoryTree()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CreateDirectoryTree(const TCHAR* Directory)"
  },
  {
    "label": "CopyFile()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CopyFile(const TCHAR* To, const TCHAR* From, EPlatformFileRead ReadFlags = EPlatformFileRead::None, EPlatformFileWrite WriteFlags = EPlatformFileWrite::None)"
  },
  {
    "label": "OpenAsyncRead()",
    "kind": "Method",
    "detail": "Function (IAsyncReadFileHandle*)",
    "insertText": "OpenAsyncRead(const TCHAR* Filename)"
  },
  {
    "label": "SetAsyncMinimumPriority()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAsyncMinimumPriority(EAsyncIOPriorityAndFlags Priority)"
  },
  {
    "label": "OpenMapped()",
    "kind": "Method",
    "detail": "Function (IMappedFileHandle*)",
    "insertText": "OpenMapped(const TCHAR* Filename)"
  },
  {
    "label": "ConvertToPakRelativePath()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "ConvertToPakRelativePath(const TCHAR* Filename, const FPakFile* Pak)"
  },
  {
    "label": "RelativeFilename()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "RelativeFilename(Filename)"
  },
  {
    "label": "ConvertToAbsolutePathForExternalAppForRead()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "ConvertToAbsolutePathForExternalAppForRead(const TCHAR* Filename)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TRefCountPtr<FPakFile> Pak ;)",
    "insertText": "if(FindFileInPakFiles(Filename, &Pak))"
  },
  {
    "label": "ConvertToAbsolutePathForExternalAppForRead()",
    "kind": "Method",
    "detail": "Function (} else { return LowerLevel ->)",
    "insertText": "ConvertToAbsolutePathForExternalAppForRead(Filename)"
  },
  {
    "label": "ConvertToAbsolutePathForExternalAppForWrite()",
    "kind": "Method",
    "detail": "Function (} } FString)",
    "insertText": "ConvertToAbsolutePathForExternalAppForWrite(const TCHAR* Filename)"
  },
  {
    "label": "ConvertToAbsolutePathForExternalAppForWrite()",
    "kind": "Method",
    "detail": "Function (} else { return LowerLevel ->)",
    "insertText": "ConvertToAbsolutePathForExternalAppForWrite(Filename)"
  },
  {
    "label": "GetFilenameSecurityDelegate()",
    "kind": "Method",
    "detail": "Function (} } FFilenameSecurityDelegate&)",
    "insertText": "GetFilenameSecurityDelegate()"
  },
  {
    "label": "GetPakCustomEncryptionDelegate()",
    "kind": "Method",
    "detail": "Function (FPakCustomEncryptionDelegate&)",
    "insertText": "GetPakCustomEncryptionDelegate()"
  },
  {
    "label": "GetLock()",
    "kind": "Method",
    "detail": "Function (struct FPakSigningFailureHandlerData { PRAGMA_DISABLE_DEPRECATION_WARNINGS FCriticalSection&)",
    "insertText": "GetLock()"
  },
  {
    "label": "GetPakSigningFailureHandlerData()",
    "kind": "Method",
    "detail": "Function (} ; FPakSigningFailureHandlerData&)",
    "insertText": "GetPakSigningFailureHandlerData()"
  },
  {
    "label": "BroadcastPakChunkSignatureCheckFailure()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BroadcastPakChunkSignatureCheckFailure(const FPakChunkSignatureCheckFailedData& InData)"
  },
  {
    "label": "BroadcastPakPrincipalSignatureTableCheckFailure()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BroadcastPakPrincipalSignatureTableCheckFailure(const FString& InFilename)"
  },
  {
    "label": "GetPakSetIndexSettingsDelegate()",
    "kind": "Method",
    "detail": "Function (FPakSetIndexSettings&)",
    "insertText": "GetPakSetIndexSettingsDelegate()"
  },
  {
    "label": "GetPrunedFilenamesInChunk()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPrunedFilenamesInChunk(const FString& InPakFilename, const TArray<int32>& InChunkIDs, TArray<FString>& OutFileList)"
  },
  {
    "label": "GetPrunedFilenamesInPakFile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPrunedFilenamesInPakFile(const FString& InPakFilename, TArray<FString>& OutFileList)"
  },
  {
    "label": "GetFilenamesFromIostoreContainer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetFilenamesFromIostoreContainer(const FString& InContainerName, TArray<FString>& OutFileList)"
  },
  {
    "label": "GetFilenamesFromIostoreByBlockIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetFilenamesFromIostoreByBlockIndex(const FString& InContainerName, const TArray<int32>& InBlockIndex, TArray<FString>& OutFileList)"
  },
  {
    "label": "ForeachPackageInIostoreWhile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ForeachPackageInIostoreWhile(TFunctionRef<bool(FName)> Predicate)"
  },
  {
    "label": "ReleaseOldReaders()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseOldReaders()"
  },
  {
    "label": "HandlePakListCommand()",
    "kind": "Method",
    "detail": "Function (# if ! UE_BUILD_SHIPPING void)",
    "insertText": "HandlePakListCommand(const TCHAR* Cmd, FOutputDevice& Ar)"
  },
  {
    "label": "HandleMountCommand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleMountCommand(const TCHAR* Cmd, FOutputDevice& Ar)"
  },
  {
    "label": "HandleUnmountCommand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleUnmountCommand(const TCHAR* Cmd, FOutputDevice& Ar)"
  },
  {
    "label": "HandlePakCorruptCommand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandlePakCorruptCommand(const TCHAR* Cmd, FOutputDevice& Ar)"
  },
  {
    "label": "HandleReloadPakReadersCommand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleReloadPakReadersCommand(const TCHAR* Cmd, FOutputDevice& Ar)"
  },
  {
    "label": "TrackPak()",
    "kind": "Method",
    "detail": "Function (# endif # if PAK_TRACKER TMap<FString,int32> GPakSizeMap ; void)",
    "insertText": "TrackPak(const TCHAR* Filename, const FPakEntry* PakEntry)"
  },
  {
    "label": "GetPakMap()",
    "kind": "Method",
    "detail": "Function (TMap<FString,int32>&)",
    "insertText": "GetPakMap()"
  },
  {
    "label": "IterateDirectoryInPakFiles()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IterateDirectoryInPakFiles(const TCHAR* Directory, UE::PakFile::Private::FPakFileDirectoryVisitorBase& Visitor, bool bRecursive, TSet<FString>& FilesVisitedInPak)"
  },
  {
    "label": "IterateDirectoryStatInternal()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IterateDirectoryStatInternal(const TCHAR* Directory, IPlatformFile::FDirectoryStatVisitor& Visitor, bool bRecursive)"
  },
  {
    "label": "FindFilesInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindFilesInternal(TArray<FString>& FoundFiles, const TCHAR* Directory, const TCHAR* FileExtension, bool bRecursive)"
  },
  {
    "label": "SetChunkHashesAndSign()",
    "kind": "Method",
    "detail": "Function (} ; struct FPakSignatureFile { const uint32 Magic = 0 x73832DAA ; enum class EVersion { Invalid,First,Last,Latest = Last - 1 } ; EVersion Version = EVersion::Latest ; TArray<uint8> EncryptedHash ; FSHAHash DecryptedHash ; TArray<uint8> SignatureData ; TArray<TPakChunkHash> ChunkHashes ; void)",
    "insertText": "SetChunkHashesAndSign(const TArray<TPakChunkHash>& InChunkHashes, const TArrayView<uint8>& InSignatureData, const FRSAKeyHandle InKey)"
  },
  {
    "label": "ComputeCurrentPrincipalHash()",
    "kind": "Method",
    "detail": "Function (ChunkHashes = InChunkHashes ; SignatureData = InSignatureData ; DecryptedHash =)",
    "insertText": "ComputeCurrentPrincipalHash()"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (TArray<uint8> NewSignatureData ; NewSignatureData .)",
    "insertText": "Append(SignatureData)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (NewSignatureData .)",
    "insertText": "Append(DecryptedHash.Hash, UE_ARRAY_COUNT(FSHAHash::Hash))"
  },
  {
    "label": "EncryptPrivate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EncryptPrivate(NewSignatureData, EncryptedHash, InKey)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uint32 FileMagic = Magic ; Ar<<FileMagic ;)",
    "insertText": "if(Ar.IsLoading() && FileMagic != Magic)"
  },
  {
    "label": "DecryptPublic()",
    "kind": "Method",
    "detail": "Function (} else { int32 BytesDecrypted =)",
    "insertText": "DecryptPublic(EncryptedHash, SignatureData, InKey)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(DecryptedHash.Hash, SignatureData.GetData() + SignatureData.Num() - UE_ARRAY_COUNT(FSHAHash::Hash), UE_ARRAY_COUNT(FSHAHash::Hash))"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (SignatureData .)",
    "insertText": "SetNum(SignatureData.Num() - UE_ARRAY_COUNT(FSHAHash::Hash))"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "UE_LOG(LogPakFile, Warning, TEXT(\"Pak signature table validation failed for '%s'! Failed to decrypt signature\"), *InFilename)"
  },
  {
    "label": "BroadcastPakPrincipalSignatureTableCheckFailure()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "BroadcastPakPrincipalSignatureTableCheckFailure(InFilename)"
  },
  {
    "label": "HashBuffer()",
    "kind": "Method",
    "detail": "Function (FSHAHash CurrentHash ;)",
    "insertText": "HashBuffer(ChunkHashes.GetData(), ChunkHashes.Num() * sizeof(TPakChunkHash), CurrentHash.Hash)"
  }
]