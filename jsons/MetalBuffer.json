[
  {
    "label": "FMetalCommandQueue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMetalCommandQueue"
  },
  {
    "label": "FMetalDevice",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMetalDevice"
  },
  {
    "label": "FMetalBuffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMetalBuffer"
  },
  {
    "label": "FMetalPooledBufferArgs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMetalPooledBufferArgs"
  },
  {
    "label": "IMetalBufferAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IMetalBufferAllocator"
  },
  {
    "label": "FMetalSubBufferHeap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMetalSubBufferHeap"
  },
  {
    "label": "FMetalResourceHeap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMetalResourceHeap"
  },
  {
    "label": "Allocation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Allocation"
  },
  {
    "label": "FMetalSubBufferLinear",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMetalSubBufferLinear"
  },
  {
    "label": "FMetalSubBufferMagazine",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMetalSubBufferMagazine"
  },
  {
    "label": "FMetalRingBufferRef",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMetalRingBufferRef"
  },
  {
    "label": "FMetalCommandBuffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMetalCommandBuffer"
  },
  {
    "label": "FMetalSubBufferRing",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMetalSubBufferRing"
  },
  {
    "label": "FMetalBufferPoolPolicyData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMetalBufferPoolPolicyData"
  },
  {
    "label": "BucketSizes",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "BucketSizes"
  },
  {
    "label": "FMetalBufferPool",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMetalBufferPool"
  },
  {
    "label": "FMetalTexturePool",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMetalTexturePool"
  },
  {
    "label": "Descriptor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Descriptor"
  },
  {
    "label": "MagazineSize",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "MagazineSize"
  },
  {
    "label": "HeapSize",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "HeapSize"
  },
  {
    "label": "TextureHeapSize",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "TextureHeapSize"
  },
  {
    "label": "AllocTypes",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "AllocTypes"
  },
  {
    "label": "EMetalHeapTextureUsage",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EMetalHeapTextureUsage"
  },
  {
    "label": "UsageTypes",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "UsageTypes"
  },
  {
    "label": "MemoryBlock",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MemoryBlock"
  },
  {
    "label": "FMetalPooledBufferArgs()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" MetalRHIPrivate . h \" # include \" MetalResources . h \" # include \" Containers / LockFreeList . h \" # include \" ResourcePool . h \" class FMetalCommandQueue ; class FMetalDevice ; class FMetalBuffer ; typedef TSharedPtr<FMetalBuffer,ESPMode::ThreadSafe> FMetalBufferPtr ; struct FMetalPooledBufferArgs {)",
    "insertText": "FMetalPooledBufferArgs() : Device(nullptr), Size(0), Flags(BUF_None), Storage(MTL::StorageModeShared), CpuCacheMode(MTL::CPUCacheModeDefaultCache)"
  },
  {
    "label": "FMetalPooledBufferArgs()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FMetalPooledBufferArgs(FMetalDevice* InDevice, uint32 InSize, EBufferUsageFlags InFlags, MTL::StorageMode InStorage, MTL::CPUCacheMode InCpuCacheMode = MTL::CPUCacheModeDefaultCache) : Device(InDevice) , Size(InSize) , Flags(InFlags) , Storage(InStorage) , CpuCacheMode(InCpuCacheMode)"
  },
  {
    "label": "ReleaseBuffer()",
    "kind": "Method",
    "detail": "Function (} FMetalDevice* Device ; uint32 Size ; EBufferUsageFlags Flags ; MTL::StorageMode Storage ; MTL::CPUCacheMode CpuCacheMode ; } ; class IMetalBufferAllocator { public : void)",
    "insertText": "ReleaseBuffer(FMetalBuffer* Buffer)"
  },
  {
    "label": "FMetalSubBufferHeap()",
    "kind": "Method",
    "detail": "Function (} ; class FMetalSubBufferHeap : public IMetalBufferAllocator { class FMetalResourceHeap ; public :)",
    "insertText": "FMetalSubBufferHeap(FMetalDevice& MetalDevice, NS::UInteger Size, NS::UInteger Alignment, MTL::ResourceOptions, FCriticalSection& PoolMutex)"
  },
  {
    "label": "FMetalSubBufferHeap()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FMetalSubBufferHeap()"
  },
  {
    "label": "GetLabel()",
    "kind": "Method",
    "detail": "Function (NS::String*)",
    "insertText": "GetLabel()"
  },
  {
    "label": "GetDevice()",
    "kind": "Method",
    "detail": "Function (MTL::Device*)",
    "insertText": "GetDevice()"
  },
  {
    "label": "GetStorageMode()",
    "kind": "Method",
    "detail": "Function (MTL::StorageMode)",
    "insertText": "GetStorageMode()"
  },
  {
    "label": "GetCpuCacheMode()",
    "kind": "Method",
    "detail": "Function (MTL::CPUCacheMode)",
    "insertText": "GetCpuCacheMode()"
  },
  {
    "label": "GetSize()",
    "kind": "Method",
    "detail": "Function (NS::UInteger)",
    "insertText": "GetSize()"
  },
  {
    "label": "GetUsedSize()",
    "kind": "Method",
    "detail": "Function (NS::UInteger)",
    "insertText": "GetUsedSize()"
  },
  {
    "label": "MaxAvailableSize()",
    "kind": "Method",
    "detail": "Function (NS::UInteger)",
    "insertText": "MaxAvailableSize()"
  },
  {
    "label": "NumCurrentAllocations()",
    "kind": "Method",
    "detail": "Function (int64)",
    "insertText": "NumCurrentAllocations()"
  },
  {
    "label": "CanAllocateSize()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CanAllocateSize(NS::UInteger Size)"
  },
  {
    "label": "SetLabel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetLabel(const NS::String* label)"
  },
  {
    "label": "NewBuffer()",
    "kind": "Method",
    "detail": "Function (FMetalBufferPtr)",
    "insertText": "NewBuffer(NS::UInteger length)"
  },
  {
    "label": "SetPurgeableState()",
    "kind": "Method",
    "detail": "Function (MTL::PurgeableState)",
    "insertText": "SetPurgeableState(MTL::PurgeableState state)"
  },
  {
    "label": "FreeRange()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeRange(NS::Range const& Range)"
  },
  {
    "label": "SetOwner()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetOwner(NS::Range const& Range, FMetalRHIBuffer* Owner, bool bIsSwap)"
  },
  {
    "label": "Allocation()",
    "kind": "Method",
    "detail": "Function (private : struct Allocation {)",
    "insertText": "Allocation() : Range(0,0)"
  },
  {
    "label": "FMetalSubBufferLinear()",
    "kind": "Method",
    "detail": "Function (} NS::Range Range ; MTL::Buffer* Resource ; FMetalRHIBuffer* Owner ; } ; FMetalDevice& Device ; FCriticalSection& PoolMutex ; int64 volatile OutstandingAllocs ; NS::UInteger MinAlign ; NS::UInteger UsedSize ; MTL::Buffer* ParentBuffer ; MTLHeapPtr ParentHeap ; TArray<NS::Range> FreeRanges ; TArray<Allocation> AllocRanges ; } ; class FMetalSubBufferLinear : public IMetalBufferAllocator { public :)",
    "insertText": "FMetalSubBufferLinear(FMetalDevice& MetalDevice, NS::UInteger Size, NS::UInteger Alignment, MTL::ResourceOptions, FCriticalSection& PoolMutex)"
  },
  {
    "label": "FMetalSubBufferLinear()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FMetalSubBufferLinear()"
  },
  {
    "label": "FMetalSubBufferMagazine()",
    "kind": "Method",
    "detail": "Function (private : FMetalDevice& Device ; FCriticalSection& PoolMutex ; NS::UInteger MinAlign ; NS::UInteger WriteHead ; NS::UInteger UsedSize ; NS::UInteger FreedSize ; MTL::Buffer* ParentBuffer ; } ; class FMetalSubBufferMagazine : public IMetalBufferAllocator { public :)",
    "insertText": "FMetalSubBufferMagazine(FMetalDevice& MetalDevice, NS::UInteger Size, NS::UInteger ChunkSize, MTL::ResourceOptions)"
  },
  {
    "label": "FMetalSubBufferMagazine()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FMetalSubBufferMagazine()"
  },
  {
    "label": "GetFreeSize()",
    "kind": "Method",
    "detail": "Function (NS::UInteger)",
    "insertText": "GetFreeSize()"
  },
  {
    "label": "NewBuffer()",
    "kind": "Method",
    "detail": "Function (FMetalBufferPtr)",
    "insertText": "NewBuffer()"
  },
  {
    "label": "FMetalRingBufferRef()",
    "kind": "Method",
    "detail": "Function (private : FMetalDevice& Device ; NS::UInteger MinAlign ; NS::UInteger BlockSize ; int64 volatile OutstandingAllocs ; int64 volatile UsedSize ; MTL::Buffer* ParentBuffer ; MTLHeapPtr ParentHeap ; TArray<int8> Blocks ; } ; struct FMetalRingBufferRef {)",
    "insertText": "FMetalRingBufferRef(FMetalDevice& InDevice, FMetalBufferPtr Buf)"
  },
  {
    "label": "FMetalRingBufferRef()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FMetalRingBufferRef()"
  },
  {
    "label": "SetLastRead()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetLastRead(uint64 Read)"
  },
  {
    "label": "InterlockedExchange()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InterlockedExchange((int64*)&LastRead, Read)"
  },
  {
    "label": "GetBuffer()",
    "kind": "Method",
    "detail": "Function (} FMetalBufferPtr)",
    "insertText": "GetBuffer()"
  },
  {
    "label": "FMetalSubBufferRing()",
    "kind": "Method",
    "detail": "Function (} FMetalDevice& Device ; FMetalBufferPtr Buffer = nullptr ; uint64 LastRead ; } ; class FMetalResourceHeap ; class FMetalCommandBuffer ; class FMetalSubBufferRing : public IMetalBufferAllocator { public :)",
    "insertText": "FMetalSubBufferRing(FMetalDevice& MetalDevice, NS::UInteger Size, NS::UInteger Alignment, MTL::ResourceOptions Options)"
  },
  {
    "label": "FMetalSubBufferRing()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FMetalSubBufferRing()"
  },
  {
    "label": "NewBuffer()",
    "kind": "Method",
    "detail": "Function (FMetalBufferPtr)",
    "insertText": "NewBuffer(NS::UInteger Size, uint32 Alignment)"
  },
  {
    "label": "Shrink()",
    "kind": "Method",
    "detail": "Function (} ; void)",
    "insertText": "Shrink()"
  },
  {
    "label": "Commit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Commit(FMetalCommandBuffer* CmdBuffer)"
  },
  {
    "label": "Submit()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "Submit()"
  },
  {
    "label": "GetPoolBucketIndex()",
    "kind": "Method",
    "detail": "Function (FMetalDevice& Device ; NS::UInteger FrameSize [ 1 0 ] ; NS::UInteger LastFrameChange ; NS::UInteger InitialSize ; NS::UInteger MinAlign ; NS::UInteger CommitHead ; NS::UInteger SubmitHead ; NS::UInteger WriteHead ; NS::UInteger BufferSize ; MTL::ResourceOptions Options ; MTL::StorageMode Storage ; TSharedPtr<FMetalRingBufferRef,ESPMode::ThreadSafe> RingBufferRef ; TArray<NS::Range> AllocatedRanges ; } ; class FMetalBufferPoolPolicyData { enum BucketSizes { BucketSize256,BucketSize512,BucketSize1k,BucketSize2k,BucketSize4k,BucketSize8k,BucketSize16k,BucketSize32k,BucketSize64k,BucketSize128k,BucketSize256k,BucketSize512k,BucketSize1Mb,BucketSize2Mb,BucketSize4Mb,BucketSize8Mb,BucketSize12Mb,BucketSize16Mb,BucketSize24Mb,BucketSize32Mb,NumBucketSizes } ; public : typedef FMetalPooledBufferArgs CreationArguments ; enum { NumResourceStorageModes = 4,NumSafeFrames = 1,NumPoolBucketSizes = NumBucketSizes,NumPoolBuckets = NumPoolBucketSizes* NumResourceStorageModes,NumToDrainPerFrame = 6 5 5 3 6,CullAfterFramesNum = 3 0 } ; uint32)",
    "insertText": "GetPoolBucketIndex(CreationArguments Args)"
  },
  {
    "label": "GetPoolBucketSize()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetPoolBucketSize(uint32 Bucket)"
  },
  {
    "label": "CreateResource()",
    "kind": "Method",
    "detail": "Function (MTL::Buffer*)",
    "insertText": "CreateResource(FRHICommandListBase& RHICmdList, CreationArguments Args)"
  },
  {
    "label": "GetCreationArguments()",
    "kind": "Method",
    "detail": "Function (CreationArguments)",
    "insertText": "GetCreationArguments(MTL::Buffer* Resource)"
  },
  {
    "label": "FreeResource()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeResource(MTL::Buffer* Resource)"
  },
  {
    "label": "FMetalBufferPool()",
    "kind": "Method",
    "detail": "Function (private : uint32 BucketSizes [ NumPoolBucketSizes ] ; TMap<MTL::Buffer*,CreationArguments> CreationArgumentMap ; } ; class FMetalBufferPool : public TResourcePool<MTL::Buffer*,FMetalBufferPoolPolicyData,FMetalBufferPoolPolicyData::CreationArguments> { public : ~)",
    "insertText": "FMetalBufferPool()"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} ; class FMetalTexturePool { enum { PurgeAfterNumFrames = 2,CullAfterNumFrames = 3,} ; public : struct Descriptor { uint32)",
    "insertText": "GetTypeHash(Descriptor const& Other)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (uint32 Hash =)",
    "insertText": "GetTypeHash((uint64)Other.textureType)"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (Hash =)",
    "insertText": "HashCombine(Hash, GetTypeHash((uint64)Other.pixelFormat))"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (Hash =)",
    "insertText": "HashCombine(Hash, GetTypeHash((uint64)Other.usage))"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (Hash =)",
    "insertText": "HashCombine(Hash, GetTypeHash((uint64)Other.width))"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (Hash =)",
    "insertText": "HashCombine(Hash, GetTypeHash((uint64)Other.height))"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (Hash =)",
    "insertText": "HashCombine(Hash, GetTypeHash((uint64)Other.depth))"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (Hash =)",
    "insertText": "HashCombine(Hash, GetTypeHash((uint64)Other.mipmapLevelCount))"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (Hash =)",
    "insertText": "HashCombine(Hash, GetTypeHash((uint64)Other.sampleCount))"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (Hash =)",
    "insertText": "HashCombine(Hash, GetTypeHash((uint64)Other.arrayLength))"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (Hash =)",
    "insertText": "HashCombine(Hash, GetTypeHash((uint64)Other.resourceOptions))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return false ; } bool)",
    "insertText": "operator(Descriptor const& Other)"
  },
  {
    "label": "FMetalTexturePool()",
    "kind": "Method",
    "detail": "Function (} return true ; } NS::UInteger textureType ; NS::UInteger pixelFormat ; NS::UInteger width ; NS::UInteger height ; NS::UInteger depth ; NS::UInteger mipmapLevelCount ; NS::UInteger sampleCount ; NS::UInteger arrayLength ; NS::UInteger resourceOptions ; NS::UInteger usage ; NS::UInteger freedFrame ; } ;)",
    "insertText": "FMetalTexturePool(FCriticalSection& PoolMutex)"
  },
  {
    "label": "FMetalTexturePool()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FMetalTexturePool()"
  },
  {
    "label": "CreateTexture()",
    "kind": "Method",
    "detail": "Function (MTLTexturePtr)",
    "insertText": "CreateTexture(FMetalDevice& Device, MTL::TextureDescriptor* Desc)"
  },
  {
    "label": "ReleaseTexture()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseTexture(MTLTexturePtr Texture)"
  },
  {
    "label": "Drain()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Drain(bool const bForce)"
  },
  {
    "label": "FMetalResourceHeap()",
    "kind": "Method",
    "detail": "Function (private : FCriticalSection& PoolMutex ; TMap<Descriptor,MTLTexturePtr> Pool ; } ; typedef NS::SharedPtr<MTL::Heap> MTLHeapPtr ; class FMetalResourceHeap : public IMetalBufferAllocator { enum MagazineSize { Size16,Size32,Size64,Size128,Size256,Size512,Size1024,Size2048,Size4096,Size8192,NumMagazineSizes } ; enum HeapSize { Size1Mb,Size2Mb,NumHeapSizes } ; enum TextureHeapSize { Size4Mb,Size8Mb,Size16Mb,Size32Mb,Size64Mb,Size128Mb,Size256Mb,NumTextureHeapSizes,MinTexturesPerHeap = 4,MaxTextureSize = Size64Mb,} ; enum AllocTypes { AllocShared,AllocPrivate,NumAllocTypes = 2 } ; enum EMetalHeapTextureUsage { EMetalHeapTextureUsageResource = 0,EMetalHeapTextureUsageRenderTarget = 1,EMetalHeapTextureUsageNum = 2 } ; enum UsageTypes { UsageStatic,UsageDynamic,NumUsageTypes = 2 } ; public :)",
    "insertText": "FMetalResourceHeap(FMetalDevice& MetalDevice)"
  },
  {
    "label": "FMetalResourceHeap()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FMetalResourceHeap()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(FMetalCommandQueue& Queue)"
  },
  {
    "label": "CreateBuffer()",
    "kind": "Method",
    "detail": "Function (FMetalBufferPtr)",
    "insertText": "CreateBuffer(uint32 Size, uint32 Alignment, EBufferUsageFlags Flags, MTL::ResourceOptions Options, bool bForceUnique = false)"
  },
  {
    "label": "CreateTexture()",
    "kind": "Method",
    "detail": "Function (MTLTexturePtr)",
    "insertText": "CreateTexture(MTL::TextureDescriptor* Desc, FMetalSurface* Surface)"
  },
  {
    "label": "ReleaseTexture()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseTexture(FMetalSurface* Surface, MTLTexturePtr Texture)"
  },
  {
    "label": "Compact()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Compact(bool const bForce)"
  },
  {
    "label": "GetMagazineIndex()",
    "kind": "Method",
    "detail": "Function (private : uint32)",
    "insertText": "GetMagazineIndex(uint32 Size)"
  },
  {
    "label": "GetHeapIndex()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetHeapIndex(uint32 Size)"
  },
  {
    "label": "TextureSizeToIndex()",
    "kind": "Method",
    "detail": "Function (TextureHeapSize)",
    "insertText": "TextureSizeToIndex(uint32 Size)"
  },
  {
    "label": "GetTextureHeap()",
    "kind": "Method",
    "detail": "Function (MTLHeapPtr)",
    "insertText": "GetTextureHeap(MTL::TextureDescriptor* Desc, MTL::SizeAndAlign Size)"
  },
  {
    "label": "MergeBlocks()",
    "kind": "Method",
    "detail": "Function (private : uint32 MagazineSizes [ NumMagazineSizes ] ; uint32 HeapSizes [ NumHeapSizes ] ; uint32 MagazineAllocSizes [ NumMagazineSizes ] ; uint32 HeapAllocSizes [ NumHeapSizes ] ; uint32 HeapTextureHeapSizes [ NumTextureHeapSizes ] ; FMetalDevice& Device ; FCriticalSection Mutex ; FMetalCommandQueue* Queue ; TArray<FMetalSubBufferMagazine*> SmallBuffers [ NumUsageTypes ] [ NumAllocTypes ] [ NumMagazineSizes ] ; TArray<FMetalSubBufferHeap*> BufferHeaps [ NumUsageTypes ] [ NumAllocTypes ] [ NumHeapSizes ] ; FMetalBufferPool Buffers [ NumAllocTypes ] ; # if PLATFORM_MAC FMetalBufferPool ManagedBuffers ; TArray<FMetalSubBufferLinear*> ManagedSubHeaps ; # endif FMetalTexturePool TexturePool ; FMetalTexturePool TargetPool ; TArray<MTLHeapPtr> TextureHeaps [ EMetalHeapTextureUsageNum ] [ NumTextureHeapSizes ] ; struct MemoryBlock { MTLHeapPtr Heap ; uint64 Offset ; uint64 Size ; MTL::Resource* Resource ; MTL::ResourceOptions Options ; } ; using FMetalListIterator = TDoubleLinkedList<FMetalResourceHeap::MemoryBlock>::TIterator ; TMap<MTL::ResourceOptions,TDoubleLinkedList<MemoryBlock>*> FreeLists ; TMap<MTL::ResourceOptions,TDoubleLinkedList<MemoryBlock>*> UsedLists ; FCriticalSection FreeListCS ; FCriticalSection InUseResourcesCS ; TArray<FMetalListIterator> InUseResources ; TQueue<uint32> InUseResourcesFreeList ; TMap<MTL::Resource*,uint32> AllocationHandlesLUT ; FMetalListIterator)",
    "insertText": "MergeBlocks(TDoubleLinkedList<FMetalResourceHeap::MemoryBlock>& List, FMetalListIterator BlockItA, FMetalListIterator BlockItB)"
  },
  {
    "label": "FreeBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeBlock(const uint32 ResourceAllocationHandle)"
  },
  {
    "label": "FindOrAllocateBlock()",
    "kind": "Method",
    "detail": "Function (FMetalListIterator)",
    "insertText": "FindOrAllocateBlock(uint32 Size, uint32 Alignment, MTL::ResourceOptions Options)"
  },
  {
    "label": "SplitBlock()",
    "kind": "Method",
    "detail": "Function (FMetalListIterator)",
    "insertText": "SplitBlock(TDoubleLinkedList<FMetalResourceHeap::MemoryBlock>& List, FMetalListIterator BlockIt, const uint64 Offset, const uint32 Size)"
  }
]