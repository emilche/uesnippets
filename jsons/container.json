[
  {
    "label": "IsUnorderedContainer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsUnorderedContainer"
  },
  {
    "label": "Key",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Key"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "Hash",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Hash"
  },
  {
    "label": "KeyEqual",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "KeyEqual"
  },
  {
    "label": "Allocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Allocator"
  },
  {
    "label": "C",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "C"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_ALGORITHM_CONTAINER_H_ # define ABSL_ALGORITHM_CONTAINER_H_ # include<algorithm> # include<cassert> # include<iterator> # include<numeric> # include<type_traits> # include<unordered_map> # include<unordered_set> # include<utility> # include<vector> # include \" absl / algorithm / algorithm . h \" # include \" absl / base / macros . h \" # include \" absl / meta / type_traits . h \" namespace absl { ABSL_NAMESPACE_BEGIN namespace container_algorithm_internal { using std::begin ; using std::end ; template<C> using ContainerIter =)",
    "insertText": "decltype(begin(std::declval<C&>()))"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (template<C1,C2> using ContainerIterPairType =)",
    "insertText": "decltype(std::make_pair(ContainerIter<C1>(), ContainerIter<C2>()))"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (template<C> using ContainerDifferenceType =)",
    "insertText": "decltype(std::distance(std::declval<ContainerIter<C>>(), std::declval<ContainerIter<C>>()))"
  },
  {
    "label": "c_begin()",
    "kind": "Method",
    "detail": "Function (template<C> using ContainerPointerType = std::iterator_traits<ContainerIter<C>>::pointer ; template<C> ContainerIter<C>)",
    "insertText": "c_begin(C& c)"
  },
  {
    "label": "c_end()",
    "kind": "Method",
    "detail": "Function (} template<C> ContainerIter<C>)",
    "insertText": "c_end(C& c)"
  },
  {
    "label": "c_size()",
    "kind": "Method",
    "detail": "Function (} template<T> struct IsUnorderedContainer : std::false_type { } ; template<class Key,class T,class Hash,class KeyEqual,class Allocator> struct IsUnorderedContainer<std::unordered_map<Key,T,Hash,KeyEqual,Allocator>> : std::true_type { } ; template<class Key,class Hash,class KeyEqual,class Allocator> struct IsUnorderedContainer<std::unordered_set<Key,Hash,KeyEqual,Allocator>> : std::true_type { } ; template<class C> auto)",
    "insertText": "c_size(C& c) -> decltype(c.size())"
  },
  {
    "label": "c_size()",
    "kind": "Method",
    "detail": "Function (} template<class T,std::size_t N> std::size_t)",
    "insertText": "c_size(T (&)[N])"
  },
  {
    "label": "c_distance()",
    "kind": "Method",
    "detail": "Function (} template<C> container_algorithm_internal::ContainerDifferenceType<const C>)",
    "insertText": "c_distance(const C& c)"
  },
  {
    "label": "c_all_of()",
    "kind": "Method",
    "detail": "Function (} template<C,Pred> bool)",
    "insertText": "c_all_of(const C& c, Pred&& pred)"
  },
  {
    "label": "c_any_of()",
    "kind": "Method",
    "detail": "Function (} template<C,Pred> bool)",
    "insertText": "c_any_of(const C& c, Pred&& pred)"
  },
  {
    "label": "c_none_of()",
    "kind": "Method",
    "detail": "Function (} template<C,Pred> bool)",
    "insertText": "c_none_of(const C& c, Pred&& pred)"
  },
  {
    "label": "c_for_each()",
    "kind": "Method",
    "detail": "Function (} template<C,Function> decay_t<Function>)",
    "insertText": "c_for_each(C&& c, Function&& f)"
  },
  {
    "label": "c_find()",
    "kind": "Method",
    "detail": "Function (} template<C,T> container_algorithm_internal::ContainerIter<C>)",
    "insertText": "c_find(C& c, T&& value)"
  },
  {
    "label": "c_find_if()",
    "kind": "Method",
    "detail": "Function (} template<C,Pred> container_algorithm_internal::ContainerIter<C>)",
    "insertText": "c_find_if(C& c, Pred&& pred)"
  },
  {
    "label": "c_find_if_not()",
    "kind": "Method",
    "detail": "Function (} template<C,Pred> container_algorithm_internal::ContainerIter<C>)",
    "insertText": "c_find_if_not(C& c, Pred&& pred)"
  },
  {
    "label": "c_find_end()",
    "kind": "Method",
    "detail": "Function (} template<Sequence1,Sequence2> container_algorithm_internal::ContainerIter<Sequence1>)",
    "insertText": "c_find_end(Sequence1& sequence, Sequence2& subsequence)"
  },
  {
    "label": "c_find_end()",
    "kind": "Method",
    "detail": "Function (} template<Sequence1,Sequence2,BinaryPredicate> container_algorithm_internal::ContainerIter<Sequence1>)",
    "insertText": "c_find_end(Sequence1& sequence, Sequence2& subsequence, BinaryPredicate&& pred)"
  },
  {
    "label": "c_find_first_of()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2> container_algorithm_internal::ContainerIter<C1>)",
    "insertText": "c_find_first_of(C1& container, C2& options)"
  },
  {
    "label": "c_find_first_of()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2,BinaryPredicate> container_algorithm_internal::ContainerIter<C1>)",
    "insertText": "c_find_first_of(C1& container, C2& options, BinaryPredicate&& pred)"
  },
  {
    "label": "c_adjacent_find()",
    "kind": "Method",
    "detail": "Function (} template<Sequence> container_algorithm_internal::ContainerIter<Sequence>)",
    "insertText": "c_adjacent_find(Sequence& sequence)"
  },
  {
    "label": "c_adjacent_find()",
    "kind": "Method",
    "detail": "Function (} template<Sequence,BinaryPredicate> container_algorithm_internal::ContainerIter<Sequence>)",
    "insertText": "c_adjacent_find(Sequence& sequence, BinaryPredicate&& pred)"
  },
  {
    "label": "c_count()",
    "kind": "Method",
    "detail": "Function (} template<C,T> container_algorithm_internal::ContainerDifferenceType<const C>)",
    "insertText": "c_count(const C& c, T&& value)"
  },
  {
    "label": "c_count_if()",
    "kind": "Method",
    "detail": "Function (} template<C,Pred> container_algorithm_internal::ContainerDifferenceType<const C>)",
    "insertText": "c_count_if(const C& c, Pred&& pred)"
  },
  {
    "label": "c_mismatch()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2> container_algorithm_internal::ContainerIterPairType<C1,C2>)",
    "insertText": "c_mismatch(C1& c1, C2& c2)"
  },
  {
    "label": "c_begin()",
    "kind": "Method",
    "detail": "Function (auto first1 =)",
    "insertText": "c_begin(c1)"
  },
  {
    "label": "c_end()",
    "kind": "Method",
    "detail": "Function (auto last1 =)",
    "insertText": "c_end(c1)"
  },
  {
    "label": "c_begin()",
    "kind": "Method",
    "detail": "Function (auto first2 =)",
    "insertText": "c_begin(c2)"
  },
  {
    "label": "c_end()",
    "kind": "Method",
    "detail": "Function (auto last2 =)",
    "insertText": "c_end(c2)"
  },
  {
    "label": "make_pair()",
    "kind": "Method",
    "detail": "Function (break ; } } return)",
    "insertText": "make_pair(first1, first2)"
  },
  {
    "label": "c_mismatch()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2,BinaryPredicate> container_algorithm_internal::ContainerIterPairType<C1,C2>)",
    "insertText": "c_mismatch(C1& c1, C2& c2, BinaryPredicate pred)"
  },
  {
    "label": "c_equal()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2> bool)",
    "insertText": "c_equal(const C1& c1, const C2& c2)"
  },
  {
    "label": "c_equal()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2,BinaryPredicate> bool)",
    "insertText": "c_equal(const C1& c1, const C2& c2, BinaryPredicate&& pred)"
  },
  {
    "label": "c_is_permutation()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2> bool)",
    "insertText": "c_is_permutation(const C1& c1, const C2& c2)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (using std::begin ; using std::end ; return c1 .)",
    "insertText": "size() == c2.size() && std::is_permutation(begin(c1), end(c1), begin(c2))"
  },
  {
    "label": "c_is_permutation()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2,BinaryPredicate> bool)",
    "insertText": "c_is_permutation(const C1& c1, const C2& c2, BinaryPredicate&& pred)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (using std::begin ; using std::end ; return c1 .)",
    "insertText": "size() == c2.size() && std::is_permutation(begin(c1), end(c1), begin(c2), std::forward<BinaryPredicate>(pred))"
  },
  {
    "label": "c_search()",
    "kind": "Method",
    "detail": "Function (} template<Sequence1,Sequence2> container_algorithm_internal::ContainerIter<Sequence1>)",
    "insertText": "c_search(Sequence1& sequence, Sequence2& subsequence)"
  },
  {
    "label": "c_search()",
    "kind": "Method",
    "detail": "Function (} template<Sequence1,Sequence2,BinaryPredicate> container_algorithm_internal::ContainerIter<Sequence1>)",
    "insertText": "c_search(Sequence1& sequence, Sequence2& subsequence, BinaryPredicate&& pred)"
  },
  {
    "label": "c_search_n()",
    "kind": "Method",
    "detail": "Function (} template<Sequence,Size,T> container_algorithm_internal::ContainerIter<Sequence>)",
    "insertText": "c_search_n(Sequence& sequence, Size count, T&& value)"
  },
  {
    "label": "c_search_n()",
    "kind": "Method",
    "detail": "Function (} template<Sequence,Size,T,BinaryPredicate> container_algorithm_internal::ContainerIter<Sequence>)",
    "insertText": "c_search_n(Sequence& sequence, Size count, T&& value, BinaryPredicate&& pred)"
  },
  {
    "label": "c_copy()",
    "kind": "Method",
    "detail": "Function (} template<InputSequence,OutputIterator> OutputIterator)",
    "insertText": "c_copy(const InputSequence& input, OutputIterator output)"
  },
  {
    "label": "c_copy_n()",
    "kind": "Method",
    "detail": "Function (} template<C,Size,OutputIterator> OutputIterator)",
    "insertText": "c_copy_n(const C& input, Size n, OutputIterator output)"
  },
  {
    "label": "c_copy_if()",
    "kind": "Method",
    "detail": "Function (} template<InputSequence,OutputIterator,Pred> OutputIterator)",
    "insertText": "c_copy_if(const InputSequence& input, OutputIterator output, Pred&& pred)"
  },
  {
    "label": "c_copy_backward()",
    "kind": "Method",
    "detail": "Function (} template<C,BidirectionalIterator> BidirectionalIterator)",
    "insertText": "c_copy_backward(const C& src, BidirectionalIterator dest)"
  },
  {
    "label": "c_move()",
    "kind": "Method",
    "detail": "Function (} template<C,OutputIterator> OutputIterator)",
    "insertText": "c_move(C&& src, OutputIterator dest)"
  },
  {
    "label": "c_move_backward()",
    "kind": "Method",
    "detail": "Function (} template<C,BidirectionalIterator> BidirectionalIterator)",
    "insertText": "c_move_backward(C&& src, BidirectionalIterator dest)"
  },
  {
    "label": "c_swap_ranges()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2> container_algorithm_internal::ContainerIter<C2>)",
    "insertText": "c_swap_ranges(C1& c1, C2& c2)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (using std::swap ;)",
    "insertText": "for(; first1 != last1 && first2 != last2; ++first1, (void)++first2)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(*first1, *first2)"
  },
  {
    "label": "c_transform()",
    "kind": "Method",
    "detail": "Function (} return first2 ; } template<InputSequence,OutputIterator,UnaryOp> OutputIterator)",
    "insertText": "c_transform(const InputSequence& input, OutputIterator output, UnaryOp&& unary_op)"
  },
  {
    "label": "c_transform()",
    "kind": "Method",
    "detail": "Function (} template<InputSequence1,InputSequence2,OutputIterator,BinaryOp> OutputIterator)",
    "insertText": "c_transform(const InputSequence1& input1, const InputSequence2& input2, OutputIterator output, BinaryOp&& binary_op)"
  },
  {
    "label": "c_begin()",
    "kind": "Method",
    "detail": "Function (auto first1 =)",
    "insertText": "c_begin(input1)"
  },
  {
    "label": "c_end()",
    "kind": "Method",
    "detail": "Function (auto last1 =)",
    "insertText": "c_end(input1)"
  },
  {
    "label": "c_begin()",
    "kind": "Method",
    "detail": "Function (auto first2 =)",
    "insertText": "c_begin(input2)"
  },
  {
    "label": "c_end()",
    "kind": "Method",
    "detail": "Function (auto last2 =)",
    "insertText": "c_end(input2)"
  },
  {
    "label": "binary_op()",
    "kind": "Method",
    "detail": "Function (* output =)",
    "insertText": "binary_op(*first1, *first2)"
  },
  {
    "label": "c_replace()",
    "kind": "Method",
    "detail": "Function (} return output ; } template<Sequence,T> void)",
    "insertText": "c_replace(Sequence& sequence, const T& old_value, const T& new_value)"
  },
  {
    "label": "replace()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "replace(container_algorithm_internal::c_begin(sequence), container_algorithm_internal::c_end(sequence), old_value, new_value)"
  },
  {
    "label": "c_replace_if()",
    "kind": "Method",
    "detail": "Function (} template<C,Pred,T> void)",
    "insertText": "c_replace_if(C& c, Pred&& pred, T&& new_value)"
  },
  {
    "label": "replace_if()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "replace_if(container_algorithm_internal::c_begin(c), container_algorithm_internal::c_end(c), std::forward<Pred>(pred), std::forward<T>(new_value))"
  },
  {
    "label": "c_replace_copy()",
    "kind": "Method",
    "detail": "Function (} template<C,OutputIterator,T> OutputIterator)",
    "insertText": "c_replace_copy(const C& c, OutputIterator result, T&& old_value, T&& new_value)"
  },
  {
    "label": "c_replace_copy_if()",
    "kind": "Method",
    "detail": "Function (} template<C,OutputIterator,Pred,T> OutputIterator)",
    "insertText": "c_replace_copy_if(const C& c, OutputIterator result, Pred&& pred, T&& new_value)"
  },
  {
    "label": "c_fill()",
    "kind": "Method",
    "detail": "Function (} template<C,T> void)",
    "insertText": "c_fill(C& c, T&& value)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(container_algorithm_internal::c_begin(c), container_algorithm_internal::c_end(c), std::forward<T>(value))"
  },
  {
    "label": "c_fill_n()",
    "kind": "Method",
    "detail": "Function (} template<C,Size,T> void)",
    "insertText": "c_fill_n(C& c, Size n, T&& value)"
  },
  {
    "label": "fill_n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill_n(container_algorithm_internal::c_begin(c), n, std::forward<T>(value))"
  },
  {
    "label": "c_generate()",
    "kind": "Method",
    "detail": "Function (} template<C,Generator> void)",
    "insertText": "c_generate(C& c, Generator&& gen)"
  },
  {
    "label": "generate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "generate(container_algorithm_internal::c_begin(c), container_algorithm_internal::c_end(c), std::forward<Generator>(gen))"
  },
  {
    "label": "c_generate_n()",
    "kind": "Method",
    "detail": "Function (} template<C,Size,Generator> container_algorithm_internal::ContainerIter<C>)",
    "insertText": "c_generate_n(C& c, Size n, Generator&& gen)"
  },
  {
    "label": "c_remove_copy()",
    "kind": "Method",
    "detail": "Function (} template<C,OutputIterator,T> OutputIterator)",
    "insertText": "c_remove_copy(const C& c, OutputIterator result, T&& value)"
  },
  {
    "label": "c_remove_copy_if()",
    "kind": "Method",
    "detail": "Function (} template<C,OutputIterator,Pred> OutputIterator)",
    "insertText": "c_remove_copy_if(const C& c, OutputIterator result, Pred&& pred)"
  },
  {
    "label": "c_unique_copy()",
    "kind": "Method",
    "detail": "Function (} template<C,OutputIterator> OutputIterator)",
    "insertText": "c_unique_copy(const C& c, OutputIterator result)"
  },
  {
    "label": "c_unique_copy()",
    "kind": "Method",
    "detail": "Function (} template<C,OutputIterator,BinaryPredicate> OutputIterator)",
    "insertText": "c_unique_copy(const C& c, OutputIterator result, BinaryPredicate&& pred)"
  },
  {
    "label": "c_reverse()",
    "kind": "Method",
    "detail": "Function (} template<Sequence> void)",
    "insertText": "c_reverse(Sequence& sequence)"
  },
  {
    "label": "reverse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reverse(container_algorithm_internal::c_begin(sequence), container_algorithm_internal::c_end(sequence))"
  },
  {
    "label": "c_reverse_copy()",
    "kind": "Method",
    "detail": "Function (} template<C,OutputIterator> OutputIterator)",
    "insertText": "c_reverse_copy(const C& sequence, OutputIterator result)"
  },
  {
    "label": "c_rotate()",
    "kind": "Method",
    "detail": "Function (} template<C,Iterator = container_algorithm_internal::ContainerIter<C>> Iterator)",
    "insertText": "c_rotate(C& sequence, Iterator middle)"
  },
  {
    "label": "c_rotate_copy()",
    "kind": "Method",
    "detail": "Function (} template<C,OutputIterator> OutputIterator)",
    "insertText": "c_rotate_copy(const C& sequence, container_algorithm_internal::ContainerIter<const C> middle, OutputIterator result)"
  },
  {
    "label": "c_shuffle()",
    "kind": "Method",
    "detail": "Function (} template<RandomAccessContainer,UniformRandomBitGenerator> void)",
    "insertText": "c_shuffle(RandomAccessContainer& c, UniformRandomBitGenerator&& gen)"
  },
  {
    "label": "shuffle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "shuffle(container_algorithm_internal::c_begin(c), container_algorithm_internal::c_end(c), std::forward<UniformRandomBitGenerator>(gen))"
  },
  {
    "label": "c_is_partitioned()",
    "kind": "Method",
    "detail": "Function (} template<C,Pred> bool)",
    "insertText": "c_is_partitioned(const C& c, Pred&& pred)"
  },
  {
    "label": "c_partition()",
    "kind": "Method",
    "detail": "Function (} template<C,Pred> container_algorithm_internal::ContainerIter<C>)",
    "insertText": "c_partition(C& c, Pred&& pred)"
  },
  {
    "label": "c_stable_partition()",
    "kind": "Method",
    "detail": "Function (} template<C,Pred> container_algorithm_internal::ContainerIter<C>)",
    "insertText": "c_stable_partition(C& c, Pred&& pred)"
  },
  {
    "label": "c_partition_copy()",
    "kind": "Method",
    "detail": "Function (} template<C,OutputIterator1,OutputIterator2,Pred> std::pair<OutputIterator1,OutputIterator2>)",
    "insertText": "c_partition_copy(const C& c, OutputIterator1 out_true, OutputIterator2 out_false, Pred&& pred)"
  },
  {
    "label": "c_partition_point()",
    "kind": "Method",
    "detail": "Function (} template<C,Pred> container_algorithm_internal::ContainerIter<C>)",
    "insertText": "c_partition_point(C& c, Pred&& pred)"
  },
  {
    "label": "c_sort()",
    "kind": "Method",
    "detail": "Function (} template<C> void)",
    "insertText": "c_sort(C& c)"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sort(container_algorithm_internal::c_begin(c), container_algorithm_internal::c_end(c))"
  },
  {
    "label": "c_sort()",
    "kind": "Method",
    "detail": "Function (} template<C,LessThan> void)",
    "insertText": "c_sort(C& c, LessThan&& comp)"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sort(container_algorithm_internal::c_begin(c), container_algorithm_internal::c_end(c), std::forward<LessThan>(comp))"
  },
  {
    "label": "c_stable_sort()",
    "kind": "Method",
    "detail": "Function (} template<C> void)",
    "insertText": "c_stable_sort(C& c)"
  },
  {
    "label": "stable_sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stable_sort(container_algorithm_internal::c_begin(c), container_algorithm_internal::c_end(c))"
  },
  {
    "label": "c_stable_sort()",
    "kind": "Method",
    "detail": "Function (} template<C,LessThan> void)",
    "insertText": "c_stable_sort(C& c, LessThan&& comp)"
  },
  {
    "label": "stable_sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stable_sort(container_algorithm_internal::c_begin(c), container_algorithm_internal::c_end(c), std::forward<LessThan>(comp))"
  },
  {
    "label": "c_is_sorted()",
    "kind": "Method",
    "detail": "Function (} template<C> bool)",
    "insertText": "c_is_sorted(const C& c)"
  },
  {
    "label": "c_is_sorted()",
    "kind": "Method",
    "detail": "Function (} template<C,LessThan> bool)",
    "insertText": "c_is_sorted(const C& c, LessThan&& comp)"
  },
  {
    "label": "c_partial_sort()",
    "kind": "Method",
    "detail": "Function (} template<RandomAccessContainer> void)",
    "insertText": "c_partial_sort(RandomAccessContainer& sequence, container_algorithm_internal::ContainerIter<RandomAccessContainer> middle)"
  },
  {
    "label": "partial_sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "partial_sort(container_algorithm_internal::c_begin(sequence), middle, container_algorithm_internal::c_end(sequence))"
  },
  {
    "label": "c_partial_sort()",
    "kind": "Method",
    "detail": "Function (} template<RandomAccessContainer,LessThan> void)",
    "insertText": "c_partial_sort(RandomAccessContainer& sequence, container_algorithm_internal::ContainerIter<RandomAccessContainer> middle, LessThan&& comp)"
  },
  {
    "label": "partial_sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "partial_sort(container_algorithm_internal::c_begin(sequence), middle, container_algorithm_internal::c_end(sequence), std::forward<LessThan>(comp))"
  },
  {
    "label": "c_partial_sort_copy()",
    "kind": "Method",
    "detail": "Function (} template<C,RandomAccessContainer> container_algorithm_internal::ContainerIter<RandomAccessContainer>)",
    "insertText": "c_partial_sort_copy(const C& sequence, RandomAccessContainer& result)"
  },
  {
    "label": "c_partial_sort_copy()",
    "kind": "Method",
    "detail": "Function (} template<C,RandomAccessContainer,LessThan> container_algorithm_internal::ContainerIter<RandomAccessContainer>)",
    "insertText": "c_partial_sort_copy(const C& sequence, RandomAccessContainer& result, LessThan&& comp)"
  },
  {
    "label": "c_is_sorted_until()",
    "kind": "Method",
    "detail": "Function (} template<C> container_algorithm_internal::ContainerIter<C>)",
    "insertText": "c_is_sorted_until(C& c)"
  },
  {
    "label": "c_is_sorted_until()",
    "kind": "Method",
    "detail": "Function (} template<C,LessThan> container_algorithm_internal::ContainerIter<C>)",
    "insertText": "c_is_sorted_until(C& c, LessThan&& comp)"
  },
  {
    "label": "c_nth_element()",
    "kind": "Method",
    "detail": "Function (} template<RandomAccessContainer> void)",
    "insertText": "c_nth_element(RandomAccessContainer& sequence, container_algorithm_internal::ContainerIter<RandomAccessContainer> nth)"
  },
  {
    "label": "nth_element()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nth_element(container_algorithm_internal::c_begin(sequence), nth, container_algorithm_internal::c_end(sequence))"
  },
  {
    "label": "c_nth_element()",
    "kind": "Method",
    "detail": "Function (} template<RandomAccessContainer,LessThan> void)",
    "insertText": "c_nth_element(RandomAccessContainer& sequence, container_algorithm_internal::ContainerIter<RandomAccessContainer> nth, LessThan&& comp)"
  },
  {
    "label": "nth_element()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nth_element(container_algorithm_internal::c_begin(sequence), nth, container_algorithm_internal::c_end(sequence), std::forward<LessThan>(comp))"
  },
  {
    "label": "c_lower_bound()",
    "kind": "Method",
    "detail": "Function (} template<Sequence,T> container_algorithm_internal::ContainerIter<Sequence>)",
    "insertText": "c_lower_bound(Sequence& sequence, T&& value)"
  },
  {
    "label": "c_lower_bound()",
    "kind": "Method",
    "detail": "Function (} template<Sequence,T,LessThan> container_algorithm_internal::ContainerIter<Sequence>)",
    "insertText": "c_lower_bound(Sequence& sequence, T&& value, LessThan&& comp)"
  },
  {
    "label": "c_upper_bound()",
    "kind": "Method",
    "detail": "Function (} template<Sequence,T> container_algorithm_internal::ContainerIter<Sequence>)",
    "insertText": "c_upper_bound(Sequence& sequence, T&& value)"
  },
  {
    "label": "c_upper_bound()",
    "kind": "Method",
    "detail": "Function (} template<Sequence,T,LessThan> container_algorithm_internal::ContainerIter<Sequence>)",
    "insertText": "c_upper_bound(Sequence& sequence, T&& value, LessThan&& comp)"
  },
  {
    "label": "c_equal_range()",
    "kind": "Method",
    "detail": "Function (} template<Sequence,T> container_algorithm_internal::ContainerIterPairType<Sequence,Sequence>)",
    "insertText": "c_equal_range(Sequence& sequence, T&& value)"
  },
  {
    "label": "c_equal_range()",
    "kind": "Method",
    "detail": "Function (} template<Sequence,T,LessThan> container_algorithm_internal::ContainerIterPairType<Sequence,Sequence>)",
    "insertText": "c_equal_range(Sequence& sequence, T&& value, LessThan&& comp)"
  },
  {
    "label": "c_binary_search()",
    "kind": "Method",
    "detail": "Function (} template<Sequence,T> bool)",
    "insertText": "c_binary_search(Sequence&& sequence, T&& value)"
  },
  {
    "label": "c_binary_search()",
    "kind": "Method",
    "detail": "Function (} template<Sequence,T,LessThan> bool)",
    "insertText": "c_binary_search(Sequence&& sequence, T&& value, LessThan&& comp)"
  },
  {
    "label": "c_merge()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2,OutputIterator> OutputIterator)",
    "insertText": "c_merge(const C1& c1, const C2& c2, OutputIterator result)"
  },
  {
    "label": "c_merge()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2,OutputIterator,LessThan> OutputIterator)",
    "insertText": "c_merge(const C1& c1, const C2& c2, OutputIterator result, LessThan&& comp)"
  },
  {
    "label": "c_inplace_merge()",
    "kind": "Method",
    "detail": "Function (} template<C> void)",
    "insertText": "c_inplace_merge(C& c, container_algorithm_internal::ContainerIter<C> middle)"
  },
  {
    "label": "inplace_merge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "inplace_merge(container_algorithm_internal::c_begin(c), middle, container_algorithm_internal::c_end(c))"
  },
  {
    "label": "c_inplace_merge()",
    "kind": "Method",
    "detail": "Function (} template<C,LessThan> void)",
    "insertText": "c_inplace_merge(C& c, container_algorithm_internal::ContainerIter<C> middle, LessThan&& comp)"
  },
  {
    "label": "inplace_merge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "inplace_merge(container_algorithm_internal::c_begin(c), middle, container_algorithm_internal::c_end(c), std::forward<LessThan>(comp))"
  },
  {
    "label": "c_includes()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2> bool)",
    "insertText": "c_includes(const C1& c1, const C2& c2)"
  },
  {
    "label": "c_includes()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2,LessThan> bool)",
    "insertText": "c_includes(const C1& c1, const C2& c2, LessThan&& comp)"
  },
  {
    "label": "c_set_union()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2,OutputIterator,= std::enable_if<! container_algorithm_internal::IsUnorderedContainer<C1>::value,void>::type,= std::enable_if<! container_algorithm_internal::IsUnorderedContainer<C2>::value,void>::type> OutputIterator)",
    "insertText": "c_set_union(const C1& c1, const C2& c2, OutputIterator output)"
  },
  {
    "label": "c_set_union()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2,OutputIterator,LessThan,= std::enable_if<! container_algorithm_internal::IsUnorderedContainer<C1>::value,void>::type,= std::enable_if<! container_algorithm_internal::IsUnorderedContainer<C2>::value,void>::type> OutputIterator)",
    "insertText": "c_set_union(const C1& c1, const C2& c2, OutputIterator output, LessThan&& comp)"
  },
  {
    "label": "c_set_intersection()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2,OutputIterator,= std::enable_if<! container_algorithm_internal::IsUnorderedContainer<C1>::value,void>::type,= std::enable_if<! container_algorithm_internal::IsUnorderedContainer<C2>::value,void>::type> OutputIterator)",
    "insertText": "c_set_intersection(const C1& c1, const C2& c2, OutputIterator output)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(absl::c_is_sorted(c1))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(absl::c_is_sorted(c2))"
  },
  {
    "label": "c_set_intersection()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2,OutputIterator,LessThan,= std::enable_if<! container_algorithm_internal::IsUnorderedContainer<C1>::value,void>::type,= std::enable_if<! container_algorithm_internal::IsUnorderedContainer<C2>::value,void>::type> OutputIterator)",
    "insertText": "c_set_intersection(const C1& c1, const C2& c2, OutputIterator output, LessThan&& comp)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(absl::c_is_sorted(c1, comp))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(absl::c_is_sorted(c2, comp))"
  },
  {
    "label": "c_set_difference()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2,OutputIterator,= std::enable_if<! container_algorithm_internal::IsUnorderedContainer<C1>::value,void>::type,= std::enable_if<! container_algorithm_internal::IsUnorderedContainer<C2>::value,void>::type> OutputIterator)",
    "insertText": "c_set_difference(const C1& c1, const C2& c2, OutputIterator output)"
  },
  {
    "label": "c_set_difference()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2,OutputIterator,LessThan,= std::enable_if<! container_algorithm_internal::IsUnorderedContainer<C1>::value,void>::type,= std::enable_if<! container_algorithm_internal::IsUnorderedContainer<C2>::value,void>::type> OutputIterator)",
    "insertText": "c_set_difference(const C1& c1, const C2& c2, OutputIterator output, LessThan&& comp)"
  },
  {
    "label": "c_set_symmetric_difference()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2,OutputIterator,= std::enable_if<! container_algorithm_internal::IsUnorderedContainer<C1>::value,void>::type,= std::enable_if<! container_algorithm_internal::IsUnorderedContainer<C2>::value,void>::type> OutputIterator)",
    "insertText": "c_set_symmetric_difference(const C1& c1, const C2& c2, OutputIterator output)"
  },
  {
    "label": "c_set_symmetric_difference()",
    "kind": "Method",
    "detail": "Function (} template<C1,C2,OutputIterator,LessThan,= std::enable_if<! container_algorithm_internal::IsUnorderedContainer<C1>::value,void>::type,= std::enable_if<! container_algorithm_internal::IsUnorderedContainer<C2>::value,void>::type> OutputIterator)",
    "insertText": "c_set_symmetric_difference(const C1& c1, const C2& c2, OutputIterator output, LessThan&& comp)"
  },
  {
    "label": "c_push_heap()",
    "kind": "Method",
    "detail": "Function (} template<RandomAccessContainer> void)",
    "insertText": "c_push_heap(RandomAccessContainer& sequence)"
  },
  {
    "label": "push_heap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "push_heap(container_algorithm_internal::c_begin(sequence), container_algorithm_internal::c_end(sequence))"
  },
  {
    "label": "c_push_heap()",
    "kind": "Method",
    "detail": "Function (} template<RandomAccessContainer,LessThan> void)",
    "insertText": "c_push_heap(RandomAccessContainer& sequence, LessThan&& comp)"
  },
  {
    "label": "push_heap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "push_heap(container_algorithm_internal::c_begin(sequence), container_algorithm_internal::c_end(sequence), std::forward<LessThan>(comp))"
  },
  {
    "label": "c_pop_heap()",
    "kind": "Method",
    "detail": "Function (} template<RandomAccessContainer> void)",
    "insertText": "c_pop_heap(RandomAccessContainer& sequence)"
  },
  {
    "label": "pop_heap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pop_heap(container_algorithm_internal::c_begin(sequence), container_algorithm_internal::c_end(sequence))"
  },
  {
    "label": "c_pop_heap()",
    "kind": "Method",
    "detail": "Function (} template<RandomAccessContainer,LessThan> void)",
    "insertText": "c_pop_heap(RandomAccessContainer& sequence, LessThan&& comp)"
  },
  {
    "label": "pop_heap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pop_heap(container_algorithm_internal::c_begin(sequence), container_algorithm_internal::c_end(sequence), std::forward<LessThan>(comp))"
  },
  {
    "label": "c_make_heap()",
    "kind": "Method",
    "detail": "Function (} template<RandomAccessContainer> void)",
    "insertText": "c_make_heap(RandomAccessContainer& sequence)"
  },
  {
    "label": "make_heap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "make_heap(container_algorithm_internal::c_begin(sequence), container_algorithm_internal::c_end(sequence))"
  },
  {
    "label": "c_make_heap()",
    "kind": "Method",
    "detail": "Function (} template<RandomAccessContainer,LessThan> void)",
    "insertText": "c_make_heap(RandomAccessContainer& sequence, LessThan&& comp)"
  },
  {
    "label": "make_heap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "make_heap(container_algorithm_internal::c_begin(sequence), container_algorithm_internal::c_end(sequence), std::forward<LessThan>(comp))"
  },
  {
    "label": "c_sort_heap()",
    "kind": "Method",
    "detail": "Function (} template<RandomAccessContainer> void)",
    "insertText": "c_sort_heap(RandomAccessContainer& sequence)"
  },
  {
    "label": "sort_heap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sort_heap(container_algorithm_internal::c_begin(sequence), container_algorithm_internal::c_end(sequence))"
  },
  {
    "label": "c_sort_heap()",
    "kind": "Method",
    "detail": "Function (} template<RandomAccessContainer,LessThan> void)",
    "insertText": "c_sort_heap(RandomAccessContainer& sequence, LessThan&& comp)"
  },
  {
    "label": "sort_heap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sort_heap(container_algorithm_internal::c_begin(sequence), container_algorithm_internal::c_end(sequence), std::forward<LessThan>(comp))"
  },
  {
    "label": "c_is_heap()",
    "kind": "Method",
    "detail": "Function (} template<RandomAccessContainer> bool)",
    "insertText": "c_is_heap(const RandomAccessContainer& sequence)"
  },
  {
    "label": "c_is_heap()",
    "kind": "Method",
    "detail": "Function (} template<RandomAccessContainer,LessThan> bool)",
    "insertText": "c_is_heap(const RandomAccessContainer& sequence, LessThan&& comp)"
  },
  {
    "label": "c_is_heap_until()",
    "kind": "Method",
    "detail": "Function (} template<RandomAccessContainer> container_algorithm_internal::ContainerIter<RandomAccessContainer>)",
    "insertText": "c_is_heap_until(RandomAccessContainer& sequence)"
  },
  {
    "label": "c_is_heap_until()",
    "kind": "Method",
    "detail": "Function (} template<RandomAccessContainer,LessThan> container_algorithm_internal::ContainerIter<RandomAccessContainer>)",
    "insertText": "c_is_heap_until(RandomAccessContainer& sequence, LessThan&& comp)"
  },
  {
    "label": "c_min_element()",
    "kind": "Method",
    "detail": "Function (} template<Sequence> container_algorithm_internal::ContainerIter<Sequence>)",
    "insertText": "c_min_element(Sequence& sequence)"
  },
  {
    "label": "c_min_element()",
    "kind": "Method",
    "detail": "Function (} template<Sequence,LessThan> container_algorithm_internal::ContainerIter<Sequence>)",
    "insertText": "c_min_element(Sequence& sequence, LessThan&& comp)"
  },
  {
    "label": "c_max_element()",
    "kind": "Method",
    "detail": "Function (} template<Sequence> container_algorithm_internal::ContainerIter<Sequence>)",
    "insertText": "c_max_element(Sequence& sequence)"
  },
  {
    "label": "c_max_element()",
    "kind": "Method",
    "detail": "Function (} template<Sequence,LessThan> container_algorithm_internal::ContainerIter<Sequence>)",
    "insertText": "c_max_element(Sequence& sequence, LessThan&& comp)"
  },
  {
    "label": "c_minmax_element()",
    "kind": "Method",
    "detail": "Function (} template<C> container_algorithm_internal::ContainerIterPairType<C,C>)",
    "insertText": "c_minmax_element(C& c)"
  },
  {
    "label": "c_minmax_element()",
    "kind": "Method",
    "detail": "Function (} template<C,LessThan> container_algorithm_internal::ContainerIterPairType<C,C>)",
    "insertText": "c_minmax_element(C& c, LessThan&& comp)"
  },
  {
    "label": "c_lexicographical_compare()",
    "kind": "Method",
    "detail": "Function (} template<Sequence1,Sequence2> bool)",
    "insertText": "c_lexicographical_compare(Sequence1&& sequence1, Sequence2&& sequence2)"
  },
  {
    "label": "c_lexicographical_compare()",
    "kind": "Method",
    "detail": "Function (} template<Sequence1,Sequence2,LessThan> bool)",
    "insertText": "c_lexicographical_compare(Sequence1&& sequence1, Sequence2&& sequence2, LessThan&& comp)"
  },
  {
    "label": "c_next_permutation()",
    "kind": "Method",
    "detail": "Function (} template<C> bool)",
    "insertText": "c_next_permutation(C& c)"
  },
  {
    "label": "c_next_permutation()",
    "kind": "Method",
    "detail": "Function (} template<C,LessThan> bool)",
    "insertText": "c_next_permutation(C& c, LessThan&& comp)"
  },
  {
    "label": "c_prev_permutation()",
    "kind": "Method",
    "detail": "Function (} template<C> bool)",
    "insertText": "c_prev_permutation(C& c)"
  },
  {
    "label": "c_prev_permutation()",
    "kind": "Method",
    "detail": "Function (} template<C,LessThan> bool)",
    "insertText": "c_prev_permutation(C& c, LessThan&& comp)"
  },
  {
    "label": "c_iota()",
    "kind": "Method",
    "detail": "Function (} template<Sequence,T> void)",
    "insertText": "c_iota(Sequence& sequence, T&& value)"
  },
  {
    "label": "iota()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "iota(container_algorithm_internal::c_begin(sequence), container_algorithm_internal::c_end(sequence), std::forward<T>(value))"
  },
  {
    "label": "c_accumulate()",
    "kind": "Method",
    "detail": "Function (} template<Sequence,T> decay_t<T>)",
    "insertText": "c_accumulate(const Sequence& sequence, T&& init)"
  },
  {
    "label": "c_accumulate()",
    "kind": "Method",
    "detail": "Function (} template<Sequence,T,BinaryOp> decay_t<T>)",
    "insertText": "c_accumulate(const Sequence& sequence, T&& init, BinaryOp&& binary_op)"
  },
  {
    "label": "c_inner_product()",
    "kind": "Method",
    "detail": "Function (} template<Sequence1,Sequence2,T> decay_t<T>)",
    "insertText": "c_inner_product(const Sequence1& factors1, const Sequence2& factors2, T&& sum)"
  },
  {
    "label": "c_inner_product()",
    "kind": "Method",
    "detail": "Function (} template<Sequence1,Sequence2,T,BinaryOp1,BinaryOp2> decay_t<T>)",
    "insertText": "c_inner_product(const Sequence1& factors1, const Sequence2& factors2, T&& sum, BinaryOp1&& op1, BinaryOp2&& op2)"
  },
  {
    "label": "c_adjacent_difference()",
    "kind": "Method",
    "detail": "Function (} template<InputSequence,OutputIt> OutputIt)",
    "insertText": "c_adjacent_difference(const InputSequence& input, OutputIt output_first)"
  },
  {
    "label": "c_adjacent_difference()",
    "kind": "Method",
    "detail": "Function (} template<InputSequence,OutputIt,BinaryOp> OutputIt)",
    "insertText": "c_adjacent_difference(const InputSequence& input, OutputIt output_first, BinaryOp&& op)"
  },
  {
    "label": "c_partial_sum()",
    "kind": "Method",
    "detail": "Function (} template<InputSequence,OutputIt> OutputIt)",
    "insertText": "c_partial_sum(const InputSequence& input, OutputIt output_first)"
  },
  {
    "label": "c_partial_sum()",
    "kind": "Method",
    "detail": "Function (} template<InputSequence,OutputIt,BinaryOp> OutputIt)",
    "insertText": "c_partial_sum(const InputSequence& input, OutputIt output_first, BinaryOp&& op)"
  }
]