[
  {
    "label": "ABrush",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ABrush"
  },
  {
    "label": "UMaterialInterface",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UMaterialInterface"
  },
  {
    "label": "UModel",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UModel"
  },
  {
    "label": "ESplitType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ESplitType"
  },
  {
    "label": "FPoly",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPoly"
  },
  {
    "label": "UPolys",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UPolys"
  },
  {
    "label": "FPoly()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" UObject / ObjectMacros . h \" # include \" UObject / UObjectGlobals . h \" # include \" UObject / Object . h \" # include \" Engine / EngineTypes . h \" # include \" Polys . generated . h \" class ABrush ; class UMaterialInterface ; class UModel ; enum ESplitType { SP_Coplanar = 0,SP_Front = 1,SP_Back = 2,SP_Split = 3,} ; class FPoly { public : typedef TArray<FVector3f,TInlineAllocator<1 6>> VerticesArrayType ; FVector3f Base ; FVector3f Normal ; FVector3f TextureU ; FVector3f TextureV ; VerticesArrayType Vertices ; uint32 PolyFlags ; TObjectPtr<ABrush> Actor ; TObjectPtr<UMaterialInterface> Material ; FName RulesetVariation ; FName ItemName ; int32 iLink ; int32 iLinkSurf ; int32 iBrushPoly ; uint32 SmoothingMask ; float LightMapScale ; FLightmassPrimitiveSettings LightmassSettings ;)",
    "insertText": "FPoly()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init()"
  },
  {
    "label": "Reverse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reverse()"
  },
  {
    "label": "Transform()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Transform(const FVector3f &PostAdd)"
  },
  {
    "label": "Rotate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Rotate(const FRotator3f &Rotation)"
  },
  {
    "label": "Scale()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Scale(const FVector3f &Scale)"
  },
  {
    "label": "Fix()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Fix()"
  },
  {
    "label": "CalcNormal()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "CalcNormal(bool bSilent = 0)"
  },
  {
    "label": "SplitWithPlane()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "SplitWithPlane(const FVector3f &InBase,const FVector3f &InNormal,FPoly *FrontPoly,FPoly *BackPoly,int32 VeryPrecise)"
  },
  {
    "label": "SplitWithNode()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "SplitWithNode(const UModel *Model,int32 iNode,FPoly *FrontPoly,FPoly *BackPoly,int32 VeryPrecise)"
  },
  {
    "label": "SplitWithPlaneFast()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "SplitWithPlaneFast(const FPlane& Plane,FPoly *FrontPoly,FPoly *BackPoly)"
  },
  {
    "label": "Split()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Split(const FVector3f &InNormal, const FVector3f &InBase)"
  },
  {
    "label": "RemoveColinears()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "RemoveColinears()"
  },
  {
    "label": "Faces()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Faces(const FPoly &Test)"
  },
  {
    "label": "Area()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "Area()"
  },
  {
    "label": "DoesLineIntersect()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "DoesLineIntersect(FVector Start, FVector End, FVector* Intersect = NULL)"
  },
  {
    "label": "OnPoly()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OnPoly(FVector InVtx)"
  },
  {
    "label": "OnPlane()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OnPlane(FVector InVtx)"
  },
  {
    "label": "InsertVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InsertVertex(int32 InPos, FVector InVtx)"
  },
  {
    "label": "RemoveVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveVertex(FVector InVtx)"
  },
  {
    "label": "IsCoplanar()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsCoplanar()"
  },
  {
    "label": "IsConvex()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsConvex()"
  },
  {
    "label": "Triangulate()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Triangulate(ABrush* InOwnerBrush, TArray<FPoly>& OutTriangles)"
  },
  {
    "label": "GetVertexIndex()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetVertexIndex(FVector3f& InVtx)"
  },
  {
    "label": "GetMidPoint()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetMidPoint()"
  },
  {
    "label": "BuildInfiniteFPoly()",
    "kind": "Method",
    "detail": "Function (FPoly)",
    "insertText": "BuildInfiniteFPoly(const FPlane& InPlane)"
  },
  {
    "label": "BuildAndCutInfiniteFPoly()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR FPoly)",
    "insertText": "BuildAndCutInfiniteFPoly(const FPlane& InPlane, const TArray<FPlane>& InCutPlanes, ABrush* InOwnerBrush)"
  },
  {
    "label": "Finalize()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Finalize(ABrush* InOwner, int32 NoError)"
  },
  {
    "label": "OptimizeIntoConvexPolys()",
    "kind": "Method",
    "detail": "Function (template<ArrayType> void)",
    "insertText": "OptimizeIntoConvexPolys(ABrush* InOwnerBrush, ArrayType& InPolygons)"
  },
  {
    "label": "GetOutsideWindings()",
    "kind": "Method",
    "detail": "Function (template<ArrayType> void)",
    "insertText": "GetOutsideWindings(ABrush* InOwnerBrush, ArrayType& InPolygons, TArray< TArray<FVector3f> >& InWindings)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (InWindings .)",
    "insertText": "Empty()"
  },
  {
    "label": "SaveNormal()",
    "kind": "Method",
    "detail": "Function (FVector3f)",
    "insertText": "SaveNormal(0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TArray<FPoly> Triangles ;)",
    "insertText": "for(int32 p = 0 ; p < InPolygons.Num() ; ++p)"
  },
  {
    "label": "Triangulate()",
    "kind": "Method",
    "detail": "Function (FPoly* Poly =& InPolygons [ p ] ; SaveNormal = Poly -> Normal ; TArray<FPoly> Polys ; Poly ->)",
    "insertText": "Triangulate(InOwnerBrush, Polys)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (Triangles .)",
    "insertText": "Append(Polys)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} TArray<FEdge> EdgePool ;)",
    "insertText": "for(int32 p = 0 ; p < Triangles.Num() ; ++p)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FPoly* Poly =& Triangles [ p ] ;)",
    "insertText": "for(int32 v = 0 ; v < Poly->Vertices.Num() ; ++v)"
  },
  {
    "label": "Vertices()",
    "kind": "Method",
    "detail": "Function (const FVector3f vtx0 = Poly -> Vertices [ v ] ; const FVector3f vtx1 = Poly ->)",
    "insertText": "Vertices(v+1) % Poly->Vertices.Num()"
  },
  {
    "label": "Edge()",
    "kind": "Method",
    "detail": "Function (FEdge)",
    "insertText": "Edge((FVector)vtx0, (FVector)vtx1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 idx ;)",
    "insertText": "if(EdgePool.Find( Edge, idx ))"
  },
  {
    "label": "AddUnique()",
    "kind": "Method",
    "detail": "Function (EdgePool [ idx ] . Count + + ; } else { Edge . Count = 1 ; EdgePool .)",
    "insertText": "AddUnique(Edge)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "for(int32 e = 0 ; e < EdgePool.Num() ; ++e)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const FEdge* Edge =& EdgePool [ e ] ;)",
    "insertText": "if(Edge->Count > 1)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (EdgePool .)",
    "insertText": "RemoveAt(e)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (e = - 1 ; } })",
    "insertText": "while(EdgePool.Num())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (TArray<FEdge> OrderedEdges ; FEdge Edge0 = EdgePool [ 0 ] ; OrderedEdges .)",
    "insertText": "Add(Edge0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FEdge Edge1 = EdgePool [ e ] ;)",
    "insertText": "if(Edge0.Vertex[1].Equals( Edge1.Vertex[0] ))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OrderedEdges .)",
    "insertText": "Add(Edge1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (e = - 1 ; } else)",
    "insertText": "if(Edge0.Vertex[1].Equals( Edge1.Vertex[1] ))"
  },
  {
    "label": "Exchange()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Exchange(Edge1.Vertex[0], Edge1.Vertex[1])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (e = - 1 ; } })",
    "insertText": "if(OrderedEdges.Num() > 2)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (TestPoly . Vertices .)",
    "insertText": "Add((FVector3f)OrderedEdges[0].Vertex[0])"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (TestPoly . Vertices .)",
    "insertText": "Add((FVector3f)OrderedEdges[1].Vertex[0])"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (TestPoly . Vertices .)",
    "insertText": "Add((FVector3f)OrderedEdges[2].Vertex[0])"
  },
  {
    "label": "Exchange()",
    "kind": "Method",
    "detail": "Function (FEdge* Edge =& SavedEdges [ e ] ;)",
    "insertText": "Exchange(Edge->Vertex[0], Edge->Vertex[1])"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OrderedEdges .)",
    "insertText": "Add(*Edge)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } } } TArray<FVector3f> WindingVerts ;)",
    "insertText": "for(int32 e = 0 ; e < OrderedEdges.Num() ; ++e)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (FEdge* Edge =& OrderedEdges [ e ] ; WindingVerts .)",
    "insertText": "Add((FVector3f)Edge->Vertex[0])"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} InWindings .)",
    "insertText": "Add(WindingVerts)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } # endif FArchive&)",
    "insertText": "operator(FArchive& Ar, FPoly& Poly)"
  },
  {
    "label": "IsBackfaced()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "IsBackfaced(const FVector3f &Point)"
  },
  {
    "label": "IsCoplanar()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "IsCoplanar(const FPoly &Test)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FPoly& A,const FPoly& B)"
  },
  {
    "label": "UCLASS()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "UCLASS(customConstructor, MinimalAPI)"
  },
  {
    "label": "GENERATED_UCLASS_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_UCLASS_BODY()"
  },
  {
    "label": "UPolys()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UPolys(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get()) : UObject(ObjectInitializer) , Element()"
  },
  {
    "label": "UPolys()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UPolys(FVTableHelper& Helper) : Super(Helper) , Element()"
  },
  {
    "label": "Modify()",
    "kind": "Method",
    "detail": "Function (} # if WITH_EDITOR bool)",
    "insertText": "Modify(bool bAlwaysMarkDirty = true)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "Serialize(FArchive& Ar)"
  },
  {
    "label": "IsAsset()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsAsset()"
  }
]