[
  {
    "label": "equal_to",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "equal_to"
  },
  {
    "label": "_Tp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tp"
  },
  {
    "label": "_Up",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Up"
  },
  {
    "label": "not_equal_to",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "not_equal_to"
  },
  {
    "label": "less",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "less"
  },
  {
    "label": "less_equal",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "less_equal"
  },
  {
    "label": "greater",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "greater"
  },
  {
    "label": "greater_equal",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "greater_equal"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___FUNCTIONAL_RANGES_OPERATIONS_H # define _LIBCPP___FUNCTIONAL_RANGES_OPERATIONS_H # include<__config> # include<__utility / forward . h> # include<concepts> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (struct equal_to { template<class _Tp,class _Up> requires equality_comparable_with<_Tp,_Up> [ [ nodiscard ] ] bool)",
    "insertText": "operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(bool(_VSTD::forward<_Tp>(__t) == _VSTD::forward<_Up>(__u))))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} using is_transparent = void ; } ; struct not_equal_to { template<class _Tp,class _Up> requires equality_comparable_with<_Tp,_Up> [ [ nodiscard ] ] bool)",
    "insertText": "operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(bool(!(_VSTD::forward<_Tp>(__t) == _VSTD::forward<_Up>(__u)))))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} using is_transparent = void ; } ; struct less { template<class _Tp,class _Up> requires totally_ordered_with<_Tp,_Up> [ [ nodiscard ] ] bool)",
    "insertText": "operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(bool(_VSTD::forward<_Tp>(__t) < _VSTD::forward<_Up>(__u))))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} using is_transparent = void ; } ; struct less_equal { template<class _Tp,class _Up> requires totally_ordered_with<_Tp,_Up> [ [ nodiscard ] ] bool)",
    "insertText": "operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(bool(!(_VSTD::forward<_Up>(__u) < _VSTD::forward<_Tp>(__t)))))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} using is_transparent = void ; } ; struct greater { template<class _Tp,class _Up> requires totally_ordered_with<_Tp,_Up> [ [ nodiscard ] ] bool)",
    "insertText": "operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(bool(_VSTD::forward<_Up>(__u) < _VSTD::forward<_Tp>(__t))))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} using is_transparent = void ; } ; struct greater_equal { template<class _Tp,class _Up> requires totally_ordered_with<_Tp,_Up> [ [ nodiscard ] ] bool)",
    "insertText": "operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(bool(!(_VSTD::forward<_Tp>(__t) < _VSTD::forward<_Up>(__u)))))"
  }
]