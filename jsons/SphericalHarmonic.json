[
  {
    "label": "Sh",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Sh"
  },
  {
    "label": "Sh2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Sh2"
  },
  {
    "label": "ShMatrix",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ShMatrix"
  },
  {
    "label": "legendrePolynomial()",
    "kind": "Method",
    "detail": "Function (# ifndef NV_MATH_SPHERICALHARMONIC_H # define NV_MATH_SPHERICALHARMONIC_H # include<nvmath / Vector . h> namespace nv { float)",
    "insertText": "legendrePolynomial(int l, int m, float x)"
  },
  {
    "label": "y()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "y(int l, int m, float theta, float phi)"
  },
  {
    "label": "y()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "y(int l, int m, Vector3::Arg v)"
  },
  {
    "label": "hy()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "hy(int l, int m, float theta, float phi)"
  },
  {
    "label": "hy()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "hy(int l, int m, Vector3::Arg v)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (class Sh ; float)",
    "insertText": "dot(const Sh & a, const Sh & b)"
  },
  {
    "label": "Sh()",
    "kind": "Method",
    "detail": "Function (class Sh { class Sh2 ; class ShMatrix ; public :)",
    "insertText": "Sh(int o) : m_order(o)"
  },
  {
    "label": "basisNum()",
    "kind": "Method",
    "detail": "Function (m_elemArray = new float [)",
    "insertText": "basisNum()"
  },
  {
    "label": "Sh()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Sh(const Sh & sh) : m_order(sh.order())"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(m_elemArray, sh.m_elemArray, sizeof(float) * basisNum())"
  },
  {
    "label": "Sh()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "Sh()"
  },
  {
    "label": "bandNum()",
    "kind": "Method",
    "detail": "Function (delete [ ] m_elemArray ; m_elemArray = NULL ; } int)",
    "insertText": "bandNum(int order)"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "index(int l, int m)"
  },
  {
    "label": "elem()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "elem(int l, int m)"
  },
  {
    "label": "elemAt()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "elemAt(int i)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (m_elemArray [ i ] = 0 . 0 f ; } } void)",
    "insertText": "operator(const Sh & sh)"
  },
  {
    "label": "nvDebugCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvDebugCheck(order() <= sh.order())"
  },
  {
    "label": "nvDebugCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvDebugCheck(order() == sh.order())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (m_elemArray [ i ]* = sh . m_elemArray [ i ] ; } } void)",
    "insertText": "operator(float f)"
  },
  {
    "label": "addScaled()",
    "kind": "Method",
    "detail": "Function (m_elemArray [ i ]* = f ; } } void)",
    "insertText": "addScaled(const Sh & sh, float f)"
  },
  {
    "label": "eval()",
    "kind": "Method",
    "detail": "Function (m_elemArray [ i ] + = sh . m_elemArray [ i ]* f ; } } void)",
    "insertText": "eval(Vector3::Arg dir)"
  },
  {
    "label": "elem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "elem(l, m) = y(l, m, dir)"
  },
  {
    "label": "sample()",
    "kind": "Method",
    "detail": "Function (} } } float)",
    "insertText": "sample(Vector3::Arg dir)"
  },
  {
    "label": "sh()",
    "kind": "Method",
    "detail": "Function (Sh)",
    "insertText": "sh(order())"
  },
  {
    "label": "eval()",
    "kind": "Method",
    "detail": "Function (sh .)",
    "insertText": "eval(dir)"
  },
  {
    "label": "nvDebugCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvDebugCheck(a.order() == b.order())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (float sum = 0 ;)",
    "insertText": "for(int i = 0; i < Sh::basisNum(a.order()); i++)"
  },
  {
    "label": "elemAt()",
    "kind": "Method",
    "detail": "Function (sum + = a .)",
    "insertText": "elemAt(i) * b.elemAt(i)"
  },
  {
    "label": "Sh2()",
    "kind": "Method",
    "detail": "Function (} return sum ; } class Sh2 : public Sh { public :)",
    "insertText": "Sh2() : Sh(2)"
  },
  {
    "label": "Sh2()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Sh2(const Sh2 & sh) : Sh(sh)"
  },
  {
    "label": "cosineTransfer()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "cosineTransfer()"
  },
  {
    "label": "normalization()",
    "kind": "Method",
    "detail": "Function (const float c1 = 0 . 2 8 2 0 9 5 f ; const float c2 = 0 . 4 8 8 6 0 3 f ; const float c3 = 1 . 0 9 2 5 4 8 f ; const float c4 = 0 . 3 1 5 3 9 2 f ; const float c5 = 0 . 5 4 6 2 7 4 f ; const float normalization = PI* 1 6 . 0 f / 1 7 . 0 f ; const float const1 = c1* normalization* 1 . 0 f ; const float const2 = c2*)",
    "insertText": "normalization(2.0f / 3.0f)"
  },
  {
    "label": "normalization()",
    "kind": "Method",
    "detail": "Function (const float const3 = c3*)",
    "insertText": "normalization(1.0f / 4.0f)"
  },
  {
    "label": "ShMatrix()",
    "kind": "Method",
    "detail": "Function (m_elemArray [ 0 ] = const1 ; m_elemArray [ 1 ] = - const2 ; m_elemArray [ 2 ] = const2 ; m_elemArray [ 3 ] = - const2 ; m_elemArray [ 4 ] = const3 ; m_elemArray [ 5 ] = - const3 ; m_elemArray [ 6 ] = const4 ; m_elemArray [ 7 ] = - const3 ; m_elemArray [ 8 ] = const5 ; } } ; # if 0 class ShMatrix { public :)",
    "insertText": "ShMatrix(int o = 2) : order(o), identity(true)"
  },
  {
    "label": "nvCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvCheck(order > 0)"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (e = new float [)",
    "insertText": "Size()"
  },
  {
    "label": "GetBandNum()",
    "kind": "Method",
    "detail": "Function (band = new float* [)",
    "insertText": "GetBandNum()"
  },
  {
    "label": "setupBands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setupBands()"
  },
  {
    "label": "ShMatrix()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ShMatrix()"
  },
  {
    "label": "setIdentity()",
    "kind": "Method",
    "detail": "Function (delete e ; delete band ; } void)",
    "insertText": "setIdentity()"
  },
  {
    "label": "isIdentity()",
    "kind": "Method",
    "detail": "Function (identity = true ; } bool)",
    "insertText": "isIdentity()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int size = 0 ;)",
    "insertText": "for(int i = 0; i < bandNum(); i++)"
  },
  {
    "label": "SQ()",
    "kind": "Method",
    "detail": "Function (size + =)",
    "insertText": "SQ(i * 2 + 1)"
  },
  {
    "label": "elem()",
    "kind": "Method",
    "detail": "Function (} return size ; } float)",
    "insertText": "elem(const int idx)"
  },
  {
    "label": "nvDebugCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvDebugCheck(b >= 0)"
  },
  {
    "label": "nvDebugCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvDebugCheck(b < bandNum())"
  },
  {
    "label": "elem()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "elem(const int b, const int x, const int y)"
  },
  {
    "label": "Copy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Copy(const ShMatrix & m)"
  },
  {
    "label": "nvDebugCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvDebugCheck(order == m.order)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(e, m.e, Size() * sizeof(float))"
  },
  {
    "label": "transform()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "transform(const Sh & restrict source, Sh * restrict dest)"
  },
  {
    "label": "piCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "piCheck(&source != dest)"
  },
  {
    "label": "piCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "piCheck(dest->order <= order)"
  },
  {
    "label": "piCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "piCheck(order <= source.order)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (* dest = source ; return ; })",
    "insertText": "for(int l = 0; l <= dest->order; l++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Color3f rgb = Color3f::Black ;)",
    "insertText": "for(int mi = -l; mi <= l; mi++)"
  },
  {
    "label": "Mad()",
    "kind": "Method",
    "detail": "Function (rgb .)",
    "insertText": "Mad(rgb, source.elem(l, mi), elem(l, mo, mi))"
  },
  {
    "label": "elem()",
    "kind": "Method",
    "detail": "Function (} dest ->)",
    "insertText": "elem(l, mo)"
  },
  {
    "label": "multiply()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "multiply(const ShMatrix &A, const ShMatrix &B)"
  },
  {
    "label": "rotation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rotation(const Matrix & m)"
  },
  {
    "label": "rotation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rotation(int axis, float angles)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print()"
  }
]